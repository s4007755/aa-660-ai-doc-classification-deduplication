{
  "raw_text": "PDF generated using the open source mwlib toolkit\nsee http://code.pediapress.com/ for more information\n A Byte of Python\nv1.92 (for Python 3.0)\n\nPython\n2\nPython\nChoose your Python version:\nIf you want to learn the current Python 2.x, read\nhere [1] or download the PDF [2]\nIf you want to learn the new Python 3.0, read here or\ndownload the PDF [3]\nYou can also buy a printed hardcopy. [4]\nIntroduction \n'A Byte of Python' is a book on programming using the Python language. It serves as a\ntutorial or guide to the Python language for a beginner audience. If all you know about\ncomputers is how to save text files, then this is the book for you.\nThis book is updated for the new Python 3.0 language. If you are looking for a tutorial\non the current Python 2.x version, please download the previous revision of the book [5]. On\nthe same note, if you're wondering whether to learn Python 2.x or 3.x, then read this article\nby James Bennett [6].\nWho Reads 'A Byte of Python'? \nHere are what people are saying about the book:\nFeedback From Readers \nThis is the best beginner's tutorial I've ever seen! Thank you for your effort.\n- Walt Michalik (wmich50-at-theramp-dot-net)\nYou've made the best Python tutorial I've found on the Net. Great work. Thanks! \n- Joshua Robin (joshrob-at-poczta-dot-onet-dot-pl)\nHi, I'm from Dominican Republic. My name is Pavel, recently I read your book 'A Byte\nof Python' and I consider it excellent!! :). I learnt much from all the examples. Your\nbook is of great help for newbies like me... \n- Pavel Simo (pavel-dot-simo-at-gmail-dot-com)\nI recently finished reading Byte of Python, and I thought I really ought to thank you. I\nwas very sad to reach the final pages as I now have to go back to dull, tedious oreilly\nor etc. manuals for learning about python. Anyway, I really appreciate your book \n- Samuel Young (sy-one-three-seven-at-gmail-dot-com)\nDear Swaroop, I am taking a class from an instructor that has no interest in teaching.\nWe are using Learning Python, second edition, by O'Reilly. It is not a text for beginner\nwithout any programming knowledge, and an instructor that should be working in\nanother field. Thank you very much for your book, without it I would be cluless about\nPython and programming. Thanks a million, you are able to 'break the message down'\nto a level that beginners can understand and not everyone can. \n- Joseph Duarte (jduarte1-at-cfl-dot-rr-dot-com)\nI love your book! It is the greatest Python tutorial ever, and a very useful reference.\nBrilliant, a true masterpiece! Keep up the good work! \n- Chris-André Sommerseth\n\nPython\n3\nI'm just e-mailing you to thank you for writing Byte of Python online. I had been\nattempting Python for a few months prior to stumbling across your book, and although\nI made limited success with pyGame, I never completed a program.\nThanks to your simplification of the categories, Python actually seems a reachable\ngoal. It seems like I have finally learned the foundations and I can continue into my\nreal goal, game development.\n... \nOnce again, thanks VERY much for placing such a structured and helpful guide to\nbasic programming on the web. It shoved me into and out of OOP with an\nunderstanding where two text books had failed.\n- Matt Gallivan (m-underscore-gallivan12-at-hotmail-dot-com)\nI would like to thank you for your book 'A byte of python' which i myself find the best\nway to learn python. I am a 15 year old i live in egypt my name is Ahmed. Python was\nmy second programming language i learn visual basic 6 at school but didn't enjoy it,\nhowever i really enjoyed learning python. I made the addressbook program and i was\nsucessful. i will try to start make more programs and read python programs (if you\ncould tell me source that would be helpful). I will also start on learning java and if you\ncan tell me where to find a tutorial as good as yours for java that would help me a lot.\nThanx. \n- Ahmed Mohammed (sedo-underscore-91-at-hotmail-dot-com)\nA wonderful resource for beginners wanting to learn more about Python is the\n110-page PDF tutorial A Byte of Python by Swaroop C H. It is well-written, easy to\nfollow, and may be the best introduction to Python programming available. \n- Drew Ames in an article on Scripting Scribus [7] published on Linux.com\nYesterday I got through most of Byte of Python on my Nokia N800 and it's the easiest\nand most concise introduction to Python I have yet encountered. Highly recommended\nas a starting point for learning Python. \n- Jason Delport on his weblog [8]\nAcademic Courses \nThis book is being used as instructional material in various educational institutions:\n1. 'Principles of Programming Languages' course at Vrije Universiteit, Amsterdam [9]\n2. 'Basic Concepts of Computing' course at University of California, Davis [10]\n3. 'Programming With Python' course at Harvard University [11]\n4. 'Introduction to Programming' course at University of Leeds [12]\n5. 'Introduction to Application Programming' course at Boston University [13]\n6. 'Information Technology Skills for Meteorology' course at University of Oklahoma [14]\n7. 'Geoprocessing' course at Michigan State University [15]\n8. 'Multi Agent Semantic Web Systems' course at the University of Edinburgh [16]\n\nPython\n4\nEven NASA \nThe book is even used by NASA! It is being used in their Jet Propulsion Laboratory [17] with\ntheir Deep Space Network project.\nOfficial Recommendation \nThis book has been listed on the official website for Python in the Full Tutorials [18] section,\nnext to the official documentation.\nLicense \n1. This book is licensed under the Creative Commons Attribution-Share Alike 3.0 Unported\n[19] license.\n• This means:\n• You are free to Share i.e. to copy, distribute and transmit this book\n• You are free to Remix i.e. to adapt this book\n • Under the following conditions:\n• Attribution. You must attribute the work in the manner specified by the author or\nlicensor (but not in any way that suggests that they endorse you or your use of this\nbook).\n• Share Alike. If you alter, transform, or build upon this work, you may distribute the\nresulting work only under the same or similar license to this one.\n • For any reuse or distribution, you must make clear to others the license terms of this\nbook.\n• Any of the above conditions can be waived if you get permission from the copyright\nholder.\n• Nothing in this license impairs or restricts the author's moral rights.\n 2. Attribution must be shown by linking back to http:/ / www. swaroopch. com/ notes/\nPython and clearly indicating that the original text can be fetched from this location.\n3. All the code/scripts provided in this book is licensed under the 3-clause BSD License [20]\nunless otherwise noted.\n4. Volunteer contributions to this original book must be under this same license and the\ncopyright must be assigned to the main author of this book.\nRead Now \nYou can read the book online at Python_en:Table of Contents.\nBuy the Book \nA printed hardcopy of the book can be purchased [21] for your offline reading pleasure, and\nto support the continued development and improvement of this book.\nDownload \n• PDF (631KB) [22]\n• Mediawiki XML dump (276KB) [23] (for advanced users only)\nIf you wish to support the continued development of this book, please consider\nmaking a donation [24] or buy a printed hardcopy [25].\n\nPython\n5\nTranslations \nIf you are interested in reading or contributing translations of this book to other human\nlanguages, please see Translations.\nNext\nReferences\n[1] http:/ / www. ibiblio. org/ swaroopch/ byteofpython/ read/\n[2] http:/ / www. ibiblio. org/ swaroopch/ byteofpython/ files/ 120/ byteofpython_120. pdf\n[3] http:/ / www. swaroopch. com/ files/ byteofpython/ byte_of_python_v191. pdf\n[4] http:/ / www. swaroopch. com/ buybook\n[5] http:/ / www. ibiblio. org/ swaroopch/ byteofpython/ files/ 120/\n[6] http:/ / www. b-list. org/ weblog/ 2008/ dec/ 05/ python-3000/\n[7] http:/ / www. linux. com/ feature/ 126522\n[8] http:/ / paxmodept. com/ telesto/ blogitem. htm?id=627\n[9] http:/ / www. few. vu. nl/ ~nsilvis/ PPL/ 2007/ index. html\n[10] http:/ / www. cs. ucdavis. edu/ courses/ exp_course_desc/ 10. html\n[11] http:/ / www. people. fas. harvard. edu/ ~preshman/ python_winter. html\n[12] http:/ / www. comp. leeds. ac. uk/ acom1900/\n[13] http:/ / www. cs. bu. edu/ courses/ cs108/ materials. html\n[14] http:/ / gentry. metr. ou. edu/ byteofpython/\n[15] http:/ / www. msu. edu/ ~ashton/ classes/ 825/ index. html\n[16] http:/ / homepages. inf. ed. ac. uk/ ewan/ masws/\n[17] http:/ / dsnra. jpl. nasa. gov/ software/ Python/ byte-of-python/ output/\nbyteofpython_html/\n[18] http:/ / www. python. org/ doc/ intros/\n[19] http:/ / creativecommons. org/ licenses/ by-sa/ 3. 0/\n[20] http:/ / www. opensource. org/ licenses/ bsd-license. php\n[21] http:/ / www. swaroopch. com/ buybook\n[22] http:/ / www. swaroopch. com/ files/ byteofpython/ byte_of_python_v191. pdf\n[23] http:/ / www. swaroopch. com/ files/ byteofpython/ byte_of_python_v191. xml\n[24] https:/ / www. paypal. com/ cgi-bin/ webscr?cmd=_donations&\nbusiness=swaroop%40swaroopch%2ecom& item_name=A%20Byte%20of%20Python&\nno_shipping=0& no_note=1& tax=0& currency_code=USD& lc=IN&\nbn=PP%2dDonationsBF& charset=UTF%2d8\n[25] http:/ / www. swaroopch. com/ buybook\nSource: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=1391\nContributors: Swaroop, 1 anonymous edits\n\nPython en:Table of Contents\n6\nPython en:Table of Contents\n• → Front Page\n1. → Translations\n2. → Preface\n3. → Introduction\n4. → Installation\n5. → First Steps\n6. → Basics\n7. → Operators and Expressions\n8. → Control Flow\n9. → Functions\n10. → Modules\n11. → Data Structures\n12. → Problem Solving\n13. → Object Oriented Programming\n14. → Input Output\n15. → Exceptions\n16. → Standard Library\n17. → More\n18. → What Next\n19. → Appendix: FLOSS\n20. → Appendix: About\n21. → Appendix: Revision History\n→ Previous → Next\nSource: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=1343\nContributors: Swaroop, Waterox888, 3 anonymous edits\n\nPython en:Translations\n7\nPython en:Translations\nThere are many translations of the book available in different human languages, thanks to\nmany tireless volunteers!\nIf you want to help these translations, please see the list of volunteers and languages below\nand decide if you want to start a new translation or help in existing translation projects.\nIf you plan to start a new translation, please read the Translation Howto.\nChinese \nJuan Shen (orion-underscore-val-at-163-dot-com) has volunteered to translate the book to\nChinese.\nwhat - I am a postgraduate at Wireless Telecommunication Graduate School,\nBeijing University of Technology, China PR. My current research interest is on the\nsynchronization, channel estimation and multi-user detection of multicarrier\nCDMA system. Python is my major programming language for daily simulation\nand research job, with the help of Python Numeric, actually. I learned Python just\nhalf a year before, but as you can see, it's really easy-understanding, easy-to-use\nand productive. Just as what is ensured in Swaroop's book, 'It's my favorite\nprogramming language now'. 'A Byte of Python' is my tutorial to learn Python. It's\nclear and effective to lead you into a world of Python in the shortest time. It's not\ntoo long, but efficiently covers almost all important things in Python. I think 'A\nByte of Python' should be strongly recommendable for newbies as their first\nPython tutorial. Just dedicate my translation to the potential millions of Python\nusers in China.\nChinese Traditional \nFred Lin (gasolin-at-gmail-dot-com) has volunteered to translate the book to Chinese\nTraditional.\nIt is available at http:/ / code. google. com/ p/ zhpy/ wiki/ ByteOfZhpy (http:/ / code. google.\ncom/ p/ zhpy/ wiki/ ByteOfZhpy).\nAn exciting feature of this translation is that it also contains the executable chinese python\nsources side by side with the original python sources.\nFred Lin - I'm working as a network firmware engineer at Delta Network, and I'm\nalso a contributor of TurboGears web framework. As a python evangelist (:-p), I\nneed some material to promote python language. I found 'A Byte of Python' hit the\nsweet point for both newbies and experienced programmers. 'A Byte of Python'\nelaborates the python essentials with affordable size. The translation are\noriginally based on simplified chinese version, and soon a lot of rewrite were\nmade to fit the current wiki version and the quality of reading. The recent chinese\ntraditional version also featured with executable chinese python sources, which\nare achieved by my new 'zhpy' (python in chinese) project (launch from Aug 07).\nzhpy(pronounce (Z.H.?, or zippy) build a layer upon python to translate or interact\nwith python in chinese(Traditional or Simplified). This project is mainly aimed for\neducation.\n\nPython en:Translations\n8\nItalian \nEnrico Morelli (mr-dot-mlucci-at-gmail-dot-com) and Massimo Lucci\n(morelli-at-cerm-dot-unifi-dot-it) have volunteered to translate the book to Italian.\nThe Italian translation is present at www.gentoo.it/Programmazione/byteofpython (http:/ /\nwww. gentoo. it/ Programmazione/ byteofpython). The new translation is in progress and\nstart with \"Prefazione\".\nMassimo Lucci and Enrico Morelli - we are working at the University of\nFlorence (Italy) - Chemistry Department. I (Massimo) as service engineer and\nsystem administrator for Nuclear Magnetic Resonance Spectrometers; Enrico as\nservice engineer and system administrator for our CED and parallel / clustered\nsystems. We are programming on python since about seven years, we had\nexperience working with Linux platforms since ten years. In Italy we are\nresponsible and administrator for www.gentoo.it web site for Gentoo/Linux\ndistrubution and www.nmr.it (now under construction) for Nuclear Magnetic\nResonance applications and Congress Organization and Managements. That's all!\nWe are impressed by the smart language used on your Book and we think this is\nessential for approaching the Python to new users (we are thinking about\nhundred of students and researcher working on our labs).\nGerman \nLutz Horn (lutz-dot-horn-at-gmx-dot-de), Bernd Hengelein\n(bernd-dot-hengelein-at-gmail-dot-com) and Christoph Zwerschke (cito-at-online-dot-de)\nhave volunteered to translate the book to German.\nTheir translation is located at http:/ / abop-german. berlios. de (http:/ / abop-german.\nberlios. de).\nLutz Horn : I'm 32 years old and have a degree of Mathematics from University\nof Heidelberg, Germany. Currently I'm working as a software engineer on a\npublicly funded project to build a web portal for all things related to computer\nscience in Germany. The main language I use as a professional is Java, but I try to\ndo as much as possible with Python behind the scenes. Especially text analysis\nand conversion is very easy with Python. I'm not very familiar with GUI toolkits,\nsince most of my programming is about web applications, where the user\ninterface is build using Java frameworks like Struts. Currently I try to make more\nuse of the functional programming features of Python and of generators. After\ntaking a short look into Ruby, I was very impressed with the use of blocks in this\nlanguage. Generally I like the dynamic nature of languages like Python and Ruby\nsince it allows me to do things not possible in more static languages like Java. I've\nsearched for some kind of introduction to programming, suitable to teach a\ncomplete non-programmer. I've found the book 'How to Think Like a Computer\nScientist: Learning with Python', and 'Dive into Python'. The first is good for\nbeginners but to long to translate. The second is not suitable for beginners. I\nthink 'A Byte of Python' falls nicely between these, since it is not too long, written\nto the point, and at the same time verbose enough to teach a newbie. Besides this,\nI like the simple DocBook structure, which makes translating the text a\ngeneration the output in various formats a charm.\n\nPython en:Translations\n9\nBernd Hengelein : Lutz and me are going to do the german translation together.\nWe just started with the intro and preface but we will keep you informed about\nthe progress we make. Ok, now some personal things about me. I am 34 years old\nand playing with computers since the 1980's, when the \"Commodore C64\" ruled\nthe nurseries. After studying computer science I started working as a software\nengineer. Currently I am working in the field of medical imaging for a major\ngerman company. Although C++ is the main language I (have to) use for my daily\nwork, I am constantly looking for new things to learn. Last year I fell in love with\nPython, which is a wonderful language, both for its possibilities and its beauty. I\nread somewhere in the net about a guy who said that he likes python, because the\ncode looks so beautiful. In my opinion he's absolutly right. At the time I decided to\nlearn python, I noticed that there is very little good documentation in german\navailable. When I came across your book the spontaneous idea of a german\ntranslation crossed my mind. Luckily, Lutz had the same idea and we can now\ndivide the work. I am looking forward to a good cooperation!\nNorwegian (bokmål) \nEirik Vågeskar (or Vages) is a high school student at Sandvika videregående skole (http:/ /\nno. wikipedia. org/ wiki/ Sandvika_videregÃ¥ende_skole) in Norway, a blogger (http:/ /\nforbedre. blogspot. com/ ) and currently translating the book to Norwegian (bokmål). The\ntranslation is in progress, and you can check the table of contents for more details.\nEirik Vågeskar: I have always wanted to program, but because I speak a small\nlanguage, the learning process was much harder. Most tutorials and books are\nwritten in very technical English, so most high school graduates will not even\nhave the vocabulary to understand what the tutorial is about. When I discovered\nthis book, all my problems were solved. \"A Byte of Python\" used simple\nnon-technical language to explain a programming language that is just as simple,\nand these two things make learning Python fun. After reading half of the book, I\ndecided that the book was worth translating. I hope the translation will help\npeople who have found themself in the same situation as me (especially young\npeople), and maybe help spread interest for the language among people with less\ntechnical knowledge.\nIndonesian \nDaniel (daniel-dot-mirror-at-gmail-dot-com) is translating the book to Indonesian at http:/ /\npython. or. id/ moin. cgi/ ByteofPython\nPolish \nDominik Kozaczko (dkozaczko-at-gmail-dot-com) has volunteered to translate the book to\nPolish. Translation is in progress and it's main page is available here: Ukąś Pythona (http:/ /\nwiki. mercury. lo5. bielsko. pl/ index. php/ UkÄ Å_Pythona).\nDominik Kozaczko - I'm a Computer Science and Information Technology\nteacher.\n\nPython en:Translations\n10\nCatalan \nMoises Gomez (moisesgomezgiron-at-gmail-dot-com) has volunteered to translate the book\nto Catalan. The translation is in progress, and starts with the chapter \"Taula de continguts\".\nMoisès Gómez - I am a developer and also a teacher of programming (normally\nfor people without any previous experience). Some time ago I needed to learn\nhow to program in Python, and Swaroop's work was really helpful. Clear, concise,\nand complete enough. Just what I needed. After this experience, I thought some\nother people in my country could take benefit from it too. But English language\ncan be a barrier. So, why not try to translate it? And I did for a previous version of\nBoP. I my country there are two official languages. I selected the Catalan\nlanguage assuming that others will translate it to the more widespread Spanish.\nPortuguese \nFidel Viegas (fidel-dot-viegas-at-gmail-dot-com) has volunteered to translate the book to\nPortuguese.\nRomanian \nPaul-Sebastian Manole (brokenthorn-at-gmail-dot-com) has volunteered to translate this\nbook to Romanian.\nPaul-Sebastian Manole - I'm a second year Computer Science student at Spiru\nHaret University, here in Romania. I'm more of a self-taught programmer and\ndecided to learn a new language, Python. The web told me there was no better\nway to do so but read A Byte of Python. That's how popular this book is\n(congratulations to the author for writing such an easy to read book). I started\nliking Python so I decided to help translate the latest version of Swaroop's book in\nRomanian. Although I could be the one with the first initiative, I'm just one\nvolunteer so if you can help, please join me.\n The translation is being done here (http:/ / www. swaroopch. com/ notes/ Python_ro).\nBrazilian Portuguese \nRodrigo Amaral (http:/ / rodrigoamaral. net) (rodrigoamaral-at-gmail-dot-com) has\nvolunteered to translate the book to Brazilian Portuguese...\nFrench \nGregory (coulix-at-ozforces-dot-com-dot-au) has volunteered to translate the book to\nFrench.\nDanish \nLars Petersen (lars-at-ioflux-dot-net) has volunteered to translate the book to Danish.\nSpanish \nAlfonso de la Guarda Reyes (alfonsodg-at-ictechperu-dot-net) and Gustavo Echeverria \n(gustavo-dot-echeverria-at-gmail-dot-com) have volunteered to translate the book to\n\nPython en:Translations\n11\nSpanish. The translation is in progress, you can read the spanish (argentinian) translation\nstarting by the table of contents (tabla de contenidos).\nGustavo Echeverria: I work as a software engineer in Argentina. I use mostly C#\nand .Net technologies at work but strictly Python or Ruby in my personal projects.\nI knew Python many years ago and I got stuck inmediately. Not so long after\nknowing Python I discovered this book and it helped me to learn the language.\nThen I volunteered to translate the book to Spanish. Now, after receiving some\nrequests, I've begun to translate \"A Byte of Python\" with the help of Maximiliano\nSoler.\nArabic \nAlaa Abadi (alaanassir-at-gmail-dot-com) has volunteered to translate the book to Arabic.\nISA .\nSwedish \nMikael Jacobsson (leochingkwake-at-gmail-dot-com) has volunteered to translate the book\nto Swedish.\nRussian and Ukranian \nAverkiev Andrey (averkiyev-at-ukr-dot-net) has volunteered to translate the book to\nRussian, and perhaps Ukranian (time permitting).\nTurkish \nTürker SEZER (tsezer-at-btturk-dot-net) and Bugra Cakir (bugracakir-at-gmail-dot-com)\nhave volunteered to translate the book to Turkish.\nMongolian \nAriunsanaa Tunjin (tariunsanaa-at-yahoo-dot-com) has volunteered to translate the book to\nMongolian.\nNote\nReplace '-at-' with '@' , '-dot-' with '.' and '-underscore-' with '_' in the\nemail addresses mentioned on this page. Dashes in other places in the email address\nremain as-is.\n\nPython en:Translations\n12\nPrevious Next\nSource: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=2278\nContributors: Geopop65, Gustavo.echeverria, Leochingkwake, Moises, Morellik, Rodrigoamaral, Swaroop, Thorns,\nVages, Waterox888, 20 anonymous edits\nPython en:Preface\nPython is probably one of the few programming languages which is both simple and\npowerful. This is good for both and beginners as well as experts, and more importantly, is\nfun to program with. This book aims to help you learn this wonderful language and show\nhow to get things done quickly and painlessly - in effect 'The Perfect Anti-venom to your\nprogramming problems'.\nWho This Book Is For \nThis book serves as a guide or tutorial to the Python programming language. It is mainly\ntargeted at newbies. It is useful for experienced programmers as well.\nThe aim is that if all you know about computers is how to save text files, then you can learn\nPython from this book. If you have previous programming experience, then you can also\nlearn Python from this book.\nIf you do have previous programming experience, you will be interested in the differences\nbetween Python and your favorite programming language - I have highlighted many such\ndifferences. A little warning though, Python is soon going to become your favorite\nprogramming language!\nHistory Lesson \nI first started with Python when I needed to write an installer for a software I had written\ncalled 'Diamond' so that I could make the installation easy. I had to choose between Python\nand Perl bindings for the Qt library. I did some research on the web and I came across an\narticle where Eric S. Raymond, the famous and respected hacker, talked about how Python\nhas become his favorite programming language. I also found out that the PyQt bindings\nwere more mature compared to Perl-Qt. So, I decided that Python was the language for me.\nThen, I started searching for a good book on Python. I couldn't find any! I did find some\nO'Reilly books but they were either too expensive or were more like a reference manual\nthan a guide. So, I settled for the documentation that came with Python. However, it was\ntoo brief and small. It did give a good idea about Python but was not complete. I managed\nwith it since I had previous programming experience, but it was unsuitable for newbies.\nAbout six months after my first brush with Python, I installed the (then) latest Red Hat 9.0\nLinux and I was playing around with KWord. I got excited about it and suddenly got the\nidea of writing some stuff on Python. I started writing a few pages but it quickly became 30\npages long. Then, I became serious about making it more useful in a book form. After a lot\nof rewrites, it has reached a stage where it has become a useful guide to learning the\nPython language. I consider this book to be my contribution and tribute to the open source\ncommunity.\n\nPython en:Preface\n13\nThis book started out as my personal notes on Python and I still consider it in the same way,\nalthough I've taken a lot of effort to make it more palatable to others :)\nIn the true spirit of open source, I have received lots of constructive suggestions, criticisms\nand feedback from enthusiastic readers which has helped me improve this book a lot.\nStatus Of The Book \nChanges since the last major revision in March 2005 is updating for the Python 3.0 release\n(expected in August/September 2008). Since the Python 3.0 language itself is still not\nfinalized/released, this book is constantly undergoing changes. However, in the spirit of the\nopen source philosophy of \"Release Early, Release Often\", the updated book has been\nreleased and is constantly being updated.\nThe book needs the help of its readers such as yourselves to point out any parts of the book\nwhich are not good, not comprehensible or are simply wrong. Please write to the main\nauthor (http:/ / www. swaroopch. com/ contact/ ) or the respective translators with your\ncomments and suggestions.\nIt's a constant tussle to balance this book between a beginner's needs and the tendency\ntowards 'completeness' of information. It would be helpful if readers also gave feedback on\nhow much depth this book should go into.\nOfficial Website \nThe official website of the book is http:/ / www. swaroopch. com/ notes/ Python where you\ncan read the whole book online, download the latest versions of the book, buy a printed\nhard copy (http:/ / www. swaroopch. com/ buybook), and also send me feedback.\nLicense \n1. This book is licensed under the Creative Commons Attribution-Noncommercial-Share\nAlike 3.0 Unported (http:/ / creativecommons. org/ licenses/ by-nc-sa/ 3. 0/ ) license.\n• This means:\n• You are free to Share i.e. to copy, distribute and transmit this book\n• You are free to Remix i.e. to adapt this book\n • Under the following conditions:\n• Attribution. You must attribute the work in the manner specified by the author or\nlicensor (but not in any way that suggests that they endorse you or your use of this\nbook).\n• Share Alike. If you alter, transform, or build upon this work, you may distribute the\nresulting work only under the same or similar license to this one.\n • For any reuse or distribution, you must make clear to others the license terms of this\nbook.\n• Any of the above conditions can be waived if you get permission from the copyright\nholder.\n• Nothing in this license impairs or restricts the author's moral rights.\n 2. Attribution must be shown by linking back to http:/ / www. swaroopch. com/ notes/\nPython and clearly indicating that the original text can be fetched from this location.\n\nPython en:Preface\n14\n3. All the code/scripts provided in this book is licensed under the 3-clause BSD License\n(http:/ / www. opensource. org/ licenses/ bsd-license. php) unless otherwise noted.\n4. Volunteer contributions to this original book must be under this same license and the\ncopyright must be assigned to the main author of this book.\nFeedback \nI have put in a lot of effort to make this book as interesting and as accurate as possible.\nHowever, if you find some material to be inconsistent or incorrect, or simply needs\nimprovement, then please do inform me, so that I can make suitable improvements. You can\nreach me via my user page.\nBuy the Book \nIf you wish to support the continued development of this book, please consider purchasing\na printed copy (http:/ / www. swaroopch. com/ buybook) or making a donation.\nSomething To Think About \nThere are two ways of constructing a software design: one way is to make it so\nsimple that there are obviously no deficiencies; the other is to make it so\ncomplicated that there are no obvious deficiencies.\n-- C. A. R. Hoare\nSuccess in life is a matter not so much of talent and opportunity as of\nconcentration and perseverance.\n-- C. W. Wendte\nPrevious Next\nSource: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=987\nContributors: Gasolin, Swaroop, 2 anonymous edits\n\nPython en:Introduction\n15\nPython en:Introduction\nIntroduction \nPython is one of those rare languages which can claim to be both simple and powerful.\nYou will find that you will be pleasantly surprised on how easy it is to concentrate on the\nsolution to the problem rather than the syntax and structure of the language you are\nprogramming in.\nThe official introduction to Python is:\nPython is an easy to learn, powerful programming language. It has efficient\nhigh-level data structures and a simple but effective approach to object-oriented\nprogramming. Python's elegant syntax and dynamic typing, together with its\ninterpreted nature, make it an ideal language for scripting and rapid application\ndevelopment in many areas on most platforms. \n I will discuss most of these features in more detail in the next section.\nNote\nGuido van Rossum, the creator of the Python language, named the language after the\nBBC show \"Monty Python's Flying Circus\". He doesn't particularly like snakes that kill\nanimals for food by winding their long bodies around them and crushing them. \nFeatures of Python \nSimple\nPython is a simple and minimalistic language. Reading a good Python program feels\nalmost like reading English, although very strict English! This pseudo-code nature of\nPython is one of its greatest strengths. It allows you to concentrate on the solution to\nthe problem rather than the language itself.\n Easy to Learn\nAs you will see, Python is extremely easy to get started with. Python has an\nextraordinarily simple syntax, as already mentioned.\n Free and Open Source\nPython is an example of a FLOSS (Free/Libré and Open Source Software). In simple\nterms, you can freely distribute copies of this software, read its source code, make\nchanges to it, and use pieces of it in new free programs. FLOSS is based on the\nconcept of a community which shares knowledge. This is one of the reasons why\nPython is so good - it has been created and is constantly improved by a community who\njust want to see a better Python.\n High-level Language\nWhen you write programs in Python, you never need to bother about the low-level\ndetails such as managing the memory used by your program, etc. \n Portable\nDue to its open-source nature, Python has been ported to (i.e. changed to make it work\non) many platforms. All your Python programs can work on any of these platforms\nwithout requiring any changes at all if you are careful enough to avoid any\n\nPython en:Introduction\n16\nsystem-dependent features. \nYou can use Python on Linux, Windows, FreeBSD, Macintosh, Solaris, OS/2, Amiga,\nAROS, AS/400, BeOS, OS/390, z/OS, Palm OS, QNX, VMS, Psion, Acorn RISC OS,\nVxWorks, PlayStation, Sharp Zaurus, Windows CE and even PocketPC !\n Interpreted\nThis requires a bit of explanation.\nA program written in a compiled language like C or C++ is converted from the source\nlanguage i.e. C or C++ into a language that is spoken by your computer (binary code\ni.e. 0s and 1s) using a compiler with various flags and options. When you run the\nprogram, the linker/loader software copies the program from hard disk to memory and\nstarts running it.\nPython, on the other hand, does not need compilation to binary. You just run the\nprogram directly from the source code. Internally, Python converts the source code\ninto an intermediate form called bytecodes and then translates this into the native\nlanguage of your computer and then runs it. All this, actually, makes using Python\nmuch easier since you don't have to worry about compiling the program, making sure\nthat the proper libraries are linked and loaded, etc, etc. This also makes your Python\nprograms much more portable, since you can just copy your Python program onto\nanother computer and it just works!\n Object Oriented\nPython supports procedure-oriented programming as well as object-oriented\nprogramming. In procedure-oriented languages, the program is built around\nprocedures or functions which are nothing but reusable pieces of programs. In\nobject-oriented languages, the program is built around objects which combine data\nand functionality. Python has a very powerful but simplistic way of doing OOP,\nespecially when compared to big languages like C++ or Java.\n Extensible\nIf you need a critical piece of code to run very fast or want to have some piece of\nalgorithm not to be open, you can code that part of your program in C or C++ and\nthen use it from your Python program. \n Embeddable\nYou can embed Python within your C/C++ programs to give 'scripting' capabilities for\nyour program's users.\n Extensive Libraries\nThe Python Standard Library is huge indeed. It can help you do various things\ninvolving regular expressions, documentation generation, unit testing, threading,\ndatabases, web browsers, CGI, FTP, email, XML, XML-RPC, HTML, WAV files,\ncryptography, GUI (graphical user interfaces), Tk, and other system-dependent stuff.\nRemember, all this is always available wherever Python is installed. This is called the\n'Batteries Included' philosophy of Python.\nBesides, the standard library, there are various other high-quality libraries such as\nwxPython (http:/ / www. wxpython. org) , Twisted (http:/ / www. twistedmatrix. com/\nproducts/ twisted), Python Imaging Library (http:/ / www. pythonware. com/ products/\npil/ index. htm) and many more.\n\nPython en:Introduction\n17\nPython is indeed an exciting and powerful language. It has the right combination of\nperformance and features that make writing programs in Python both fun and easy. \nWhy not Perl? \nIf you didn't know already, Perl is another extremely popular open source interpreted\nprogramming language.\nIf you have ever tried writing a large program in Perl, you would have answered this\nquestion yourself! In other words, Perl programs are easy when they are small and it excels\nat small hacks and scripts to 'get work done'. However, they quickly become unwieldy once\nyou start writing bigger programs and I am speaking this out of my experience writing\nlarge Perl programs at Yahoo!\nWhen compared to Perl, Python programs are definitely simpler, clearer, easier to write\nand hence more understandable and maintainable. I do admire Perl and I do use it on a\ndaily basis for various things but whenever I write a program, I always start thinking in\nterms of Python because it has become so natural for me. Perl has undergone so many\nhacks and changes, that it feels like it is one big (but one hell of a) hack. Sadly, the\nupcoming Perl 6 does not seem to be making any improvements regarding this.\nThe only and very significant advantage that I feel Perl has, is its huge CPAN (http:/ / cpan.\nperl. org) library - the Comprehensive Perl Archive Network. As the name suggests, this is a\nhumongous collection of Perl modules and it is simply mind-boggling because of its sheer\nsize and depth - you can do virtually anything you can do with a computer using these\nmodules. One of the reasons that Perl has more libraries than Python is that it has been\naround for a much longer time than Python. However this seems to be changing with the\ngrowing Python Package Index (http:/ / pypi. python. org/ pypi).\nWhy not Ruby? \nIf you didn't know already, Ruby is another popular open source interpreted programming\nlanguage.\nIf you already like and use Ruby, then I would definitely recommend you to continue using\nit.\nFor other people who have not used it and are trying to judge whether to learn Python or to\nlearn Ruby, then I would recommend Python, purely from an ease-of-learning perspective. I\npersonally found it hard to grok the Ruby language, but for people who understand Ruby,\nthey all praise the beauty of the language. Unfortunately, I am not as lucky.\nWhat Programmers Say \nYou may find it interesting to read what great hackers like ESR have to say about Python:\n• Eric S. Raymond is the author of \"The Cathedral and the Bazaar\" and is also the person\nwho coined the term Open Source. He says that Python has become his favorite\nprogramming language (http:/ / www. linuxjournal. com/ article. php?sid=3882). This\narticle was the real inspiration for my first brush with Python.\n• Bruce Eckel is the author of the famous Thinking in Java and Thinking in C++ books. \nHe says that no language has made him more productive than Python. He says that \nPython is perhaps the only language that focuses on making things easier for the\n\nPython en:Introduction\n18\nprogrammer. Read the complete interview (http:/ / www. artima. com/ intv/ aboutme.\nhtml) for more details.\n• Peter Norvig is a well-known Lisp author and Director of Search Quality at Google\n(thanks to Guido van Rossum for pointing that out). He says that Python has always been\nan integral part of Google. You can actually verify this statement by looking at the Google\nJobs (http:/ / www. google. com/ jobs/ index. html) page which lists Python knowledge as a\nrequirement for software engineers.\nAbout Python 3. 0 \nPython 3.0 is the new version of the language. It is sometimes referred to as Python 3000 or\nPy3K.\nThe main reason for a major new version of Python is to remove all the small problems and\nnitpicks that have accumulated over the years and to make the language even more clean.\nIf you already have a lot of Python 2.x code, then there is a utility to assist you to convert\n2.x to 3.x source (http:/ / docs. python. org/ dev/ 3. 0/ library/ 2to3. html).\nMore details are at:\n• Guido van Rossum's introduction (http:/ / www. artima. com/ weblogs/ viewpost.\njsp?thread=208549)\n• What's New in Python 2.6 (http:/ / docs. python. org/ dev/ whatsnew/ 2. 6. html) (features\nsignificantly different from previous Python 2.x versions and most likely will be included\nin Python 3.0)\n• What's New in Python 3.0 (http:/ / docs. python. org/ dev/ 3. 0/ whatsnew/ 3. 0. html)\n• Python 2.6 and 3.0 Release Schedule (http:/ / www. python. org/ dev/ peps/ pep-0361/ )\n• Python 3000 (the official authoritative list of proposed changes) (http:/ / www. python.\norg/ dev/ peps/ pep-3000/ )\n• Miscellaneous Python 3.0 Plans (http:/ / www. python. org/ dev/ peps/ pep-3100/ )\n• Python News (detailed list of changes) (http:/ / www. python. org/ download/ releases/ 3.\n0/ NEWS. txt)\nPrevious Next\nSource: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=1789\nContributors: JeremyBicha, Swaroop, 2 anonymous edits\n\nPython en:Installation\n19\nPython en:Installation\nIf you have Python 2.x installed already, you do not have to remove it to install Python 3.0.\nYou can have both installed at the same time.\nFor Linux and BSD users \nIf you are using a Linux distribution such as Ubuntu, Fedora, OpenSUSE or {put your\nchoice here}, or a BSD system such as FreeBSD, then it is most likely you already have\nPython installed on your system.\nTo test if you have Python already installed on your Linux box, open a shell program (like\nkonsole or gnome-terminal) and enter the command python -V as shown below.\n    $ python -V\n    Python 3.0b1\nNote\n$ is the prompt of the shell. It will be different for you depending on the settings of\nyour OS, hence I will indicate the prompt by just the $ symbol.\nIf you see some version information like the one shown above, then you have Python\ninstalled already.\nHowever, if you get a message like this one:\n    $ python -V\n    bash: Python: command not found\nThen you don't have Python installed. This is highly unlikely but possible.\nNote\nIf you have Python 2.x already installed, then try python3 -V.\nIn this case, you have two ways of installing Python on your system.\n• You can compile Python from the source code (http:/ / www. python. org/ download/\nreleases/ 3. 0/ ) and install it. The compilation instructions are provided at the website.\n• [This option will be available after the final release of Python 3.0] Install the binary\npackages using the package management software that comes with your OS, such as\napt-get in Ubuntu/Debian and other Debian-based Linux, yum in Fedora Linux, pkg_add\nin FreeBSD, etc. Note that you will need an internet connection to use this method.\nAlternatively, you can download the binaries from somewhere else and then copy to your\nPC and install it.\n\nPython en:Installation\n20\nFor Windows Users \nVisit http:/ / www. python. org/ download/ releases/ 3. 0/ and download the latest version\nfrom this website, which was 3.0 beta 1 (http:/ / www. python. org/ ftp/ python/ 3. 0/\npython-3. 0b1. msi) as of this writing. This is just 12.8 MB which is very compact compared\nto most other languages or software. The installation is just like any other Windows-based\nsoftware.\nCaution\nWhen you are given the option of unchecking any \"optional\" components, don't\nuncheck any! Some of these components can be useful for you, especially IDLE.\nAn interesting fact is that majority of Python downloads are by Windows users. Of course,\nthis doesn't give the complete picture since almost all Linux users will have Python installed\nalready on their systems by default.\nDOS Prompt \nIf you want to be able to use Python from the Windows command line i.e. the DOS prompt,\nthen you need to set the PATH variable appropriately.\nFor Windows 2000, XP, 2003 , click on Control Panel -> System -> Advanced ->\nEnvironment Variables. Click on the variable named PATH in the 'System Variables'\nsection, then select Edit and add ;C:\\Python30 to the end of what is already there. Of\ncourse, use the appropriate directory name.\nFor older versions of Windows, add the following line to the file C:\\AUTOEXEC.BAT :\n'PATH=%PATH%;C:\\Python30' (without the quotes) and restart the system. For Windows NT,\nuse the AUTOEXEC.NT file.\nFor Mac OS X Users \nMac OS X Users will find Python already installed on their system. Open the Terminal.app\nand run python -V and follow the advice in the above Linux section.\nSummary \nFor a Linux system, you most probably already have Python installed on your system.\nOtherwise, you can install it using the package management software that comes with your\ndistribution. For a Windows system, installing Python is as easy as downloading the\ninstaller and double-clicking on it. From now on, we will assume that you have Python\ninstalled on your system.\nNext, we will write our first Python program.\n\nPython en:Installation\n21\nPrevious Next\nSource: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=1746\nContributors: Swaroop, 1 anonymous edits\nPython en:First Steps\nIntroduction \nWe will now see how to run a traditional 'Hello World' program in Python. This will teach\nyou how to write, save and run Python programs. \nThere are two ways of using Python to run your program - using the interactive interpreter\nprompt or using a source file. We will now see how to use both of these methods\nUsing The Interpreter Prompt \nStart the interpreter on the command line by entering python at the shell prompt.\nFor Windows users, you can run the interpreter in the command line if you have set the\nPATH variable appropriately.\nIf you are using IDLE, click on Start → Programs → Python 3.0 → IDLE (Python GUI).\nNow enter print('Hello World') followed by the Enter key. You should see the words\nHello World as output.\n    $ python\n    Python 3.0b2 (r30b2:65106, Jul 18 2008, 18:44:17) [MSC v.1500 32 \nbit (Intel)] on win32\n    Type \"help\", \"copyright\", \"credits\" or \"license\" for more \ninformation.\n    >>> print('Hello World')\n    Hello World\n    >>>\nNotice that Python gives you the output of the line immediately! What you just entered is a\nsingle Python statement. We use print to (unsurprisingly) print any value that you supply\nto it. Here, we are supplying the text Hello World and this is promptly printed to the\nscreen.\nHow to Quit the Interpreter Prompt \nTo exit the prompt, press ctrl-d if you are using IDLE or are using a Linux/BSD shell.\nIn case of the Windows command prompt, press ctrl-z followed by enter key.\nChoosing An Editor \nBefore we move on to writing Python programs in source files, we need an editor to write\nthe source files. The choice of an editor is crucial indeed. You have to choose an editor as\nyou would choose a car you would buy. A good editor will help you write Python programs\neasily, making your journey more comfortable and helps you reach your destination\n(achieve your goal) in a much faster and safer way. \n\nPython en:First Steps\n22\nOne of the very basic requirements is syntax highlighting where all the different parts of\nyour Python program are colorized so that you can see your program and visualize its\nrunning.\nIf you are using Windows, then I suggest that you use IDLE. IDLE does syntax highlighting\nand a lot more such as allowing you to run your programs within IDLE among other things.\nA special note: Do not use Notepad - it is a bad choice because it does not do syntax\nhighlighting and also importantly it does not support indentation of the text which is very\nimportant in our case as we will see later. Good editors such as IDLE (and also VIM) will\nautomatically help you do this.\nIf you are using Linux/FreeBSD, then you have a lot of choices for an editor. If you are just\nbeginning to program, you might want to use geany. It has a graphical user interface and\nhas buttons to compile and run your python program without a fuss.\nIf you are an experienced programmer, then you must be already using Vim or Emacs.\nNeedless to say, these are two of the most powerful editors and you will be benefitted by\nusing them to write your Python programs. I personally use Vim for most of my programs.\nIf you are a beginner programmer, then you can use Kate which is one of my favorites. In\ncase you are willing to take the time to learn Vim or Emacs, then I highly recommend that\nyou do learn to use either of them as it will be very useful for you in the long run.\nIn this book, we will use IDLE, our IDE and editor of choice. IDLE is installed by default\nwith the Windows and Mac OS X Python installers. It is also available for installation for\nLinux (http:/ / love-python. blogspot. com/ 2008/ 03/ install-idle-in-linux. html) and BSDs in\ntheir respective repositories.\nWe will explore how to use IDLE in the next section. For further details, please refer the\nIDLE documentation (http:/ / www. python. org/ idle/ doc/ idlemain. html).\nIf you still want to explore other choices of an editor, see the comprehensive list of Python\neditors (http:/ / www. python. org/ cgi-bin/ moinmoin/ PythonEditors) and make your choice.\nYou can also choose an IDE (Integrated Development Environment) for Python. See the\ncomprehensive list of IDEs that support Python (http:/ / www. python. org/ cgi-bin/\nmoinmoin/ IntegratedDevelopmentEnvironments) for more details. Once you start writing\nlarge Python programs, IDEs can be very useful indeed.\nI repeat once again, please choose a proper editor - it can make writing Python programs\nmore fun and easy. \nFor Vim users \nThere is a good introduction on how to make Vim a powerful Python IDE by John M\nAnderson (http:/ / blog. sontek. net/ 2008/ 05/ 11/ python-with-a-modular-ide-vim/ ).\n For Emacs users \nThere is a good introduction on how to make Emacs a powerful Python IDE by Ryan\nMcGuire (http:/ / www. enigmacurry. com/ 2008/ 05/ 09/\nemacs-as-a-powerful-python-ide/ ).\n\nPython en:First Steps\n23\nUsing A Source File \nNow let's get back to programming. There is a tradition that whenever you learn a new\nprogramming language, the first program that you write and run is the 'Hello World'\nprogram - all it does is just say 'Hello World' when you run it. As Simon Cozens [1] puts it, it\nis the 'traditional incantation to the programming gods to help you learn the language\nbetter' :) .\nStart your choice of editor, enter the following program and save it as helloworld.py\nIf you are using IDLE, click on File → New Window and enter the following program. Then\nclick on File → Save.\n#!/usr/bin/python \n#Filename: helloworld.py\nprint('Hello World') \nRun this program by opening a shell (Linux terminal or DOS prompt) and entering the\ncommand python helloworld.py.\nIf you are using IDLE, use the menu Run → Run Module or the keyboard shortcut F5.\nThe output is as shown below. \n    $ python helloworld.py\n    Hello World\nIf you got the output as shown above, congratulations! - you have successfully run your first\nPython program. \nIn case you got an error, please type the above program exactly as shown and above and\nrun the program again. Note that Python is case-sensitive i.e. print is not the same as\nPrint - note the lowercase p in the former and the uppercase P in the latter. Also, ensure\nthere are no spaces or tabs before the first character in each line - we will see why this is\nimportant later.\nHow It Works \nLet us consider the first two lines of the program. These are called comments - anything to\nthe right of the # symbol is a comment and is mainly useful as notes for the reader of the\nprogram.\nPython does not use comments except for the special case of the first line here. It is called\nthe shebang line - whenever the first two characters of the source file are #! followed by\nthe location of a program, this tells your Linux/Unix system that this program should be run\nwith this interpreter when you execute the program. This is explained in detail in the next\nsection. Note that you can always run the program on any platform by specifying the\ninterpreter directly on the command line such as the command python helloworld.py .\nImportant \nUse comments sensibly in your program to explain some important details of your\nprogram - this is useful for readers of your program so that they can easily understand\nwhat the program is doing. Remember, that person can be yourself after six months!\nThe comments are followed by a Python statement. Here we call the print function this \njust prints the text 'Hello World'. We will learn about functions in a → later chapter, what\n\nPython en:First Steps\n24\nyou should understand now is that whatever you supply in the parentheses will be printed\nback to the screen. In this case, we supply 'Hello World' which is referred to as a string -\ndon't worry, we will explore these terminologies in detail later.\nExecutable Python Programs \nThis applies only to Linux/Unix users but Windows users might be curious as well about the\nfirst line of the program. First, we have to give the program executable permission using\nthe chmod command then run the source program.\n    $ chmod a+x helloworld.py\n    $ ./helloworld.py\n    Hello World\nThe chmod command is used here to change the mode of the file by giving execute\npermission to all users of the system. Then, we execute the program directly by specifying\nthe location of the source file. We use the ./ to indicate that the program is located in the\ncurrent directory.\nTo make things more fun, you can rename the file to just helloworld and run it as\n./helloworld and it will still work since the system knows that it has to run the program\nusing the interpreter whose location is specified in the first line in the source file.\nWhat if you don't know where Python is located? Then, you can use the special env\nprogram on Linux/Unix systems. Just change the first line of the program to the following:\n#!/usr/bin/env python\nThe env program will in turn look for the Python interpreter which will run the program.\nSo far, we have been able to run our program as long as we know the exact path. What if\nwe wanted to be able to run the program from anywhere? You can do this by storing the\nprogram in one of the directories listed in the PATH environment variable. Whenever you\nrun any program, the system looks for that program in each of the directories listed in the\nPATH environment variable and then runs that program. We can make this program\navailable everywhere by simply copying this source file to one of the directories listed in\nPATH.\n    $ echo $PATH\n    /usr/local/bin:/usr/bin:/bin:/usr/X11R6/bin:/home/swaroop/bin\n    $ cp helloworld.py /home/swaroop/bin/helloworld\n    $ helloworld\n    Hello World\nWe can display the PATH variable using the echo command and prefixing the variable name\nby $ to indicate to the shell that we need the value of this variable. We see that\n/home/swaroop/bin is one of the directories in the PATH variable where swaroop is the\nusername I am using in my system. There will usually be a similar directory for your\nusername on your system. Alternatively, you can add a directory of your choice to the PATH\nvariable - this can be done by running PATH=$PATH:/home/swaroop/mydir where\n'/home/swaroop/mydir' is the directory I want to add to the PATH variable.\nThis method is very useful if you want to write useful scripts that you want to run the \nprogram anytime, anywhere. It is like creating your own commands just like cd or any\n\nPython en:First Steps\n25\nother commands that you use in the Linux terminal or DOS prompt.\nCaution \nW.r.t. Python, a program or a script or software all mean the same thing.\nGetting Help \nIf you need quick information about any function or statement in Python, then you can use\nthe built-in help functionality. This is very useful especially when using the interpreter\nprompt. For example, run help(print) - this displays the help for the print function which\nis used to print things to the screen.\nNote \nPress q to exit the help.\nSimilarly, you can obtain information about almost anything in Python. Use help() to learn\nmore about using help itself!\nIn case you need to get help for operators like return, then you need to put those inside\nquotes such as help('return') so that Python doesn't get confused on what we're trying\nto do.\nSummary \nYou should now be able to write, save and run Python programs at ease. Now that you are a\nPython user, let's learn some more Python concepts. \nReferences: \n[1] The author of the amazing 'Beginning Perl' book\n→ Previous → Next\nSource: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=2332\nContributors: Swaroop, 9 anonymous edits\n\nPython en:Basics\n26\nPython en:Basics\nJust printing 'Hello World' is not enough, is it? You want to do more than that - you want to\ntake some input, manipulate it and get something out of it. We can achieve this in Python\nusing constants and variables.\nLiteral Constants \nAn example of a literal constant is a number like 5, 1.23, 9.25e-3 or a string like 'This is\na string' or \"It's a string!\". It is called a literal because it is literal - you use its value\nliterally. The number 2 always represents itself and nothing else - it is a constant because\nits value cannot be changed. Hence, all these are referred to as literal constants.\nNumbers \nNumbers in Python are of three types - integers, floating point and complex numbers.\n• An examples of an integer is 2 which is just a whole number.\n• Examples of floating point numbers (or floats for short) are 3.23 and 52.3E-4. The E\nnotation indicates powers of 10. In this case, 52.3E-4 means 52.3 * 10-4.\n• Examples of complex numbers are (-5+4j) and (2.3 - 4.6j)\nNote for Experienced Programmers\nThere is no separate 'long int' type. The default integer type can be any large value.\nStrings \nA string is a sequence of characters. Strings are basically just a bunch of words. The words\ncan be in English or any other language that is supported in the Unicode standard, which\nmeans almost any language in the world (http:/ / www. unicode. org/ faq/ basic_q. html#16).\nNote for Experienced Programmers\nThere are no \"ASCII-only\" strings because Unicode is a superset of ASCII. If a strictly\nASCII-encoded byte-stream is needed, then use str.encode(\"ascii\"). For more\ndetails, please see the related discussion at StackOverflow (http:/ / stackoverflow. com/\nquestions/ 175240/\nhow-do-i-convert-a-files-format-from-unicode-to-ascii-using-python#175270).\nBy default, all strings are in Unicode.\nI can almost guarantee that you will be using strings in almost every Python program that\nyou write, so pay attention to the following part on how to use strings in Python.\n\nPython en:Basics\n27\nSingle Quotes \nYou can specify strings using single quotes such as 'Quote me on this'. All white space\ni.e. spaces and tabs are preserved as-is.\nDouble Quotes \nStrings in double quotes work exactly the same way as strings in single quotes. An example\nis \"What's your name?\"\nTriple Quotes \nYou can specify multi-line strings using triple quotes - (\"\"\" or '''). You can use single quotes\nand double quotes freely within the triple quotes. An example is:\n    '''This is a multi-line string. This is the first line.\n    This is the second line.\n    \"What's your name?,\" I asked.\n    He said \"Bond, James Bond.\"\n    '''\nEscape Sequences \nSuppose, you want to have a string which contains a single quote ('), how will you specify\nthis string? For example, the string is What's your name?. You cannot specify 'What's\nyour name?' because Python will be confused as to where the string starts and ends. So,\nyou will have to specify that this single quote does not indicate the end of the string. This\ncan be done with the help of what is called an escape sequence. You specify the single\nquote as \\' - notice the backslash. Now, you can specify the string as 'What\\'s your\nname?'.\nAnother way of specifying this specific string would be \"What's your name?\" i.e. using\ndouble quotes. Similarly, you have to use an escape sequence for using a double quote itself\nin a double quoted string. Also, you have to indicate the backslash itself using the escape\nsequence \\\\.\nWhat if you wanted to specify a two-line string? One way is to use a triple-quoted string as\nshown previously or you can use an escape sequence for the newline character - \\n to\nindicate the start of a new line. An example is This is the first line\\nThis is the\nsecond line. Another useful escape sequence to know is the tab - \\t. There are many more\nescape sequences but I have mentioned only the most useful ones here.\nOne thing to note is that in a string, a single backslash at the end of the line indicates that\nthe string is continued in the next line, but no newline is added. For example:\n    \"This is the first sentence.\\\n    This is the second sentence.\"\nis equivalent to \"This is the first sentence. This is the second sentence.\".\n\nPython en:Basics\n28\nRaw Strings \nIf you need to specify some strings where no special processing such as escape sequences\nare handled, then what you need is to specify a raw string by prefixing r or R to the string.\nAn example is r\"Newlines are indicated by \\n\".\nStrings Are Immutable \nThis means that once you have created a string, you cannot change it. Although this might\nseem like a bad thing, it really isn't. We will see why this is not a limitation in the various\nprograms that we see later on.\nString Literal Concatenation \nIf you place two string literals side by side, they are automatically concatenated by Python.\nFor example, 'What\\'s ' 'your name?' is automatically converted in to \"What's your\nname?\".\nNote for C/C++ Programmers\nThere is no separate char data type in Python. There is no real need for it and I am\nsure you won't miss it.\n Note for Perl/PHP Programmers\nRemember that single-quoted strings and double-quoted strings are the same - they do\nnot differ in any way.\n Note for Regular Expression Users\nAlways use raw strings when dealing with regular expressions. Otherwise, a lot of\nbackwhacking may be required. For example, backreferences can be referred to as\n'\\\\1' or r'\\1'.\nThe format Method \nSometimes we may want to construct strings from other information. This is where the\nformat() method is useful.\n#!/usr/bin/python\n# Filename: str_format.py\nage = 25\nname = 'Swaroop'\nprint('{0} is {1} years old'.format(name, age))\nprint('Why is {0} playing with that python?'.format(name))\nOutput:\n    $ python str_format.py\n    Swaroop is 25 years old\n    Why is Swaroop playing with that python?\nHow It Works:\nA string can use certain specifications and subsequently, the format method can be called\nto substitute those specifications with corresponding arguments to the format method.\n\nPython en:Basics\n29\nObserve the first usage where we use {0} and this corresponds to the variable name which\nis the first argument to the format method. Similarly, the second specification is {1}\ncorresponding to age which is the second argument to the format method.\nNotice that we could achieved the same using string concatenation: name + ' is ' +\nstr(age) + ' years old' but notice how much uglier and error-prone this is. Second, the\nconversion to string would be done automatically by the format method instead of the\nexplicit conversion here. Third, when using the format method, we can change the\nmessage without having to deal with the variables used and vice-versa.\nWhat Python does in the format method is that it substitutes each argument value into the\nplace of the specification. There can be more detailed specifications such as:\n>>> '{0:.3}'.format(1/3) # decimal (.) precision of 3 for float\n'0.333'\n>>> '{0:_^11}'.format('hello') # fill with underscores (_) with the text \ncentered (^) to 11 width\n'___hello___'\n>>> '{name} wrote {book}'.format(name='Swaroop', book='A Byte of Python') \n# keyword-based\n'Swaroop wrote A Byte of Python'\nDetails of this formatting specification is explained in the Python Enhancement Proposal\nNo. 3101 (http:/ / www. python. org/ dev/ peps/ pep-3101/ ).\nVariables \nUsing just literal constants can soon become boring - we need some way of storing any\ninformation and manipulate them as well. This is where variables come into the picture.\nVariables are exactly what the name implies - their value can vary, i.e., you can store\nanything using a variable. Variables are just parts of your computer's memory where you\nstore some information. Unlike literal constants, you need some method of accessing these\nvariables and hence you give them names.\nIdentifier Naming \nVariables are examples of identifiers. Identifiers are names given to identify something.\nThere are some rules you have to follow for naming identifiers:\n• The first character of the identifier must be a letter of the alphabet (uppercase ASCII or\nlowercase ASCII or Unicode character) or an underscore ('_').\n• The rest of the identifier name can consist of letters (uppercase ASCII or lowercase\nASCII or Unicode character), underscores ('_') or digits (0-9).\n• Identifier names are case-sensitive. For example, myname and myName are not the same.\nNote the lowercase n in the former and the uppercase N in the latter.\n• Examples of valid identifier names are i, __my_name, name_23, a1b2_c3 and\nresumÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â©_count.\n• Examples of invalid identifier names are 2things, this is spaced out, my-name, and\n\"this_is_in_quotes\".\n\nPython en:Basics\n30\nData Types \nVariables can hold values of different types called data types. The basic types are numbers\nand strings, which we have already discussed. In later chapters, we will see how to create\nour own types using classes.\nObjects \nRemember, Python refers to anything used in a program as an object. This is meant in the\ngeneric sense. Instead of saying 'the something', we say 'the object'.\nNote for Object Oriented Programming users\nPython is strongly object-oriented in the sense that everything is an object including\nnumbers, strings and functions.\nWe will now see how to use variables along with literal constants. Save the following\nexample and run the program.\nHow to write Python programs\nHenceforth, the standard procedure to save and run a Python program is as follows:\n1. Open your favorite editor.\n1. Enter the program code given in the example.\n1. Save it as a file with the filename mentioned in the comment. I follow the convention\nof having all Python programs saved with the extension .py.\n1. Run the interpreter with the command python program.py or use IDLE to run the\nprograms. You can also use the executable method as explained earlier.\nExample: Using Variables And Literal Constants \n# Filename : var.py\ni = 5\nprint(i)\ni = i + 1\nprint(i)\ns = '''This is a multi-line string.\nThis is the second line.'''\nprint(s)\nOutput:\n    $ python var.py\n    5\n    6\n    This is a multi-line string.\n    This is the second line.\nHow It Works:\nHere's how this program works. First, we assign the literal constant value 5 to the variable \ni using the assignment operator (=). This line is called a statement because it states that\n\nPython en:Basics\n31\nsomething should be done and in this case, we connect the variable name i to the value 5.\nNext, we print the value of i using the print statement which, unsurprisingly, just prints\nthe value of the variable to the screen.\nThen we add 1 to the value stored in i and store it back. We then print it and expectedly,\nwe get the value 6.\nSimilarly, we assign the literal string to the variable s and then print it.\nNote for static language programmers\nVariables are used by just assigning them a value. No declaration or data type\ndefinition is needed/used.\nLogical And Physical Lines \nA physical line is what you see when you write the program. A logical line is what Python\nsees as a single statement. Python implicitly assumes that each physical line corresponds to\na logical line.\nAn example of a logical line is a statement like print('Hello World') - if this was on a\nline by itself (as you see it in an editor), then this also corresponds to a physical line.\nImplicitly, Python encourages the use of a single statement per line which makes code more\nreadable.\nIf you want to specify more than one logical line on a single physical line, then you have to\nexplicitly specify this using a semicolon (;) which indicates the end of a logical\nline/statement. For example,\n    i = 5\n    print(i)\nis effectively same as\n    i = 5;\n    print(i);\nand the same can be written as\n    i = 5; print(i);\nor even\n    i = 5; print(i)\nHowever, I strongly recommend that you stick to writing a single logical line in a\nsingle physical line only. Use more than one physical line for a single logical line only if\nthe logical line is really long. The idea is to avoid the semicolon as much as possible since it\nleads to more readable code. In fact, I have never used or even seen a semicolon in a\nPython program.\nAn example of writing a logical line spanning many physical lines follows. This is referred to\nas explicit line joining.\n    s = 'This is a string. \\\n    This continues the string.'\n    print(s)\n\nPython en:Basics\n32\nThis gives the output:\n    This is a string. This continues the string.\nSimilarly,\n    print\\\n    (i)\nis the same as\n    print(i)\nSometimes, there is an implicit assumption where you don't need to use a backslash. This is\nthe case where the logical line uses parentheses, square brackets or curly braces. This is is\ncalled implicit line joining. You can see this in action when we write programs using lists\nin later chapters.\nIndentation \nWhitespace is important in Python. Actually, whitespace at the beginning of the line is\nimportant. This is called indentation. Leading whitespace (spaces and tabs) at the\nbeginning of the logical line is used to determine the indentation level of the logical line,\nwhich in turn is used to determine the grouping of statements.\nThis means that statements which go together must have the same indentation. Each such\nset of statements is called a block. We will see examples of how blocks are important in\nlater chapters.\nOne thing you should remember is that wrong indentation can give rise to errors. For\nexample:\ni = 5\n print('Value is ', i) # Error! Notice a single space at the start of \nthe line\nprint('I repeat, the value is ', i)\nWhen you run this, you get the following error:\n      File \"whitespace.py\", line 4\n        print('Value is ', i) # Error! Notice a single space at the \nstart of the line\n        ^\n    IndentationError: unexpected indent\nNotice that there is a single space at the beginning of the second line. The error indicated\nby Python tells us that the syntax of the program is invalid i.e. the program was not\nproperly written. What this means to you is that you cannot arbitrarily start new blocks of\nstatements (except for the default main block which you have been using all along, of\ncourse). Cases where you can use new blocks will be detailed in later chapters such as the\ncontrol flow chapter.\nHow to indent\nDo not use a mixture of tabs and spaces for the indentation as it does not work across \ndifferent platforms properly. I strongly recommend that you use a single tab or four\n\nPython en:Basics\n33\nspaces for each indentation level.\nChoose either of these two indentation styles. More importantly, choose one and use it\nconsistently i.e. use that indentation style only.\n Note to static language programmers\nPython will always use indentation for blocks and will never use braces. Run from\n__future__ import braces to learn more.\nSummary \nNow that we have gone through many nitty-gritty details, we can move on to more\ninteresting stuff such as control flow statements. Be sure to become comfortable with what\nyou have read in this chapter.\nPrevious Next\nSource: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=2376\nContributors: Swaroop, Vages, 10 anonymous edits\nPython en:Operators and Expressions\nIntroduction \nMost statements (logical lines) that you write will contain expressions. A simple example\nof an expression is 2 + 3. An expression can be broken down into operators and operands.\nOperators are functionality that do something and can be represented by symbols such as +\nor by special keywords. Operators require some data to operate on and such data is called\noperands. In this case, 2 and 3 are the operands.\nOperators \nWe will briefly take a look at the operators and their usage:\nNote that you can evaluate the expressions given in the examples using the interpreter\ninteractively. For example, to test the expression 2 + 3, use the interactive Python\ninterpreter prompt:\n>>> 2 + 3\n5\n>>> 3 * 5\n15\n>>>\nOperator \nName \nExplanation \nExamples \n+ \nPlus \nAdds the two objects \n3 + 5 gives 8. 'a' + 'b' gives 'ab'.\n- \nMinus \nEither gives a negative\nnumber or gives the\nsubtraction of one number\nfrom the other\n-5.2 gives a negative number. 50 - 24 gives 26.\n\nPython en:Operators and Expressions\n34\n* \nMultiply \nGives the multiplication of the\ntwo numbers or returns the\nstring repeated that many\ntimes.\n2 * 3 gives 6. 'la' * 3 gives 'lalala'.\n** \nPower \nReturns x to the power of y\n3 ** 4 gives 81 (i.e. 3 * 3 * 3 * 3)\n/ \nDivide \nDivide x by y\n4 / 3 gives 1.3333333333333333.\n// \nFloor Division\nReturns the floor of the\nquotient \n4 // 3 gives 1.\n% \nModulo \nReturns the remainder of the\ndivision \n8 % 3 gives 2. -25.5 % 2.25 gives 1.5.\n<<\nLeft Shift \nShifts the bits of the number\nto the left by the number of\nbits specified. (Each number is\nrepresented in memory by bits\nor binary digits i.e. 0 and 1)\n2 << 2 gives 8. 2 is represented by 10 in bits. Left\nshifting by 2 bits gives 1000 which represents the\ndecimal 8.\n>>\nRight Shift \nShifts the bits of the number\nto the right by the number of\nbits specified.\n11 >> 1 gives 5. 11 is represented in bits by 1011\nwhich when right shifted by 1 bit gives 101 which is\nthe decimal 5.\n&\nBitwise AND \nBitwise AND of the numbers \n5 & 3 gives 1.\n| \nBit-wise OR \nBitwise OR of the numbers \n5 | 3 gives 7\n^ \nBit-wise XOR \nBitwise XOR of the numbers\n5 ^ 3 gives 6\n~ \nBit-wise\ninvert \nThe bit-wise inversion of x is\n-(x+1) \n~5 gives -6.\n<\nLess Than \nReturns whether x is less than\ny. All comparison operators\nreturn True or False. Note\nthe capitalization of these\nnames.\n5 < 3 gives False and 3 < 5 gives True.\nComparisons can be chained arbitrarily: 3 < 5 < 7\ngives True.\n>\nGreater Than \nReturns whether x is greater\nthan y \n5 > 3 returns True. If both operands are numbers,\nthey are first converted to a common type.\nOtherwise, it always returns False.\n<=\nLess Than or\nEqual To \nReturns whether x is less than\nor equal to y\nx = 3; y = 6; x <= y returns True.\n>=\nGreater Than\nor Equal To \nReturns whether x is greater\nthan or equal to y\nx = 4; y = 3; x >= 3 returns True.\n== \nEqual To \nCompares if the objects are\nequal\nx = 2; y = 2; x == y returns True.\nx = 'str'; y = 'stR'; x == y returns False.\nx = 'str'; y = 'str'; x == y returns True.\n!= \nNot Equal To \nCompares if the objects are\nnot equal\nx = 2; y = 3; x != y returns True.\nnot \nBoolean NOT \nIf x is True, it returns False. If\nx is False, it returns True.\nx = True; not x returns False.\nand \nBoolean AND \nx and y returns False if x is\nFalse, else it returns\nevaluation of y\nx = False; y = True; x and y returns False\nsince x is False. In this case, Python will not evaluate\ny since it knows that the left hand side of the 'and'\nexpression is False which implies that the whole\nexpression will be False irrespective of the other\nvalues. This is called short-circuit evaluation.\n\nPython en:Operators and Expressions\n35\nor \nBoolean OR \nIf x is True, it returns True,\nelse it returns evaluation of y\nx = True; y = False; x or y returns True.\nShort-circuit evaluation applies here as well.\nShortcut for math operation and assignment \nIt is common to run a math operation on a variable and then assign the result of the\noperation back to the variable, hence there is a shortcut for such expressions:\nYou can write:\na = 2; a = a * 3\nas:\na = 2; a *= 3\nNotice that var = var operation expression becomes var operation= expression.\nEvaluation Order \nIf you had an expression such as 2 + 3 * 4, is the addition done first or the multiplication?\nOur high school maths tells us that the multiplication should be done first. This means that\nthe multiplication operator has higher precedence than the addition operator.\nThe following table gives the precedence table for Python, from the lowest precedence\n(least binding) to the highest precedence (most binding). This means that in a given\nexpression, Python will first evaluate the operators and expressions lower in the table\nbefore the ones listed higher in the table.\nThe following table, taken from the Python reference manual (http:/ / docs. python. org/\ndev/ 3. 0/ reference/ expressions. html#evaluation-order), is provided for the sake of\ncompleteness. It is far better to use parentheses to group operators and operands\nappropriately in order to explicitly specify the precedence. This makes the program more\nreadable. See Changing the Order of Evaluation below for details.\nOperator \nDescription \nlambda \nLambda Expression \nor \nBoolean OR \nand \nBoolean AND \nnot x \nBoolean NOT \nin, not in \nMembership tests \nis, is not \nIdentity tests \n<, <=, >, >=, !=, ==\nComparisons \n| \nBitwise OR \n^ \nBitwise XOR \n&\nBitwise AND \n<<, >>\nShifts \n+, - \nAddition and subtraction \n*, /, //, % \nMultiplication, Division, Floor Division and Remainder \n+x, -x \nPositive, Negative \n\nPython en:Operators and Expressions\n36\n~x \nBitwise NOT \n** \nExponentiation \nx.attribute \nAttribute reference \nx[index] \nSubscription \nx[index1:index2] \nSlicing \nf(arguments ...) \nFunction call \n(expressions, ...) \nBinding or tuple display \n[expressions, ...] \nList display \n{key:datum, ...} \nDictionary display \nThe operators which we have not already come across will be explained in later chapters.\nOperators with the same precedence are listed in the same row in the above table. For\nexample, + and - have the same precedence.\nChanging the Order Of Evaluation \nTo make the expressions more readable, we can use parentheses. For example, 2 + (3 *\n4) is definitely easier to understand than 2 + 3 * 4 which requires knowledge of the\noperator precedences. As with everything else, the parentheses should be used reasonably\n(do not overdo it) and should not be redundant (as in 2 + (3 + 4)).\nThere is an additional advantage to using parentheses - it helps us to change the order of\nevaluation. For example, if you want addition to be evaluated before multiplication in an\nexpression, then you can write something like (2 + 3) * 4.\nAssociativity \nOperators are usually associated from left to right i.e. operators with same precedence are\nevaluated in a left to right manner. For example, 2 + 3 + 4 is evaluated as (2 + 3) + 4.\nSome operators like assignment operators have right to left associativity i.e. a = b = c is\ntreated as a = (b = c).\nExpressions \nExample:\n#!/usr/bin/python\n# Filename: expression.py\nlength = 5\nbreadth = 2\narea = length * breadth\nprint('Area is', area)\nprint('Perimeter is', 2 * (length + breadth))\nOutput:\n\nPython en:Operators and Expressions\n37\n    $ python expression.py\n    Area is 10\n    Perimeter is 14\nHow It Works:\nThe length and breadth of the rectangle are stored in variables by the same name. We use\nthese to calculate the area and perimeter of the rectangle with the help of expressions. We\nstore the result of the expression length * breadth in the variable area and then print it\nusing the print function. In the second case, we directly use the value of the expression 2\n* (length + breadth) in the print function.\nAlso, notice how Python 'pretty-prints' the output. Even though we have not specified a\nspace between 'Area is' and the variable area, Python puts it for us so that we get a\nclean nice output and the program is much more readable this way (since we don't need to\nworry about spacing in the strings we use for output). This is an example of how Python\nmakes life easy for the programmer.\nSummary \nWe have seen how to use operators, operands and expressions - these are the basic building\nblocks of any program. Next, we will see how to make use of these in our programs using\nstatements.\nPrevious Next\nSource: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=1579\nContributors: Swaroop, 4 anonymous edits\n\nPython en:Control Flow\n38\nPython en:Control Flow\nIntroduction \nIn the programs we have seen till now, there has always been a series of statements and\nPython faithfully executes them in the same order. What if you wanted to change the flow of\nhow it works? For example, you want the program to take some decisions and do different\nthings depending on different situations such as printing 'Good Morning' or 'Good Evening'\ndepending on the time of the day?\nAs you might have guessed, this is achieved using control flow statements. There are three\ncontrol flow statements in Python - if, for and while.\nThe if statement \nThe if statement is used to check a condition and if the condition is true, we run a block of\nstatements (called the if-block), else we process another block of statements (called the\nelse-block). The else clause is optional.\nExample:\n#!/usr/bin/python\n# Filename: if.py\nnumber = 23\nguess = int(input('Enter an integer : '))\nif guess == number:\n    print('Congratulations, you guessed it.') # New block starts here\n    print('(but you do not win any prizes!)') # New block ends here\nelif guess < number:\n    print('No, it is a little higher than that') # Another block\n    # You can do whatever you want in a block ...\nelse:\n    print('No, it is a little lower than that')\n    # you must have guess > number to reach here\nprint('Done')\n# This last statement is always executed, after the if statement is \nexecuted\nOutput:\n    $ python if.py\n    Enter an integer : 50\n    No, it is a little lower than that\n    Done\n    \n    $ python if.py\n    Enter an integer : 22\n\nPython en:Control Flow\n39\n    No, it is a little higher than that\n    Done\n    \n    $ python if.py\n    Enter an integer : 23\n    Congratulations, you guessed it.\n    (but you do not win any prizes!)\n    Done\nHow It Works:\nIn this program, we take guesses from the user and check if it is the number that we have.\nWe set the variable number to any integer we want, say 23. Then, we take the user's guess\nusing the input() function. Functions are just reusable pieces of programs. We'll read\nmore about them in the next chapter.\nWe supply a string to the built-in input function which prints it to the screen and waits for\ninput from the user. Once we enter something and press enter key, the input() function\nreturns what we entered, as a string. We then convert this string to an integer using int\nand then store it in the variable guess. Actually, the int is a class but all you need to know\nright now is that you can use it to convert a string to an integer (assuming the string\ncontains a valid integer in the text).\nNext, we compare the guess of the user with the number we have chosen. If they are equal,\nwe print a success message. Notice that we use indentation levels to tell Python which\nstatements belong to which block. This is why indentation is so important in Python. I hope\nyou are sticking to the \"consistent indentation\" rule. Are you?\nNotice how the if statement contains a colon at the end - we are indicating to Python that\na block of statements follows.\nThen, we check if the guess is less than the number, and if so, we inform the user to guess\na little higher than that. What we have used here is the elif clause which actually\ncombines two related if else-if else statements into one combined if-elif-else\nstatement. This makes the program easier and reduces the amount of indentation required.\nThe elif and else statements must also have a colon at the end of the logical line\nfollowed by their corresponding block of statements (with proper indentation, of course)\nYou can have another if statement inside the if-block of an if statement and so on - this is\ncalled a nested if statement.\nRemember that the elif and else parts are optional. A minimal valid if statement is:\nif True:\n    print('Yes, it is true')\nAfter Python has finished executing the complete if statement along with the associated\nelif and else clauses, it moves on to the next statement in the block containing the if\nstatement. In this case, it is the main block where execution of the program starts and the\nnext statement is the print('Done') statement. After this, Python sees the ends of the\nprogram and simply finishes up.\nAlthough this is a very simple program, I have been pointing out a lot of things that you\nshould notice even in this simple program. All these are pretty straightforward (and\nsurprisingly simple for those of you from C/C++ backgrounds) and requires you to become\n\nPython en:Control Flow\n40\naware of all these initially, but after that, you will become comfortable with it and it'll feel\n'natural' to you.\nNote for C/C++ Programmers\nThere is no switch statement in Python. You can use an if..elif..else statement to\ndo the same thing (and in some cases, use a dictionary to do it quickly)\nThe while Statement \nThe while statement allows you to repeatedly execute a block of statements as long as a\ncondition is true. A while statement is an example of what is called a looping statement. A\nwhile statement can have an optional else clause.\nExample:\n#!/usr/bin/python\n# Filename: while.py\nnumber = 23\nrunning = True\nwhile running:\n    guess = int(input('Enter an integer : '))\n    if guess == number:\n        print('Congratulations, you guessed it.')\n        running = False # this causes the while loop to stop\n    elif guess < number:\n        print('No, it is a little higher than that.')\n    else:\n        print('No, it is a little lower than that.')\nelse:\n    print('The while loop is over.')\n    # Do anything else you want to do here\nprint('Done')\nOutput:\n    $ python while.py\n    Enter an integer : 50\n    No, it is a little lower than that.\n    Enter an integer : 22\n    No, it is a little higher than that.\n    Enter an integer : 23\n    Congratulations, you guessed it.\n    The while loop is over.\n    Done\nHow It Works:\n\nPython en:Control Flow\n41\nIn this program, we are still playing the guessing game, but the advantage is that the user\nis allowed to keep guessing until he guesses correctly - there is no need to repeatedly run\nthe program for each guess, as we have done in the previous section. This aptly\ndemonstrates the use of the while statement.\nWe move the input and if statements to inside the while loop and set the variable\nrunning to True before the while loop. First, we check if the variable running is True and\nthen proceed to execute the corresponding while-block. After this block is executed, the\ncondition is again checked which in this case is the running variable. If it is true, we\nexecute the while-block again, else we continue to execute the optional else-block and then\ncontinue to the next statement.\nThe else block is executed when the while loop condition becomes False - this may even\nbe the first time that the condition is checked. If there is an else clause for a while loop,\nit is always executed unless you break out of the loop with a break statement.\nThe True and False are called Boolean types and you can consider them to be equivalent\nto the value 1 and 0 respectively.\nNote for C/C++ Programmers\nRemember that you can have an else clause for the while loop.\nThe for loop \nThe for..in statement is another looping statement which iterates over a sequence of\nobjects i.e. go through each item in a sequence. We will see more about sequences in detail\nin later chapters. What you need to know right now is that a sequence is just an ordered\ncollection of items.\nExample:\n#!/usr/bin/python\n# Filename: for.py\nfor i in range(1, 5):\n    print(i)\nelse:\n    print('The for loop is over')\nOutput:\n    $ python for.py\n    1\n    2\n    3\n    4\n    The for loop is over\nHow It Works:\nIn this program, we are printing a sequence of numbers. We generate this sequence of\nnumbers using the built-in range function.\nWhat we do here is supply it two numbers and range returns a sequence of numbers \nstarting from the first number and up to the second number. For example, range(1,5)\n\nPython en:Control Flow\n42\ngives the sequence [1, 2, 3, 4]. By default, range takes a step count of 1. If we supply a\nthird number to range, then that becomes the step count. For example, range(1,5,2)\ngives [1,3]. Remember that the range extends up to the second number i.e. it does not\ninclude the second number.\nThe for loop then iterates over this range - for i in range(1,5) is equivalent to for i\nin [1, 2, 3, 4] which is like assigning each number (or object) in the sequence to i, one\nat a time, and then executing the block of statements for each value of i. In this case, we\njust print the value in the block of statements.\nRemember that the else part is optional. When included, it is always executed once after\nthe for loop is over unless a break statement is encountered.\nRemember that the for..in loop works for any sequence. Here, we have a list of numbers\ngenerated by the built-in range function, but in general we can use any kind of sequence of\nany kind of objects! We will explore this idea in detail in later chapters.\nNote for C/C++/Java/C# Programmers\nThe Python for loop is radically different from the C/C++ for loop. C# programmers\nwill note that the for loop in Python is similar to the foreach loop in C#. Java\nprogrammers will note that the same is similar to for (int i : IntArray) in Java\n1.5 .\nIn C/C++, if you want to write for (int i = 0; i < 5; i++), then in Python you\nwrite just for i in range(0,5). As you can see, the for loop is simpler, more\nexpressive and less error prone in Python.\nThe break Statement \nThe break statement is used to break out of a loop statement i.e. stop the execution of a\nlooping statement, even if the loop condition has not become False or the sequence of\nitems has been completely iterated over.\nAn important note is that if you break out of a for or while loop, any corresponding loop\nelse block is not executed.\nExample:\n#!/usr/bin/python\n# Filename: break.py\nwhile True:\n    s = (input('Enter something : '))\n    if s == 'quit':\n        break\n    print('Length of the string is', len(s))\nprint('Done')\nOutput:\n    $ python break.py\n    Enter something : Programming is fun\n    Length of the string is 18\n    Enter something : When the work is done\n    Length of the string is 21\n\nPython en:Control Flow\n43\n    Enter something : if you wanna make your work also fun:\n    Length of the string is 37\n    Enter something :       use Python!\n    Length of the string is 12\n    Enter something : quit\n    Done\nHow It Works:\nIn this program, we repeatedly take the user's input and print the length of each input each\ntime. We are providing a special condition to stop the program by checking if the user input\nis 'quit'. We stop the program by breaking out of the loop and reach the end of the\nprogram.\nThe length of the input string can be found out using the built-in len function.\nRemember that the break statement can be used with the for loop as well.\nSwaroop's Poetic Python \nThe input I have used here is a mini poem I have written called Swaroop's Poetic Python:\n    Programming is fun\n    When the work is done\n    if you wanna make your work also fun:\n        use Python!\nThe continue Statement \nThe continue statement is used to tell Python to skip the rest of the statements in the\ncurrent loop block and to continue to the next iteration of the loop.\nExample:\n#!/usr/bin/python\n# Filename: continue.py\nwhile True:\n    s = input('Enter something : ')\n    if s == 'quit':\n        break\n    if len(s) < 3:\n        print('Too small')\n        continue\n    print('Input is of sufficient length')\n    # Do other kinds of processing here...\nOutput:\n    $ python test.py\n    Enter something : a\n    Too small\n    Enter something : 12\n    Too small\n\nPython en:Control Flow\n44\n    Enter something : abc\n    Input is of sufficient length\n    Enter something : quit\nHow It Works:\nIn this program, we accept input from the user, but we process them only if they are at\nleast 3 characters long. So, we use the built-in len function to get the length and if the\nlength is less than 3, we skip the rest of the statements in the block by using the continue\nstatement. Otherwise, the rest of the statements in the loop are executed and we can do\nany kind of processing we want to do here.\nNote that the continue statement works with the for loop as well.\nSummary \nWe have seen how to use the three control flow statements - if, while and for along with\ntheir associated break and continue statements. These are some of the most often used\nparts of Python and hence, becoming comfortable with them is essential.\nNext, we will see how to create and use functions.\nPrevious Next\nSource: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=1664\nContributors: Swaroop, 8 anonymous edits\nPython en:Functions\nIntroduction \nFunctions are reusable pieces of programs. They allow you to give a name to a block of\nstatements and you can run that block using that name anywhere in your program and any\nnumber of times. This is known as calling the function. We have already used many built-in\nfunctions such as the len and range.\nThe function concept is probably the most important building block of any non-trivial\nsoftware (in any programming language), so we will explore various aspects of functions in\nthis chapter.\nFunctions are defined using the def keyword. This is followed by an identifier name for the\nfunction followed by a pair of parentheses which may enclose some names of variables and\nthe line ends with a colon. Next follows the block of statements that are part of this\nfunction. An example will show that this is actually very simple:\nExample:\n#!/usr/bin/python\n# Filename: function1.py\ndef sayHello():\n    print('Hello World!') # block belonging to the function\n# End of function\n\nPython en:Functions\n45\nsayHello() # call the function\nsayHello() # call the function again\nOutput:\n    $ python function1.py\n    Hello World!\n    Hello World!\nHow It Works:\nWe define a function called sayHello using the syntax as explained above. This function\ntakes no parameters and hence there are no variables declared in the parentheses.\nParameters to functions are just input to the function so that we can pass in different values\nto it and get back corresponding results.\nNotice that we can call the same function twice which means we do not have to write the\nsame code again.\nFunction Parameters \nA function can take parameters, which are values you supply to the function so that the\nfunction can do something utilising those values. These parameters are just like variables\nexcept that the values of these variables are defined when we call the function and are\nalready assigned values when the function runs.\nParameters are specified within the pair of parentheses in the function definition, separated\nby commas. When we call the function, we supply the values in the same way. Note the\nterminology used - the names given in the function definition are called parameters\nwhereas the values you supply in the function call are called arguments.\nExample:\n#!/usr/bin/python\n# Filename: func_param.py\ndef printMax(a, b):\n    if a > b:\n        print(a, 'is maximum')\n    elif a == b:\n        print(a, 'is equal to', b)\n    else:\n        print(b, 'is maximum')\nprintMax(3, 4) # directly give literal values\nx = 5\ny = 7\nprintMax(x, y) # give variables as arguments\nOutput:\n\nPython en:Functions\n46\n    $ python func_param.py\n    4 is maximum\n    7 is maximum\nHow It Works:\nHere, we define a function called printMax where we take two parameters called a and b.\nWe find out the greater number using a simple if..else statement and then print the\nbigger number.\nIn the first usage of printMax, we directly supply the numbers i.e. arguments. In the second\nusage, we call the function using variables. printMax(x, y) causes value of argument x to\nbe assigned to parameter a and the value of argument y assigned to parameter b. The\nprintMax function works the same in both the cases.\nLocal Variables \nWhen you declare variables inside a function definition, they are not related in any way to\nother variables with the same names used outside the function i.e. variable names are local\nto the function. This is called the scope of the variable. All variables have the scope of the\nblock they are declared in starting from the point of definition of the name.\nExample:\n#!/usr/bin/python\n# Filename: func_local.py\nx = 50\ndef func(x):\n    print('x is', x)\n    x = 2\n    print('Changed local x to', x)\nfunc(x)\nprint('x is still', x)\nOutput:\n    $ python func_local.py\n    x is 50\n    Changed local x to 2\n    x is still 50\nHow It Works:\nIn the function, the first time that we use the value of the name x, Python uses the value of\nthe parameter declared in the function.\nNext, we assign the value 2 to x. The name x is local to our function. So, when we change\nthe value of x in the function, the x defined in the main block remains unaffected.\nIn the last print function call, we display the value of x in the main block and confirm that\nit is actually unaffected.\n\nPython en:Functions\n47\nUsing The global Statement \nIf you want to assign a value to a name defined at the top level of the program (i.e. not\ninside any kind of scope such as functions or classes), then you have to tell Python that the\nname is not local, but it is global. We do this using the global statement. It is impossible to\nassign a value to a variable defined outside a function without the global statement.\nYou can use the values of such variables defined outside the function (assuming there is no\nvariable with the same name within the function). However, this is not encouraged and\nshould be avoided since it becomes unclear to the reader of the program as to where that\nvariable's definition is. Using the global statement makes it amply clear that the variable\nis defined in an outermost block.\nExample:\n#!/usr/bin/python\n# Filename: func_global.py\nx = 50\ndef func():\n    global x\n    print('x is', x)\n    x = 2\n    print('Changed global x to', x)\nfunc()\nprint('Value of x is', x)\nOutput:\n    $ python func_global.py\n    x is 50\n    Changed global x to 2\n    Value of x is 2\nHow It Works:\nThe global statement is used to declare that x is a global variable - hence, when we assign\na value to x inside the function, that change is reflected when we use the value of x in the\nmain block.\nYou can specify more than one global variable using the same global statement. For\nexample, global x, y, z.\n\nPython en:Functions\n48\nUsing nonlocal statement \nWe have seen how to access variables in the local and global scope above. There is another\nkind of scope called \"nonlocal\" scope which is in-between these two types of scopes.\nNonlocal scopes are observed when you define functions inside functions.\nSince everything in Python is just executable code, you can define functions anywhere.\nLet's take an example:\n#!/usr/bin/python\n# Filename: func_nonlocal.py\ndef func_outer():\n    x = 2\n    print('x is', x)\n    def func_inner():\n        nonlocal x\n        x = 5\n    func_inner()\n    print('Changed local x to', x)\nfunc_outer()\nOutput:\n    $ python func_nonlocal.py\n    x is 2\n    Changed local x to 5\nHow It Works:\nWhen we are inside func_inner, the 'x' defined in the first line of func_outer is relatively\nneither in local scope nor in global scope. We declare that we are using this x by nonlocal\nx and hence we get access to that variable.\nTry changing the nonlocal x to global x and also by removing the statement itself and\nobserve the difference in behavior in these two cases.\nDefault Argument Values \nFor some functions, you may want to make some of its parameters as optional and use\ndefault values if the user does not want to provide values for such parameters. This is done\nwith the help of default argument values. You can specify default argument values for\nparameters by following the parameter name in the function definition with the assignment\noperator (=) followed by the default value.\nNote that the default argument value should be a constant. More precisely, the default\nargument value should be immutable - this is explained in detail in later chapters. For now,\njust remember this.\nExample:\n\nPython en:Functions\n49\n#!/usr/bin/python\n# Filename: func_default.py\ndef say(message, times = 1):\n    print(message * times)\nsay('Hello')\nsay('World', 5)\nOutput:\n    $ python func_default.py\n    Hello\n    WorldWorldWorldWorldWorld\nHow It Works:\nThe function named say is used to print a string as many times as specified. If we don't\nsupply a value, then by default, the string is printed just once. We achieve this by specifying\na default argument value of 1 to the parameter times.\nIn the first usage of say, we supply only the string and it prints the string once. In the\nsecond usage of say, we supply both the string and an argument 5 stating that we want to\nsay the string message 5 times.\nImportant\nOnly those parameters which are at the end of the parameter list can be given default\nargument values i.e. you cannot have a parameter with a default argument value\nbefore a parameter without a default argument value in the order of parameters\ndeclared in the function parameter list.\nThis is because the values are assigned to the parameters by position. For example,\ndef func(a, b=5) is valid, but def func(a=5, b) is not valid.\nKeyword Arguments \nIf you have some functions with many parameters and you want to specify only some of\nthem, then you can give values for such parameters by naming them - this is called keyword\narguments - we use the name (keyword) instead of the position (which we have been using\nall along) to specify the arguments to the function.\nThere are two advantages - one, using the function is easier since we do not need to worry\nabout the order of the arguments. Two, we can give values to only those parameters which\nwe want, provided that the other parameters have default argument values.\nExample:\n#!/usr/bin/python\n# Filename: func_key.py\ndef func(a, b=5, c=10):\n    print('a is', a, 'and b is', b, 'and c is', c)\nfunc(3, 7)\n\nPython en:Functions\n50\nfunc(25, c=24)\nfunc(c=50, a=100)\nOutput:\n    $ python func_key.py\n    a is 3 and b is 7 and c is 10\n    a is 25 and b is 5 and c is 24\n    a is 100 and b is 5 and c is 50\nHow It Works:\nThe function named func has one parameter without default argument values, followed by\ntwo parameters with default argument values.\nIn the first usage, func(3, 7), the parameter a gets the value 3, the parameter b gets the\nvalue 7 and c gets the default value of 10.\nIn the second usage func(25, c=24), the variable a gets the value of 25 due to the position\nof the argument. Then, the parameter c gets the value of 24 due to naming i.e. keyword\narguments. The variable b gets the default value of 5.\nIn the third usage func(c=50, a=100), we use keyword arguments completely to specify\nthe values. Notice, that we are specifying value for parameter c before that for a even\nthough a is defined before c in the function definition.\nVarArgs parameters \nTODO\nShould I write about this in a later chapter since we haven't talked about lists and\ndictionaries yet?\nSometimes you might want to define a function that can take any number of parameters,\nthis can be achieved by using the stars:\n#!/usr/bin/python\n# Filename: total.py\ndef total(initial=5, *numbers, **keywords):\n    count = initial\n    for number in numbers:\n        count += number\n    for key in keywords:\n        count += keywords[key]\n    return count\nprint(total(10, 1, 2, 3, vegetables=50, fruits=100))\nOutput:\n    $ python total.py\n    166\nHow It Works:\n\nPython en:Functions\n51\nWhen we declare a starred parameter such as *param, then all the positional arguments\nfrom that point till the end are collected as a list called 'param'.\nSimilarly, when we declare a double-starred parameter such as **param, then all the\nkeyword arguments from that point till the end are collected as a dictionary called 'param'.\nWe will explore lists and dictionaries in a later chapter.\nKeyword- only Parameters \nIf we want to specify certain keyword parameters to be available as keyword-only and not\nas positional arguments, they can be declared after a starred parameter:\n#!/usr/bin/python\n# Filename: keyword_only.py\ndef total(initial=5, *numbers, vegetables):\n    count = initial\n    for number in numbers:\n        count += number\n    count += vegetables\n    return count\nprint(total(10, 1, 2, 3, vegetables=50))\nprint(total(10, 1, 2, 3))\n# Raises error because we have not supplied a default argument value \nfor 'vegetables'\nOutput:\n    $ python keyword_only.py\n    66\n    Traceback (most recent call last):\n      File \"test.py\", line 12, in <module>\n    print(total(10, 1, 2, 3))\n    TypeError: total() needs keyword-only argument vegetables\nHow It Works:\nDeclaring parameters after a starred parameter results in keyword-only arguments. If these\narguments are not supplied a default value, then calls to the function will raise an error if\nthe keyword argument is not supplied, as seen above.\nIf you want to have keyword-only arguments but have no need for a starred parameter, then\nsimply use an empty star without using any name such as def total(initial=5, *,\nvegetables).\n\nPython en:Functions\n52\nThe return Statement \nThe return statement is used to return from a function i.e. break out of the function. We\ncan optionally return a value from the function as well.\nExample:\n#!/usr/bin/python\n# Filename: func_return.py\ndef maximum(x, y):\n    if x > y:\n        return x\n    else:\n        return y\nprint(maximum(2, 3))\nOutput:\n    $ python func_return.py\n    3\nHow It Works:\nThe maximum function returns the maximum of the parameters, in this case the numbers\nsupplied to the function. It uses a simple if..else statement to find the greater value and\nthen returns that value.\nNote that a return statement without a value is equivalent to return None. None is a\nspecial type in Python that represents nothingness. For example, it is used to indicate that a\nvariable has no value if it has a value of None.\nEvery function implicitly contains a return None statement at the end unless you have\nwritten your own return statement. You can see this by running print(someFunction())\nwhere the function someFunction does not use the return statement such as:\ndef someFunction():\n    pass\nThe pass statement is used in Python to indicate an empty block of statements.\nNote\nThere is a built-in function called max that already implements the 'find maximum'\nfunctionality, so use this built-in function whenever possible.\n\nPython en:Functions\n53\nDocStrings \nPython has a nifty feature called documentation strings, usually referred to by its shorter\nname docstrings. DocStrings are an important tool that you should make use of since it\nhelps to document the program better and makes it easier to understand. Amazingly, we\ncan even get the docstring back from, say a function, when the program is actually running!\nExample:\n#!/usr/bin/python\n# Filename: func_doc.py\ndef printMax(x, y):\n    '''Prints the maximum of two numbers.\n    The two values must be integers.'''\n    x = int(x) # convert to integers, if possible\n    y = int(y)\n    if x > y:\n        print(x, 'is maximum')\n    else:\n        print(y, 'is maximum')\nprintMax(3, 5)\nprint(printMax.__doc__)\nOutput:\n    $ python func_doc.py\n    5 is maximum\n    Prints the maximum of two numbers.\n    \n            The two values must be integers.\nHow It Works:\nA string on the first logical line of a function is the docstring for that function. Note that\nDocStrings also apply to modules and classes which we will learn about in the respective\nchapters.\nThe convention followed for a docstring is a multi-line string where the first line starts with\na capital letter and ends with a dot. Then the second line is blank followed by any detailed\nexplanation starting from the third line. You are strongly advised to follow this convention\nfor all your docstrings for all your non-trivial functions.\nWe can access the docstring of the printMax function using the __doc__ (notice the\ndouble underscores) attribute (name belonging to) of the function. Just remember that\nPython treats everything as an object and this includes functions. We'll learn more about\nobjects in the chapter on classes.\nIf you have used help() in Python, then you have already seen the usage of docstrings! \nWhat it does is just fetch the __doc__ attribute of that function and displays it in a neat \nmanner for you. You can try it out on the function above - just include help(printMax) in\n\nPython en:Functions\n54\nyour program. Remember to press the q key to exit help.\nAutomated tools can retrieve the documentation from your program in this manner.\nTherefore, I strongly recommend that you use docstrings for any non-trivial function that\nyou write. The pydoc command that comes with your Python distribution works similarly to\nhelp() using docstrings.\nAnnotations \nFunctions have another advanced feature called annotations which are a nifty way of\nattaching additional information for each of the parameters as well as the return value.\nSince the Python language itself does not interpret these annotations in any way (that\nfunctionality is left to third-party libraries to interpret in any way they want), we will skip\nthis feature in our discussion. If you are interested to read about annotations, please see\nthe Python Enhancement Proposal No. 3107 (http:/ / www. python. org/ dev/ peps/\npep-3107/ ).\nSummary \nWe have seen so many aspects of functions but note that we still haven't covered all aspects\nof it. However, we have already covered most of what you'll use regarding Python functions\non an everyday basis.\nNext, we will see how to use as well as create Python modules.\nPrevious Next\nSource: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=2379\nContributors: Swaroop, Vages, 7 anonymous edits\n\nPython en:Modules\n55\nPython en:Modules\nIntroduction \nYou have seen how you can reuse code in your program by defining functions once. What if\nyou wanted to reuse a number of functions in other programs that you write? As you might\nhave guessed, the answer is modules.\nThere are various methods of writing modules, but the simplest way is to create a file with a\n.py extension that contains functions and variables.\nAnother method is to write the modules in the native language in which the Python\ninterpreter itself was written. For example, you can write modules in the C programming\nlanguage (http:/ / docs. python. org/ extending/ ) and when compiled, they can be used from\nyour Python code when using the standard Python interpreter.\nA module can be imported by another program to make use of its functionality. This is how\nwe can use the Python standard library as well. First, we will see how to use the standard\nlibrary modules.\nExample:\n#!/usr/bin/python\n# Filename: using_sys.py\nimport sys\nprint('The command line arguments are:')\nfor i in sys.argv:\n    print(i)\nprint('\\n\\nThe PYTHONPATH is', sys.path, '\\n')\nOutput:\n    $ python using_sys.py we are arguments\n    The command line arguments are:\n    using_sys.py\n    we\n    are\n    arguments\n    \n    The PYTHONPATH is ['', 'C:\\\\Windows\\\\system32\\\\python30.zip',\n    'C:\\\\Python30\\\\DLLs', 'C:\\\\Python30\\\\lib',\n    'C:\\\\Python30\\\\lib\\\\plat-win', 'C:\\\\Python30', \n    'C:\\\\Python30\\\\lib\\\\site-packages']\nHow It Works:\nFirst, we import the sys module using the import statement. Basically, this translates to\nus telling Python that we want to use this module. The sys module contains functionality\nrelated to the Python interpreter and its environment i.e. the system.\n\nPython en:Modules\n56\nWhen Python executes the import sys statement, it looks for the sys module. In this case,\nit is one of the built-in modules, and hence Python knows where to find it.\nIf it was not a compiled module i.e. a module written in Python, then the Python interpreter\nwill search for it in the directories listed in its sys.path variable. If the module is found,\nthen the statements in the body of that module is run and then the module is made\navailable for you to use. Note that the initialization is done only the first time that we\nimport a module.\nThe argv variable in the sys module is accessed using the dotted notation i.e. sys.argv. It\nclearly indicates that this name is part of the sys module. Another advantage of this\napproach is that the name does not clash with any argv variable used in your program.\nThe sys.argv variable is a list of strings (lists are explained in detail in a later chapter.\nSpecifically, the sys.argv contains the list of command line arguments i.e. the arguments\npassed to your program using the command line.\nIf you are using an IDE to write and run these programs, look for a way to specify command\nline arguments to the program in the menus.\nHere, when we execute python using_sys.py we are arguments, we run the module\nusing_sys.py with the python command and the other things that follow are arguments\npassed to the program. Python stores the command line arguments in the sys.argv\nvariable for us to use.\nRemember, the name of the script running is always the first argument in the sys.argv\nlist. So, in this case we will have 'using_sys.py' as sys.argv[0], 'we' as sys.argv[1],\n'are' as sys.argv[2] and 'arguments' as sys.argv[3]. Notice that Python starts\ncounting from 0 and not 1.\nThe sys.path contains the list of directory names where modules are imported from.\nObserve that the first string in sys.path is empty - this empty string indicates that the\ncurrent directory is also part of the sys.path which is same as the PYTHONPATH\nenvironment variable. This means that you can directly import modules located in the\ncurrent directory. Otherwise, you will have to place your module in one of the directories\nlisted in sys.path.\nNote that the current directory is the directory from which the program is launched. Run\nimport os; print(os.getcwd()) to find out the current directory of your program.\nByte- compiled . pyc files \nImporting a module is a relatively costly affair, so Python does some tricks to make it faster.\nOne way is to create byte-compiled files with the extension .pyc which is an intermediate\nform that Python transforms the program into (remember the introduction section on how\nPython works?). This .pyc file is useful when you import the module the next time from a\ndifferent program - it will be much faster since a portion of the processing required in\nimporting a module is already done. Also, these byte-compiled files are\nplatform-independent.\nNote\nThese .pyc files are usually created in the same directory as the corresponding .py\nfiles. If Python does not have permission to write to files in that directory, then the\n.pyc files will not be created.\n\nPython en:Modules\n57\nThe from . . . import . . . statement \nIf you want to directly import the argv variable into your program (to avoid typing the\nsys. everytime for it), then you can use the from sys import argv statement. If you want\nto import all the names used in the sys module, then you can use the from sys import *\nstatement. This works for any module.\nIn general, you should avoid using this statement and use the import statement instead\nsince your program will avoid name clashes and will be more readable.\nA module's _ _ name_ _ \nEvery module has a name and statements in a module can find out the name of its module.\nThis is handy in the particular situation of figuring out if the module is being run standalone\nor being imported. As mentioned previously, when a module is imported for the first time,\nthe code in that module is executed. We can use this concept to alter the behavior of the\nmodule if the program was used by itself and not when it was imported from another\nmodule. This can be achieved using the __name__ attribute of the module.\nExample:\n#!/usr/bin/python\n# Filename: using_name.py\nif __name__ == '__main__':\n    print('This program is being run by itself')\nelse:\n    print('I am being imported from another module')\nOutput:\n    $ python using_name.py\n    This program is being run by itself\n    \n    $ python\n    >>> import using_name\n    I am being imported from another module\n    >>>\nHow It Works:\nEvery Python module has it's __name__ defined and if this is '__main__', it implies that the\nmodule is being run standalone by the user and we can take appropriate actions.\n\nPython en:Modules\n58\nMaking Your Own Modules \nCreating your own modules is easy, you've been doing it all along! This is because every\nPython program is also a module. You just have to make sure it has a .py extension. The\nfollowing example should make it clear.\nExample:\n#!/usr/bin/python\n# Filename: mymodule.py\ndef sayhi():\n    print('Hi, this is mymodule speaking.')\n__version__ = '0.1'\n# End of mymodule.py\nThe above was a sample module. As you can see, there is nothing particularly special about\ncompared to our usual Python program. We will next see how to use this module in our\nother Python programs.\nRemember that the module should be placed in the same directory as the program that we\nimport it in, or the module should be in one of the directories listed in sys.path.\n#!/usr/bin/python\n# Filename: mymodule_demo.py\nimport mymodule\nmymodule.sayhi()\nprint ('Version', mymodule.__version__)\nOutput:\n    $ python mymodule_demo.py\n    Hi, this is mymodule speaking.\n    Version 0.1\nHow It Works:\nNotice that we use the same dotted notation to access members of the module. Python\nmakes good reuse of the same notation to give the distinctive 'Pythonic' feel to it so that we\ndon't have to keep learning new ways to do things.\nHere is a version utilising the from..import syntax:\n#!/usr/bin/python\n# Filename: mymodule_demo2.py\nfrom mymodule import sayhi, __version__\nsayhi()\nprint('Version', __version__)\n\nPython en:Modules\n59\nThe output of mymodule_demo2.py is same as the output of mymodule_demo.py.\nNotice that if there was already a __version__ name declared in the module that imports\nmymodule, there would be a clash. This is also likely because it is common practice for each\nmodule to declare it's version number using this name. Hence, it is always recommended to\nprefer the import statement even though it might make your program a little longer.\nYou could also use:\nfrom mymodule import *\nThis will import all public names such as sayhi but would not import __version__\nbecause it starts with double underscores.\nZen of Python\nOne of Python's guiding principles is that \"Explicit is better than Implicit\". Run import\nthis to learn more and see this discussion (http:/ / stackoverflow. com/ questions/\n228181/ zen-of-python) which lists examples for each of the principles.\nThe dir function \nYou can use the built-in dir function to list the identifiers that an object defines. For\nexample, for a module, the identifiers include the functions, classes and variables defined in\nthat module.\nWhen you supply a module name to the dir() function, it returns the list of the names\ndefined in that module. When no argument is applied to it, it returns the list of names\ndefined in the current module.\nExample:\n$ python\n>>> import sys # get list of attributes, in this case, for the sys module\n>>> dir(sys)\n['__displayhook__', '__doc__', '__excepthook__', '__name__', \n'__package__', '__s\ntderr__', '__stdin__', '__stdout__', '_clear_type_cache', \n'_compact_freelists',\n'_current_frames', '_getframe', 'api_version', 'argv', \n'builtin_module_names', '\nbyteorder', 'call_tracing', 'callstats', 'copyright', 'displayhook', \n'dllhandle'\n, 'dont_write_bytecode', 'exc_info', 'excepthook', 'exec_prefix', \n'executable',\n'exit', 'flags', 'float_info', 'getcheckinterval', \n'getdefaultencoding', 'getfil\nesystemencoding', 'getprofile', 'getrecursionlimit', 'getrefcount', \n'getsizeof',\n 'gettrace', 'getwindowsversion', 'hexversion', 'intern', 'maxsize', \n'maxunicode\n', 'meta_path', 'modules', 'path', 'path_hooks', 'path_importer_cache',\n\nPython en:Modules\n60\n 'platfor\nm', 'prefix', 'ps1', 'ps2', 'setcheckinterval', 'setprofile', \n'setrecursionlimit\n', 'settrace', 'stderr', 'stdin', 'stdout', 'subversion', 'version', \n'version_in\nfo', 'warnoptions', 'winver']\n>>> dir() # get list of attributes for current module\n['__builtins__', '__doc__', '__name__', '__package__', 'sys']\n>>> a = 5 # create a new variable 'a'\n>>> dir()\n['__builtins__', '__doc__', '__name__', '__package__', 'a', 'sys']\n>>> del a # delete/remove a name\n>>> dir()\n['__builtins__', '__doc__', '__name__', '__package__', 'sys']\n>>>\nHow It Works:\nFirst, we see the usage of dir on the imported sys module. We can see the huge list of\nattributes that it contains.\nNext, we use the dir function without passing parameters to it. By default, it returns the\nlist of attributes for the current module. Notice that the list of imported modules is also part\nof this list.\nIn order to observe the dir in action, we define a new variable a and assign it a value and\nthen check dir and we observe that there is an additional value in the list of the same\nname. We remove the variable/attribute of the current module using the del statement and\nthe change is reflected again in the output of the dir function.\nA note on del - this statement is used to delete a variable/name and after the statement\nhas run, in this case del a, you can no longer access the variable a - it is as if it never\nexisted before at all.\nNote that the dir() function works on any object. For example, run dir(print) to learn\nabout the attributes of the print function, or dir(str) for the attributes of the str class.\n\nPython en:Modules\n61\nPackages \nBy now, you must have started observing the hierarchy of organizing your programs.\nVariables usually go inside functions. Functions and global variables usually go inside\nmodules. What if you wanted to organize modules? That's where packages come into the\npicture.\nPackages are just folders of modules with a special __init__.py file that indicates to\nPython that this folder is special because it contains Python modules.\nLet's say you want to create a package called 'world' with subpackages 'asia', 'africa', etc.\nand these subpackages in turn contain modules like 'india', 'madagascar', etc.\nThis is how you would structure the folders:\n    - <some folder present in the sys.path>/\n        - world/\n            - __init__.py\n            - asia/\n                - __init__.py\n                - india/\n                    - __init__.py\n                    - foo.py\n            - africa/\n                - __init__.py\n                - madagascar/\n                    - __init__.py\n                    - bar.py\nPackages are just a convenience to hierarchically organize modules. You will see many\ninstances of this in the standard library.\nSummary \nJust like functions are reusable parts of programs, modules are reusable programs.\nPackages are another hierarchy to organize modules. The standard library that comes with\nPython is an example of such a set of packages and modules.\nWe have seen how to use these modules and create our own modules.\nNext, we will learn about some interesting concepts called data structures.\nPrevious Next\nSource: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=2371\nContributors: Swaroop, 7 anonymous edits\n\nPython en:Data Structures\n62\nPython en:Data Structures\nIntroduction \nData structures are basically just that - they are structures which can hold some data\ntogether. In other words, they are used to store a collection of related data.\nThere are four built-in data structures in Python - list, tuple, dictionary and set. We will see\nhow to use each of them and how they make life easier for us.\nList \nA list is a data structure that holds an ordered collection of items i.e. you can store a\nsequence of items in a list. This is easy to imagine if you can think of a shopping list where\nyou have a list of items to buy, except that you probably have each item on a separate line\nin your shopping list whereas in Python you put commas in between them.\nThe list of items should be enclosed in square brackets so that Python understands that you\nare specifying a list. Once you have created a list, you can add, remove or search for items\nin the list. Since we can add and remove items, we say that a list is a mutable data type i.e.\nthis type can be altered.\nQuick Introduction To Objects And Classes \nAlthough I've been generally delaying the discussion of objects and classes till now, a little\nexplanation is needed right now so that you can understand lists better. We will explore this\ntopic in detail later in its own chapter.\nA list is an example of usage of objects and classes. When we use a variable i and assign a\nvalue to it, say integer 5 to it, you can think of it as creating an object (i.e. instance) i of\nclass (i.e. type) int. In fact, you can read help(int) to understand this better.\nA class can also have methods i.e. functions defined for use with respect to that class only.\nYou can use these pieces of functionality only when you have an object of that class. For\nexample, Python provides an append method for the list class which allows you to add an\nitem to the end of the list. For example, mylist.append('an item') will add that string to\nthe list mylist. Note the use of dotted notation for accessing methods of the objects.\nA class can also have fields which are nothing but variables defined for use with respect to\nthat class only. You can use these variables/names only when you have an object of that\nclass. Fields are also accessed by the dotted notation, for example, mylist.field.\nExample:\n#!/usr/bin/python\n# Filename: using_list.py\n# This is my shopping list\nshoplist = ['apple', 'mango', 'carrot', 'banana']\nprint('I have', len(shoplist), 'items to purchase.')\nprint('These items are:', end=' ')\n\nPython en:Data Structures\n63\nfor item in shoplist:\n    print(item, end=' ')\nprint('\\nI also have to buy rice.')\nshoplist.append('rice')\nprint('My shopping list is now', shoplist)\nprint('I will sort my list now')\nshoplist.sort()\nprint('Sorted shopping list is', shoplist)\nprint('The first item I will buy is', shoplist[0])\nolditem = shoplist[0]\ndel shoplist[0]\nprint('I bought the', olditem)\nprint('My shopping list is now', shoplist)\nOutput:\n    $ python using_list.py\n    I have 4 items to purchase.\n    These items are: apple mango carrot banana\n    I also have to buy rice.\n    My shopping list is now ['apple', 'mango', 'carrot', 'banana', \n'rice']\n    I will sort my list now\n    Sorted shopping list is ['apple', 'banana', 'carrot', 'mango', \n'rice']\n    The first item I will buy is apple\n    I bought the apple\n    My shopping list is now ['banana', 'carrot', 'mango', 'rice']\nHow It Works:\nThe variable shoplist is a shopping list for someone who is going to the market. In\nshoplist, we only store strings of the names of the items to buy but you can add any kind\nof object to a list including numbers and even other lists.\nWe have also used the for..in loop to iterate through the items of the list. By now, you\nmust have realised that a list is also a sequence. The speciality of sequences will be\ndiscussed in a later section.\nNotice the use of the end keyword argument to the print function to indicate that we\nwant to end the output with a space instead of the usual line break.\nNext, we add an item to the list using the append method of the list object, as already\ndiscussed before. Then, we check that the item has been indeed added to the list by\nprinting the contents of the list by simply passing the list to the print statement which\nprints it neatly.\nThen, we sort the list by using the sort method of the list. It is important to understand \nthat this method affects the list itself and does not return a modified list - this is different \nfrom the way strings work. This is what we mean by saying that lists are mutable and that\n\nPython en:Data Structures\n64\nstrings are immutable.\nNext, when we finish buying an item in the market, we want to remove it from the list. We\nachieve this by using the del statement. Here, we mention which item of the list we want\nto remove and the del statement removes it from the list for us. We specify that we want to\nremove the first item from the list and hence we use del shoplist[0] (remember that\nPython starts counting from 0).\nIf you want to know all the methods defined by the list object, see help(list) for details.\nTuple \nTuples are used to hold together multiple objects. Think of them as similar to lists, but\nwithout the extensive functionality that the list class gives you. One major feature of tuples\nis that they are immutable like strings i.e. you cannot modify tuples.\nTuples are defined by specifying items separated by commas within an optional pair of\nparentheses.\nTuples are usually used in cases where a statement or a user-defined function can safely\nassume that the collection of values i.e. the tuple of values used will not change.\nExample:\n#!/usr/bin/python\n# Filename: using_tuple.py\nzoo = ('python', 'elephant', 'penguin') # remember the parentheses are \noptional\nprint('Number of animals in the zoo is', len(zoo))\nnew_zoo = ('monkey', 'camel', zoo)\nprint('Number of cages in the new zoo is', len(new_zoo))\nprint('All animals in new zoo are', new_zoo)\nprint('Animals brought from old zoo are', new_zoo[2])\nprint('Last animal brought from old zoo is', new_zoo[2][2])\nprint('Number of animals in the new zoo is', \nlen(new_zoo)-1+len(new_zoo[2]))\nOutput:\n    $ python using_tuple.py\n    Number of animals in the zoo is 3\n    Number of cages in the new zoo is 3\n    All animals in new zoo are ('monkey', 'camel', ('python', \n'elephant', 'penguin'))\n    Animals brought from old zoo are ('python', 'elephant', 'penguin')\n    Last animal brought from old zoo is penguin\n    Number of animals in the new zoo is 5\nHow It Works:\nThe variable zoo refers to a tuple of items. We see that the len function can be used to get\nthe length of the tuple. This also indicates that a tuple is a sequence as well.\n\nPython en:Data Structures\n65\nWe are now shifting these animals to a new zoo since the old zoo is being closed. Therefore,\nthe new_zoo tuple contains some animals which are already there along with the animals\nbrought over from the old zoo. Back to reality, note that a tuple within a tuple does not lose\nits identity.\nWe can access the items in the tuple by specifying the item's position within a pair of\nsquare brackets just like we did for lists. This is called the indexing operator. We access the\nthird item in new_zoo by specifying new_zoo[2] and we access the third item within the\nthird item in the new_zoo tuple by specifying new_zoo[2][2]. This is pretty simple once\nyou've understood the idiom.\nParentheses\nAlthough the parentheses is optional, I prefer always having them to make it obvious\nthat it is a tuple, especially because it avoids ambiguity. For example, print(1,2,3)\nand print( (1,2,3) ) mean two different things - the former prints three numbers\nwhereas the latter prints a tuple (which contains three numbers).\n Tuple with 0 or 1 items\nAn empty tuple is constructed by an empty pair of parentheses such as myempty = ().\nHowever, a tuple with a single item is not so simple. You have to specify it using a\ncomma following the first (and only) item so that Python can differentiate between a\ntuple and a pair of parentheses surrounding the object in an expression i.e. you have to\nspecify singleton = (2 , ) if you mean you want a tuple containing the item 2.\n Note for Perl programmers\nA list within a list does not lose its identity i.e. lists are not flattened as in Perl. The\nsame applies to a tuple within a tuple, or a tuple within a list, or a list within a tuple,\netc. As far as Python is concerned, they are just objects stored using another object,\nthat's all.\nDictionary \nA dictionary is like an address-book where you can find the address or contact details of a\nperson by knowing only his/her name i.e. we associate keys (name) with values (details).\nNote that the key must be unique just like you cannot find out the correct information if you\nhave two persons with the exact same name.\nNote that you can use only immutable objects (like strings) for the keys of a dictionary but\nyou can use either immutable or mutable objects for the values of the dictionary. This\nbasically translates to say that you should use only simple objects for keys.\nPairs of keys and values are specified in a dictionary by using the notation d = {key1 :\nvalue1, key2 : value2 }. Notice that the key-value pairs are separated by a colon and the\npairs are separated themselves by commas and all this is enclosed in a pair of curly braces.\nRemember that key-value pairs in a dictionary are not ordered in any manner. If you want a\nparticular order, then you will have to sort them yourself before using it.\nThe dictionaries that you will be using are instances/objects of the dict class.\nExample:\n#!/usr/bin/python\n# Filename: using_dict.py\n\nPython en:Data Structures\n66\n# 'ab' is short for 'a'ddress'b'ook\nab = {  'Swaroop'   : 'swaroop@swaroopch.com',\n        'Larry'     : 'larry@wall.org',\n        'Matsumoto' : 'matz@ruby-lang.org',\n        'Spammer'   : 'spammer@hotmail.com'\n    }\nprint(\"Swaroop's address is\", ab['Swaroop'])\n# Deleting a key-value pair\ndel ab['Spammer']\nprint('\\nThere are {0} contacts in the address-book\\n'.format(len(ab)))\nfor name, address in ab.items():\n    print('Contact {0} at {1}'.format(name, address))\n# Adding a key-value pair\nab['Guido'] = 'guido@python.org'\nif 'Guido' in ab: # OR ab.has_key('Guido')\n    print(\"\\nGuido's address is\", ab['Guido'])\nOutput:\n    $ python using_dict.py\n    Swaroop's address is swaroop@swaroopch.com\n    \n    There are 3 contacts in the address-book\n    \n    Contact Swaroop at swaroop@swaroopch.com\n    Contact Matsumoto at matz@ruby-lang.org\n    Contact Larry at larry@wall.org\n    \n    Guido's address is guido@python.org\nHow It Works:\nWe create the dictionary ab using the notation already discussed. We then access key-value\npairs by specifying the key using the indexing operator as discussed in the context of lists\nand tuples. Observe the simple syntax.\nWe can delete key-value pairs using our old friend - the del statement. We simply specify\nthe dictionary and the indexing operator for the key to be removed and pass it to the del\nstatement. There is no need to know the value corresponding to the key for this operation.\nNext, we access each key-value pair of the dictionary using the items method of the \ndictionary which returns a list of tuples where each tuple contains a pair of items - the key \nfollowed by the value. We retrieve this pair and assign it to the variables name and address \ncorrespondingly for each pair using the for..in loop and then print these values in the\n\nPython en:Data Structures\n67\nfor-block.\nWe can add new key-value pairs by simply using the indexing operator to access a key and\nassign that value, as we have done for Guido in the above case.\nWe can check if a key-value pair exists using the in operator or even the has_key method\nof the dict class. You can see the documentation for the complete list of methods of the\ndict class using help(dict).\nKeyword Arguments and Dictionaries\nOn a different note, if you have used keyword arguments in your functions, you have\nalready used dictionaries! Just think about it - the key-value pair is specified by you in\nthe parameter list of the function definition and when you access variables within your\nfunction, it is just a key access of a dictionary (which is called the symbol table in\ncompiler design terminology).\nSequences \nLists, tuples and strings are examples of sequences, but what are sequences and what is so\nspecial about them?\nThe major features is that they have membership tests (i.e. the in and not in expressions)\nand indexing operations. The indexing operation which allows us to fetch a particular item\nin the sequence directly.\nThe three types of sequences mentioned above - lists, tuples and strings, also have a\nslicing operation which allows us to retrieve a slice of the sequence i.e. a part of the\nsequence.\nExample:\n#!/usr/bin/python\n# Filename: seq.py\nshoplist = ['apple', 'mango', 'carrot', 'banana']\nname = 'swaroop'\n# Indexing or 'Subscription' operation\nprint('Item 0 is', shoplist[0])\nprint('Item 1 is', shoplist[1])\nprint('Item 2 is', shoplist[2])\nprint('Item 3 is', shoplist[3])\nprint('Item -1 is', shoplist[-1])\nprint('Item -2 is', shoplist[-2])\nprint('Character 0 is', name[0])\n# Slicing on a list\nprint('Item 1 to 3 is', shoplist[1:3])\nprint('Item 2 to end is', shoplist[2:])\nprint('Item 1 to -1 is', shoplist[1:-1])\nprint('Item start to end is', shoplist[:])\n# Slicing on a string\n\nPython en:Data Structures\n68\nprint('characters 1 to 3 is', name[1:3])\nprint('characters 2 to end is', name[2:])\nprint('characters 1 to -1 is', name[1:-1])\nprint('characters start to end is', name[:])\nOutput:\n    $ python seq.py\n    Item 0 is apple\n    Item 1 is mango\n    Item 2 is carrot\n    Item 3 is banana\n    Item -1 is banana\n    Item -2 is carrot\n    Character 0 is s\n    Item 1 to 3 is ['mango', 'carrot']\n    Item 2 to end is ['carrot', 'banana']\n    Item 1 to -1 is ['mango', 'carrot']\n    Item start to end is ['apple', 'mango', 'carrot', 'banana']\n    characters 1 to 3 is wa\n    characters 2 to end is aroop\n    characters 1 to -1 is waroo\n    characters start to end is swaroop\nHow It Works:\nFirst, we see how to use indexes to get individual items of a sequence. This is also referred\nto as the subscription operation. Whenever you specify a number to a sequence within\nsquare brackets as shown above, Python will fetch you the item corresponding to that\nposition in the sequence. Remember that Python starts counting numbers from 0. Hence,\nshoplist[0] fetches the first item and shoplist[3] fetches the fourth item in the\nshoplist sequence.\nThe index can also be a negative number, in which case, the position is calculated from the\nend of the sequence. Therefore, shoplist[-1] refers to the last item in the sequence and\nshoplist[-2] fetches the second last item in the sequence.\nThe slicing operation is used by specifying the name of the sequence followed by an\noptional pair of numbers separated by a colon within square brackets. Note that this is very\nsimilar to the indexing operation you have been using till now. Remember the numbers are\noptional but the colon isn't.\nThe first number (before the colon) in the slicing operation refers to the position from\nwhere the slice starts and the second number (after the colon) indicates where the slice will\nstop at. If the first number is not specified, Python will start at the beginning of the\nsequence. If the second number is left out, Python will stop at the end of the sequence.\nNote that the slice returned starts at the start position and will end just before the end\nposition i.e. the start position is included but the end position is excluded from the\nsequence slice.\nThus, shoplist[1:3] returns a slice of the sequence starting at position 1, includes\nposition 2 but stops at position 3 and therefore a slice of two items is returned. Similarly,\nshoplist[:] returns a copy of the whole sequence.\n\nPython en:Data Structures\n69\nYou can also do slicing with negative positions. Negative numbers are used for positions\nfrom the end of the sequence. For example, shoplist[:-1] will return a slice of the\nsequence which excludes the last item of the sequence but contains everything else.\nYou can also provide a third argument for the slice, which is the step for the slicing (by\ndefault, the step size is 1):\n>>> shoplist = ['apple', 'mango', 'carrot', 'banana']\n>>> shoplist[::1]\n['apple', 'mango', 'carrot', 'banana']\n>>> shoplist[::2]\n['apple', 'carrot']\n>>> shoplist[::3]\n['apple', 'banana']\n>>> shoplist[::-1]\n['banana', 'carrot', 'mango', 'apple']\nNotice that when the step is 2, we get the items with position 0, 2, ... When the step size is\n3, we get the items with position 0, 3, etc.\nTry various combinations of such slice specifications using the Python interpreter\ninteractively i.e. the prompt so that you can see the results immediately. The great thing\nabout sequences is that you can access tuples, lists and strings all in the same way!\nSet \nSets are unordered collections of simple objects. These are used when the existence of an\nobject in a collection is more important than the order or how many times it occurs.\nUsing sets, you can test for membership, whether it is a subset of another set, find the\nintersection between two sets, and so on.\n>>> bri = set(['brazil', 'russia', 'india'])\n>>> 'india' in bri\nTrue\n>>> 'usa' in bri\nFalse\n>>> bric = bri.copy()\n>>> bric.add('china')\n>>> bric.issuperset(bri)\nTrue\n>>> bri.remove('russia')\n>>> bri & bric # OR bri.intersection(bric)\n{'brazil', 'india'}\nHow It Works:\nThe example is pretty much self-explanatory because it involves basic set theory\nmathematics taught in school.\n\nPython en:Data Structures\n70\nReferences \nWhen you create an object and assign it to a variable, the variable only refers to the object\nand does not represent the object itself! That is, the variable name points to that part of\nyour computer's memory where the object is stored. This is called as binding of the name\nto the object.\nGenerally, you don't need to be worried about this, but there is a subtle effect due to\nreferences which you need to be aware of:\nExample:\n#!/usr/bin/python\n# Filename: reference.py\nprint('Simple Assignment')\nshoplist = ['apple', 'mango', 'carrot', 'banana']\nmylist = shoplist # mylist is just another name pointing to the same \nobject!\ndel shoplist[0] # I purchased the first item, so I remove it from the \nlist\nprint('shoplist is', shoplist)\nprint('mylist is', mylist)\n# notice that both shoplist and mylist both print the same list without\n# the 'apple' confirming that they point to the same object\nprint('Copy by making a full slice')\nmylist = shoplist[:] # make a copy by doing a full slice\ndel mylist[0] # remove first item\nprint('shoplist is', shoplist)\nprint('mylist is', mylist)\n# notice that now the two lists are different\nOutput:\n    $ python reference.py\n    Simple Assignment\n    shoplist is ['mango', 'carrot', 'banana']\n    mylist is ['mango', 'carrot', 'banana']\n    Copy by making a full slice\n    shoplist is ['mango', 'carrot', 'banana']\n    mylist is ['carrot', 'banana']\nHow It Works:\nMost of the explanation is available in the comments.\nRemember that if you want to make a copy of a list or such kinds of sequences or complex \nobjects (not simple objects such as integers), then you have to use the slicing operation to \nmake a copy. If you just assign the variable name to another name, both of them will refer\n\nPython en:Data Structures\n71\nto the same object and this could be trouble if you are not careful.\nNote for Perl programmers\nRemember that an assignment statement for lists does not create a copy. You have to\nuse slicing operation to make a copy of the sequence.\nMore About Strings \nWe have already discussed strings in detail earlier. What more can there be to know? Well,\ndid you know that strings are also objects and have methods which do everything from\nchecking part of a string to stripping spaces!\nThe strings that you use in program are all objects of the class str. Some useful methods of\nthis class are demonstrated in the next example. For a complete list of such methods, see\nhelp(str).\nExample:\n#!/usr/bin/python\n# Filename: str_methods.py\nname = 'Swaroop' # This is a string object\nif name.startswith('Swa'):\n    print('Yes, the string starts with \"Swa\"')\nif 'a' in name:\n    print('Yes, it contains the string \"a\"')\nif name.find('war') != -1:\n    print('Yes, it contains the string \"war\"')\ndelimiter = '_*_'\nmylist = ['Brazil', 'Russia', 'India', 'China']\nprint(delimiter.join(mylist))\nOutput:\n    $ python str_methods.py\n    Yes, the string starts with \"Swa\"\n    Yes, it contains the string \"a\"\n    Yes, it contains the string \"war\"\n    Brazil_*_Russia_*_India_*_China\nHow It Works:\nHere, we see a lot of the string methods in action. The startswith method is used to find\nout whether the string starts with the given string. The in operator is used to check if a\ngiven string is a part of the string.\nThe find method is used to do find the position of the given string in the string or returns\n-1 if it is not successful to find the substring. The str class also has a neat method to join\nthe items of a sequence with the string acting as a delimiter between each item of the\nsequence and returns a bigger string generated from this.\n\nPython en:Data Structures\n72\nSummary \nWe have explored the various built-in data structures of Python in detail. These data\nstructures will be essential for writing programs of reasonable size.\nNow that we have a lot of the basics of Python in place, we will next see how to design and\nwrite a real-world Python program.\nPrevious Next\nSource: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=1582\nContributors: Swaroop, 5 anonymous edits\nPython en:Problem Solving\nWe have explored various parts of the Python language and now we will take a look at how\nall these parts fit together, by designing and writing a program which does something\nuseful. The idea is to learn how to write a Python script on your own.\nThe Problem \nThe problem is \"I want a program which creates a backup of all my important files\".\nAlthough, this is a simple problem, there is not enough information for us to get started\nwith the solution. A little more analysis is required. For example, how do we specify which\nfiles are to be backed up? How are they stored? Where are they stored?\nAfter analyzing the problem properly, we design our program. We make a list of things\nabout how our program should work. In this case, I have created the following list on how I\nwant it to work. If you do the design, you may not come up with the same kind of analysis\nsince every person has their own way of doing things, so that is perfectly okay.\n1. The files and directories to be backed up are specified in a list.\n2. The backup must be stored in a main backup directory.\n3. The files are backed up into a zip file.\n4. The name of the zip archive is the current date and time.\n5. We use the standard zip command available by default in any standard Linux/Unix\ndistribution. Windows users can install (http:/ / gnuwin32. sourceforge. net/ downlinks/\nzip. php) from the GnuWin32 project page (http:/ / gnuwin32. sourceforge. net/ packages/\nzip. htm) and add C:\\Program Files\\GnuWin32\\bin to your system PATH environment\nvariable, similar to what we did for recognizing the python command itself. Note that you\ncan use any archiving command you want as long as it has a command line interface so\nthat we can pass arguments to it from our script.\n\nPython en:Problem Solving\n73\nThe Solution \nAs the design of our program is now reasonably stable, we can write the code which is an\nimplementation of our solution.\n#!/usr/bin/python\n# Filename: backup_ver1.py\nimport os\nimport time\n# 1. The files and directories to be backed up are specified in a list.\nsource = ['\"C:\\\\My Documents\"', 'C:\\\\Code']\n# Notice we had to use double quotes inside the string for names with \nspaces in it.\n# 2. The backup must be stored in a main backup directory\ntarget_dir = 'E:\\\\Backup' # Remember to change this to what you will be\n using\n# 3. The files are backed up into a zip file.\n# 4. The name of the zip archive is the current date and time\ntarget = target_dir + os.sep + time.strftime('%Y%m%d%H%M%S') + '.zip'\n# 5. We use the zip command to put the files in a zip archive\nzip_command = \"zip -qr {0} {1}\".format(target, ' '.join(source))\n# Run the backup\nif os.system(zip_command) == 0:\n    print('Successful backup to', target)\nelse:\n    print('Backup FAILED')\nOutput:\n    $ python backup_ver1.py\n    Successful backup to E:\\Backup\\20080702185040.zip\nNow, we are in the testing phase where we test that our program works properly. If it\ndoesn't behave as expected, then we have to debug our program i.e. remove the bugs\n(errors) from the program.\nIf the above program does not work for you, put a print(zip_command) just before the\nos.system call and run the program. Now copy/paste the printed zip_command to the shell\nprompt and see if it runs properly on its own. If this command fails, check the zip command\nmanual on what could be wrong. If this command succeeds, then check the Python program\nif it exactly matches the program written above.\nHow It Works:\nYou will notice how we have converted our design into code in a step-by-step manner.\n\nPython en:Problem Solving\n74\nWe make use of the os and time modules by first importing them. Then, we specify the\nfiles and directories to be backed up in the source list. The target directory is where store\nall the backup files and this is specified in the target_dir variable. The name of the zip\narchive that we are going to create is the current date and time which we find out using the\ntime.strftime() function. It will also have the .zip extension and will be stored in the\ntarget_dir directory.\nNotice the use of os.sep variable - this gives the directory separator according to your\noperating system i.e. it will be '/' in Linux, Unix, it will be '\\\\' in Windows and ':' in\nMac OS. Using os.sep instead of these characters directly will make our program portable\nand work across these systems.\nThe time.strftime() function takes a specification such as the one we have used in the\nabove program. The %Y specification will be replaced by the year without the century. The\n%m specification will be replaced by the month as a decimal number between 01 and 12 and\nso on. The complete list of such specifications can be found in the Python Reference Manual\n(http:/ / docs. python. org/ dev/ 3. 0/ library/ time. html#time. strftime).\nWe create the name of the target zip file using the addition operator which concatenates\nthe strings i.e. it joins the two strings together and returns a new one. Then, we create a\nstring zip_command which contains the command that we are going to execute. You can\ncheck if this command works by running it on the shell (Linux terminal or DOS prompt).\nThe zip command that we are using has some options and parameters passed. The -q\noption is used to indicate that the zip command should work quietly. The -r option\nspecifies that the zip command should work recursively for directories i.e. it should include\nall the subdirectories and files. The two options are combined and specified in a shortcut as\n-qr. The options are followed by the name of the zip archive to create followed by the list of\nfiles and directories to backup. We convert the source list into a string using the join\nmethod of strings which we have already seen how to use.\nThen, we finally run the command using the os.system function which runs the command\nas if it was run from the system i.e. in the shell - it returns 0 if the command was\nsuccessfully, else it returns an error number.\nDepending on the outcome of the command, we print the appropriate message that the\nbackup has failed or succeeded.\nThat's it, we have created a script to take a backup of our important files!\nNote to Windows Users\nInstead of double backslash escape sequences, you can also use raw strings. For\nexample, use 'C:\\\\Documents' or r'C:\\Documents'. However, do not use\n'C:\\Documents' since you end up using an unknown escape sequence \\D.\nNow that we have a working backup script, we can use it whenever we want to take a\nbackup of the files. Linux/Unix users are advised to use the executable method as discussed\nearlier so that they can run the backup script anytime anywhere. This is called the\noperation phase or the deployment phase of the software.\nThe above program works properly, but (usually) first programs do not work exactly as you\nexpect. For example, there might be problems if you have not designed the program\nproperly or if you have made a mistake in typing the code, etc. Appropriately, you will have\nto go back to the design phase or you will have to debug your program.\n\nPython en:Problem Solving\n75\nSecond Version \nThe first version of our script works. However, we can make some refinements to it so that\nit can work better on a daily basis. This is called the maintenance phase of the software.\nOne of the refinements I felt was useful is a better file-naming mechanism - using the time\nas the name of the file within a directory with the current date as a directory within the\nmain backup directory. First advantage is that your backups are stored in a hierarchical\nmanner and therefore it is much easier to manage. Second advantage is that the length of\nthe filenames are much shorter. Third advantage is that separate directories will help you\nto easily check if you have taken a backup for each day since the directory would be\ncreated only if you have taken a backup for that day.\n#!/usr/bin/python\n# Filename: backup_ver2.py\nimport os\nimport time\n# 1. The files and directories to be backed up are specified in a list.\nsource = ['\"C:\\\\My Documents\"', 'C:\\\\Code']\n# Notice we had to use double quotes inside the string for names with \nspaces in it.\n# 2. The backup must be stored in a main backup directory\ntarget_dir = 'E:\\\\Backup' # Remember to change this to what you will be\n using\n# 3. The files are backed up into a zip file.\n# 4. The current day is the name of the subdirectory in the main \ndirectory\ntoday = target_dir + os.sep + time.strftime('%Y%m%d')\n# The current time is the name of the zip archive\nnow = time.strftime('%H%M%S')\n# Create the subdirectory if it isn't already there\nif not os.path.exists(today):\n    os.mkdir(today) # make directory\n    print('Successfully created directory', today)\n# The name of the zip file\ntarget = today + os.sep + now + '.zip'\n# 5. We use the zip command to put the files in a zip archive\nzip_command = \"zip -qr {0} {1}\".format(target, ' '.join(source))\n# Run the backup\nif os.system(zip_command) == 0:\n    print('Successful backup to', target)\n\nPython en:Problem Solving\n76\nelse:\n    print('Backup FAILED')\nOutput:\n    $ python backup_ver2.py\n    Successfully created directory E:\\Backup\\20080702\n    Successful backup to E:\\Backup\\20080702\\202311.zip\n    \n    $ python backup_ver2.py\n    Successful backup to E:\\Backup\\20080702\\202325.zip\nHow It Works:\nMost of the program remains the same. The changes is that we check if there is a directory\nwith the current day as name inside the main backup directory using the os.path.exists\nfunction. If it doesn't exist, we create it using the os.mkdir function.\nThird Version \nThe second version works fine when I do many backups, but when there are lots of\nbackups, I am finding it hard to differentiate what the backups were for! For example, I\nmight have made some major changes to a program or presentation, then I want to\nassociate what those changes are with the name of the zip archive. This can be easily\nachieved by attaching a user-supplied comment to the name of the zip archive.\nNote\nThe following program does not work, so do not be alarmed, please follow along\nbecause there's a lesson in here.\n#!/usr/bin/python\n# Filename: backup_ver3.py\nimport os\nimport time\n# 1. The files and directories to be backed up are specified in a list.\nsource = ['\"C:\\\\My Documents\"', 'C:\\\\Code']\n# Notice we had to use double quotes inside the string for names with \nspaces in it.\n# 2. The backup must be stored in a main backup directory\ntarget_dir = 'E:\\\\Backup' # Remember to change this to what you will be\n using\n# 3. The files are backed up into a zip file.\n# 4. The current day is the name of the subdirectory in the main \ndirectory\ntoday = target_dir + os.sep + time.strftime('%Y%m%d')\n# The current time is the name of the zip archive\nnow = time.strftime('%H%M%S')\n\nPython en:Problem Solving\n77\n# Take a comment from the user to create the name of the zip file\ncomment = input('Enter a comment --> ')\nif len(comment) == 0: # check if a comment was entered\n    target = today + os.sep + now + '.zip'\nelse:\n    target = today + os.sep + now + '_' +\n        comment.replace(' ', '_') + '.zip'\n# Create the subdirectory if it isn't already there\nif not os.path.exists(today):\n    os.mkdir(today) # make directory\n    print('Successfully created directory', today)\n# 5. We use the zip command to put the files in a zip archive\nzip_command = \"zip -qr {0} {1}\".format(target, ' '.join(source))\n# Run the backup\nif os.system(zip_command) == 0:\n    print('Successful backup to', target)\nelse:\n    print('Backup FAILED')\nOutput:\n    $ python backup_ver3.py\n      File \"backup_ver3.py\", line 25\n        target = today + os.sep + now + '_' +\n                                            ^\n    SyntaxError: invalid syntax\nHow This (does not) Work:\nThis program does not work! Python says there is a syntax error which means that the\nscript does not satisfy the structure that Python expects to see. When we observe the error\ngiven by Python, it also tells us the place where it detected the error as well. So we start\ndebugging our program from that line.\nOn careful observation, we see that the single logical line has been split into two physical\nlines but we have not specified that these two physical lines belong together. Basically,\nPython has found the addition operator (+) without any operand in that logical line and\nhence it doesn't know how to continue. Remember that we can specify that the logical line\ncontinues in the next physical line by the use of a backslash at the end of the physical line.\nSo, we make this correction to our program. This correction of the program when we find\nerrors is called bug fixing.\n\nPython en:Problem Solving\n78\nFourth Version \n#!/usr/bin/python\n# Filename: backup_ver4.py\nimport os\nimport time\n# 1. The files and directories to be backed up are specified in a list.\nsource = ['\"C:\\\\My Documents\"', 'C:\\\\Code']\n# Notice we had to use double quotes inside the string for names with \nspaces in it.\n# 2. The backup must be stored in a main backup directory\ntarget_dir = 'E:\\\\Backup' # Remember to change this to what you will be\n using\n# 3. The files are backed up into a zip file.\n# 4. The current day is the name of the subdirectory in the main \ndirectory\ntoday = target_dir + os.sep + time.strftime('%Y%m%d')\n# The current time is the name of the zip archive\nnow = time.strftime('%H%M%S')\n# Take a comment from the user to create the name of the zip file\ncomment = input('Enter a comment --> ')\nif len(comment) == 0: # check if a comment was entered\n    target = today + os.sep + now + '.zip'\nelse:\n    target = today + os.sep + now + '_' + \\\n        comment.replace(' ', '_') + '.zip'\n# Create the subdirectory if it isn't already there\nif not os.path.exists(today):\n    os.mkdir(today) # make directory\n    print('Successfully created directory', today)\n# 5. We use the zip command to put the files in a zip archive\nzip_command = \"zip -qr {0} {1}\".format(target, ' '.join(source))\n# Run the backup\nif os.system(zip_command) == 0:\n    print('Successful backup to', target)\nelse:\n    print('Backup FAILED')\nOutput:\n\nPython en:Problem Solving\n79\n    $ python backup_ver4.py\n    Enter a comment --> added new examples\n    Successful backup to \nE:\\Backup\\20080702\\202836_added_new_examples.zip\n    \n    $ python backup_ver4.py\n    Enter a comment -->\n    Successful backup to E:\\Backup\\20080702\\202839.zip\nHow It Works:\nThis program now works! Let us go through the actual enhancements that we had made in\nversion 3. We take in the user's comments using the input function and then check if the\nuser actually entered something by finding out the length of the input using the len\nfunction. If the user has just pressed enter without entering anything (maybe it was just a\nroutine backup or no special changes were made), then we proceed as we have done\nbefore.\nHowever, if a comment was supplied, then this is attached to the name of the zip archive\njust before the .zip extension. Notice that we are replacing spaces in the comment with\nunderscores - this is because managing filenames without spaces are much easier.\nMore Refinements \nThe fourth version is a satisfactorily working script for most users, but there is always room\nfor improvement. For example, you can include a verbosity level for the program where you\ncan specify a -v option to make your program become more talkative.\nAnother possible enhancement would be to allow extra files and directories to be passed to\nthe script at the command line. We can get these names from the sys.argv list and we can\nadd them to our source list using the extend method provided by the list class.\nThe most important refinement would be to not use the os.system way of creating archives\nand instead using the zipfile or tarfile built-in module to create these archives. They\nare part of the standard library and available already for you to use without external\ndependencies on the zip program to be available on your computer.\nHowever, I have been using the os.system way of creating a backup in the above examples\npurely for pedagogical purposes, so that the example is simple enough to be understood by\neverybody but real enough to be useful.\nCan you try writing the fifth version that uses the zipfile (http:/ / docs. python. org/ dev/ 3.\n0/ library/ zipfile. html) module instead of the os.system call?\n\nPython en:Problem Solving\n80\nThe Software Development Process \nWe have now gone through the various phases in the process of writing a software. These\nphases can be summarised as follows:\n1. What (Analysis)\n2. How (Design)\n3. Do It (Implementation)\n4. Test (Testing and Debugging)\n5. Use (Operation or Deployment)\n6. Maintain (Refinement)\nA recommended way of writing programs is the procedure we have followed in creating the\nbackup script: Do the analysis and design. Start implementing with a simple version. Test\nand debug it. Use it to ensure that it works as expected. Now, add any features that you\nwant and continue to repeat the Do It-Test-Use cycle as many times as required.\nRemember, Software is grown, not built.\nSummary \nWe have seen how to create our own Python programs/scripts and the various stages\ninvolved in writing such programs. You may find it useful to create your own program just\nlike we did in this chapter so that you become comfortable with Python as well as\nproblem-solving.\nNext, we will discuss object-oriented programming.\nPrevious Next\nSource: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=1395\nContributors: Swaroop, 3 anonymous edits\n\nPython en:Object Oriented Programming\n81\nPython en:Object Oriented\nProgramming\nIntroduction \nIn all the programs we wrote till now, we have designed our program around functions i.e.\nblocks of statements which manipulate data. This is called the procedure-oriented way of\nprogramming. There is another way of organizing your program which is to combine data\nand functionality and wrap it inside something called an object. This is called the object\noriented programming paradigm. Most of the time you can use procedural programming,\nbut when writing large programs or have a problem that is better suited to this method, you\ncan use object oriented programming techniques.\nClasses and objects are the two main aspects of object oriented programming. A class\ncreates a new type where objects are instances of the class. An analogy is that you can\nhave variables of type int which translates to saying that variables that store integers are\nvariables which are instances (objects) of the int class.\nNote for Static Language Programmers\nNote that even integers are treated as objects (of the int class). This is unlike C++\nand Java (before version 1.5) where integers are primitive native types. See\nhelp(int) for more details on the class.\nC# and Java 1.5 programmers will find this similar to the boxing and unboxing\nconcept.\nObjects can store data using ordinary variables that belong to the object. Variables that\nbelong to an object or class are referred to as fields. Objects can also have functionality by\nusing functions that belong to a class. Such functions are called methods of the class. This\nterminology is important because it helps us to differentiate between functions and\nvariables which are independent and those which belong to a class or object. Collectively,\nthe fields and methods can be referred to as the attributes of that class.\nFields are of two types - they can belong to each instance/object of the class or they can\nbelong to the class itself. They are called instance variables and class variables\nrespectively.\nA class is created using the class keyword. The fields and methods of the class are listed\nin an indented block.\nThe self \nClass methods have only one specific difference from ordinary functions - they must have\nan extra first name that has to be added to the beginning of the parameter list, but you do\nnot give a value for this parameter when you call the method, Python will provide it. This\nparticular variable refers to the object itself, and by convention, it is given the name self.\nAlthough, you can give any name for this parameter, it is strongly recommended that you\nuse the name self - any other name is definitely frowned upon. There are many\nadvantages to using a standard name - any reader of your program will immediately\nrecognize it and even specialized IDEs (Integrated Development Environments) can help\nyou if you use self.\n\nPython en:Object Oriented Programming\n82\nNote for C++/Java/C# Programmers\nThe self in Python is equivalent to the this pointer in C++ and the this reference\nin Java and C#.\nYou must be wondering how Python gives the value for self and why you don't need to\ngive a value for it. An example will make this clear. Say you have a class called MyClass\nand an instance of this class called myobject. When you call a method of this object as\nmyobject.method(arg1, arg2), this is automatically converted by Python into\nMyClass.method(myobject, arg1, arg2) - this is all the special self is about.\nThis also means that if you have a method which takes no arguments, then you still have to\nhave one argument - the self.\nClasses \nThe simplest class possible is shown in the following example.\n#!/usr/bin/python\n# Filename: simplestclass.py\nclass Person:\n    pass # An empty block\np = Person()\nprint(p)\nOutput:\n    $ python simplestclass.py\n    <__main__.Person object at 0x019F85F0>\nHow It Works:\nWe create a new class using the class statement and the name of the class. This is\nfollowed by an indented block of statements which form the body of the class. In this case,\nwe have an empty block which is indicated using the pass statement.\nNext, we create an object/instance of this class using the name of the class followed by a\npair of parentheses. (We will learn more about instantiation in the next section). For our\nverification, we confirm the type of the variable by simply printing it. It tells us that we\nhave an instance of the Person class in the __main__ module.\nNotice that the address of the computer memory where your object is stored is also printed.\nThe address will have a different value on your computer since Python can store the object\nwherever it finds space.\n\nPython en:Object Oriented Programming\n83\nObject Methods \nWe have already discussed that classes/objects can have methods just like functions except\nthat we have an extra self variable. We will now see an example.\n#!/usr/bin/python\n# Filename: method.py\nclass Person:\n    def sayHi(self):\n        print('Hello, how are you?')\np = Person()\np.sayHi()\n# This short example can also be written as Person().sayHi()\nOutput:\n    $ python method.py\n    Hello, how are you?\nHow It Works:\nHere we see the self in action. Notice that the sayHi method takes no parameters but\nstill has the self in the function definition.\nThe _ _ init_ _ method \nThere are many method names which have special significance in Python classes. We will\nsee the significance of the __init__ method now.\nThe __init__ method is run as soon as an object of a class is instantiated. The method is\nuseful to do any initialization you want to do with your object. Notice the double\nunderscores both at the beginning and at the end of the name.\nExample:\n#!/usr/bin/python\n# Filename: class_init.py\nclass Person:\n    def __init__(self, name):\n        self.name = name\n    def sayHi(self):\n        print('Hello, my name is', self.name)\np = Person('Swaroop')\np.sayHi()\n# This short example can also be written as Person('Swaroop').sayHi()\nOutput:\n\nPython en:Object Oriented Programming\n84\n    $ python class_init.py\n    Hello, my name is Swaroop\nHow It Works:\nHere, we define the __init__ method as taking a parameter name (along with the usual\nself). Here, we just create a new field also called name. Notice these are two different\nvariables even though they are both called 'name'. The dotted notation allows us to\ndifferentiate between them.\nMost importantly, notice that we do not explicitly call the __init__ method but pass the\narguments in the parentheses following the class name when creating a new instance of the\nclass. This is the special significance of this method.\nNow, we are able to use the self.name field in our methods which is demonstrated in the\nsayHi method.\nClass And Object Variables \nWe have already discussed the functionality part of classes and objects (i.e. methods), now\nlet us learn about the data part. The data part, i.e. fields, are nothing but ordinary variables\nthat are bound to the namespaces of the classes and objects. This means that these names\nare valid within the context of these classes and objects only. That's why they are called\nname spaces.\nThere are two types of fields - class variables and object variables which are classified\ndepending on whether the class or the object owns the variables respectively.\nClass variables are shared - they can be accessed by all instances of that class. There is\nonly one copy of the class variable and when any one object makes a change to a class\nvariable, that change will be seen by all the other instances.\nObject variables are owned by each individual object/instance of the class. In this case,\neach object has its own copy of the field i.e. they are not shared and are not related in any\nway to the field by the same name in a different instance. An example will make this easy to\nunderstand:\n#!/usr/bin/python\n# Filename: objvar.py\n \nclass Robot:\n    '''Represents a robot, with a name.'''\n    # A class variable, counting the number of robots\n    population = 0\n \n    def __init__(self, name):\n        '''Initializes the data.'''\n        self.name = name\n        print('(Initializing {0})'.format(self.name))\n \n        # When this person is created, the robot\n        # adds to the population\n        Robot.population += 1\n\nPython en:Object Oriented Programming\n85\n \n    def __del__(self):\n        '''I am dying.'''\n        print('{0} is being destroyed!'.format(self.name))\n \n        Robot.population -= 1\n \n        if Robot.population == 0:\n            print('{0} was the last one.'.format(self.name))\n        else:\n            print('There are still {0:d} robots \nworking.'.format(Robot.population))\n \n    def sayHi(self):\n        '''Greeting by the robot.\n \n        Yeah, they can do that.'''\n        print('Greetings, my masters call me {0}.'.format(self.name))\n    def howMany():\n        '''Prints the current population.'''\n        print('We have {0:d} robots.'.format(Robot.population))\n    howMany = staticmethod(howMany)\n \ndroid1 = Robot('R2-D2')\ndroid1.sayHi()\nRobot.howMany()\n \ndroid2 = Robot('C-3PO')\ndroid2.sayHi()\nRobot.howMany()\n \nprint(\"\\nRobots can do some work here.\\n\")\nprint(\"Robots have finished their work. So let's destroy them.\")\ndel droid1\ndel droid2\nRobot.howMany()\nOutput:\n    (Initializing R2-D2)\n    Greetings, my masters call me R2-D2.\n    We have 1 robots.\n    (Initializing C-3PO)\n    Greetings, my masters call me C-3PO.\n    We have 2 robots.\n\nPython en:Object Oriented Programming\n86\n    \n    Robots can do some work here.\n    \n    Robots have finished their work. So let's destroy them.\n    R2-D2 is being destroyed!\n    There are still 1 robots working.\n    C-3PO is being destroyed!\n    C-3PO was the last one.\n    We have 0 robots.\nHow It Works:\nThis is a long example but helps demonstrate the nature of class and object variables. Here,\npopulation belongs to the Robot class and hence is a class variable. The name variable\nbelongs to the object (it is assigned using self) and hence is an object variable.\nThus, we refer to the population class variable as Robot.population and not as\nself.population. We refer to the object variable name using self.name notation in the\nmethods of that object. Remember this simple difference between class and object\nvariables. Also note that an object variable with the same name as a class variable will hide\nthe class variable!\nThe howMany is actually a method that belongs to the class and not to the object. This\nmeans we can define it as either a classmethod or a staticmethod depending on whether\nwe need to know which class we are part of. Since we don't need such information, we will\ngo for staticmethod.\nWe could have also achieved the same using decorators (http:/ / www. ibm. com/\ndeveloperworks/ linux/ library/ l-cpdecor. html):\n    @staticmethod\n    def howMany():\n        '''Prints the current population.'''\n        print('We have {0:d} robots.'.format(Robot.population))\nDecorators can be imagined to be a shortcut to calling an explicit statement, as we have\nseen in this example.\nObserve that the __init__ method is used to initialize the Robot instance with a name. In\nthis method, we increase the population count by 1 since we have one more robot being\nadded. Also observe that the values of self.name is specific to each object which indicates\nthe nature of object variables.\nRemember, that you must refer to the variables and methods of the same object using the\nself only. This is called an attribute reference.\nIn this program, we also see the use of docstrings for classes as well as methods. We can\naccess the class docstring at runtime using Robot.__doc__ and the method docstring as\nRobot.sayHi.__doc__\nJust like the __init__ method, there is another special method __del__ which is called\nwhen an object is going to die i.e. it is no longer being used and is being returned to the\ncomputer system for reusing that piece of memory. In this method, we simply decrease the\nRobot.population count by 1.\n\nPython en:Object Oriented Programming\n87\nThe __del__ method is run when the object is no longer in use and there is no guarantee\nwhen that method will be run. If you want to explicitly see it in action, we have to use the\ndel statement which is what we have done here.\nNote for C++/Java/C# Programmers\nAll class members (including the data members) are public and all the methods are\nvirtual in Python.\nOne exception: If you use data members with names using the double underscore\nprefix such as __privatevar, Python uses name-mangling to effectively make it a\nprivate variable.\nThus, the convention followed is that any variable that is to be used only within the\nclass or object should begin with an underscore and all other names are public and can\nbe used by other classes/objects. Remember that this is only a convention and is not\nenforced by Python (except for the double underscore prefix).\nInheritance \nOne of the major benefits of object oriented programming is reuse of code and one of the\nways this is achieved is through the inheritance mechanism. Inheritance can be best\nimagined as implementing a type and subtype relationship between classes.\nSuppose you want to write a program which has to keep track of the teachers and students\nin a college. They have some common characteristics such as name, age and address. They\nalso have specific characteristics such as salary, courses and leaves for teachers and, marks\nand fees for students.\nYou can create two independent classes for each type and process them but adding a new\ncommon characteristic would mean adding to both of these independent classes. This\nquickly becomes unwieldy.\nA better way would be to create a common class called SchoolMember and then have the\nteacher and student classes inherit from this class i.e. they will become sub-types of this\ntype (class) and then we can add specific characteristics to these sub-types.\nThere are many advantages to this approach. If we add/change any functionality in\nSchoolMember, this is automatically reflected in the subtypes as well. For example, you can\nadd a new ID card field for both teachers and students by simply adding it to the\nSchoolMember class. However, changes in the subtypes do not affect other subtypes.\nAnother advantage is that if you can refer to a teacher or student object as a SchoolMember\nobject which could be useful in some situations such as counting of the number of school\nmembers. This is called polymorphism where a sub-type can be substituted in any\nsituation where a parent type is expected i.e. the object can be treated as an instance of the\nparent class.\nAlso observe that we reuse the code of the parent class and we do not need to repeat it in\nthe different classes as we would have had to in case we had used independent classes.\nThe SchoolMember class in this situation is known as the base class or the superclass. The\nTeacher and Student classes are called the derived classes or subclasses.\nWe will now see this example as a program.\n#!/usr/bin/python\n# Filename: inherit.py\n\nPython en:Object Oriented Programming\n88\nclass SchoolMember:\n    '''Represents any school member.'''\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n        print('(Initialized SchoolMember: {0})'.format(self.name))\n    \n    def tell(self):\n        '''Tell my details.'''\n        print('Name:\"{0}\" Age:\"{1}\"'.format(self.name, self.age), end=\"\n \")\nclass Teacher(SchoolMember):\n    '''Represents a teacher.'''\n    def __init__(self, name, age, salary):\n        SchoolMember.__init__(self, name, age)\n        self.salary = salary\n        print('(Initialized Teacher: {0})'.format(self.name))\n    def tell(self):\n        SchoolMember.tell(self)\n        print('Salary: \"{0:d}\"'.format(self.salary))\nclass Student(SchoolMember):\n    '''Represents a student.'''\n    def __init__(self, name, age, marks):\n        SchoolMember.__init__(self, name, age)\n        self.marks = marks\n        print('(Initialized Student: {0})'.format(self.name))\n    \n    def tell(self):\n        SchoolMember.tell(self)\n        print('Marks: \"{0:d}\"'.format(self.marks))\nt = Teacher('Mrs. Shrividya', 40, 30000)\ns = Student('Swaroop', 25, 75)\nprint() # prints a blank line\nmembers = [t, s]\nfor member in members:\n    member.tell() # works for both Teachers and Students\nOutput:\n    $ python inherit.py\n    (Initialized SchoolMember: Mrs. Shrividya)\n\nPython en:Object Oriented Programming\n89\n    (Initialized Teacher: Mrs. Shrividya)\n    (Initialized SchoolMember: Swaroop)\n    (Initialized Student: Swaroop)\n    \n    Name:\"Mrs. Shrividya\" Age:\"40\" Salary: \"30000\"\n    Name:\"Swaroop\" Age:\"25\" Marks: \"75\"\nHow It Works:\nTo use inheritance, we specify the base class names in a tuple following the class name in\nthe class definition. Next, we observe that the __init__ method of the base class is\nexplicitly called using the self variable so that we can initialize the base class part of the\nobject. This is very important to remember - Python does not automatically call the\nconstructor of the base class, you have to explicitly call it yourself.\nWe also observe that we can call methods of the base class by prefixing the class name to\nthe method call and then pass in the self variable along with any arguments.\nNotice that we can treat instances of Teacher or Student as just instances of the\nSchoolMember when we use the tell method of the SchoolMember class.\nAlso, observe that the tell method of the subtype is called and not the tell method of the\nSchoolMember class. One way to understand this is that Python always starts looking for\nmethods in the actual type, which in this case it does. If it could not find the method, it\nstarts looking at the methods belonging to its base classes one by one in the order they are\nspecified in the tuple in the class definition.\nA note on terminology - if more than one class is listed in the inheritance tuple, then it is\ncalled multiple inheritance.\nSummary \nWe have now explored the various aspects of classes and objects as well as the various\nterminologies associated with it. We have also seen the benefits and pitfalls of\nobject-oriented programming. Python is highly object-oriented and understanding these\nconcepts carefully will help you a lot in the long run.\nNext, we will learn how to deal with input/output and how to access files in Python.\nPrevious Next\nSource: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=2359\nContributors: Horstjens, Swaroop, 6 anonymous edits\n\nPython en:Input Output\n90\nPython en:Input Output\nIntroduction \nThere will be situations where your program has to interact with the user. For example, you\nwould want to take input from the user and then print some results back. We can achieve\nthis using the input() and print() functions respectively.\nFor output, we can also use the various methods of the str (string) class. For example, you\ncan use the rjust method to get a string which is right justified to a specified width. See\nhelp(str) for more details.\nAnother common type of input/output is dealing with files. The ability to create, read and\nwrite files is essential to many programs and we will explore this aspect in this chapter.\nInput from user \n#!/usr/bin/python\n# user_input.py\ndef reverse(text):\n    return text[::-1]\ndef is_palindrome(text):\n    return text == reverse(text)\nsomething = input('Enter text: ')\nif (is_palindrome(something)):\n    print(\"Yes, it is a palindrome\")\nelse:\n    print(\"No, it is not a palindrome\")\nOutput:\n    $ python user_input.py\n    Enter text: sir\n    No, it is not a palindrome\n    \n    $ python user_input.py\n    Enter text: madam\n    Yes, it is a palindrome\n    \n    $ python user_input.py\n    Enter text: racecar\n    Yes, it is a palindrome\nHow It Works:\nWe use the slicing feature to reverse the text. We've already seen how we can make slices \nfrom sequences using the seq[a:b] code starting from position a to position b. We can \nalso provide a third argument that determines the step by which the slicing is done. The\n\nPython en:Input Output\n91\ndefault step is 1 because of which it returns a continuous part of the text. Giving a negative\nstep, i.e., -1 will return the text in reverse.\nThe input() function takes a string as argument and displays it to the user. Then it waits\nfor the user to type something and press the return key. Once the user has entered, the\ninput() function will then return that text.\nWe take that text and reverse it. If the original text and reversed text are equal, then the\ntext is a palindrome (http:/ / en. wiktionary. org/ wiki/ palindrome).\nHomework exercise:\nChecking whether a text is a palindrome should also ignore punctuation, spaces and case.\nFor example, \"Rise to vote, sir.\" is also a palindrome but our current program doesn't say it\nis. Can you improve the above program to recognize this palindrome?\nFiles \nYou can open and use files for reading or writing by creating an object of the file class\nand using its read, readline or write methods appropriately to read from or write to the\nfile. The ability to read or write to the file depends on the mode you have specified for the\nfile opening. Then finally, when you are finished with the file, you call the close method to\ntell Python that we are done using the file.\nExample:\n#!/usr/bin/python\n# Filename: using_file.py\n \npoem = '''\\\nProgramming is fun\nWhen the work is done\nif you wanna make your work also fun:\n    use Python!\n'''\n \nf = open('poem.txt', 'w') # open for 'w'riting\nf.write(poem) # write text to file\nf.close() # close the file\n \nf = open('poem.txt') # if no mode is specified, 'r'ead mode is assumed \nby default\nwhile True:\n    line = f.readline()\n    if len(line) == 0: # Zero length indicates EOF\n        break\n    print(line, end='')\nf.close() # close the file\nOutput:\n    $ python using_file.py\n    Programming is fun\n\nPython en:Input Output\n92\n    When the work is done\n    if you wanna make your work also fun:\n            use Python!\nHow It Works:\nFirst, open a file by using the built-in open function and specifying the name of the file and\nthe mode in which we want to open the file. The mode can be a read mode ('r'), write\nmode ('w') or append mode ('a'). We can also by dealing with a text file ('t') or a binary\nfile ('b'). There are actually many more modes available and help(open) will give you\nmore details about them. By default, open() considers the file to be a 't'ext file and opens it\nin 'r'ead mode.\nIn our example, we first open the file in write text mode and use the write method of the\nfile object to write to the file and then we finally close the file.\nNext, we open the same file again for reading. We don't need to specify a mode because\n'read text file' is the default mode. We read in each line of the file using the readline\nmethod in a loop. This method returns a complete line including the newline character at\nthe end of the line. When an empty string is returned, it means that we have reached the\nend of the file and we 'break' out of the loop.\nBy deafult, the print() function prints the text as well as an automatic newline to the\nscreen. We are suppressing the newline by specifying end='' because the line that is read\nfrom the file already ends with a newline character. Then, we finally close the file.\nNow, check the contents of the poem.txt file to confirm that the program has indeed\nwritten and read from that file.\nPickle \nPython provides a standard module called pickle using which you can store any Python\nobject in a file and then get it back later. This is called storing the object persistently.\nExample:\n#!/usr/bin/python\n# Filename: pickling.py\n \nimport pickle\n \n# the name of the file where we will store the object\nshoplistfile = 'shoplist.data'\n# the list of things to buy \nshoplist = ['apple', 'mango', 'carrot']\n \n# Write to the file\nf = open(shoplistfile, 'wb')\npickle.dump(shoplist, f) # dump the object to a file\nf.close()\n \ndel shoplist # destroy the shoplist variable\n \n# Read back from the storage\n\nPython en:Input Output\n93\nf = open(shoplistfile, 'rb')\nstoredlist = pickle.load(f) # load the object from the file\nprint(storedlist)\nOutput:\n    $ python pickling.py\n    ['apple', 'mango', 'carrot']\nHow It Works:\nTo store an object in a file, we have to first open the file in 'w'rite 'b'inary mode and then\ncall the dump function of the pickle module. This process is called pickling.\nNext, we retrieve the object using the load function of the pickle module which returns\nthe object. This process is called unpickling.\nSummary \nWe have discussed various types of input/output and also file handling and using the pickle\nmodule.\nNext, we will explore the concept of exceptions.\nPrevious Next\nSource: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=1583\nContributors: Horstjens, Swaroop, 1 anonymous edits\nPython en:Exceptions\nIntroduction \nExceptions occur when certain exceptional situations occur in your program. For example,\nwhat if you are going to read a file and the file does not exist? Or what if you accidentally\ndeleted it when the program was running? Such situations are handled using exceptions.\nSimilarly, what if your program had some invalid statements? This is handled by Python\nwhich raises its hands and tells you there is an error.\nErrors \nConsider a simple print function call. What if we misspelt print as Print? Note the\ncapitalization. In this case, Python raises a syntax error.\n    >>> Print('Hello World')\n    Traceback (most recent call last):\n      File \"<pyshell#0>\", line 1, in <module>\n        Print('Hello World')\n    NameError: name 'Print' is not defined\n    >>> print('Hello World')\n    Hello World\n\nPython en:Exceptions\n94\nObserve that a NameError is raised and also the location where the error was detected is\nprinted. This is what an error handler for this error does.\nExceptions \nWe will try to read input from the user. Press ctrl-d and see what happens.\n    >>> s = input('Enter something --> ')\n    Enter something --> \n    Traceback (most recent call last):\n      File \"<pyshell#2>\", line 1, in <module>\n        s = input('Enter something --> ')\n    EOFError: EOF when reading a line\nPython raises an error called EOFError which basically means it found an end of file symbol\n(which is represented by ctrl-d) when it did not expect to see it.\nHandling Exceptions \nWe can handle exceptions using the try..except statement. We basically put our usual\nstatements within the try-block and put all our error handlers in the except-block.\n#!/usr/bin/python\n# Filename: try_except.py\ntry:\n    text = input('Enter something --> ')\nexcept EOFError:\n    print('Why did you do an EOF on me?')\nexcept KeyboardInterrupt:\n    print('You cancelled the operation.')\nelse:\n    print('You entered {0}'.format(text))\nOutput:\n    $ python try_except.py\n    Enter something -->     # Press ctrl-d\n    Why did you do an EOF on me?\n    \n    $ python try_except.py\n    Enter something -->     # Press ctrl-c\n    You cancelled the operation.\n    \n    $ python try_except.py\n    Enter something --> no exceptions\n    You entered no exceptions\nHow It Works:\nWe put all the statements that might raise exceptions/errors inside the try block and then \nput handlers for the appropriate errors/exceptions in the except clause/block. The except\n\nPython en:Exceptions\n95\nclause can handle a single specified error or exception, or a parenthesized list of\nerrors/exceptions. If no names of errors or exceptions are supplied, it will handle all errors\nand exceptions.\nNote that there has to be at least one except clause associated with every try clause.\nOtherwise, what's the point of having a try block?\nIf any error or exception is not handled, then the default Python handler is called which just\nstops the execution of the program and prints an error message. We have already seen this\nin action above.\nYou can also have an else clause associated with a try..except block. The else clause is\nexecuted if no exception occurs.\nIn the next example, we will also see how to get the exception object so that we can retrieve\nadditional information.\nRaising Exceptions \nYou can raise exceptions using the raise statement by providing the name of the\nerror/exception and the exception object that is to be thrown.\nThe error or exception that you can arise should be class which directly or indirectly must\nbe a derived class of the Exception class.\n#!/usr/bin/python\n# Filename: raising.py\nclass ShortInputException(Exception):\n    '''A user-defined exception class.'''\n    def __init__(self, length, atleast):\n        Exception.__init__(self)\n        self.length = length\n        self.atleast = atleast\ntry:\n    text = input('Enter something --> ')\n    if len(text) < 3:\n        raise ShortInputException(len(text), 3)\n    # Other work can continue as usual here\nexcept EOFError:\n    print('Why did you do an EOF on me?')\nexcept ShortInputException as ex:\n    print('ShortInputException: The input was {0} long, expected at \nleast {1}'\\\n          .format(ex.length, ex.atleast))\nelse:\n    print('No exception was raised.')\nOutput:\n    $ python raising.py\n    Enter something --> a\n\nPython en:Exceptions\n96\n    ShortInputException: The input was 1 long, expected at least 3\n    \n    $ python raising.py\n    Enter something --> abc\n    No exception was raised.\nHow It Works:\nHere, we are creating our own exception type. This new exception type is called\nShortInputException. It has two fields - length which is the length of the given input, and\natleast which is the minimum length that the program was expecting.\nIn the except clause, we mention the class of error which will be stored as the variable\nname to hold the corresponding error/exception object. This is analogous to parameters and\narguments in a function call. Within this particular except clause, we use the length and\natleast fields of the exception object to print an appropriate message to the user.\nTry . . Finally \nSuppose you are reading a file in your program. How do you ensure that the file object is\nclosed properly whether or not an exception was raised? This can be done using the\nfinally block. Note that you can use an except clause along with a finally block for the\nsame corresponding try block. You will have to embed one within another if you want to\nuse both.\n#!/usr/bin/python\n# Filename: finally.py\nimport time\ntry:\n    f = open('poem.txt')\n    while True: # our usual file-reading idiom\n        line = f.readline()\n        if len(line) == 0:\n            break\n        print(line, end='')\n        time.sleep(2) # To make sure it runs for a while\nexcept KeyboardInterrupt:\n    print('!! You cancelled the reading from the file.')\nfinally:\n    f.close()\n    print('(Cleaning up: Closed the file)')\nOutput:\n    $ python finally.py\n    Programming is fun\n    When the work is done\n    if you wanna make your work also fun:\n    !! You cancelled the reading from the file.\n\nPython en:Exceptions\n97\n    (Cleaning up: Closed the file)\nHow It Works:\nWe do the usual file-reading stuff, but we have arbitrarily introduced sleeping for 2 seconds\nafter printing each line using the time.sleep function so that the program runs slowly\n(Python is very fast by nature). When the program is still running, press ctrl-c to\ninterrupt/cancel the program.\nObserve that the KeyboardInterrupt exception is thrown and the program quits. However,\nbefore the program exits, the finally clause is executed and the file object is always closed.\nThe with statement \nAcquiring a resource in the try block and subsequently releasing the resource in the\nfinally block is a common pattern. Hence, there is also a with statement that enables this\nto be done in a clean manner:\n#!/usr/bin/python\n# Filename: using_with.py\nwith open(\"poem.txt\") as f:\n    for line in f:\n        print(line, end='')\nHow It Works:\nThe output should be same as the previous example. The difference here is that we are\nusing the open function with the with statement - we leave the closing of the file to be\ndone automatically by with open.\nWhat happens behind the scenes is that there is a protocol used by the with statement. It\nfetches the object returned by the open statement, let's call it \"thefile\" in this case.\nIt always calls the thefile.__enter__ function before starting the block of code under it\nand always calls thefile.__exit__ after finishing the block of code.\nSo the code that we would have written in a finally block is should be taken care of\nautomatically by the __exit__ method. This is what helps us to avoid having to use explicit\ntry..finally statements repeatedly.\nMore discussion on this topic is beyond scope of this book, so please refer PEP 343 (http:/ /\nwww. python. org/ dev/ peps/ pep-0343/ ) for comprehensive explanation.\nSummary \nWe have discussed the usage of the try..except and try..finally statements. We have\nseen how to create our own exception types and how to raise exceptions as well.\nNext, we will explore the Python Standard Library.\nPrevious Next\nSource: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=1470\nContributors: Swaroop, 2 anonymous edits\n\nPython en:Standard Library\n98\nPython en:Standard Library\nIntroduction \nThe Python Standard Library contains a huge number of useful modules and is part of every\nstandard Python installation. It is important to become familiar with the Python Standard\nLibrary since many problems can be solved quickly if you are familiar with the range of\nthings that these libraries can do.\nWe will explore some of the commonly used modules in this library. You can find complete\ndetails for all of the modules in the Python Standard Library in the 'Library Reference'\nsection (http:/ / docs. python. org/ dev/ 3. 0/ library/ ) of the documentation that comes with\nyour Python installation.\nLet us explore a few useful modules.\nNote\nIf you find the topics in this chapter too advanced, you may skip this chapter. However,\nI highly recommend coming back to this chapter when you are more comfortable with\nprogramming using Python.\nsys module \nThe sys module contains system-specific functionality. We have already seen that the\nsys.argv list contains the command-line arguments.\nSuppose we want to check the version of the Python command being used so that, say, we\nwant to ensure that we are using at least version 3. The sys module gives us such\nfunctionality.\n>>> import sys\n>>> sys.version_info\n(3, 0, 0, 'beta', 2)\n>>> sys.version_info[0] >= 3\nTrue\nHow It Works:\nThe sys module has a version_info tuple that gives us the version information. The first\nentry is the major version. We can check this to, for example, ensure the program runs only\nunder Python 3.0:\n#!/usr/bin/python\n# Filename: versioncheck.py\nimport sys, warnings\nif sys.version_info[0] < 3:\n    warnings.warn(\"Need Python 3.0 for this program to run\",\n        RuntimeWarning)\nelse:\n    print('Proceed as normal')\nOutput:\n\nPython en:Standard Library\n99\n    $ python2.5 versioncheck.py\n    versioncheck.py:6: RuntimeWarning: Need Python 3.0 for this program\n to run\n      RuntimeWarning)\n    \n    $ python3 versioncheck.py\n    Proceed as normal\nHow It Works:\nWe use another module from the standard library called warnings that is used to display\nwarnings to the end-user. If the Python version number is not at least 3, we display a\ncorresponding warning.\nlogging module \nWhat if you wanted to have some debugging messages or important messages to be stored\nsomewhere so that you can check whether your program has been running as you would\nexpect it? How do you \"store somewhere\" these messages? This can be achieved using the\nlogging module.\n#!/usr/bin/python\n# Filename: use_logging.py\nimport os, platform, logging\nif platform.platform().startswith('Windows'):\n    logging_file = os.path.join(os.getenv('HOMEDRIVE'), \nos.getenv('HOMEPATH'), 'test.log')\nelse:\n    logging_file = os.path.join(os.getenv('HOME'), 'test.log')\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format='%(asctime)s : %(levelname)s : %(message)s',\n    filename = logging_file,\n    filemode = 'w',\n)\nlogging.debug(\"Start of the program\")\nlogging.info(\"Doing something\")\nlogging.warning(\"Dying now\")\nOutput:\n    $python use_logging.py\n    Logging to C:\\Users\\swaroop\\test.log\nIf we check the contents of test.log, it will look something like this:\n    2008-09-03 13:18:16,233 : DEBUG : Start of the program\n    2008-09-03 13:18:16,233 : INFO : Doing something\n    2008-09-03 13:18:16,233 : WARNING : Dying now\n\nPython en:Standard Library\n100\nHow It Works:\nWe use three modules from the standard library - the os module for interacting with the\noperating system, the platform module for information about the platform i.e. the\noperating system and the logging module to log information.\nFirst, we check which operating system we are using by checking the string returned by\nplatform.platform() (for more information, see import platform; help(platform)). If it\nis Windows, we figure out the home drive, the home folder and the filename where we want\nto store the information. Putting these three parts together, we get the full location of the\nfile. For other platforms, we need to know just the home folder of the user and we get the\nfull location of the file.\nWe use the os.path.join() function to put these three parts of the location together. The\nreason to use a special function rather than just adding the strings together is because this\nfunction will ensure the full location matches the format expected by the operating system.\nWe configure the logging module to write all the messages in a particular format to the\nfile we have specified.\nFinally, we can put messages that are either meant for debugging, information, warning or\neven critical messages. Once the program has run, we can check this file and we will know\nwhat happened in the program, even though no information was displayed to the user\nrunning the program.\nurllib and json modules \nHow much fun would it be if we could write our own program that will get search results\nfrom the web? Let us explore that now.\nThis can be achieved using a few modules. First is the urllib module that we can use to\nfetch any webpage from the internet. We will make use of Yahoo! Search to get the search\nresults and luckily they can give us the results in a format called JSON which is easy for us\nto parse because of the built-in json module in the standard library.\nTODO\nThis program doesn't work yet which seems to be a bug in Python 3.0 beta 2 (http:/ /\nbugs. python. org/ issue3763).\n#!/usr/bin/python\n# Filename: yahoo_search.py\nimport sys\nif sys.version_info[0] != 3:\n    sys.exit('This program needs Python 3.0')\nimport json\nimport urllib, urllib.parse, urllib.request, urllib.response\n# Get your own APP ID at http://developer.yahoo.com/wsregapp/\nYAHOO_APP_ID = \n'jl22psvV34HELWhdfUJbfDQzlJ2B57KFS_qs4I8D0Wz5U5_yCI1Awv8.lBSfPhwr'\nSEARCH_BASE = \n'http://search.yahooapis.com/WebSearchService/V1/webSearch'\n\nPython en:Standard Library\n101\nclass YahooSearchError(Exception):\n    pass\n# Taken from http://developer.yahoo.com/python/python-json.html\ndef search(query, results=20, start=1, **kwargs):\n    kwargs.update({\n        'appid': YAHOO_APP_ID,\n        'query': query,\n        'results': results,\n        'start': start,\n        'output': 'json'\n    })\n    url = SEARCH_BASE + '?' + urllib.parse.urlencode(kwargs)\n    result = json.load(urllib.request.urlopen(url))\n    if 'Error' in result:\n        raise YahooSearchError(result['Error'])\n    return result['ResultSet']\nquery = input('What do you want to search for? ')\nfor result in search(query)['Result']:\n    print(\"{0} : {1}\".format(result['Title'], result['Url']))\nOutput:\nTODO\nHow It Works:\nWe can get the search results from a particular website by giving the text we are searching\nfor in a particular format. We have to specify many options which we combine using\nkey1=value1&key2=value2 format which is handled by the urllib.parse.urlencode()\nfunction.\nSo for example, open this link in your web browser (http:/ / search. yahooapis. com/\nWebSearchService/ V1/ webSearch?query=byte+ of+ python&\nappid=jl22psvV34HELWhdfUJbfDQzlJ2B57KFS_qs4I8D0Wz5U5_yCI1Awv8. lBSfPhwr&\nresults=20& start=1& output=json) and you will see 20 results, starting from the first\nresult, for the words \"byte of python\", and we are asking for the output in JSON format.\nWe make a connection to this URL using the urllib.request.urlopen() function and pass\nthat file handle to json.load() which will read the content and simultaneously convert it\nto a Python object. We then loop through these results and display it to the end-user.\n\nPython en:Standard Library\n102\nModule of the Week Series \nThere is much more to be explored in the standard library such as debugging (http:/ / docs.\npython. org/ dev/ library/ pdb. html), handling command line options (http:/ / docs. python.\norg/ dev/ 3. 0/ library/ getopt. html), regular expressions (http:/ / www. diveintopython. org/\nregular_expressions/ index. html) and so on.\nThe best way to further explore the standard library is to read Doug Hellmann's excellent\nPython Module of the Week (http:/ / www. doughellmann. com/ projects/ PyMOTW/ ) series.\nSummary \nWe have explored some of the functionality of many modules in the Python Standard\nLibrary. It is highly recommended to browse through the Python Standard Library\ndocumentation (http:/ / docs. python. org/ dev/ 3. 0/ library/ ) to get an idea of all the\nmodules that are available.\nNext, we will cover various aspects of Python that will make our tour of Python more\ncomplete.\nPrevious Next\nSource: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=1156\nContributors: Swaroop, 2 anonymous edits\nPython en:More\nIntroduction \nSo far we have covered majority of the various aspects of Python that you will use. In this\nchapter, we will cover some more aspects that will make our knowledge of Python more\nwell-rounded.\nPassing tuples around \nEver wished you could return two different values from a function? You can. All you have to\ndo is use a tuple.\n>>> def get_error_details():\n...     return (2, 'second error details')\n...\n>>> errnum, errstr = get_error_details()\n>>> errnum\n2\n>>> errstr\n'second error details'\nNotice that the usage of a, b = <some expression> interprets the result of the expression\nas a tuple with two values.\nIf you want to interpret the results as (a, <everything else>), then you just need to star\nit just like you would in function parameters:\n\nPython en:More\n103\n>>> a, *b = [1, 2, 3, 4]\n>>> a\n1\n>>> b\n[2, 3, 4]\nThis also means the fastest way to swap two variables in Python is:\n>>> a = 5; b = 8\n>>> a, b = b, a\n>>> a, b\n(8, 5)\nSpecial Methods \nThere are certain methods such as the __init__ and __del__ methods which have special\nsignificance in classes.\nSpecial methods are used to mimic certain behaviors of built-in types. For example, if you\nwant to use the x[key] indexing operation for your class (just like you use it for lists and\ntuples), then all you have to do is implement the __getitem__() method and your job is\ndone. If you think about it, this is what Python does for the list class itself!\nSome useful special methods are listed in the following table. If you want to know about all\nthe special methods, see the manual (http:/ / docs. python. org/ dev/ 3. 0/ reference/\ndatamodel. html#special-method-names).\nName \nExplanation \n__init__(self, ...) \nThis method is called just before the newly created object is returned for usage.\n__del__(self) \nCalled just before the object is destroyed\n__str__(self) \nCalled when we use the print function or when str() is used.\n__lt__(self, other) \nCalled when the less than operator (<) is used. Similarly, there are special\nmethods for all the operators (+, >, etc.)\n__getitem__(self, key) \nCalled when x[key] indexing operation is used.\n__len__(self) \nCalled when the built-in len() function is used for the sequence object.\nSingle Statement Blocks \nWe have seen that each block of statements is set apart from the rest by its own indentation\nlevel. Well, there is one caveat. If your block of statements contains only one single\nstatement, then you can specify it on the same line of, say, a conditional statement or\nlooping statement. The following example should make this clear: \n>>> flag = True\n>>> if flag: print 'Yes'\n...\nYes\nNotice that the single statement is used in-place and not as a separate block. Although, you \ncan use this for making your program smaller, I strongly recommend avoiding this short-cut \nmethod, except for error checking, mainly because it will be much easier to add an extra\n\nPython en:More\n104\nstatement if you are using proper indentation.\nLambda Forms \nA lambda statement is used to create new function objects and then return them at\nruntime.\n#!/usr/bin/python\n# Filename: lambda.py\ndef make_repeater(n):\n    return lambda s: s * n\ntwice = make_repeater(2)\nprint(twice('word'))\nprint(twice(5))\nOutput:\n    $ python lambda.py\n    wordword\n    10\nHow It Works:\nHere, we use a function make_repeater to create new function objects at runtime and\nreturn it. A lambda statement is used to create the function object. Essentially, the lambda\ntakes a parameter followed by a single expression only which becomes the body of the\nfunction and the value of this expression is returned by the new function. Note that even a\nprint statement cannot be used inside a lambda form, only expressions.\nTODO\nCan we do a list.sort() by providing a compare function created using lambda?\npoints = [ { 'x' : 2, 'y' : 3 }, { 'x' : 4, 'y' : 1 } ]\n# points.sort(lambda a, b : cmp(a['x'], b['x']))\nList Comprehension \nList comprehensions are used to derive a new list from an existing list. Suppose you have a\nlist of numbers and you want to get a corresponding list with all the numbers multiplied by\n2 only when the number itself is greater than 2. List comprehensions are ideal for such\nsituations.\n#!/usr/bin/python\n# Filename: list_comprehension.py\nlistone = [2, 3, 4]\nlisttwo = [2*i for i in listone if i > 2]\nprint(listtwo)\nOutput:\n\nPython en:More\n105\n    $ python list_comprehension.py\n    [6, 8]\nHow It Works:\nHere, we derive a new list by specifying the manipulation to be done (2*i) when some\ncondition is satisfied (if i > 2). Note that the original list remains unmodified.\nThe advantage of using list comprehensions is that it reduces the amount of boilerplate\ncode required when we use loops to process each element of a list and store it in a new list.\nReceiving Tuples and Lists in Functions \nThere is a special way of receiving parameters to a function as a tuple or a dictionary using\nthe * or ** prefix respectively. This is useful when taking variable number of arguments in\nthe function.\n>>> def powersum(power, *args):\n...     '''Return the sum of each argument raised to specified power.'''\n...     total = 0\n...     for i in args:\n...         total += pow(i, power)\n...     return total\n...\n>>> powersum(2, 3, 4)\n25\n>>> powersum(2, 10)\n100\nBecause we have a * prefix on the args variable, all extra arguments passed to the\nfunction are stored in args as a tuple. If a ** prefix had been used instead, the extra\nparameters would be considered to be key/value pairs of a dictionary.\nexec and eval \nThe exec function is used to execute Python statements which are stored in a string or file,\nas opposed to written in the program itself. For example, we can generate a string\ncontaining Python code at runtime and then execute these statements using the exec\nstatement:\n>>> exec('print(\"Hello World\")')\nHello World\nSimilarly, the eval function is used to evaluate valid Python expressions which are stored\nin a string. A simple example is shown below.\n>>> eval('2*3')\n6\n\nPython en:More\n106\nThe assert statement \nThe assert statement is used to assert that something is true. For example, if you are very\nsure that you will have at least one element in a list you are using and want to check this,\nand raise an error if it is not true, then assert statement is ideal in this situation. When\nthe assert statement fails, an AssertionError is raised.\n>>> mylist = ['item']\n>>> assert len(mylist) >= 1\n>>> mylist.pop()\n'item'\n>>> mylist\n[]\n>>> assert len(mylist) >= 1\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAssertionError\nThe assert statement should be used judiciously. Most of the time, it is better to catch\nexceptions, either handle the problem or display an error message to the user and then\nquit.\nThe repr function \nThe repr function is used to obtain a canonical string representation of the object. The\ninteresting part is that you will have eval(repr(object)) == object most of the time.\n>>> i = []\n>>> i.append('item')\n>>> repr(i)\n\"['item']\"\n>>> eval(repr(i))\n['item']\n>>> eval(repr(i)) == i\nTrue\nBasically, the repr function is used to obtain a printable representation of the object. You\ncan control what your classes return for the repr function by defining the __repr__\nmethod in your class.\nSummary \nWe have covered some more features of Python in this chapter and yet we haven't covered\nall the features of Python. However, at this stage, we have covered most of what you are\never going to use in practice. This is sufficient for you to get started with whatever\nprograms you are going to create.\nNext, we will discuss how to explore Python further.\n\nPython en:More\n107\nPrevious Next\nSource: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=1463\nContributors: Swaroop, 1 anonymous edits\nPython en:What Next\nIf you have read this book thoroughly till now and practiced writing a lot of programs, then\nyou must have become comfortable and familiar with Python. You have probably created\nsome Python programs to try out stuff and to exercise your Python skills as well. If you have\nnot done it already, you should. The question now is 'What Next?'.\nI would suggest that you tackle this problem:\nCreate your own command-line address-book program using which you can\nbrowse, add, modify, delete or search for your contacts such as friends, family\nand colleagues and their information such as email address and/or phone number.\nDetails must be stored for later retrieval.\nThis is fairly easy if you think about it in terms of all the various stuff that we have come\nacross till now. If you still want directions on how to proceed, then here's a hint.\nHint (Don't read)\nCreate a class to represent the person's information. Use a dictionary to store person\nobjects with their name as the key. Use the pickle module to store the objects\npersistently on your hard disk. Use the dictionary built-in methods to add, delete and\nmodify the persons.\nOnce you are able to do this, you can claim to be a Python programmer. Now, immediately\nsend me a mail (http:/ / www. swaroopch. com/ contact/ ) thanking me for this great book ;-)\n. This step is optional but recommended. Also, please consider making a donation,\ncontributing improvements or volunteering translations to support the continued\ndevelopment of this book.\nIf you found that program easy, here's another one:\nImplement the replace command (http:/ / unixhelp. ed. ac. uk/ CGI/\nman-cgi?replace). This command will replace one string with another in the list of\nfiles provided.\nThe replace command can be as simple or as sophisticated as you wish, from simple string\nsubstitution to looking for patterns (regular expressions).\nAfter that, here are some ways to continue your journey with Python:\n\nPython en:What Next\n108\nExample Code \nThe best way to learn a programming language is to write a lot of code and read a lot of\ncode:\n• The PLEAC project (http:/ / pleac. sourceforge. net/ pleac_python/ index. html)\n• Rosetta code repository (http:/ / www. rosettacode. org/ wiki/ Category:Python)\n• Python examples at java2s (http:/ / www. java2s. com/ Code/ Python/ CatalogPython. htm)\n• Python Cookbook (http:/ / code. activestate. com/ recipes/ langs/ python/ ) is an\nextremely valuable collection of recipes or tips on how to solve certain kinds of problems\nusing Python. This is a must-read for every Python user.\nQuestions and Answers \n• Official Python Dos and Don'ts (http:/ / docs. python. org/ dev/ howto/ doanddont. html)\n• Official Python FAQ (http:/ / www. python. org/ doc/ faq/ general/ )\n• Norvig's list of Infrequently Asked Questions (http:/ / norvig. com/ python-iaq. html)\n• Python Interview Q & A (http:/ / dev. fyicenter. com/ Interview-Questions/ Python/ index.\nhtml)\n• StackOverflow questions tagged with python (http:/ / beta. stackoverflow. com/\nquestions/ tagged/ python)\nTips and Tricks \n• Python Tips & Tricks (http:/ / www. siafoo. net/ article/ 52)\n• Advanced Software Carpentry using Python (http:/ / ivory. idyll. org/ articles/\nadvanced-swc/ )\n• Charming Python (http:/ / gnosis. cx/ publish/ tech_index_cp. html) is an excellent series\nof Python-related articles by David Mertz.\nBooks, Papers, Tutorials, Videos \nThe logical next step after this book is to read Mark Pilgrim's awesome Dive Into Python\n(http:/ / www. diveintopython. org) book which you can read fully online as well. The Dive\nInto Python book explores topics such as regular expressions, XML processing, web\nservices, unit testing, etc. in detail.\nOther useful resources are:\n• ShowMeDo videos for Python (http:/ / showmedo. com/ videos/ python)\n• GoogleTechTalks videos on Python (http:/ / youtube. com/\nresults?search_query=googletechtalks+ python)\n• Awaretek's comprehensive list of Python tutorials (http:/ / www. awaretek. com/ tutorials.\nhtml)\n• The Effbot's Python Zone (http:/ / effbot. org/ zone/ )\n• Links at the end of every Python-URL! email (http:/ / groups. google. com/ group/ comp.\nlang. python. announce/ t/ 37de95ef0326293d)\n• Python Papers (http:/ / pythonpapers. org)\n\nPython en:What Next\n109\nDiscussion \nIf you are stuck with a Python problem, and don't know whom to ask, then the\ncomp.lang.python discussion group (http:/ / groups. google. com/ group/ comp. lang. python/\ntopics) is the best place to ask your question.\nMake sure you do your homework and have tried solving the problem yourself first.\nNews \nIf you want to learn what is the latest in the world of Python, then follow the Official Python\nPlanet (http:/ / planet. python. org) and/or the Unofficial Python Planet (http:/ / www.\nplanetpython. org).\nInstalling libraries \nThere are a huge number of open source libraries at the Python Package Index (http:/ /\npypi. python. org/ pypi) which you can use in your own programs.\nTo install and use these libraries, you can use Philip J. Eby's excellent EasyInstall tool\n(http:/ / peak. telecommunity. com/ DevCenter/ EasyInstall#using-easy-install).\nGraphical Software \nSuppose you want to create your own graphical programs using Python. This can be done\nusing a GUI (Graphical User Interface) library with their Python bindings. Bindings are\nwhat allow you to write programs in Python and use the libraries which are themselves\nwritten in C or C++ or other languages.\nThere are lots of choices for GUI using Python:\nPyQt\nThis is the Python binding for the Qt toolkit which is the foundation upon which the\nKDE is built. Qt is extremely easy to use and very powerful especially due to the Qt\nDesigner and the amazing Qt documentation. PyQt is free if you want to create open\nsource (GPL'ed) software and you need to buy it if you want to create proprietary\nclosed source software. Starting with Qt 4.5 you can use it to create non-GPL software\nas well. To get started, read the PyQt tutorial (http:/ / zetcode. com/ tutorials/ pyqt4/ )\nor the PyQt book (http:/ / www. qtrac. eu/ pyqtbook. html).\n PyGTK\nThis is the Python binding for the GTK+ toolkit which is the foundation upon which\nGNOME is built. GTK+ has many quirks in usage but once you become comfortable,\nyou can create GUI apps fast. The Glade graphical interface designer is indispensable.\nThe documentation is yet to improve. GTK+ works well on Linux but its port to\nWindows is incomplete. You can create both free as well as proprietary software using\nGTK+. To get started, read the PyGTK tutorial (http:/ / www. pygtk. org/ tutorial. html).\n wxPython\nThis is the Python bindings for the wxWidgets toolkit. wxPython has a learning curve \nassociated with it. However, it is very portable and runs on Linux, Windows, Mac and \neven embedded platforms. There are many IDEs available for wxPython which include \nGUI designers as well such as SPE (Stani's Python Editor) (http:/ / spe. pycs. net/ ) and\n\nPython en:What Next\n110\nthe wxGlade (http:/ / wxglade. sourceforge. net/ ) GUI builder. You can create free as\nwell as proprietary software using wxPython. To get started, read the wxPython\ntutorial (http:/ / zetcode. com/ wxpython/ ).\n TkInter\nThis is one of the oldest GUI toolkits in existence. If you have used IDLE, you have\nseen a TkInter program at work. It doesn't have one of the best look & feel because it\nhas an old-school look to it. TkInter is portable and works on both Linux/Unix as well\nas Windows. Importantly, TkInter is part of the standard Python distribution. To get\nstarted, read the Tkinter tutorial (http:/ / www. pythonware. com/ library/ tkinter/\nintroduction/ ).\nFor more choices, see the GuiProgramming wiki page at the official python website (http:/ /\nwww. python. org/ cgi-bin/ moinmoin/ GuiProgramming).\nSummary of GUI Tools \nUnfortunately, there is no one standard GUI tool for Python. I suggest that you choose one\nof the above tools depending on your situation. The first factor is whether you are willing to\npay to use any of the GUI tools. The second factor is whether you want the program to run\nonly on Windows or on Mac and Linux or all of them. The third factor, if Linux is a chosen\nplatform, is whether you are a KDE or GNOME user on Linux.\nFor a more detailed and comprehensive analysis, see Page 26 of the The Python Papers,\nVolume 3, Issue 1 (http:/ / archive. pythonpapers. org/ ThePythonPapersVolume3Issue1. pdf).\nVarious Implementations \nThere are usually two parts a programming language - the language and the software. A\nlanguage is how you write something. The software is what actually runs our programs.\nWe have been using the CPython software to run our programs. It is referred to as CPython\nbecause it is written in the C language and is the Classical Python interpreter.\nThere are also other software that can run your Python programs:\nJython (http:/ / www. jython. org)\nA Python implementation that runs on the Java platform. This means you can use Java\nlibraries and classes from within Python language and vice-versa.\nIronPython (http:/ / www. codeplex. com/ Wiki/ View.\naspx?ProjectName=IronPython)\nA Python implementation that runs on the .NET platform. This means you can use\n.NET libraries and classes from within Python language and vice-versa.\n PyPy (http:/ / codespeak. net/ pypy/ dist/ pypy/ doc/ home. html)\nA Python implementation written in Python! This is a research project to make it fast\nand easy to improve the interpreter since the interpreter itself is written in a dynamic\nlanguage (as opposed to static languages such as C, Java or C# in the above three\nimplementations)\n Stackless Python (http:/ / www. stackless. com)\nA Python implementation that is specialized for thread-based performance.\n\nPython en:What Next\n111\nThere are also others such as CLPython (http:/ / common-lisp. net/ project/ clpython/ ) - a\nPython implementation written in Common Lisp and IronMonkey (http:/ / wiki. mozilla. org/\nTamarin:IronMonkey) which is a port of IronPython to work on top of a JavaScript\ninterpreter which could mean that you can use Python (instead of JavaScript) to write your\nweb-browser (\"Ajax\") programs.\nEach of these implementations have their specialized areas where they are useful.\nSummary \nWe have now come to the end of this book but, as they say, this is the the beginning of the\nend!. You are now an avid Python user and you are no doubt ready to solve many problems\nusing Python. You can start automating your computer to do all kinds of previously\nunimaginable things or write your own games and much much more. So, get started!\nPrevious Next\nSource: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=1845\nContributors: Swaroop, 2 anonymous edits\nPython en:Appendix FLOSS\nFree/ Libre and Open Source Software (FLOSS) \nFLOSS (http:/ / en. wikipedia. org/ wiki/ FLOSS) is based on the concept of a community,\nwhich itself is based on the concept of sharing, and particularly the sharing of knowledge.\nFLOSS are free for usage, modification and redistribution.\nIf you have already read this book, then you are already familiar with FLOSS since you have\nbeen using Python all along and Python is an open source software!\nHere are some examples of FLOSS to give an idea of the kind of things that community\nsharing and building can create:\n• Linux. This is a FLOSS operating system that the whole world is slowly embracing! It\nwas started by Linus Torvalds as a student. Now, it is giving competition to Microsoft\nWindows. [  Linux Kernel (http:/ / www. kernel. org) ]\n• Ubuntu. This is a community-driven distribution, sponsored by Canonical and it is the\nmost popular Linux distribution today. It allows you to install a plethora of FLOSS\navailable and all this in an easy-to-use and easy-to-install manner. Best of all, you can just\nreboot your computer and run Linux off the CD! This allows you to completely try out the\nnew OS before installing it on your computer. [  Ubuntu Linux (http:/ / www. ubuntu.\ncom) ]\n• OpenOffice.org. This is an excellent office suite with a writer, presentation,\nspreadsheet and drawing components among other things. It can even open and edit MS\nWord and MS PowerPoint files with ease. It runs on almost all platforms. [  OpenOffice\n(http:/ / www. openoffice. org) ]\n• Mozilla Firefox. This is the next generation web browser which is giving great\ncompetition to Internet Explorer. It is blazingly fast and has gained critical acclaim for its\nsensible and impressive features. The extensions concept allows any kind of plugins to be\nused.\n\nPython en:Appendix FLOSS\n112\n• Its companion product Thunderbird is an excellent email client that makes reading email\na snap. [  Mozilla Firefox (http:/ / www. mozilla. org/ products/ firefox), Mozilla\nThunderbird (http:/ / www. mozilla. org/ products/ thunderbird) ]\n• Mono. This is an open source implementation of the Microsoft .NET platform. It allows\n.NET applications to be created and run on Linux, Windows, FreeBSD, Mac OS and many\nother platforms as well. [  Mono (http:/ / www. mono-project. com), ECMA (http:/ / www.\necma-international. org), Microsoft .NET (http:/ / www. microsoft. com/ net) ]\n• Apache web server. This is the popular open source web server. In fact, it is the most\npopular web server on the planet! It runs nearly more than half of the websites out there.\nYes, that's right - Apache handles more websites than all the competition (including\nMicrosoft IIS) combined. [  Apache (http:/ / httpd. apache. org) ]\n• MySQL. This is an extremely popular open source database server. It is most famous for\nit's blazing speed. It is the M in the famous LAMP stack which runs most of the websites\non the internet. [  MySQL (http:/ / www. mysql. com) ]\n• VLC Player. This is a video player that can play anything from DivX to MP3 to Ogg to\nVCDs and DVDs to ... who says open source ain't fun? ;-) [  VLC media player (http:/ /\nwww. videolan. org/ vlc/ ) ]\n• GeexBox is a Linux distribution that is designed to play movies as soon as you boot up\nfrom the CD! [  GeexBox (http:/ / geexbox. org/ en/ start. html) ]\nThis list is just intended to give you a brief idea - there are many more excellent FLOSS out\nthere, such as the Perl language, PHP language, Drupal content management system for\nwebsites, PostgreSQL database server, TORCS racing game, KDevelop IDE, Xine - the\nmovie player, VIM editor, Quanta+ editor, Banshee audio player, GIMP image editing\nprogram, ... This list could go on forever.\nTo get the latest buzz in the FLOSS world, check out the following websites:\n• linux.com (http:/ / www. linux. com)\n• LinuxToday (http:/ / www. linuxtoday. com)\n• NewsForge (http:/ / www. newsforge. com)\n• DistroWatch (http:/ / www. distrowatch. com)\nVisit the following websites for more information on FLOSS:\n• SourceForge (http:/ / www. sourceforge. net)\n• FreshMeat (http:/ / www. freshmeat. net)\nSo, go ahead and explore the vast, free and open world of FLOSS!\nPrevious Next\nSource: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=1580\nContributors: Swaroop, 1 anonymous edits\n\nPython en:Appendix About\n113\nPython en:Appendix About\nColophon \nAlmost all of the software that I have used in the creation of this book are free and open\nsource software.\nBirth of the Book \nIn the first draft of this book, I had used Red Hat 9.0 Linux as the foundation of my setup\nand in the sixth draft, I used Fedora Core 3 Linux as the basis of my setup.\nInitially, I was using KWord to write the book (as explained in the History Lesson in the\npreface).\nTeenage Years \nLater, I switched to DocBook XML using Kate but I found it too tedious. So, I switched to\nOpenOffice which was just excellent with the level of control it provided for formatting as\nwell as the PDF generation, but it produced very sloppy HTML from the document.\nFinally, I discovered XEmacs and I rewrote the book from scratch in DocBook XML (again)\nafter I decided that this format was the long term solution.\nIn the sixth draft, I decided to use Quanta+ to do all the editing. The standard XSL\nstylesheets that came with Fedora Core 3 Linux were being used. The standard default\nfonts are used as well. The standard fonts are used as well. However, I had written a CSS\ndocument to give color and style to the HTML pages. I had also written a crude lexical\nanalyzer, in Python of course, which automatically provides syntax highlighting to all the\nprogram listings.\nNow \nFor this seventh draft, I'm using MediaWiki (http:/ / www. mediawiki. org) as the basis of my\nsetup (http:/ / www. swaroopch. com/ notes/ ). Now I edit everything online and the readers\ncan directly read/edit/discuss within the wiki website.\nI still use Vim for editing thanks to the ViewSourceWith extension for Firefox (https:/ /\naddons. mozilla. org/ en-US/ firefox/ addon/ 394) that integrates with Vim.\n\nPython en:Appendix About\n114\nAbout The Author \nhttp:/ / www. swaroopch. com/ about/\nPrevious Next\nSource: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=236\nContributors: Swaroop\nPython en:Appendix Revision History\n• 1.90\n• 04/09/2008 and still in progress\n• Revival after a gap of 3.5 years!\n• Updating to Python 3.0\n• Rewrite using MediaWiki (again)\n • 1.20\n• 13/01/2005\n• Complete rewrite using Quanta+ on FC3 with lot of corrections and updates. Many\nnew examples. Rewrote my DocBook setup from scratch.\n • 1.15\n• 28/03/2004\n• Minor revisions\n • 1.12\n• 16/03/2004\n• Additions and corrections.\n • 1.10\n• 09/03/2004\n• More typo corrections, thanks to many enthusiastic and helpful readers.\n • 1.00\n• 08/03/2004\n• After tremendous feedback and suggestions from readers, I have made significant\nrevisions to the content along with typo corrections.\n • 0.99\n• 22/02/2004\n• Added a new chapter on modules. Added details about variable number of arguments\nin functions.\n • 0.98\n• 16/02/2004\n• Wrote a Python script and CSS stylesheet to improve XHTML output, including a\ncrude-yet-functional lexical analyzer for automatic VIM-like syntax highlighting of the\nprogram listings.\n • 0.97\n• 13/02/2004\n• Another completely rewritten draft, in DocBook XML (again). Book has improved a lot\n- it is more coherent and readable.\n\nPython en:Appendix Revision History\n115\n• 0.93\n• 25/01/2004\n• Added IDLE talk and more Windows-specific stuff\n • 0.92\n• 05/01/2004\n• Changes to few examples.\n • 0.91\n• 30/12/2003\n• Corrected typos. Improvised many topics.\n • 0.90\n• 18/12/2003\n• Added 2 more chapters. OpenOffice format with revisions.\n • 0.60\n• 21/11/2003\n• Fully rewritten and expanded.\n • 0.20\n• 20/11/2003\n• Corrected some typos and errors.\n • 0.15\n• 20/11/2003\n• Converted to DocBook XML.\n • 0.10\n• 14/11/2003\n• Initial draft using KWord.\n→ Previous → Back to Table of Contents\nSource: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=240\nContributors: Swaroop\n\nPython en:Appendix Changes for Python 3000\n116\nPython en:Appendix Changes for\nPython 3000\n• Vim and Emacs editors\n• http:/ / henry. precheur. org/ 2008/ 4/ 18/ Indenting%20Python%20with%20VIM. html\n• http:/ / www. enigmacurry. com/ 2008/ 05/ 09/ emacs-as-a-powerful-python-ide/\n • String - unicode only\n• http:/ / docs. python. org/ dev/ 3. 0/ tutorial/ introduction. html#about-unicode\n • Non-ASCII identifiers allowed\n• http:/ / www. python. org/ dev/ peps/ pep-3131/\n • print() function\n• http:/ / www. python. org/ dev/ peps/ pep-3105/\n • raw_input() becomes input()\n• http:/ / www. python. org/ dev/ peps/ pep-3111/\n • Integer Literal Support and Syntax\n• http:/ / www. python. org/ dev/ peps/ pep-3127/\n • nonlocal statement\n• http:/ / www. python. org/ dev/ peps/ pep-3104/\n • Functions can take * argument (varargs) for lists and keyword-only arguments\n• http:/ / www. python. org/ dev/ peps/ pep-3102/\n • Functions can have annotations (make a passing note?)\n• http:/ / www. python. org/ dev/ peps/ pep-3107/\n • Better explanation of modules, packages and their organization (including __init__.py,\netc.)\n• http:/ / ivory. idyll. org/ articles/ advanced-swc/ #packages\n • String .format() instead of % operator\n• http:/ / www. python. org/ dev/ peps/ pep-3101/\n• http:/ / docs. python. org/ dev/ library/ string. html#formatstrings\n • Dict method changes\n• http:/ / www. python. org/ dev/ peps/ pep-3106/\n • Built-in set class, in data structures chapter\n• Problem Solving\n• Use http:/ / gnuwin32. sourceforge. net/ packages/ zip. htm on Windows\n • Classes\n• http:/ / docs. python. org/ dev/ 3. 0/ reference/ datamodel. html\n • Metaclasses\n• http:/ / www. python. org/ dev/ peps/ pep-3115/\n • Abstract Base Classes\n• http:/ / www. python. org/ dev/ peps/ pep-3119/\n • Not sure if any changes required for New I/O\n• http:/ / www. python. org/ dev/ peps/ pep-3116/\n • Exception handling\n\nPython en:Appendix Changes for Python 3000\n117\n• http:/ / www. python. org/ dev/ peps/ pep-0352/\n• http:/ / www. python. org/ dev/ peps/ pep-3109/\n• http:/ / www. python. org/ dev/ peps/ pep-3110/\n • Standard Library - interesting additions\n• Reorganization : http:/ / www. python. org/ dev/ peps/ pep-3108/\n• http:/ / docs. python. org/ dev/ library/ warnings. html\n• http:/ / docs. python. org/ dev/ library/ logging. html (important)\n• http:/ / docs. python. org/ dev/ library/ urllib. html\n• http:/ / docs. python. org/ dev/ library/ json. html\n• Debugging\n• http:/ / docs. python. org/ dev/ library/ pdb. html\n• http:/ / docs. python. org/ dev/ 3. 0/ library/ trace. html\n• eval, repr/ascii functions\n • getopt/optparse - how to write a standard command-line program using python?\n• something like replace?\n• http:/ / hpux. connect. org. uk/ hppd/ hpux/ Users/ replace-2. 24/ man. html\n • More\n• Unpacking can take * argument\n• http:/ / www. python. org/ dev/ peps/ pep-3132/\n • with statement\n• http:/ / www. python. org/ dev/ peps/ pep-0343/\n • What Next?\n• Implement 'replace'\n• http:/ / unixhelp. ed. ac. uk/ CGI/ man-cgi?replace\n • Mention use of PyPI\n• Q&A\n• http:/ / docs. python. org/ dev/ howto/ doanddont. html\n• http:/ / www. python. org/ doc/ faq/ general/\n• http:/ / norvig. com/ python-iaq. html\n • Books & Resources\n• http:/ / www. coderholic. com/ free-python-programming-books/\n• http:/ / pythonpapers. org\n• http:/ / www. mobilepythonbook. org\n• http:/ / effbot. org/ zone/\n• Links at the end of every Python-URL! email\n• http:/ / groups. google. com/ group/ comp. lang. python. announce/ t/\n37de95ef0326293d\n • Examples\n• http:/ / www. rosettacode. org\n• http:/ / dev. fyicenter. com/ Interview-Questions/ Python/ index. html\n• http:/ / www. java2s. com/ Code/ Python/ CatalogPython. htm\n • Tips & Tricks\n• http:/ / www. siafoo. net/ article/ 52\nSource: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=242\n\nPython en:Appendix Changes for Python 3000\n118\nContributors: Swaroop\nLicense\nCreative Commons Attribution-Share Alike 3.0 Unported\nhttp:/ / creativecommons. org/ licenses/ by-sa/ 3. 0/\n",
  "normalized_text": "pdf generated using the open source mwlib toolkit see http://code.pediapress.com/ for more information a byte of python v1.92 (for python 3.0) python 2 python choose your python version: if you want to learn the current python 2.x, read here [1] or download the pdf [2] if you want to learn the new python 3.0, read here or download the pdf [3] you can also buy a printed hardcopy. [4] introduction 'a byte of python' is a book on programming using the python language. it serves as a tutorial or guide to the python language for a beginner audience. if all you know about computers is how to save text files, then this is the book for you. this book is updated for the new python 3.0 language. if you are looking for a tutorial on the current python 2.x version, please download the previous revision of the book [5]. on the same note, if you're wondering whether to learn python 2.x or 3.x, then read this article by james bennett [6]. who reads 'a byte of python'? here are what people are saying about the book: feedback from readers this is the best beginner's tutorial i've ever seen! thank you for your effort. - walt michalik (wmich50-at-theramp-dot-net) you've made the best python tutorial i've found on the net. great work. thanks! - joshua robin (joshrob-at-poczta-dot-onet-dot-pl) hi, i'm from dominican republic. my name is pavel, recently i read your book 'a byte of python' and i consider it excellent!! :). i learnt much from all the examples. your book is of great help for newbies like me... - pavel simo (pavel-dot-simo-at-gmail-dot-com) i recently finished reading byte of python, and i thought i really ought to thank you. i was very sad to reach the final pages as i now have to go back to dull, tedious oreilly or etc. manuals for learning about python. anyway, i really appreciate your book - samuel young (sy-one-three-seven-at-gmail-dot-com) dear swaroop, i am taking a class from an instructor that has no interest in teaching. we are using learning python, second edition, by o'reilly. it is not a text for beginner without any programming knowledge, and an instructor that should be working in another field. thank you very much for your book, without it i would be cluless about python and programming. thanks a million, you are able to 'break the message down' to a level that beginners can understand and not everyone can. - joseph duarte (jduarte1-at-cfl-dot-rr-dot-com) i love your book! it is the greatest python tutorial ever, and a very useful reference. brilliant, a true masterpiece! keep up the good work! - chris-andré sommerseth python 3 i'm just e-mailing you to thank you for writing byte of python online. i had been attempting python for a few months prior to stumbling across your book, and although i made limited success with pygame, i never completed a program. thanks to your simplification of the categories, python actually seems a reachable goal. it seems like i have finally learned the foundations and i can continue into my real goal, game development. ... once again, thanks very much for placing such a structured and helpful guide to basic programming on the web. it shoved me into and out of oop with an understanding where two text books had failed. - matt gallivan (m-underscore-gallivan12-at-hotmail-dot-com) i would like to thank you for your book 'a byte of python' which i myself find the best way to learn python. i am a 15 year old i live in egypt my name is ahmed. python was my second programming language i learn visual basic 6 at school but didn't enjoy it, however i really enjoyed learning python. i made the addressbook program and i was sucessful. i will try to start make more programs and read python programs (if you could tell me source that would be helpful). i will also start on learning java and if you can tell me where to find a tutorial as good as yours for java that would help me a lot. thanx. - ahmed mohammed (sedo-underscore-91-at-hotmail-dot-com) a wonderful resource for beginners wanting to learn more about python is the 110-page pdf tutorial a byte of python by swaroop c h. it is well-written, easy to follow, and may be the best introduction to python programming available. - drew ames in an article on scripting scribus [7] published on linux.com yesterday i got through most of byte of python on my nokia n800 and it's the easiest and most concise introduction to python i have yet encountered. highly recommended as a starting point for learning python. - jason delport on his weblog [8] academic courses this book is being used as instructional material in various educational institutions: 1. 'principles of programming languages' course at vrije universiteit, amsterdam [9] 2. 'basic concepts of computing' course at university of california, davis [10] 3. 'programming with python' course at harvard university [11] 4. 'introduction to programming' course at university of leeds [12] 5. 'introduction to application programming' course at boston university [13] 6. 'information technology skills for meteorology' course at university of oklahoma [14] 7. 'geoprocessing' course at michigan state university [15] 8. 'multi agent semantic web systems' course at the university of edinburgh [16] python 4 even nasa the book is even used by nasa! it is being used in their jet propulsion laboratory [17] with their deep space network project. official recommendation this book has been listed on the official website for python in the full tutorials [18] section, next to the official documentation. license 1. this book is licensed under the creative commons attribution-share alike 3.0 unported [19] license. • this means: • you are free to share i.e. to copy, distribute and transmit this book • you are free to remix i.e. to adapt this book • under the following conditions: • attribution. you must attribute the work in the manner specified by the author or licensor (but not in any way that suggests that they endorse you or your use of this book). • share alike. if you alter, transform, or build upon this work, you may distribute the resulting work only under the same or similar license to this one. • for any reuse or distribution, you must make clear to others the license terms of this book. • any of the above conditions can be waived if you get permission from the copyright holder. • nothing in this license impairs or restricts the author's moral rights. 2. attribution must be shown by linking back to http:/ / www. swaroopch. com/ notes/ python and clearly indicating that the original text can be fetched from this location. 3. all the code/scripts provided in this book is licensed under the 3-clause bsd license [20] unless otherwise noted. 4. volunteer contributions to this original book must be under this same license and the copyright must be assigned to the main author of this book. read now you can read the book online at python_en:table of contents. buy the book a printed hardcopy of the book can be purchased [21] for your offline reading pleasure, and to support the continued development and improvement of this book. download • pdf (631kb) [22] • mediawiki xml dump (276kb) [23] (for advanced users only) if you wish to support the continued development of this book, please consider making a donation [24] or buy a printed hardcopy [25]. python 5 translations if you are interested in reading or contributing translations of this book to other human languages, please see translations. next references [1] http:/ / www. ibiblio. org/ swaroopch/ byteofpython/ read/ [2] http:/ / www. ibiblio. org/ swaroopch/ byteofpython/ files/ 120/ byteofpython_120. pdf [3] http:/ / www. swaroopch. com/ files/ byteofpython/ byte_of_python_v191. pdf [4] http:/ / www. swaroopch. com/ buybook [5] http:/ / www. ibiblio. org/ swaroopch/ byteofpython/ files/ 120/ [6] http:/ / www. b-list. org/ weblog/ 2008/ dec/ 05/ python-3000/ [7] http:/ / www. linux. com/ feature/ 126522 [8] http:/ / paxmodept. com/ telesto/ blogitem. htm?id=627 [9] http:/ / www. few. vu. nl/ ~nsilvis/ ppl/ 2007/ index. html [10] http:/ / www. cs. ucdavis. edu/ courses/ exp_course_desc/ 10. html [11] http:/ / www. people. fas. harvard. edu/ ~preshman/ python_winter. html [12] http:/ / www. comp. leeds. ac. uk/ acom1900/ [13] http:/ / www. cs. bu. edu/ courses/ cs108/ materials. html [14] http:/ / gentry. metr. ou. edu/ byteofpython/ [15] http:/ / www. msu. edu/ ~ashton/ classes/ 825/ index. html [16] http:/ / homepages. inf. ed. ac. uk/ ewan/ masws/ [17] http:/ / dsnra. jpl. nasa. gov/ software/ python/ byte-of-python/ output/ byteofpython_html/ [18] http:/ / www. python. org/ doc/ intros/ [19] http:/ / creativecommons. org/ licenses/ by-sa/ 3. 0/ [20] http:/ / www. opensource. org/ licenses/ bsd-license. php [21] http:/ / www. swaroopch. com/ buybook [22] http:/ / www. swaroopch. com/ files/ byteofpython/ byte_of_python_v191. pdf [23] http:/ / www. swaroopch. com/ files/ byteofpython/ byte_of_python_v191. xml [24] https:/ / www. paypal. com/ cgi-bin/ webscr?cmd=_donations& business=swaroop%40swaroopch%2ecom& item_name=a%20byte%20of%20python& no_shipping=0& no_note=1& tax=0& currency_code=usd& lc=in& bn=pp%2ddonationsbf& charset=utf%2d8 [25] http:/ / www. swaroopch. com/ buybook source: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=1391 contributors: swaroop, 1 anonymous edits python en:table of contents 6 python en:table of contents • → front . → translations 2. → preface 3. → introduction 4. → installation 5. → first steps 6. → basics 7. → operators and expressions 8. → control flow 9. → functions 10. → modules 11. → data structures 12. → problem solving 13. → object oriented programming 14. → input output 15. → exceptions 16. → standard library 17. → more 18. → what next 19. → appendix: floss 20. → appendix: about 21. → appendix: revision history → previous → next source: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=1343 contributors: swaroop, waterox888, 3 anonymous edits python en:translations 7 python en:translations there are many translations of the book available in different human languages, thanks to many tireless volunteers! if you want to help these translations, please see the list of volunteers and languages below and decide if you want to start a new translation or help in existing translation projects. if you plan to start a new translation, please read the translation howto. chinese juan shen (orion-underscore-val-at-163-dot-com) has volunteered to translate the book to chinese. what - i am a postgraduate at wireless telecommunication graduate school, beijing university of technology, china pr. my current research interest is on the synchronization, channel estimation and multi-user detection of multicarrier cdma system. python is my major programming language for daily simulation and research job, with the help of python numeric, actually. i learned python just half a year before, but as you can see, it's really easy-understanding, easy-to-use and productive. just as what is ensured in swaroop's book, 'it's my favorite programming language now'. 'a byte of python' is my tutorial to learn python. it's clear and effective to lead you into a world of python in the shortest time. it's not too long, but efficiently covers almost all important things in python. i think 'a byte of python' should be strongly recommendable for newbies as their first python tutorial. just dedicate my translation to the potential millions of python users in china. chinese traditional fred lin (gasolin-at-gmail-dot-com) has volunteered to translate the book to chinese traditional. it is available at http:/ / code. google. com/ p/ zhpy/ wiki/ byteofzhpy (http:/ / code. google. com/ p/ zhpy/ wiki/ byteofzhpy). an exciting feature of this translation is that it also contains the executable chinese python sources side by side with the original python sources. fred lin - i'm working as a network firmware engineer at delta network, and i'm also a contributor of turbogears web framework. as a python evangelist (:-p), i need some material to promote python language. i found 'a byte of python' hit the sweet point for both newbies and experienced programmers. 'a byte of python' elaborates the python essentials with affordable size. the translation are originally based on simplified chinese version, and soon a lot of rewrite were made to fit the current wiki version and the quality of reading. the recent chinese traditional version also featured with executable chinese python sources, which are achieved by my new 'zhpy' (python in chinese) project (launch from aug 07). zhpy(pronounce (z.h.?, or zippy) build a layer upon python to translate or interact with python in chinese(traditional or simplified). this project is mainly aimed for education. python en:translations 8 italian enrico morelli (mr-dot-mlucci-at-gmail-dot-com) and massimo lucci (morelli-at-cerm-dot-unifi-dot-it) have volunteered to translate the book to italian. the italian translation is present at www.gentoo.it/programmazione/byteofpython (http:/ / www. gentoo. it/ programmazione/ byteofpython). the new translation is in progress and start with \"prefazione\". massimo lucci and enrico morelli - we are working at the university of florence (italy) - chemistry department. i (massimo) as service engineer and system administrator for nuclear magnetic resonance spectrometers; enrico as service engineer and system administrator for our ced and parallel / clustered systems. we are programming on python since about seven years, we had experience working with linux platforms since ten years. in italy we are responsible and administrator for www.gentoo.it web site for gentoo/linux distrubution and www.nmr.it (now under construction) for nuclear magnetic resonance applications and congress organization and managements. that's all! we are impressed by the smart language used on your book and we think this is essential for approaching the python to new users (we are thinking about hundred of students and researcher working on our labs). german lutz horn (lutz-dot-horn-at-gmx-dot-de), bernd hengelein (bernd-dot-hengelein-at-gmail-dot-com) and christoph zwerschke (cito-at-online-dot-de) have volunteered to translate the book to german. their translation is located at http:/ / abop-german. berlios. de (http:/ / abop-german. berlios. de). lutz horn : i'm 32 years old and have a degree of mathematics from university of heidelberg, germany. currently i'm working as a software engineer on a publicly funded project to build a web portal for all things related to computer science in germany. the main language i use as a professional is java, but i try to do as much as possible with python behind the scenes. especially text analysis and conversion is very easy with python. i'm not very familiar with gui toolkits, since most of my programming is about web applications, where the user interface is build using java frameworks like struts. currently i try to make more use of the functional programming features of python and of generators. after taking a short look into ruby, i was very impressed with the use of blocks in this language. generally i like the dynamic nature of languages like python and ruby since it allows me to do things not possible in more static languages like java. i've searched for some kind of introduction to programming, suitable to teach a complete non-programmer. i've found the book 'how to think like a computer scientist: learning with python', and 'dive into python'. the first is good for beginners but to long to translate. the second is not suitable for beginners. i think 'a byte of python' falls nicely between these, since it is not too long, written to the point, and at the same time verbose enough to teach a newbie. besides this, i like the simple docbook structure, which makes translating the text a generation the output in various formats a charm. python en:translations 9 bernd hengelein : lutz and me are going to do the german translation together. we just started with the intro and preface but we will keep you informed about the progress we make. ok, now some personal things about me. i am 34 years old and playing with computers since the 1980's, when the \"commodore c64\" ruled the nurseries. after studying computer science i started working as a software engineer. currently i am working in the field of medical imaging for a major german company. although c++ is the main language i (have to) use for my daily work, i am constantly looking for new things to learn. last year i fell in love with python, which is a wonderful language, both for its possibilities and its beauty. i read somewhere in the net about a guy who said that he likes python, because the code looks so beautiful. in my opinion he's absolutly right. at the time i decided to learn python, i noticed that there is very little good documentation in german available. when i came across your book the spontaneous idea of a german translation crossed my mind. luckily, lutz had the same idea and we can now divide the work. i am looking forward to a good cooperation! norwegian (bokmål) eirik vågeskar (or vages) is a high school student at sandvika videregående skole (http:/ / no. wikipedia. org/ wiki/ sandvika_videregã¥ende_skole) in norway, a blogger (http:/ / forbedre. blogspot. com/ ) and currently translating the book to norwegian (bokmål). the translation is in progress, and you can check the table of contents for more details. eirik vågeskar: i have always wanted to program, but because i speak a small language, the learning process was much harder. most tutorials and books are written in very technical english, so most high school graduates will not even have the vocabulary to understand what the tutorial is about. when i discovered this book, all my problems were solved. \"a byte of python\" used simple non-technical language to explain a programming language that is just as simple, and these two things make learning python fun. after reading half of the book, i decided that the book was worth translating. i hope the translation will help people who have found themself in the same situation as me (especially young people), and maybe help spread interest for the language among people with less technical knowledge. indonesian daniel (daniel-dot-mirror-at-gmail-dot-com) is translating the book to indonesian at http:/ / python. or. id/ moin. cgi/ byteofpython polish dominik kozaczko (dkozaczko-at-gmail-dot-com) has volunteered to translate the book to polish. translation is in progress and it's main page is available here: ukąś pythona (http:/ / wiki. mercury. lo5. bielsko. pl/ index. php/ ukä å_pythona). dominik kozaczko - i'm a computer science and information technology teacher. python en:translations 10 catalan moises gomez (moisesgomezgiron-at-gmail-dot-com) has volunteered to translate the book to catalan. the translation is in progress, and starts with the chapter \"taula de continguts\". moisès gómez - i am a developer and also a teacher of programming (normally for people without any previous experience). some time ago i needed to learn how to program in python, and swaroop's work was really helpful. clear, concise, and complete enough. just what i needed. after this experience, i thought some other people in my country could take benefit from it too. but english language can be a barrier. so, why not try to translate it? and i did for a previous version of bop. i my country there are two official languages. i selected the catalan language assuming that others will translate it to the more widespread spanish. portuguese fidel viegas (fidel-dot-viegas-at-gmail-dot-com) has volunteered to translate the book to portuguese. romanian paul-sebastian manole (brokenthorn-at-gmail-dot-com) has volunteered to translate this book to romanian. paul-sebastian manole - i'm a second year computer science student at spiru haret university, here in romania. i'm more of a self-taught programmer and decided to learn a new language, python. the web told me there was no better way to do so but read a byte of python. that's how popular this book is (congratulations to the author for writing such an easy to read book). i started liking python so i decided to help translate the latest version of swaroop's book in romanian. although i could be the one with the first initiative, i'm just one volunteer so if you can help, please join me. the translation is being done here (http:/ / www. swaroopch. com/ notes/ python_ro). brazilian portuguese rodrigo amaral (http:/ / rodrigoamaral. net) (rodrigoamaral-at-gmail-dot-com) has volunteered to translate the book to brazilian portuguese... french gregory (coulix-at-ozforces-dot-com-dot-au) has volunteered to translate the book to french. danish lars petersen (lars-at-ioflux-dot-net) has volunteered to translate the book to danish. spanish alfonso de la guarda reyes (alfonsodg-at-ictechperu-dot-net) and gustavo echeverria (gustavo-dot-echeverria-at-gmail-dot-com) have volunteered to translate the book to python en:translations 11 spanish. the translation is in progress, you can read the spanish (argentinian) translation starting by the table of contents (tabla de contenidos). gustavo echeverria: i work as a software engineer in argentina. i use mostly c# and .net technologies at work but strictly python or ruby in my personal projects. i knew python many years ago and i got stuck inmediately. not so long after knowing python i discovered this book and it helped me to learn the language. then i volunteered to translate the book to spanish. now, after receiving some requests, i've begun to translate \"a byte of python\" with the help of maximiliano soler. arabic alaa abadi (alaanassir-at-gmail-dot-com) has volunteered to translate the book to arabic. isa . swedish mikael jacobsson (leochingkwake-at-gmail-dot-com) has volunteered to translate the book to swedish. russian and ukranian averkiev andrey (averkiyev-at-ukr-dot-net) has volunteered to translate the book to russian, and perhaps ukranian (time permitting). turkish türker sezer (tsezer-at-btturk-dot-net) and bugra cakir (bugracakir-at-gmail-dot-com) have volunteered to translate the book to turkish. mongolian ariunsanaa tunjin (tariunsanaa-at-yahoo-dot-com) has volunteered to translate the book to mongolian. note replace '-at-' with '@' , '-dot-' with '.' and '-underscore-' with '_' in the email addresses mentioned on this page. dashes in other places in the email address remain as-is. python en:translations 12 previous next source: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=2278 contributors: geopop65, gustavo.echeverria, leochingkwake, moises, morellik, rodrigoamaral, swaroop, thorns, vages, waterox888, 20 anonymous edits python en:preface python is probably one of the few programming languages which is both simple and powerful. this is good for both and beginners as well as experts, and more importantly, is fun to program with. this book aims to help you learn this wonderful language and show how to get things done quickly and painlessly - in effect 'the perfect anti-venom to your programming problems'. who this book is for this book serves as a guide or tutorial to the python programming language. it is mainly targeted at newbies. it is useful for experienced programmers as well. the aim is that if all you know about computers is how to save text files, then you can learn python from this book. if you have previous programming experience, then you can also learn python from this book. if you do have previous programming experience, you will be interested in the differences between python and your favorite programming language - i have highlighted many such differences. a little warning though, python is soon going to become your favorite programming language! history lesson i first started with python when i needed to write an installer for a software i had written called 'diamond' so that i could make the installation easy. i had to choose between python and perl bindings for the qt library. i did some research on the web and i came across an article where eric s. raymond, the famous and respected hacker, talked about how python has become his favorite programming language. i also found out that the pyqt bindings were more mature compared to perl-qt. so, i decided that python was the language for me. then, i started searching for a good book on python. i couldn't find any! i did find some o'reilly books but they were either too expensive or were more like a reference manual than a guide. so, i settled for the documentation that came with python. however, it was too brief and small. it did give a good idea about python but was not complete. i managed with it since i had previous programming experience, but it was unsuitable for newbies. about six months after my first brush with python, i installed the (then) latest red hat 9.0 linux and i was playing around with kword. i got excited about it and suddenly got the idea of writing some stuff on python. i started writing a few pages but it quickly became 30 pages long. then, i became serious about making it more useful in a book form. after a lot of rewrites, it has reached a stage where it has become a useful guide to learning the python language. i consider this book to be my contribution and tribute to the open source community. python en:preface 13 this book started out as my personal notes on python and i still consider it in the same way, although i've taken a lot of effort to make it more palatable to others :) in the true spirit of open source, i have received lots of constructive suggestions, criticisms and feedback from enthusiastic readers which has helped me improve this book a lot. status of the book changes since the last major revision in march 2005 is updating for the python 3.0 release (expected in august/september 2008). since the python 3.0 language itself is still not finalized/released, this book is constantly undergoing changes. however, in the spirit of the open source philosophy of \"release early, release often\", the updated book has been released and is constantly being updated. the book needs the help of its readers such as yourselves to point out any parts of the book which are not good, not comprehensible or are simply wrong. please write to the main author (http:/ / www. swaroopch. com/ contact/ ) or the respective translators with your comments and suggestions. it's a constant tussle to balance this book between a beginner's needs and the tendency towards 'completeness' of information. it would be helpful if readers also gave feedback on how much depth this book should go into. official website the official website of the book is http:/ / www. swaroopch. com/ notes/ python where you can read the whole book online, download the latest versions of the book, buy a printed hard copy (http:/ / www. swaroopch. com/ buybook), and also send me feedback. license 1. this book is licensed under the creative commons attribution-noncommercial-share alike 3.0 unported (http:/ / creativecommons. org/ licenses/ by-nc-sa/ 3. 0/ ) license. • this means: • you are free to share i.e. to copy, distribute and transmit this book • you are free to remix i.e. to adapt this book • under the following conditions: • attribution. you must attribute the work in the manner specified by the author or licensor (but not in any way that suggests that they endorse you or your use of this book). • share alike. if you alter, transform, or build upon this work, you may distribute the resulting work only under the same or similar license to this one. • for any reuse or distribution, you must make clear to others the license terms of this book. • any of the above conditions can be waived if you get permission from the copyright holder. • nothing in this license impairs or restricts the author's moral rights. 2. attribution must be shown by linking back to http:/ / www. swaroopch. com/ notes/ python and clearly indicating that the original text can be fetched from this location. python en:preface 14 3. all the code/scripts provided in this book is licensed under the 3-clause bsd license (http:/ / www. opensource. org/ licenses/ bsd-license. php) unless otherwise noted. 4. volunteer contributions to this original book must be under this same license and the copyright must be assigned to the main author of this book. feedback i have put in a lot of effort to make this book as interesting and as accurate as possible. however, if you find some material to be inconsistent or incorrect, or simply needs improvement, then please do inform me, so that i can make suitable improvements. you can reach me via my user page. buy the book if you wish to support the continued development of this book, please consider purchasing a printed copy (http:/ / www. swaroopch. com/ buybook) or making a donation. something to think about there are two ways of constructing a software design: one way is to make it so simple that there are obviously no deficiencies; the other is to make it so complicated that there are no obvious deficiencies. -- c. a. r. hoare success in life is a matter not so much of talent and opportunity as of concentration and perseverance. -- c. w. wendte previous next source: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=987 contributors: gasolin, swaroop, 2 anonymous edits python en:introduction 15 python en:introduction introduction python is one of those rare languages which can claim to be both simple and powerful. you will find that you will be pleasantly surprised on how easy it is to concentrate on the solution to the problem rather than the syntax and structure of the language you are programming in. the official introduction to python is: python is an easy to learn, powerful programming language. it has efficient high-level data structures and a simple but effective approach to object-oriented programming. python's elegant syntax and dynamic typing, together with its interpreted nature, make it an ideal language for scripting and rapid application development in many areas on most platforms. i will discuss most of these features in more detail in the next section. note guido van rossum, the creator of the python language, named the language after the bbc show \"monty python's flying circus\". he doesn't particularly like snakes that kill animals for food by winding their long bodies around them and crushing them. features of python simple python is a simple and minimalistic language. reading a good python program feels almost like reading english, although very strict english! this pseudo-code nature of python is one of its greatest strengths. it allows you to concentrate on the solution to the problem rather than the language itself. easy to learn as you will see, python is extremely easy to get started with. python has an extraordinarily simple syntax, as already mentioned. free and open source python is an example of a floss (free/libré and open source software). in simple terms, you can freely distribute copies of this software, read its source code, make changes to it, and use pieces of it in new free programs. floss is based on the concept of a community which shares knowledge. this is one of the reasons why python is so good - it has been created and is constantly improved by a community who just want to see a better python. high-level language when you write programs in python, you never need to bother about the low-level details such as managing the memory used by your program, etc. portable due to its open-source nature, python has been ported to (i.e. changed to make it work on) many platforms. all your python programs can work on any of these platforms without requiring any changes at all if you are careful enough to avoid any python en:introduction 16 system-dependent features. you can use python on linux, windows, freebsd, macintosh, solaris, os/2, amiga, aros, as/400, beos, os/390, z/os, palm os, qnx, vms, psion, acorn risc os, vxworks, playstation, sharp zaurus, windows ce and even pocketpc ! interpreted this requires a bit of explanation. a program written in a compiled language like c or c++ is converted from the source language i.e. c or c++ into a language that is spoken by your computer (binary code i.e. 0s and 1s) using a compiler with various flags and options. when you run the program, the linker/loader software copies the program from hard disk to memory and starts running it. python, on the other hand, does not need compilation to binary. you just run the program directly from the source code. internally, python converts the source code into an intermediate form called bytecodes and then translates this into the native language of your computer and then runs it. all this, actually, makes using python much easier since you don't have to worry about compiling the program, making sure that the proper libraries are linked and loaded, etc, etc. this also makes your python programs much more portable, since you can just copy your python program onto another computer and it just works! object oriented python supports procedure-oriented programming as well as object-oriented programming. in procedure-oriented languages, the program is built around procedures or functions which are nothing but reusable pieces of programs. in object-oriented languages, the program is built around objects which combine data and functionality. python has a very powerful but simplistic way of doing oop, especially when compared to big languages like c++ or java. extensible if you need a critical piece of code to run very fast or want to have some piece of algorithm not to be open, you can code that part of your program in c or c++ and then use it from your python program. embeddable you can embed python within your c/c++ programs to give 'scripting' capabilities for your program's users. extensive libraries the python standard library is huge indeed. it can help you do various things involving regular expressions, documentation generation, unit testing, threading, databases, web browsers, cgi, ftp, email, xml, xml-rpc, html, wav files, cryptography, gui (graphical user interfaces), tk, and other system-dependent stuff. remember, all this is always available wherever python is installed. this is called the 'batteries included' philosophy of python. besides, the standard library, there are various other high-quality libraries such as wxpython (http:/ / www. wxpython. org) , twisted (http:/ / www. twistedmatrix. com/ products/ twisted), python imaging library (http:/ / www. pythonware. com/ products/ pil/ index. htm) and many more. python en:introduction 17 python is indeed an exciting and powerful language. it has the right combination of performance and features that make writing programs in python both fun and easy. why not perl? if you didn't know already, perl is another extremely popular open source interpreted programming language. if you have ever tried writing a large program in perl, you would have answered this question yourself! in other words, perl programs are easy when they are small and it excels at small hacks and scripts to 'get work done'. however, they quickly become unwieldy once you start writing bigger programs and i am speaking this out of my experience writing large perl programs at yahoo! when compared to perl, python programs are definitely simpler, clearer, easier to write and hence more understandable and maintainable. i do admire perl and i do use it on a daily basis for various things but whenever i write a program, i always start thinking in terms of python because it has become so natural for me. perl has undergone so many hacks and changes, that it feels like it is one big (but one hell of a) hack. sadly, the upcoming perl 6 does not seem to be making any improvements regarding this. the only and very significant advantage that i feel perl has, is its huge cpan (http:/ / cpan. perl. org) library - the comprehensive perl archive network. as the name suggests, this is a humongous collection of perl modules and it is simply mind-boggling because of its sheer size and depth - you can do virtually anything you can do with a computer using these modules. one of the reasons that perl has more libraries than python is that it has been around for a much longer time than python. however this seems to be changing with the growing python package index (http:/ / pypi. python. org/ pypi). why not ruby? if you didn't know already, ruby is another popular open source interpreted programming language. if you already like and use ruby, then i would definitely recommend you to continue using it. for other people who have not used it and are trying to judge whether to learn python or to learn ruby, then i would recommend python, purely from an ease-of-learning perspective. i personally found it hard to grok the ruby language, but for people who understand ruby, they all praise the beauty of the language. unfortunately, i am not as lucky. what programmers say you may find it interesting to read what great hackers like esr have to say about python: • eric s. raymond is the author of \"the cathedral and the bazaar\" and is also the person who coined the term open source. he says that python has become his favorite programming language (http:/ / www. linuxjournal. com/ article. php?sid=3882). this article was the real inspiration for my first brush with python. • bruce eckel is the author of the famous thinking in java and thinking in c++ books. he says that no language has made him more productive than python. he says that python is perhaps the only language that focuses on making things easier for the python en:introduction 18 programmer. read the complete interview (http:/ / www. artima. com/ intv/ aboutme. html) for more details. • peter norvig is a well-known lisp author and director of search quality at google (thanks to guido van rossum for pointing that out). he says that python has always been an integral part of google. you can actually verify this statement by looking at the google jobs (http:/ / www. google. com/ jobs/ index. html) page which lists python knowledge as a requirement for software engineers. about python 3. 0 python 3.0 is the new version of the language. it is sometimes referred to as python 3000 or py3k. the main reason for a major new version of python is to remove all the small problems and nitpicks that have accumulated over the years and to make the language even more clean. if you already have a lot of python 2.x code, then there is a utility to assist you to convert 2.x to 3.x source (http:/ / docs. python. org/ dev/ 3. 0/ library/ 2to3. html). more details are at: • guido van rossum's introduction (http:/ / www. artima. com/ weblogs/ viewpost. jsp?thread=208549) • what's new in python 2.6 (http:/ / docs. python. org/ dev/ whatsnew/ 2. 6. html) (features significantly different from previous python 2.x versions and most likely will be included in python 3.0) • what's new in python 3.0 (http:/ / docs. python. org/ dev/ 3. 0/ whatsnew/ 3. 0. html) • python 2.6 and 3.0 release schedule (http:/ / www. python. org/ dev/ peps/ pep-0361/ ) • python 3000 (the official authoritative list of proposed changes) (http:/ / www. python. org/ dev/ peps/ pep-3000/ ) • miscellaneous python 3.0 plans (http:/ / www. python. org/ dev/ peps/ pep-3100/ ) • python news (detailed list of changes) (http:/ / www. python. org/ download/ releases/ 3. 0/ news. txt) previous next source: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=1789 contributors: jeremybicha, swaroop, 2 anonymous edits python en:installation 19 python en:installation if you have python 2.x installed already, you do not have to remove it to install python 3.0. you can have both installed at the same time. for linux and bsd users if you are using a linux distribution such as ubuntu, fedora, opensuse or {put your choice here}, or a bsd system such as freebsd, then it is most likely you already have python installed on your system. to test if you have python already installed on your linux box, open a shell program (like konsole or gnome-terminal) and enter the command python -v as shown below. $ python -v python 3.0b1 note $ is the prompt of the shell. it will be different for you depending on the settings of your os, hence i will indicate the prompt by just the $ symbol. if you see some version information like the one shown above, then you have python installed already. however, if you get a message like this one: $ python -v bash: python: command not found then you don't have python installed. this is highly unlikely but possible. note if you have python 2.x already installed, then try python3 -v. in this case, you have two ways of installing python on your system. • you can compile python from the source code (http:/ / www. python. org/ download/ releases/ 3. 0/ ) and install it. the compilation instructions are provided at the website. • [this option will be available after the final release of python 3.0] install the binary packages using the package management software that comes with your os, such as apt-get in ubuntu/debian and other debian-based linux, yum in fedora linux, pkg_add in freebsd, etc. note that you will need an internet connection to use this method. alternatively, you can download the binaries from somewhere else and then copy to your pc and install it. python en:installation 20 for windows users visit http:/ / www. python. org/ download/ releases/ 3. 0/ and download the latest version from this website, which was 3.0 beta 1 (http:/ / www. python. org/ ftp/ python/ 3. 0/ python-3. 0b1. msi) as of this writing. this is just 12.8 mb which is very compact compared to most other languages or software. the installation is just like any other windows-based software. caution when you are given the option of unchecking any \"optional\" components, don't uncheck any! some of these components can be useful for you, especially idle. an interesting fact is that majority of python downloads are by windows users. of course, this doesn't give the complete picture since almost all linux users will have python installed already on their systems by default. dos prompt if you want to be able to use python from the windows command line i.e. the dos prompt, then you need to set the path variable appropriately. for windows 2000, xp, 2003 , click on control panel -> system -> advanced -> environment variables. click on the variable named path in the 'system variables' section, then select edit and add ;c:\\python30 to the end of what is already there. of course, use the appropriate directory name. for older versions of windows, add the following line to the file c:\\autoexec.bat : 'path=%path%;c:\\python30' (without the quotes) and restart the system. for windows nt, use the autoexec.nt file. for mac os x users mac os x users will find python already installed on their system. open the terminal.app and run python -v and follow the advice in the above linux section. summary for a linux system, you most probably already have python installed on your system. otherwise, you can install it using the package management software that comes with your distribution. for a windows system, installing python is as easy as downloading the installer and double-clicking on it. from now on, we will assume that you have python installed on your system. next, we will write our first python program. python en:installation 21 previous next source: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=1746 contributors: swaroop, 1 anonymous edits python en:first steps introduction we will now see how to run a traditional 'hello world' program in python. this will teach you how to write, save and run python programs. there are two ways of using python to run your program - using the interactive interpreter prompt or using a source file. we will now see how to use both of these methods using the interpreter prompt start the interpreter on the command line by entering python at the shell prompt. for windows users, you can run the interpreter in the command line if you have set the path variable appropriately. if you are using idle, click on start → programs → python 3.0 → idle (python gui). now enter print('hello world') followed by the enter key. you should see the words hello world as output. $ python python 3.0b2 (r30b2:65106, jul 18 2008, 18:44:17) [msc v.1500 32 bit (intel)] on win32 type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> print('hello world') hello world >>> notice that python gives you the output of the line immediately! what you just entered is a single python statement. we use print to (unsurprisingly) print any value that you supply to it. here, we are supplying the text hello world and this is promptly printed to the screen. how to quit the interpreter prompt to exit the prompt, press ctrl-d if you are using idle or are using a linux/bsd shell. in case of the windows command prompt, press ctrl-z followed by enter key. choosing an editor before we move on to writing python programs in source files, we need an editor to write the source files. the choice of an editor is crucial indeed. you have to choose an editor as you would choose a car you would buy. a good editor will help you write python programs easily, making your journey more comfortable and helps you reach your destination (achieve your goal) in a much faster and safer way. python en:first steps 22 one of the very basic requirements is syntax highlighting where all the different parts of your python program are colorized so that you can see your program and visualize its running. if you are using windows, then i suggest that you use idle. idle does syntax highlighting and a lot more such as allowing you to run your programs within idle among other things. a special note: do not use notepad - it is a bad choice because it does not do syntax highlighting and also importantly it does not support indentation of the text which is very important in our case as we will see later. good editors such as idle (and also vim) will automatically help you do this. if you are using linux/freebsd, then you have a lot of choices for an editor. if you are just beginning to program, you might want to use geany. it has a graphical user interface and has buttons to compile and run your python program without a fuss. if you are an experienced programmer, then you must be already using vim or emacs. needless to say, these are two of the most powerful editors and you will be benefitted by using them to write your python programs. i personally use vim for most of my programs. if you are a beginner programmer, then you can use kate which is one of my favorites. in case you are willing to take the time to learn vim or emacs, then i highly recommend that you do learn to use either of them as it will be very useful for you in the long run. in this book, we will use idle, our ide and editor of choice. idle is installed by default with the windows and mac os x python installers. it is also available for installation for linux (http:/ / love-python. blogspot. com/ 2008/ 03/ install-idle-in-linux. html) and bsds in their respective repositories. we will explore how to use idle in the next section. for further details, please refer the idle documentation (http:/ / www. python. org/ idle/ doc/ idlemain. html). if you still want to explore other choices of an editor, see the comprehensive list of python editors (http:/ / www. python. org/ cgi-bin/ moinmoin/ pythoneditors) and make your choice. you can also choose an ide (integrated development environment) for python. see the comprehensive list of ides that support python (http:/ / www. python. org/ cgi-bin/ moinmoin/ integrateddevelopmentenvironments) for more details. once you start writing large python programs, ides can be very useful indeed. i repeat once again, please choose a proper editor - it can make writing python programs more fun and easy. for vim users there is a good introduction on how to make vim a powerful python ide by john m anderson (http:/ / blog. sontek. net/ 2008/ 05/ 11/ python-with-a-modular-ide-vim/ ). for emacs users there is a good introduction on how to make emacs a powerful python ide by ryan mcguire (http:/ / www. enigmacurry. com/ 2008/ 05/ 09/ emacs-as-a-powerful-python-ide/ ). python en:first steps 23 using a source file now let's get back to programming. there is a tradition that whenever you learn a new programming language, the first program that you write and run is the 'hello world' program - all it does is just say 'hello world' when you run it. as simon cozens [1] puts it, it is the 'traditional incantation to the programming gods to help you learn the language better' :) . start your choice of editor, enter the following program and save it as helloworld.py if you are using idle, click on file → new window and enter the following program. then click on file → save. #!/usr/bin/python #filename: helloworld.py print('hello world') run this program by opening a shell (linux terminal or dos prompt) and entering the command python helloworld.py. if you are using idle, use the menu run → run module or the keyboard shortcut f5. the output is as shown below. $ python helloworld.py hello world if you got the output as shown above, congratulations! - you have successfully run your first python program. in case you got an error, please type the above program exactly as shown and above and run the program again. note that python is case-sensitive i.e. print is not the same as print - note the lowercase p in the former and the uppercase p in the latter. also, ensure there are no spaces or tabs before the first character in each line - we will see why this is important later. how it works let us consider the first two lines of the program. these are called comments - anything to the right of the # symbol is a comment and is mainly useful as notes for the reader of the program. python does not use comments except for the special case of the first line here. it is called the shebang line - whenever the first two characters of the source file are #! followed by the location of a program, this tells your linux/unix system that this program should be run with this interpreter when you execute the program. this is explained in detail in the next section. note that you can always run the program on any platform by specifying the interpreter directly on the command line such as the command python helloworld.py . important use comments sensibly in your program to explain some important details of your program - this is useful for readers of your program so that they can easily understand what the program is doing. remember, that person can be yourself after six months! the comments are followed by a python statement. here we call the print function this just prints the text 'hello world'. we will learn about functions in a → later chapter, what python en:first steps 24 you should understand now is that whatever you supply in the parentheses will be printed back to the screen. in this case, we supply 'hello world' which is referred to as a string don't worry, we will explore these terminologies in detail later. executable python programs this applies only to linux/unix users but windows users might be curious as well about the first line of the program. first, we have to give the program executable permission using the chmod command then run the source program. $ chmod a+x helloworld.py $ ./helloworld.py hello world the chmod command is used here to change the mode of the file by giving execute permission to all users of the system. then, we execute the program directly by specifying the location of the source file. we use the ./ to indicate that the program is located in the current directory. to make things more fun, you can rename the file to just helloworld and run it as ./helloworld and it will still work since the system knows that it has to run the program using the interpreter whose location is specified in the first line in the source file. what if you don't know where python is located? then, you can use the special env program on linux/unix systems. just change the first line of the program to the following: #!/usr/bin/env python the env program will in turn look for the python interpreter which will run the program. so far, we have been able to run our program as long as we know the exact path. what if we wanted to be able to run the program from anywhere? you can do this by storing the program in one of the directories listed in the path environment variable. whenever you run any program, the system looks for that program in each of the directories listed in the path environment variable and then runs that program. we can make this program available everywhere by simply copying this source file to one of the directories listed in path. $ echo $path /usr/local/bin:/usr/bin:/bin:/usr/x11r6/bin:/home/swaroop/bin $ cp helloworld.py /home/swaroop/bin/helloworld $ helloworld hello world we can display the path variable using the echo command and prefixing the variable name by $ to indicate to the shell that we need the value of this variable. we see that /home/swaroop/bin is one of the directories in the path variable where swaroop is the username i am using in my system. there will usually be a similar directory for your username on your system. alternatively, you can add a directory of your choice to the path variable - this can be done by running path=$path:/home/swaroop/mydir where '/home/swaroop/mydir' is the directory i want to add to the path variable. this method is very useful if you want to write useful scripts that you want to run the program anytime, anywhere. it is like creating your own commands just like cd or any python en:first steps 25 other commands that you use in the linux terminal or dos prompt. caution w.r.t. python, a program or a script or software all mean the same thing. getting help if you need quick information about any function or statement in python, then you can use the built-in help functionality. this is very useful especially when using the interpreter prompt. for example, run help(print) - this displays the help for the print function which is used to print things to the screen. note press q to exit the help. similarly, you can obtain information about almost anything in python. use help() to learn more about using help itself! in case you need to get help for operators like return, then you need to put those inside quotes such as help('return') so that python doesn't get confused on what we're trying to do. summary you should now be able to write, save and run python programs at ease. now that you are a python user, let's learn some more python concepts. references: [1] the author of the amazing 'beginning perl' book → previous → next source: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=2332 contributors: swaroop, 9 anonymous edits python en:basics 26 python en:basics just printing 'hello world' is not enough, is it? you want to do more than that - you want to take some input, manipulate it and get something out of it. we can achieve this in python using constants and variables. literal constants an example of a literal constant is a number like 5, 1.23, 9.25e-3 or a string like 'this is a string' or \"it's a string!\". it is called a literal because it is literal - you use its value literally. the number 2 always represents itself and nothing else - it is a constant because its value cannot be changed. hence, all these are referred to as literal constants. numbers numbers in python are of three types - integers, floating point and complex numbers. • an examples of an integer is 2 which is just a whole number. • examples of floating point numbers (or floats for short) are 3.23 and 52.3e-4. the e notation indicates powers of 10. in this case, 52.3e-4 means 52.3 * 10-4. • examples of complex numbers are (-5+4j) and (2.3 - 4.6j) note for experienced programmers there is no separate 'long int' type. the default integer type can be any large value. strings a string is a sequence of characters. strings are basically just a bunch of words. the words can be in english or any other language that is supported in the unicode standard, which means almost any language in the world (http:/ / www. unicode. org/ faq/ basic_q. html#16). note for experienced programmers there are no \"ascii-only\" strings because unicode is a superset of ascii. if a strictly ascii-encoded byte-stream is needed, then use str.encode(\"ascii\"). for more details, please see the related discussion at stackoverflow (http:/ / stackoverflow. com/ questions/ 175240/ how-do-i-convert-a-files-format-from-unicode-to-ascii-using-python#175270). by default, all strings are in unicode. i can almost guarantee that you will be using strings in almost every python program that you write, so pay attention to the following part on how to use strings in python. python en:basics 27 single quotes you can specify strings using single quotes such as 'quote me on this'. all white space i.e. spaces and tabs are preserved as-is. double quotes strings in double quotes work exactly the same way as strings in single quotes. an example is \"what's your name?\" triple quotes you can specify multi-line strings using triple quotes - (\"\"\" or '''). you can use single quotes and double quotes freely within the triple quotes. an example is: '''this is a multi-line string. this is the first line. this is the second line. \"what's your name?,\" i asked. he said \"bond, james bond.\" ''' escape sequences suppose, you want to have a string which contains a single quote ('), how will you specify this string? for example, the string is what's your name?. you cannot specify 'what's your name?' because python will be confused as to where the string starts and ends. so, you will have to specify that this single quote does not indicate the end of the string. this can be done with the help of what is called an escape sequence. you specify the single quote as \\' - notice the backslash. now, you can specify the string as 'what\\'s your name?'. another way of specifying this specific string would be \"what's your name?\" i.e. using double quotes. similarly, you have to use an escape sequence for using a double quote itself in a double quoted string. also, you have to indicate the backslash itself using the escape sequence \\\\. what if you wanted to specify a two-line string? one way is to use a triple-quoted string as shown previously or you can use an escape sequence for the newline character - \\n to indicate the start of a new line. an example is this is the first line\\nthis is the second line. another useful escape sequence to know is the tab - \\t. there are many more escape sequences but i have mentioned only the most useful ones here. one thing to note is that in a string, a single backslash at the end of the line indicates that the string is continued in the next line, but no newline is added. for example: \"this is the first sentence.\\ this is the second sentence.\" is equivalent to \"this is the first sentence. this is the second sentence.\". python en:basics 28 raw strings if you need to specify some strings where no special processing such as escape sequences are handled, then what you need is to specify a raw string by prefixing r or r to the string. an example is r\"newlines are indicated by \\n\". strings are immutable this means that once you have created a string, you cannot change it. although this might seem like a bad thing, it really isn't. we will see why this is not a limitation in the various programs that we see later on. string literal concatenation if you place two string literals side by side, they are automatically concatenated by python. for example, 'what\\'s ' 'your name?' is automatically converted in to \"what's your name?\". note for c/c++ programmers there is no separate char data type in python. there is no real need for it and i am sure you won't miss it. note for perl/php programmers remember that single-quoted strings and double-quoted strings are the same - they do not differ in any way. note for regular expression users always use raw strings when dealing with regular expressions. otherwise, a lot of backwhacking may be required. for example, backreferences can be referred to as '\\\\1' or r'\\1'. the format method sometimes we may want to construct strings from other information. this is where the format() method is useful. #!/usr/bin/python # filename: str_format.py age = 25 name = 'swaroop' print('{0} is {1} years old'.format(name, age)) print('why is {0} playing with that python?'.format(name)) output: $ python str_format.py swaroop is 25 years old why is swaroop playing with that python? how it works: a string can use certain specifications and subsequently, the format method can be called to substitute those specifications with corresponding arguments to the format method. python en:basics 29 observe the first usage where we use {0} and this corresponds to the variable name which is the first argument to the format method. similarly, the second specification is {1} corresponding to age which is the second argument to the format method. notice that we could achieved the same using string concatenation: name + ' is ' + str(age) + ' years old' but notice how much uglier and error-prone this is. second, the conversion to string would be done automatically by the format method instead of the explicit conversion here. third, when using the format method, we can change the message without having to deal with the variables used and vice-versa. what python does in the format method is that it substitutes each argument value into the place of the specification. there can be more detailed specifications such as: >>> '{0:.3}'.format(1/3) # decimal (.) precision of 3 for float '0.333' >>> '{0:_^11}'.format('hello') # fill with underscores (_) with the text centered (^) to 11 width '___hello___' >>> '{name} wrote {book}'.format(name='swaroop', book='a byte of python') # keyword-based 'swaroop wrote a byte of python' details of this formatting specification is explained in the python enhancement proposal no. 3101 (http:/ / www. python. org/ dev/ peps/ pep-3101/ ). variables using just literal constants can soon become boring - we need some way of storing any information and manipulate them as well. this is where variables come into the picture. variables are exactly what the name implies - their value can vary, i.e., you can store anything using a variable. variables are just parts of your computer's memory where you store some information. unlike literal constants, you need some method of accessing these variables and hence you give them names. identifier naming variables are examples of identifiers. identifiers are names given to identify something. there are some rules you have to follow for naming identifiers: • the first character of the identifier must be a letter of the alphabet (uppercase ascii or lowercase ascii or unicode character) or an underscore ('_'). • the rest of the identifier name can consist of letters (uppercase ascii or lowercase ascii or unicode character), underscores ('_') or digits (0-9). • identifier names are case-sensitive. for example, myname and myname are not the same. note the lowercase n in the former and the uppercase n in the latter. • examples of valid identifier names are i, __my_name, name_23, a1b2_c3 and resumãƒæ’ã†â€tmãƒâ€ ã¢â‚¬â„¢ãƒæ’ã¢â‚¬å¡ãƒâ€šã‚â©_count. • examples of invalid identifier names are 2things, this is spaced out, my-name, and \"this_is_in_quotes\". python en:basics 30 data types variables can hold values of different types called data types. the basic types are numbers and strings, which we have already discussed. in later chapters, we will see how to create our own types using classes. objects remember, python refers to anything used in a program as an object. this is meant in the generic sense. instead of saying 'the something', we say 'the object'. note for object oriented programming users python is strongly object-oriented in the sense that everything is an object including numbers, strings and functions. we will now see how to use variables along with literal constants. save the following example and run the program. how to write python programs henceforth, the standard procedure to save and run a python program is as follows: 1. open your favorite editor. 1. enter the program code given in the example. 1. save it as a file with the filename mentioned in the comment. i follow the convention of having all python programs saved with the extension .py. 1. run the interpreter with the command python program.py or use idle to run the programs. you can also use the executable method as explained earlier. example: using variables and literal constants # filename : var.py i = 5 print(i) i = i + 1 print(i) s = '''this is a multi-line string. this is the second line.''' print(s) output: $ python var.py 5 6 this is a multi-line string. this is the second line. how it works: here's how this program works. first, we assign the literal constant value 5 to the variable i using the assignment operator (=). this line is called a statement because it states that python en:basics 31 something should be done and in this case, we connect the variable name i to the value 5. next, we print the value of i using the print statement which, unsurprisingly, just prints the value of the variable to the screen. then we add 1 to the value stored in i and store it back. we then print it and expectedly, we get the value 6. similarly, we assign the literal string to the variable s and then print it. note for static language programmers variables are used by just assigning them a value. no declaration or data type definition is needed/used. logical and physical lines a physical line is what you see when you write the program. a logical line is what python sees as a single statement. python implicitly assumes that each physical line corresponds to a logical line. an example of a logical line is a statement like print('hello world') - if this was on a line by itself (as you see it in an editor), then this also corresponds to a physical line. implicitly, python encourages the use of a single statement per line which makes code more readable. if you want to specify more than one logical line on a single physical line, then you have to explicitly specify this using a semicolon (;) which indicates the end of a logical line/statement. for example, i = 5 print(i) is effectively same as i = 5; print(i); and the same can be written as i = 5; print(i); or even i = 5; print(i) however, i strongly recommend that you stick to writing a single logical line in a single physical line only. use more than one physical line for a single logical line only if the logical line is really long. the idea is to avoid the semicolon as much as possible since it leads to more readable code. in fact, i have never used or even seen a semicolon in a python program. an example of writing a logical line spanning many physical lines follows. this is referred to as explicit line joining. s = 'this is a string. \\ this continues the string.' print(s) python en:basics 32 this gives the output: this is a string. this continues the string. similarly, print\\ (i) is the same as print(i) sometimes, there is an implicit assumption where you don't need to use a backslash. this is the case where the logical line uses parentheses, square brackets or curly braces. this is is called implicit line joining. you can see this in action when we write programs using lists in later chapters. indentation whitespace is important in python. actually, whitespace at the beginning of the line is important. this is called indentation. leading whitespace (spaces and tabs) at the beginning of the logical line is used to determine the indentation level of the logical line, which in turn is used to determine the grouping of statements. this means that statements which go together must have the same indentation. each such set of statements is called a block. we will see examples of how blocks are important in later chapters. one thing you should remember is that wrong indentation can give rise to errors. for example: i = 5 print('value is ', i) # error! notice a single space at the start of the line print('i repeat, the value is ', i) when you run this, you get the following error: file \"whitespace.py\", line 4 print('value is ', i) # error! notice a single space at the start of the line ^ indentationerror: unexpected indent notice that there is a single space at the beginning of the second line. the error indicated by python tells us that the syntax of the program is invalid i.e. the program was not properly written. what this means to you is that you cannot arbitrarily start new blocks of statements (except for the default main block which you have been using all along, of course). cases where you can use new blocks will be detailed in later chapters such as the control flow chapter. how to indent do not use a mixture of tabs and spaces for the indentation as it does not work across different platforms properly. i strongly recommend that you use a single tab or four python en:basics 33 spaces for each indentation level. choose either of these two indentation styles. more importantly, choose one and use it consistently i.e. use that indentation style only. note to static language programmers python will always use indentation for blocks and will never use braces. run from __future__ import braces to learn more. summary now that we have gone through many nitty-gritty details, we can move on to more interesting stuff such as control flow statements. be sure to become comfortable with what you have read in this chapter. previous next source: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=2376 contributors: swaroop, vages, 10 anonymous edits python en:operators and expressions introduction most statements (logical lines) that you write will contain expressions. a simple example of an expression is 2 + 3. an expression can be broken down into operators and operands. operators are functionality that do something and can be represented by symbols such as + or by special keywords. operators require some data to operate on and such data is called operands. in this case, 2 and 3 are the operands. operators we will briefly take a look at the operators and their usage: note that you can evaluate the expressions given in the examples using the interpreter interactively. for example, to test the expression 2 + 3, use the interactive python interpreter prompt: >>> 2 + 3 5 >>> 3 * 5 15 >>> operator name explanation examples + plus adds the two objects 3 + 5 gives 8. 'a' + 'b' gives 'ab'. - minus either gives a negative number or gives the subtraction of one number from the other -5.2 gives a negative number. 50 - 24 gives 26. python en:operators and expressions 34 * multiply gives the multiplication of the two numbers or returns the string repeated that many times. 2 * 3 gives 6. 'la' * 3 gives 'lalala'. ** power returns x to the power of y 3 ** 4 gives 81 (i.e. 3 * 3 * 3 * 3) / divide divide x by y 4 / 3 gives 1.3333333333333333. // floor division returns the floor of the quotient 4 // 3 gives 1. % modulo returns the remainder of the division 8 % 3 gives 2. -25.5 % 2.25 gives 1.5. << left shift shifts the bits of the number to the left by the number of bits specified. (each number is represented in memory by bits or binary digits i.e. 0 and 1) 2 << 2 gives 8. 2 is represented by 10 in bits. left shifting by 2 bits gives 1000 which represents the decimal 8. >> right shift shifts the bits of the number to the right by the number of bits specified. 11 >> 1 gives 5. 11 is represented in bits by 1011 which when right shifted by 1 bit gives 101 which is the decimal 5. & bitwise and bitwise and of the numbers 5 & 3 gives 1. | bit-wise or bitwise or of the numbers 5 | 3 gives 7 ^ bit-wise xor bitwise xor of the numbers 5 ^ 3 gives 6 ~ bit-wise invert the bit-wise inversion of x is -(x+1) ~5 gives -6. < less than returns whether x is less than y. all comparison operators return true or false. note the capitalization of these names. 5 < 3 gives false and 3 < 5 gives true. comparisons can be chained arbitrarily: 3 < 5 < 7 gives true. > greater than returns whether x is greater than y 5 > 3 returns true. if both operands are numbers, they are first converted to a common type. otherwise, it always returns false. <= less than or equal to returns whether x is less than or equal to y x = 3; y = 6; x <= y returns true. >= greater than or equal to returns whether x is greater than or equal to y x = 4; y = 3; x >= 3 returns true. == equal to compares if the objects are equal x = 2; y = 2; x == y returns true. x = 'str'; y = 'str'; x == y returns false. x = 'str'; y = 'str'; x == y returns true. != not equal to compares if the objects are not equal x = 2; y = 3; x != y returns true. not boolean not if x is true, it returns false. if x is false, it returns true. x = true; not x returns false. and boolean and x and y returns false if x is false, else it returns evaluation of y x = false; y = true; x and y returns false since x is false. in this case, python will not evaluate y since it knows that the left hand side of the 'and' expression is false which implies that the whole expression will be false irrespective of the other values. this is called short-circuit evaluation. python en:operators and expressions 35 or boolean or if x is true, it returns true, else it returns evaluation of y x = true; y = false; x or y returns true. short-circuit evaluation applies here as well. shortcut for math operation and assignment it is common to run a math operation on a variable and then assign the result of the operation back to the variable, hence there is a shortcut for such expressions: you can write: a = 2; a = a * 3 as: a = 2; a *= 3 notice that var = var operation expression becomes var operation= expression. evaluation order if you had an expression such as 2 + 3 * 4, is the addition done first or the multiplication? our high school maths tells us that the multiplication should be done first. this means that the multiplication operator has higher precedence than the addition operator. the following table gives the precedence table for python, from the lowest precedence (least binding) to the highest precedence (most binding). this means that in a given expression, python will first evaluate the operators and expressions lower in the table before the ones listed higher in the table. the following table, taken from the python reference manual (http:/ / docs. python. org/ dev/ 3. 0/ reference/ expressions. html#evaluation-order), is provided for the sake of completeness. it is far better to use parentheses to group operators and operands appropriately in order to explicitly specify the precedence. this makes the program more readable. see changing the order of evaluation below for details. operator description lambda lambda expression or boolean or and boolean and not x boolean not in, not in membership tests is, is not identity tests <, <=, >, >=, !=, == comparisons | bitwise or ^ bitwise xor & bitwise and <<, >> shifts +, - addition and subtraction *, /, //, % multiplication, division, floor division and remainder +x, -x positive, negative python en:operators and expressions 36 ~x bitwise not ** exponentiation x.attribute attribute reference x[index] subscription x[index1:index2] slicing f(arguments ...) function call (expressions, ...) binding or tuple display [expressions, ...] list display {key:datum, ...} dictionary display the operators which we have not already come across will be explained in later chapters. operators with the same precedence are listed in the same row in the above table. for example, + and - have the same precedence. changing the order of evaluation to make the expressions more readable, we can use parentheses. for example, 2 + (3 * 4) is definitely easier to understand than 2 + 3 * 4 which requires knowledge of the operator precedences. as with everything else, the parentheses should be used reasonably (do not overdo it) and should not be redundant (as in 2 + (3 + 4)). there is an additional advantage to using parentheses - it helps us to change the order of evaluation. for example, if you want addition to be evaluated before multiplication in an expression, then you can write something like (2 + 3) * 4. associativity operators are usually associated from left to right i.e. operators with same precedence are evaluated in a left to right manner. for example, 2 + 3 + 4 is evaluated as (2 + 3) + 4. some operators like assignment operators have right to left associativity i.e. a = b = c is treated as a = (b = c). expressions example: #!/usr/bin/python # filename: expression.py length = 5 breadth = 2 area = length * breadth print('area is', area) print('perimeter is', 2 * (length + breadth)) output: python en:operators and expressions 37 $ python expression.py area is 10 perimeter is 14 how it works: the length and breadth of the rectangle are stored in variables by the same name. we use these to calculate the area and perimeter of the rectangle with the help of expressions. we store the result of the expression length * breadth in the variable area and then print it using the print function. in the second case, we directly use the value of the expression 2 * (length + breadth) in the print function. also, notice how python 'pretty-prints' the output. even though we have not specified a space between 'area is' and the variable area, python puts it for us so that we get a clean nice output and the program is much more readable this way (since we don't need to worry about spacing in the strings we use for output). this is an example of how python makes life easy for the programmer. summary we have seen how to use operators, operands and expressions - these are the basic building blocks of any program. next, we will see how to make use of these in our programs using statements. previous next source: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=1579 contributors: swaroop, 4 anonymous edits python en:control flow 38 python en:control flow introduction in the programs we have seen till now, there has always been a series of statements and python faithfully executes them in the same order. what if you wanted to change the flow of how it works? for example, you want the program to take some decisions and do different things depending on different situations such as printing 'good morning' or 'good evening' depending on the time of the day? as you might have guessed, this is achieved using control flow statements. there are three control flow statements in python - if, for and while. the if statement the if statement is used to check a condition and if the condition is true, we run a block of statements (called the if-block), else we process another block of statements (called the else-block). the else clause is optional. example: #!/usr/bin/python # filename: if.py number = 23 guess = int(input('enter an integer : ')) if guess == number: print('congratulations, you guessed it.') # new block starts here print('(but you do not win any prizes!)') # new block ends here elif guess < number: print('no, it is a little higher than that') # another block # you can do whatever you want in a block ... else: print('no, it is a little lower than that') # you must have guess > number to reach here print('done') # this last statement is always executed, after the if statement is executed output: $ python if.py enter an integer : 50 no, it is a little lower than that done $ python if.py enter an integer : 22 python en:control flow 39 no, it is a little higher than that done $ python if.py enter an integer : 23 congratulations, you guessed it. (but you do not win any prizes!) done how it works: in this program, we take guesses from the user and check if it is the number that we have. we set the variable number to any integer we want, say 23. then, we take the user's guess using the input() function. functions are just reusable pieces of programs. we'll read more about them in the next chapter. we supply a string to the built-in input function which prints it to the screen and waits for input from the user. once we enter something and press enter key, the input() function returns what we entered, as a string. we then convert this string to an integer using int and then store it in the variable guess. actually, the int is a class but all you need to know right now is that you can use it to convert a string to an integer (assuming the string contains a valid integer in the text). next, we compare the guess of the user with the number we have chosen. if they are equal, we print a success message. notice that we use indentation levels to tell python which statements belong to which block. this is why indentation is so important in python. i hope you are sticking to the \"consistent indentation\" rule. are you? notice how the if statement contains a colon at the end - we are indicating to python that a block of statements follows. then, we check if the guess is less than the number, and if so, we inform the user to guess a little higher than that. what we have used here is the elif clause which actually combines two related if else-if else statements into one combined if-elif-else statement. this makes the program easier and reduces the amount of indentation required. the elif and else statements must also have a colon at the end of the logical line followed by their corresponding block of statements (with proper indentation, of course) you can have another if statement inside the if-block of an if statement and so on - this is called a nested if statement. remember that the elif and else parts are optional. a minimal valid if statement is: if true: print('yes, it is true') after python has finished executing the complete if statement along with the associated elif and else clauses, it moves on to the next statement in the block containing the if statement. in this case, it is the main block where execution of the program starts and the next statement is the print('done') statement. after this, python sees the ends of the program and simply finishes up. although this is a very simple program, i have been pointing out a lot of things that you should notice even in this simple program. all these are pretty straightforward (and surprisingly simple for those of you from c/c++ backgrounds) and requires you to become python en:control flow 40 aware of all these initially, but after that, you will become comfortable with it and it'll feel 'natural' to you. note for c/c++ programmers there is no switch statement in python. you can use an if..elif..else statement to do the same thing (and in some cases, use a dictionary to do it quickly) the while statement the while statement allows you to repeatedly execute a block of statements as long as a condition is true. a while statement is an example of what is called a looping statement. a while statement can have an optional else clause. example: #!/usr/bin/python # filename: while.py number = 23 running = true while running: guess = int(input('enter an integer : ')) if guess == number: print('congratulations, you guessed it.') running = false # this causes the while loop to stop elif guess < number: print('no, it is a little higher than that.') else: print('no, it is a little lower than that.') else: print('the while loop is over.') # do anything else you want to do here print('done') output: $ python while.py enter an integer : 50 no, it is a little lower than that. enter an integer : 22 no, it is a little higher than that. enter an integer : 23 congratulations, you guessed it. the while loop is over. done how it works: python en:control flow 41 in this program, we are still playing the guessing game, but the advantage is that the user is allowed to keep guessing until he guesses correctly - there is no need to repeatedly run the program for each guess, as we have done in the previous section. this aptly demonstrates the use of the while statement. we move the input and if statements to inside the while loop and set the variable running to true before the while loop. first, we check if the variable running is true and then proceed to execute the corresponding while-block. after this block is executed, the condition is again checked which in this case is the running variable. if it is true, we execute the while-block again, else we continue to execute the optional else-block and then continue to the next statement. the else block is executed when the while loop condition becomes false - this may even be the first time that the condition is checked. if there is an else clause for a while loop, it is always executed unless you break out of the loop with a break statement. the true and false are called boolean types and you can consider them to be equivalent to the value 1 and 0 respectively. note for c/c++ programmers remember that you can have an else clause for the while loop. the for loop the for..in statement is another looping statement which iterates over a sequence of objects i.e. go through each item in a sequence. we will see more about sequences in detail in later chapters. what you need to know right now is that a sequence is just an ordered collection of items. example: #!/usr/bin/python # filename: for.py for i in range(1, 5): print(i) else: print('the for loop is over') output: $ python for.py 1 2 3 4 the for loop is over how it works: in this program, we are printing a sequence of numbers. we generate this sequence of numbers using the built-in range function. what we do here is supply it two numbers and range returns a sequence of numbers starting from the first number and up to the second number. for example, range(1,5) python en:control flow 42 gives the sequence [1, 2, 3, 4]. by default, range takes a step count of 1. if we supply a third number to range, then that becomes the step count. for example, range(1,5,2) gives [1,3]. remember that the range extends up to the second number i.e. it does not include the second number. the for loop then iterates over this range - for i in range(1,5) is equivalent to for i in [1, 2, 3, 4] which is like assigning each number (or object) in the sequence to i, one at a time, and then executing the block of statements for each value of i. in this case, we just print the value in the block of statements. remember that the else part is optional. when included, it is always executed once after the for loop is over unless a break statement is encountered. remember that the for..in loop works for any sequence. here, we have a list of numbers generated by the built-in range function, but in general we can use any kind of sequence of any kind of objects! we will explore this idea in detail in later chapters. note for c/c++/java/c# programmers the python for loop is radically different from the c/c++ for loop. c# programmers will note that the for loop in python is similar to the foreach loop in c#. java programmers will note that the same is similar to for (int i : intarray) in java 1.5 . in c/c++, if you want to write for (int i = 0; i < 5; i++), then in python you write just for i in range(0,5). as you can see, the for loop is simpler, more expressive and less error prone in python. the break statement the break statement is used to break out of a loop statement i.e. stop the execution of a looping statement, even if the loop condition has not become false or the sequence of items has been completely iterated over. an important note is that if you break out of a for or while loop, any corresponding loop else block is not executed. example: #!/usr/bin/python # filename: break.py while true: s = (input('enter something : ')) if s == 'quit': break print('length of the string is', len(s)) print('done') output: $ python break.py enter something : programming is fun length of the string is 18 enter something : when the work is done length of the string is 21 python en:control flow 43 enter something : if you wanna make your work also fun: length of the string is 37 enter something : use python! length of the string is 12 enter something : quit done how it works: in this program, we repeatedly take the user's input and print the length of each input each time. we are providing a special condition to stop the program by checking if the user input is 'quit'. we stop the program by breaking out of the loop and reach the end of the program. the length of the input string can be found out using the built-in len function. remember that the break statement can be used with the for loop as well. swaroop's poetic python the input i have used here is a mini poem i have written called swaroop's poetic python: programming is fun when the work is done if you wanna make your work also fun: use python! the continue statement the continue statement is used to tell python to skip the rest of the statements in the current loop block and to continue to the next iteration of the loop. example: #!/usr/bin/python # filename: continue.py while true: s = input('enter something : ') if s == 'quit': break if len(s) < 3: print('too small') continue print('input is of sufficient length') # do other kinds of processing here... output: $ python test.py enter something : a too small enter something : 12 too small python en:control flow 44 enter something : abc input is of sufficient length enter something : quit how it works: in this program, we accept input from the user, but we process them only if they are at least 3 characters long. so, we use the built-in len function to get the length and if the length is less than 3, we skip the rest of the statements in the block by using the continue statement. otherwise, the rest of the statements in the loop are executed and we can do any kind of processing we want to do here. note that the continue statement works with the for loop as well. summary we have seen how to use the three control flow statements - if, while and for along with their associated break and continue statements. these are some of the most often used parts of python and hence, becoming comfortable with them is essential. next, we will see how to create and use functions. previous next source: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=1664 contributors: swaroop, 8 anonymous edits python en:functions introduction functions are reusable pieces of programs. they allow you to give a name to a block of statements and you can run that block using that name anywhere in your program and any number of times. this is known as calling the function. we have already used many built-in functions such as the len and range. the function concept is probably the most important building block of any non-trivial software (in any programming language), so we will explore various aspects of functions in this chapter. functions are defined using the def keyword. this is followed by an identifier name for the function followed by a pair of parentheses which may enclose some names of variables and the line ends with a colon. next follows the block of statements that are part of this function. an example will show that this is actually very simple: example: #!/usr/bin/python # filename: function1.py def sayhello(): print('hello world!') # block belonging to the function # end of function python en:functions 45 sayhello() # call the function sayhello() # call the function again output: $ python function1.py hello world! hello world! how it works: we define a function called sayhello using the syntax as explained above. this function takes no parameters and hence there are no variables declared in the parentheses. parameters to functions are just input to the function so that we can pass in different values to it and get back corresponding results. notice that we can call the same function twice which means we do not have to write the same code again. function parameters a function can take parameters, which are values you supply to the function so that the function can do something utilising those values. these parameters are just like variables except that the values of these variables are defined when we call the function and are already assigned values when the function runs. parameters are specified within the pair of parentheses in the function definition, separated by commas. when we call the function, we supply the values in the same way. note the terminology used - the names given in the function definition are called parameters whereas the values you supply in the function call are called arguments. example: #!/usr/bin/python # filename: func_param.py def printmax(a, b): if a > b: print(a, 'is maximum') elif a == b: print(a, 'is equal to', b) else: print(b, 'is maximum') printmax(3, 4) # directly give literal values x = 5 y = 7 printmax(x, y) # give variables as arguments output: python en:functions 46 $ python func_param.py 4 is maximum 7 is maximum how it works: here, we define a function called printmax where we take two parameters called a and b. we find out the greater number using a simple if..else statement and then print the bigger number. in the first usage of printmax, we directly supply the numbers i.e. arguments. in the second usage, we call the function using variables. printmax(x, y) causes value of argument x to be assigned to parameter a and the value of argument y assigned to parameter b. the printmax function works the same in both the cases. local variables when you declare variables inside a function definition, they are not related in any way to other variables with the same names used outside the function i.e. variable names are local to the function. this is called the scope of the variable. all variables have the scope of the block they are declared in starting from the point of definition of the name. example: #!/usr/bin/python # filename: func_local.py x = 50 def func(x): print('x is', x) x = 2 print('changed local x to', x) func(x) print('x is still', x) output: $ python func_local.py x is 50 changed local x to 2 x is still 50 how it works: in the function, the first time that we use the value of the name x, python uses the value of the parameter declared in the function. next, we assign the value 2 to x. the name x is local to our function. so, when we change the value of x in the function, the x defined in the main block remains unaffected. in the last print function call, we display the value of x in the main block and confirm that it is actually unaffected. python en:functions 47 using the global statement if you want to assign a value to a name defined at the top level of the program (i.e. not inside any kind of scope such as functions or classes), then you have to tell python that the name is not local, but it is global. we do this using the global statement. it is impossible to assign a value to a variable defined outside a function without the global statement. you can use the values of such variables defined outside the function (assuming there is no variable with the same name within the function). however, this is not encouraged and should be avoided since it becomes unclear to the reader of the program as to where that variable's definition is. using the global statement makes it amply clear that the variable is defined in an outermost block. example: #!/usr/bin/python # filename: func_global.py x = 50 def func(): global x print('x is', x) x = 2 print('changed global x to', x) func() print('value of x is', x) output: $ python func_global.py x is 50 changed global x to 2 value of x is 2 how it works: the global statement is used to declare that x is a global variable - hence, when we assign a value to x inside the function, that change is reflected when we use the value of x in the main block. you can specify more than one global variable using the same global statement. for example, global x, y, z. python en:functions 48 using nonlocal statement we have seen how to access variables in the local and global scope above. there is another kind of scope called \"nonlocal\" scope which is in-between these two types of scopes. nonlocal scopes are observed when you define functions inside functions. since everything in python is just executable code, you can define functions anywhere. let's take an example: #!/usr/bin/python # filename: func_nonlocal.py def func_outer(): x = 2 print('x is', x) def func_inner(): nonlocal x x = 5 func_inner() print('changed local x to', x) func_outer() output: $ python func_nonlocal.py x is 2 changed local x to 5 how it works: when we are inside func_inner, the 'x' defined in the first line of func_outer is relatively neither in local scope nor in global scope. we declare that we are using this x by nonlocal x and hence we get access to that variable. try changing the nonlocal x to global x and also by removing the statement itself and observe the difference in behavior in these two cases. default argument values for some functions, you may want to make some of its parameters as optional and use default values if the user does not want to provide values for such parameters. this is done with the help of default argument values. you can specify default argument values for parameters by following the parameter name in the function definition with the assignment operator (=) followed by the default value. note that the default argument value should be a constant. more precisely, the default argument value should be immutable - this is explained in detail in later chapters. for now, just remember this. example: python en:functions 49 #!/usr/bin/python # filename: func_default.py def say(message, times = 1): print(message * times) say('hello') say('world', 5) output: $ python func_default.py hello worldworldworldworldworld how it works: the function named say is used to print a string as many times as specified. if we don't supply a value, then by default, the string is printed just once. we achieve this by specifying a default argument value of 1 to the parameter times. in the first usage of say, we supply only the string and it prints the string once. in the second usage of say, we supply both the string and an argument 5 stating that we want to say the string message 5 times. important only those parameters which are at the end of the parameter list can be given default argument values i.e. you cannot have a parameter with a default argument value before a parameter without a default argument value in the order of parameters declared in the function parameter list. this is because the values are assigned to the parameters by position. for example, def func(a, b=5) is valid, but def func(a=5, b) is not valid. keyword arguments if you have some functions with many parameters and you want to specify only some of them, then you can give values for such parameters by naming them - this is called keyword arguments - we use the name (keyword) instead of the position (which we have been using all along) to specify the arguments to the function. there are two advantages - one, using the function is easier since we do not need to worry about the order of the arguments. two, we can give values to only those parameters which we want, provided that the other parameters have default argument values. example: #!/usr/bin/python # filename: func_key.py def func(a, b=5, c=10): print('a is', a, 'and b is', b, 'and c is', c) func(3, 7) python en:functions 50 func(25, c=24) func(c=50, a=100) output: $ python func_key.py a is 3 and b is 7 and c is 10 a is 25 and b is 5 and c is 24 a is 100 and b is 5 and c is 50 how it works: the function named func has one parameter without default argument values, followed by two parameters with default argument values. in the first usage, func(3, 7), the parameter a gets the value 3, the parameter b gets the value 7 and c gets the default value of 10. in the second usage func(25, c=24), the variable a gets the value of 25 due to the position of the argument. then, the parameter c gets the value of 24 due to naming i.e. keyword arguments. the variable b gets the default value of 5. in the third usage func(c=50, a=100), we use keyword arguments completely to specify the values. notice, that we are specifying value for parameter c before that for a even though a is defined before c in the function definition. varargs parameters todo should i write about this in a later chapter since we haven't talked about lists and dictionaries yet? sometimes you might want to define a function that can take any number of parameters, this can be achieved by using the stars: #!/usr/bin/python # filename: total.py def total(initial=5, *numbers, **keywords): count = initial for number in numbers: count += number for key in keywords: count += keywords[key] return count print(total(10, 1, 2, 3, vegetables=50, fruits=100)) output: $ python total.py 166 how it works: python en:functions 51 when we declare a starred parameter such as *param, then all the positional arguments from that point till the end are collected as a list called 'param'. similarly, when we declare a double-starred parameter such as **param, then all the keyword arguments from that point till the end are collected as a dictionary called 'param'. we will explore lists and dictionaries in a later chapter. keyword- only parameters if we want to specify certain keyword parameters to be available as keyword-only and not as positional arguments, they can be declared after a starred parameter: #!/usr/bin/python # filename: keyword_only.py def total(initial=5, *numbers, vegetables): count = initial for number in numbers: count += number count += vegetables return count print(total(10, 1, 2, 3, vegetables=50)) print(total(10, 1, 2, 3)) # raises error because we have not supplied a default argument value for 'vegetables' output: $ python keyword_only.py 66 traceback (most recent call last): file \"test.py\", line 12, in <module> print(total(10, 1, 2, 3)) typeerror: total() needs keyword-only argument vegetables how it works: declaring parameters after a starred parameter results in keyword-only arguments. if these arguments are not supplied a default value, then calls to the function will raise an error if the keyword argument is not supplied, as seen above. if you want to have keyword-only arguments but have no need for a starred parameter, then simply use an empty star without using any name such as def total(initial=5, *, vegetables). python en:functions 52 the return statement the return statement is used to return from a function i.e. break out of the function. we can optionally return a value from the function as well. example: #!/usr/bin/python # filename: func_return.py def maximum(x, y): if x > y: return x else: return y print(maximum(2, 3)) output: $ python func_return.py 3 how it works: the maximum function returns the maximum of the parameters, in this case the numbers supplied to the function. it uses a simple if..else statement to find the greater value and then returns that value. note that a return statement without a value is equivalent to return none. none is a special type in python that represents nothingness. for example, it is used to indicate that a variable has no value if it has a value of none. every function implicitly contains a return none statement at the end unless you have written your own return statement. you can see this by running print(somefunction()) where the function somefunction does not use the return statement such as: def somefunction(): pass the pass statement is used in python to indicate an empty block of statements. note there is a built-in function called max that already implements the 'find maximum' functionality, so use this built-in function whenever possible. python en:functions 53 docstrings python has a nifty feature called documentation strings, usually referred to by its shorter name docstrings. docstrings are an important tool that you should make use of since it helps to document the program better and makes it easier to understand. amazingly, we can even get the docstring back from, say a function, when the program is actually running! example: #!/usr/bin/python # filename: func_doc.py def printmax(x, y): '''prints the maximum of two numbers. the two values must be integers.''' x = int(x) # convert to integers, if possible y = int(y) if x > y: print(x, 'is maximum') else: print(y, 'is maximum') printmax(3, 5) print(printmax.__doc__) output: $ python func_doc.py 5 is maximum prints the maximum of two numbers. the two values must be integers. how it works: a string on the first logical line of a function is the docstring for that function. note that docstrings also apply to modules and classes which we will learn about in the respective chapters. the convention followed for a docstring is a multi-line string where the first line starts with a capital letter and ends with a dot. then the second line is blank followed by any detailed explanation starting from the third line. you are strongly advised to follow this convention for all your docstrings for all your non-trivial functions. we can access the docstring of the printmax function using the __doc__ (notice the double underscores) attribute (name belonging to) of the function. just remember that python treats everything as an object and this includes functions. we'll learn more about objects in the chapter on classes. if you have used help() in python, then you have already seen the usage of docstrings! what it does is just fetch the __doc__ attribute of that function and displays it in a neat manner for you. you can try it out on the function above - just include help(printmax) in python en:functions 54 your program. remember to press the q key to exit help. automated tools can retrieve the documentation from your program in this manner. therefore, i strongly recommend that you use docstrings for any non-trivial function that you write. the pydoc command that comes with your python distribution works similarly to help() using docstrings. annotations functions have another advanced feature called annotations which are a nifty way of attaching additional information for each of the parameters as well as the return value. since the python language itself does not interpret these annotations in any way (that functionality is left to third-party libraries to interpret in any way they want), we will skip this feature in our discussion. if you are interested to read about annotations, please see the python enhancement proposal no. 3107 (http:/ / www. python. org/ dev/ peps/ pep-3107/ ). summary we have seen so many aspects of functions but note that we still haven't covered all aspects of it. however, we have already covered most of what you'll use regarding python functions on an everyday basis. next, we will see how to use as well as create python modules. previous next source: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=2379 contributors: swaroop, vages, 7 anonymous edits python en:modules 55 python en:modules introduction you have seen how you can reuse code in your program by defining functions once. what if you wanted to reuse a number of functions in other programs that you write? as you might have guessed, the answer is modules. there are various methods of writing modules, but the simplest way is to create a file with a .py extension that contains functions and variables. another method is to write the modules in the native language in which the python interpreter itself was written. for example, you can write modules in the c programming language (http:/ / docs. python. org/ extending/ ) and when compiled, they can be used from your python code when using the standard python interpreter. a module can be imported by another program to make use of its functionality. this is how we can use the python standard library as well. first, we will see how to use the standard library modules. example: #!/usr/bin/python # filename: using_sys.py import sys print('the command line arguments are:') for i in sys.argv: print(i) print('\\n\\nthe pythonpath is', sys.path, '\\n') output: $ python using_sys.py we are arguments the command line arguments are: using_sys.py we are arguments the pythonpath is ['', 'c:\\\\windows\\\\system32\\\\python30.zip', 'c:\\\\python30\\\\dlls', 'c:\\\\python30\\\\lib', 'c:\\\\python30\\\\lib\\\\plat-win', 'c:\\\\python30', 'c:\\\\python30\\\\lib\\\\site-packages'] how it works: first, we import the sys module using the import statement. basically, this translates to us telling python that we want to use this module. the sys module contains functionality related to the python interpreter and its environment i.e. the system. python en:modules 56 when python executes the import sys statement, it looks for the sys module. in this case, it is one of the built-in modules, and hence python knows where to find it. if it was not a compiled module i.e. a module written in python, then the python interpreter will search for it in the directories listed in its sys.path variable. if the module is found, then the statements in the body of that module is run and then the module is made available for you to use. note that the initialization is done only the first time that we import a module. the argv variable in the sys module is accessed using the dotted notation i.e. sys.argv. it clearly indicates that this name is part of the sys module. another advantage of this approach is that the name does not clash with any argv variable used in your program. the sys.argv variable is a list of strings (lists are explained in detail in a later chapter. specifically, the sys.argv contains the list of command line arguments i.e. the arguments passed to your program using the command line. if you are using an ide to write and run these programs, look for a way to specify command line arguments to the program in the menus. here, when we execute python using_sys.py we are arguments, we run the module using_sys.py with the python command and the other things that follow are arguments passed to the program. python stores the command line arguments in the sys.argv variable for us to use. remember, the name of the script running is always the first argument in the sys.argv list. so, in this case we will have 'using_sys.py' as sys.argv[0], 'we' as sys.argv[1], 'are' as sys.argv[2] and 'arguments' as sys.argv[3]. notice that python starts counting from 0 and not 1. the sys.path contains the list of directory names where modules are imported from. observe that the first string in sys.path is empty - this empty string indicates that the current directory is also part of the sys.path which is same as the pythonpath environment variable. this means that you can directly import modules located in the current directory. otherwise, you will have to place your module in one of the directories listed in sys.path. note that the current directory is the directory from which the program is launched. run import os; print(os.getcwd()) to find out the current directory of your program. byte- compiled . pyc files importing a module is a relatively costly affair, so python does some tricks to make it faster. one way is to create byte-compiled files with the extension .pyc which is an intermediate form that python transforms the program into (remember the introduction section on how python works?). this .pyc file is useful when you import the module the next time from a different program - it will be much faster since a portion of the processing required in importing a module is already done. also, these byte-compiled files are platform-independent. note these .pyc files are usually created in the same directory as the corresponding .py files. if python does not have permission to write to files in that directory, then the .pyc files will not be created. python en:modules 57 the from . . . import . . . statement if you want to directly import the argv variable into your program (to avoid typing the sys. everytime for it), then you can use the from sys import argv statement. if you want to import all the names used in the sys module, then you can use the from sys import * statement. this works for any module. in general, you should avoid using this statement and use the import statement instead since your program will avoid name clashes and will be more readable. a module's _ _ name_ _ every module has a name and statements in a module can find out the name of its module. this is handy in the particular situation of figuring out if the module is being run standalone or being imported. as mentioned previously, when a module is imported for the first time, the code in that module is executed. we can use this concept to alter the behavior of the module if the program was used by itself and not when it was imported from another module. this can be achieved using the __name__ attribute of the module. example: #!/usr/bin/python # filename: using_name.py if __name__ == '__main__': print('this program is being run by itself') else: print('i am being imported from another module') output: $ python using_name.py this program is being run by itself $ python >>> import using_name i am being imported from another module >>> how it works: every python module has it's __name__ defined and if this is '__main__', it implies that the module is being run standalone by the user and we can take appropriate actions. python en:modules 58 making your own modules creating your own modules is easy, you've been doing it all along! this is because every python program is also a module. you just have to make sure it has a .py extension. the following example should make it clear. example: #!/usr/bin/python # filename: mymodule.py def sayhi(): print('hi, this is mymodule speaking.') __version__ = '0.1' # end of mymodule.py the above was a sample module. as you can see, there is nothing particularly special about compared to our usual python program. we will next see how to use this module in our other python programs. remember that the module should be placed in the same directory as the program that we import it in, or the module should be in one of the directories listed in sys.path. #!/usr/bin/python # filename: mymodule_demo.py import mymodule mymodule.sayhi() print ('version', mymodule.__version__) output: $ python mymodule_demo.py hi, this is mymodule speaking. version 0.1 how it works: notice that we use the same dotted notation to access members of the module. python makes good reuse of the same notation to give the distinctive 'pythonic' feel to it so that we don't have to keep learning new ways to do things. here is a version utilising the from..import syntax: #!/usr/bin/python # filename: mymodule_demo2.py from mymodule import sayhi, __version__ sayhi() print('version', __version__) python en:modules 59 the output of mymodule_demo2.py is same as the output of mymodule_demo.py. notice that if there was already a __version__ name declared in the module that imports mymodule, there would be a clash. this is also likely because it is common practice for each module to declare it's version number using this name. hence, it is always recommended to prefer the import statement even though it might make your program a little longer. you could also use: from mymodule import * this will import all public names such as sayhi but would not import __version__ because it starts with double underscores. zen of python one of python's guiding principles is that \"explicit is better than implicit\". run import this to learn more and see this discussion (http:/ / stackoverflow. com/ questions/ 228181/ zen-of-python) which lists examples for each of the principles. the dir function you can use the built-in dir function to list the identifiers that an object defines. for example, for a module, the identifiers include the functions, classes and variables defined in that module. when you supply a module name to the dir() function, it returns the list of the names defined in that module. when no argument is applied to it, it returns the list of names defined in the current module. example: $ python >>> import sys # get list of attributes, in this case, for the sys module >>> dir(sys) ['__displayhook__', '__doc__', '__excepthook__', '__name__', '__package__', '__s tderr__', '__stdin__', '__stdout__', '_clear_type_cache', '_compact_freelists', '_current_frames', '_getframe', 'api_version', 'argv', 'builtin_module_names', ' byteorder', 'call_tracing', 'callstats', 'copyright', 'displayhook', 'dllhandle' , 'dont_write_bytecode', 'exc_info', 'excepthook', 'exec_prefix', 'executable', 'exit', 'flags', 'float_info', 'getcheckinterval', 'getdefaultencoding', 'getfil esystemencoding', 'getprofile', 'getrecursionlimit', 'getrefcount', 'getsizeof', 'gettrace', 'getwindowsversion', 'hexversion', 'intern', 'maxsize', 'maxunicode ', 'meta_path', 'modules', 'path', 'path_hooks', 'path_importer_cache', python en:modules 60 'platfor m', 'prefix', 'ps1', 'ps2', 'setcheckinterval', 'setprofile', 'setrecursionlimit ', 'settrace', 'stderr', 'stdin', 'stdout', 'subversion', 'version', 'version_in fo', 'warnoptions', 'winver'] >>> dir() # get list of attributes for current module ['__builtins__', '__doc__', '__name__', '__package__', 'sys'] >>> a = 5 # create a new variable 'a' >>> dir() ['__builtins__', '__doc__', '__name__', '__package__', 'a', 'sys'] >>> del a # delete/remove a name >>> dir() ['__builtins__', '__doc__', '__name__', '__package__', 'sys'] >>> how it works: first, we see the usage of dir on the imported sys module. we can see the huge list of attributes that it contains. next, we use the dir function without passing parameters to it. by default, it returns the list of attributes for the current module. notice that the list of imported modules is also part of this list. in order to observe the dir in action, we define a new variable a and assign it a value and then check dir and we observe that there is an additional value in the list of the same name. we remove the variable/attribute of the current module using the del statement and the change is reflected again in the output of the dir function. a note on del - this statement is used to delete a variable/name and after the statement has run, in this case del a, you can no longer access the variable a - it is as if it never existed before at all. note that the dir() function works on any object. for example, run dir(print) to learn about the attributes of the print function, or dir(str) for the attributes of the str class. python en:modules 61 packages by now, you must have started observing the hierarchy of organizing your programs. variables usually go inside functions. functions and global variables usually go inside modules. what if you wanted to organize modules? that's where packages come into the picture. packages are just folders of modules with a special __init__.py file that indicates to python that this folder is special because it contains python modules. let's say you want to create a package called 'world' with subpackages 'asia', 'africa', etc. and these subpackages in turn contain modules like 'india', 'madagascar', etc. this is how you would structure the folders: - <some folder present in the sys.path>/ - world/ - __init__.py - asia/ - __init__.py - india/ - __init__.py - foo.py - africa/ - __init__.py - madagascar/ - __init__.py - bar.py packages are just a convenience to hierarchically organize modules. you will see many instances of this in the standard library. summary just like functions are reusable parts of programs, modules are reusable programs. packages are another hierarchy to organize modules. the standard library that comes with python is an example of such a set of packages and modules. we have seen how to use these modules and create our own modules. next, we will learn about some interesting concepts called data structures. previous next source: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=2371 contributors: swaroop, 7 anonymous edits python en:data structures 62 python en:data structures introduction data structures are basically just that - they are structures which can hold some data together. in other words, they are used to store a collection of related data. there are four built-in data structures in python - list, tuple, dictionary and set. we will see how to use each of them and how they make life easier for us. list a list is a data structure that holds an ordered collection of items i.e. you can store a sequence of items in a list. this is easy to imagine if you can think of a shopping list where you have a list of items to buy, except that you probably have each item on a separate line in your shopping list whereas in python you put commas in between them. the list of items should be enclosed in square brackets so that python understands that you are specifying a list. once you have created a list, you can add, remove or search for items in the list. since we can add and remove items, we say that a list is a mutable data type i.e. this type can be altered. quick introduction to objects and classes although i've been generally delaying the discussion of objects and classes till now, a little explanation is needed right now so that you can understand lists better. we will explore this topic in detail later in its own chapter. a list is an example of usage of objects and classes. when we use a variable i and assign a value to it, say integer 5 to it, you can think of it as creating an object (i.e. instance) i of class (i.e. type) int. in fact, you can read help(int) to understand this better. a class can also have methods i.e. functions defined for use with respect to that class only. you can use these pieces of functionality only when you have an object of that class. for example, python provides an append method for the list class which allows you to add an item to the end of the list. for example, mylist.append('an item') will add that string to the list mylist. note the use of dotted notation for accessing methods of the objects. a class can also have fields which are nothing but variables defined for use with respect to that class only. you can use these variables/names only when you have an object of that class. fields are also accessed by the dotted notation, for example, mylist.field. example: #!/usr/bin/python # filename: using_list.py # this is my shopping list shoplist = ['apple', 'mango', 'carrot', 'banana'] print('i have', len(shoplist), 'items to purchase.') print('these items are:', end=' ') python en:data structures 63 for item in shoplist: print(item, end=' ') print('\\ni also have to buy rice.') shoplist.append('rice') print('my shopping list is now', shoplist) print('i will sort my list now') shoplist.sort() print('sorted shopping list is', shoplist) print('the first item i will buy is', shoplist[0]) olditem = shoplist[0] del shoplist[0] print('i bought the', olditem) print('my shopping list is now', shoplist) output: $ python using_list.py i have 4 items to purchase. these items are: apple mango carrot banana i also have to buy rice. my shopping list is now ['apple', 'mango', 'carrot', 'banana', 'rice'] i will sort my list now sorted shopping list is ['apple', 'banana', 'carrot', 'mango', 'rice'] the first item i will buy is apple i bought the apple my shopping list is now ['banana', 'carrot', 'mango', 'rice'] how it works: the variable shoplist is a shopping list for someone who is going to the market. in shoplist, we only store strings of the names of the items to buy but you can add any kind of object to a list including numbers and even other lists. we have also used the for..in loop to iterate through the items of the list. by now, you must have realised that a list is also a sequence. the speciality of sequences will be discussed in a later section. notice the use of the end keyword argument to the print function to indicate that we want to end the output with a space instead of the usual line break. next, we add an item to the list using the append method of the list object, as already discussed before. then, we check that the item has been indeed added to the list by printing the contents of the list by simply passing the list to the print statement which prints it neatly. then, we sort the list by using the sort method of the list. it is important to understand that this method affects the list itself and does not return a modified list - this is different from the way strings work. this is what we mean by saying that lists are mutable and that python en:data structures 64 strings are immutable. next, when we finish buying an item in the market, we want to remove it from the list. we achieve this by using the del statement. here, we mention which item of the list we want to remove and the del statement removes it from the list for us. we specify that we want to remove the first item from the list and hence we use del shoplist[0] (remember that python starts counting from 0). if you want to know all the methods defined by the list object, see help(list) for details. tuple tuples are used to hold together multiple objects. think of them as similar to lists, but without the extensive functionality that the list class gives you. one major feature of tuples is that they are immutable like strings i.e. you cannot modify tuples. tuples are defined by specifying items separated by commas within an optional pair of parentheses. tuples are usually used in cases where a statement or a user-defined function can safely assume that the collection of values i.e. the tuple of values used will not change. example: #!/usr/bin/python # filename: using_tuple.py zoo = ('python', 'elephant', 'penguin') # remember the parentheses are optional print('number of animals in the zoo is', len(zoo)) new_zoo = ('monkey', 'camel', zoo) print('number of cages in the new zoo is', len(new_zoo)) print('all animals in new zoo are', new_zoo) print('animals brought from old zoo are', new_zoo[2]) print('last animal brought from old zoo is', new_zoo[2][2]) print('number of animals in the new zoo is', len(new_zoo)-1+len(new_zoo[2])) output: $ python using_tuple.py number of animals in the zoo is 3 number of cages in the new zoo is 3 all animals in new zoo are ('monkey', 'camel', ('python', 'elephant', 'penguin')) animals brought from old zoo are ('python', 'elephant', 'penguin') last animal brought from old zoo is penguin number of animals in the new zoo is 5 how it works: the variable zoo refers to a tuple of items. we see that the len function can be used to get the length of the tuple. this also indicates that a tuple is a sequence as well. python en:data structures 65 we are now shifting these animals to a new zoo since the old zoo is being closed. therefore, the new_zoo tuple contains some animals which are already there along with the animals brought over from the old zoo. back to reality, note that a tuple within a tuple does not lose its identity. we can access the items in the tuple by specifying the item's position within a pair of square brackets just like we did for lists. this is called the indexing operator. we access the third item in new_zoo by specifying new_zoo[2] and we access the third item within the third item in the new_zoo tuple by specifying new_zoo[2][2]. this is pretty simple once you've understood the idiom. parentheses although the parentheses is optional, i prefer always having them to make it obvious that it is a tuple, especially because it avoids ambiguity. for example, print(1,2,3) and print( (1,2,3) ) mean two different things - the former prints three numbers whereas the latter prints a tuple (which contains three numbers). tuple with 0 or 1 items an empty tuple is constructed by an empty pair of parentheses such as myempty = (). however, a tuple with a single item is not so simple. you have to specify it using a comma following the first (and only) item so that python can differentiate between a tuple and a pair of parentheses surrounding the object in an expression i.e. you have to specify singleton = (2 , ) if you mean you want a tuple containing the item 2. note for perl programmers a list within a list does not lose its identity i.e. lists are not flattened as in perl. the same applies to a tuple within a tuple, or a tuple within a list, or a list within a tuple, etc. as far as python is concerned, they are just objects stored using another object, that's all. dictionary a dictionary is like an address-book where you can find the address or contact details of a person by knowing only his/her name i.e. we associate keys (name) with values (details). note that the key must be unique just like you cannot find out the correct information if you have two persons with the exact same name. note that you can use only immutable objects (like strings) for the keys of a dictionary but you can use either immutable or mutable objects for the values of the dictionary. this basically translates to say that you should use only simple objects for keys. pairs of keys and values are specified in a dictionary by using the notation d = {key1 : value1, key2 : value2 }. notice that the key-value pairs are separated by a colon and the pairs are separated themselves by commas and all this is enclosed in a pair of curly braces. remember that key-value pairs in a dictionary are not ordered in any manner. if you want a particular order, then you will have to sort them yourself before using it. the dictionaries that you will be using are instances/objects of the dict class. example: #!/usr/bin/python # filename: using_dict.py python en:data structures 66 # 'ab' is short for 'a'ddress'b'ook ab = { 'swaroop' : 'swaroop@swaroopch.com', 'larry' : 'larry@wall.org', 'matsumoto' : 'matz@ruby-lang.org', 'spammer' : 'spammer@hotmail.com' } print(\"swaroop's address is\", ab['swaroop']) # deleting a key-value pair del ab['spammer'] print('\\nthere are {0} contacts in the address-book\\n'.format(len(ab))) for name, address in ab.items(): print('contact {0} at {1}'.format(name, address)) # adding a key-value pair ab['guido'] = 'guido@python.org' if 'guido' in ab: # or ab.has_key('guido') print(\"\\nguido's address is\", ab['guido']) output: $ python using_dict.py swaroop's address is swaroop@swaroopch.com there are 3 contacts in the address-book contact swaroop at swaroop@swaroopch.com contact matsumoto at matz@ruby-lang.org contact larry at larry@wall.org guido's address is guido@python.org how it works: we create the dictionary ab using the notation already discussed. we then access key-value pairs by specifying the key using the indexing operator as discussed in the context of lists and tuples. observe the simple syntax. we can delete key-value pairs using our old friend - the del statement. we simply specify the dictionary and the indexing operator for the key to be removed and pass it to the del statement. there is no need to know the value corresponding to the key for this operation. next, we access each key-value pair of the dictionary using the items method of the dictionary which returns a list of tuples where each tuple contains a pair of items - the key followed by the value. we retrieve this pair and assign it to the variables name and address correspondingly for each pair using the for..in loop and then print these values in the python en:data structures 67 for-block. we can add new key-value pairs by simply using the indexing operator to access a key and assign that value, as we have done for guido in the above case. we can check if a key-value pair exists using the in operator or even the has_key method of the dict class. you can see the documentation for the complete list of methods of the dict class using help(dict). keyword arguments and dictionaries on a different note, if you have used keyword arguments in your functions, you have already used dictionaries! just think about it - the key-value pair is specified by you in the parameter list of the function definition and when you access variables within your function, it is just a key access of a dictionary (which is called the symbol table in compiler design terminology). sequences lists, tuples and strings are examples of sequences, but what are sequences and what is so special about them? the major features is that they have membership tests (i.e. the in and not in expressions) and indexing operations. the indexing operation which allows us to fetch a particular item in the sequence directly. the three types of sequences mentioned above - lists, tuples and strings, also have a slicing operation which allows us to retrieve a slice of the sequence i.e. a part of the sequence. example: #!/usr/bin/python # filename: seq.py shoplist = ['apple', 'mango', 'carrot', 'banana'] name = 'swaroop' # indexing or 'subscription' operation print('item 0 is', shoplist[0]) print('item 1 is', shoplist[1]) print('item 2 is', shoplist[2]) print('item 3 is', shoplist[3]) print('item -1 is', shoplist[-1]) print('item -2 is', shoplist[-2]) print('character 0 is', name[0]) # slicing on a list print('item 1 to 3 is', shoplist[1:3]) print('item 2 to end is', shoplist[2:]) print('item 1 to -1 is', shoplist[1:-1]) print('item start to end is', shoplist[:]) # slicing on a string python en:data structures 68 print('characters 1 to 3 is', name[1:3]) print('characters 2 to end is', name[2:]) print('characters 1 to -1 is', name[1:-1]) print('characters start to end is', name[:]) output: $ python seq.py item 0 is apple item 1 is mango item 2 is carrot item 3 is banana item -1 is banana item -2 is carrot character 0 is s item 1 to 3 is ['mango', 'carrot'] item 2 to end is ['carrot', 'banana'] item 1 to -1 is ['mango', 'carrot'] item start to end is ['apple', 'mango', 'carrot', 'banana'] characters 1 to 3 is wa characters 2 to end is aroop characters 1 to -1 is waroo characters start to end is swaroop how it works: first, we see how to use indexes to get individual items of a sequence. this is also referred to as the subscription operation. whenever you specify a number to a sequence within square brackets as shown above, python will fetch you the item corresponding to that position in the sequence. remember that python starts counting numbers from 0. hence, shoplist[0] fetches the first item and shoplist[3] fetches the fourth item in the shoplist sequence. the index can also be a negative number, in which case, the position is calculated from the end of the sequence. therefore, shoplist[-1] refers to the last item in the sequence and shoplist[-2] fetches the second last item in the sequence. the slicing operation is used by specifying the name of the sequence followed by an optional pair of numbers separated by a colon within square brackets. note that this is very similar to the indexing operation you have been using till now. remember the numbers are optional but the colon isn't. the first number (before the colon) in the slicing operation refers to the position from where the slice starts and the second number (after the colon) indicates where the slice will stop at. if the first number is not specified, python will start at the beginning of the sequence. if the second number is left out, python will stop at the end of the sequence. note that the slice returned starts at the start position and will end just before the end position i.e. the start position is included but the end position is excluded from the sequence slice. thus, shoplist[1:3] returns a slice of the sequence starting at position 1, includes position 2 but stops at position 3 and therefore a slice of two items is returned. similarly, shoplist[:] returns a copy of the whole sequence. python en:data structures 69 you can also do slicing with negative positions. negative numbers are used for positions from the end of the sequence. for example, shoplist[:-1] will return a slice of the sequence which excludes the last item of the sequence but contains everything else. you can also provide a third argument for the slice, which is the step for the slicing (by default, the step size is 1): >>> shoplist = ['apple', 'mango', 'carrot', 'banana'] >>> shoplist[::1] ['apple', 'mango', 'carrot', 'banana'] >>> shoplist[::2] ['apple', 'carrot'] >>> shoplist[::3] ['apple', 'banana'] >>> shoplist[::-1] ['banana', 'carrot', 'mango', 'apple'] notice that when the step is 2, we get the items with position 0, 2, ... when the step size is 3, we get the items with position 0, 3, etc. try various combinations of such slice specifications using the python interpreter interactively i.e. the prompt so that you can see the results immediately. the great thing about sequences is that you can access tuples, lists and strings all in the same way! set sets are unordered collections of simple objects. these are used when the existence of an object in a collection is more important than the order or how many times it occurs. using sets, you can test for membership, whether it is a subset of another set, find the intersection between two sets, and so on. >>> bri = set(['brazil', 'russia', 'india']) >>> 'india' in bri true >>> 'usa' in bri false >>> bric = bri.copy() >>> bric.add('china') >>> bric.issuperset(bri) true >>> bri.remove('russia') >>> bri & bric # or bri.intersection(bric) {'brazil', 'india'} how it works: the example is pretty much self-explanatory because it involves basic set theory mathematics taught in school. python en:data structures 70 references when you create an object and assign it to a variable, the variable only refers to the object and does not represent the object itself! that is, the variable name points to that part of your computer's memory where the object is stored. this is called as binding of the name to the object. generally, you don't need to be worried about this, but there is a subtle effect due to references which you need to be aware of: example: #!/usr/bin/python # filename: reference.py print('simple assignment') shoplist = ['apple', 'mango', 'carrot', 'banana'] mylist = shoplist # mylist is just another name pointing to the same object! del shoplist[0] # i purchased the first item, so i remove it from the list print('shoplist is', shoplist) print('mylist is', mylist) # notice that both shoplist and mylist both print the same list without # the 'apple' confirming that they point to the same object print('copy by making a full slice') mylist = shoplist[:] # make a copy by doing a full slice del mylist[0] # remove first item print('shoplist is', shoplist) print('mylist is', mylist) # notice that now the two lists are different output: $ python reference.py simple assignment shoplist is ['mango', 'carrot', 'banana'] mylist is ['mango', 'carrot', 'banana'] copy by making a full slice shoplist is ['mango', 'carrot', 'banana'] mylist is ['carrot', 'banana'] how it works: most of the explanation is available in the comments. remember that if you want to make a copy of a list or such kinds of sequences or complex objects (not simple objects such as integers), then you have to use the slicing operation to make a copy. if you just assign the variable name to another name, both of them will refer python en:data structures 71 to the same object and this could be trouble if you are not careful. note for perl programmers remember that an assignment statement for lists does not create a copy. you have to use slicing operation to make a copy of the sequence. more about strings we have already discussed strings in detail earlier. what more can there be to know? well, did you know that strings are also objects and have methods which do everything from checking part of a string to stripping spaces! the strings that you use in program are all objects of the class str. some useful methods of this class are demonstrated in the next example. for a complete list of such methods, see help(str). example: #!/usr/bin/python # filename: str_methods.py name = 'swaroop' # this is a string object if name.startswith('swa'): print('yes, the string starts with \"swa\"') if 'a' in name: print('yes, it contains the string \"a\"') if name.find('war') != -1: print('yes, it contains the string \"war\"') delimiter = '_*_' mylist = ['brazil', 'russia', 'india', 'china'] print(delimiter.join(mylist)) output: $ python str_methods.py yes, the string starts with \"swa\" yes, it contains the string \"a\" yes, it contains the string \"war\" brazil_*_russia_*_india_*_china how it works: here, we see a lot of the string methods in action. the startswith method is used to find out whether the string starts with the given string. the in operator is used to check if a given string is a part of the string. the find method is used to do find the position of the given string in the string or returns -1 if it is not successful to find the substring. the str class also has a neat method to join the items of a sequence with the string acting as a delimiter between each item of the sequence and returns a bigger string generated from this. python en:data structures 72 summary we have explored the various built-in data structures of python in detail. these data structures will be essential for writing programs of reasonable size. now that we have a lot of the basics of python in place, we will next see how to design and write a real-world python program. previous next source: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=1582 contributors: swaroop, 5 anonymous edits python en:problem solving we have explored various parts of the python language and now we will take a look at how all these parts fit together, by designing and writing a program which does something useful. the idea is to learn how to write a python script on your own. the problem the problem is \"i want a program which creates a backup of all my important files\". although, this is a simple problem, there is not enough information for us to get started with the solution. a little more analysis is required. for example, how do we specify which files are to be backed up? how are they stored? where are they stored? after analyzing the problem properly, we design our program. we make a list of things about how our program should work. in this case, i have created the following list on how i want it to work. if you do the design, you may not come up with the same kind of analysis since every person has their own way of doing things, so that is perfectly okay. 1. the files and directories to be backed up are specified in a list. 2. the backup must be stored in a main backup directory. 3. the files are backed up into a zip file. 4. the name of the zip archive is the current date and time. 5. we use the standard zip command available by default in any standard linux/unix distribution. windows users can install (http:/ / gnuwin32. sourceforge. net/ downlinks/ zip. php) from the gnuwin32 project page (http:/ / gnuwin32. sourceforge. net/ packages/ zip. htm) and add c:\\program files\\gnuwin32\\bin to your system path environment variable, similar to what we did for recognizing the python command itself. note that you can use any archiving command you want as long as it has a command line interface so that we can pass arguments to it from our script. python en:problem solving 73 the solution as the design of our program is now reasonably stable, we can write the code which is an implementation of our solution. #!/usr/bin/python # filename: backup_ver1.py import os import time # 1. the files and directories to be backed up are specified in a list. source = ['\"c:\\\\my documents\"', 'c:\\\\code'] # notice we had to use double quotes inside the string for names with spaces in it. # 2. the backup must be stored in a main backup directory target_dir = 'e:\\\\backup' # remember to change this to what you will be using # 3. the files are backed up into a zip file. # 4. the name of the zip archive is the current date and time target = target_dir + os.sep + time.strftime('%y%m%d%h%m%s') + '.zip' # 5. we use the zip command to put the files in a zip archive zip_command = \"zip -qr {0} {1}\".format(target, ' '.join(source)) # run the backup if os.system(zip_command) == 0: print('successful backup to', target) else: print('backup failed') output: $ python backup_ver1.py successful backup to e:\\backup\\20080702185040.zip now, we are in the testing phase where we test that our program works properly. if it doesn't behave as expected, then we have to debug our program i.e. remove the bugs (errors) from the program. if the above program does not work for you, put a print(zip_command) just before the os.system call and run the program. now copy/paste the printed zip_command to the shell prompt and see if it runs properly on its own. if this command fails, check the zip command manual on what could be wrong. if this command succeeds, then check the python program if it exactly matches the program written above. how it works: you will notice how we have converted our design into code in a step-by-step manner. python en:problem solving 74 we make use of the os and time modules by first importing them. then, we specify the files and directories to be backed up in the source list. the target directory is where store all the backup files and this is specified in the target_dir variable. the name of the zip archive that we are going to create is the current date and time which we find out using the time.strftime() function. it will also have the .zip extension and will be stored in the target_dir directory. notice the use of os.sep variable - this gives the directory separator according to your operating system i.e. it will be '/' in linux, unix, it will be '\\\\' in windows and ':' in mac os. using os.sep instead of these characters directly will make our program portable and work across these systems. the time.strftime() function takes a specification such as the one we have used in the above program. the %y specification will be replaced by the year without the century. the %m specification will be replaced by the month as a decimal number between 01 and 12 and so on. the complete list of such specifications can be found in the python reference manual (http:/ / docs. python. org/ dev/ 3. 0/ library/ time. html#time. strftime). we create the name of the target zip file using the addition operator which concatenates the strings i.e. it joins the two strings together and returns a new one. then, we create a string zip_command which contains the command that we are going to execute. you can check if this command works by running it on the shell (linux terminal or dos prompt). the zip command that we are using has some options and parameters passed. the -q option is used to indicate that the zip command should work quietly. the -r option specifies that the zip command should work recursively for directories i.e. it should include all the subdirectories and files. the two options are combined and specified in a shortcut as -qr. the options are followed by the name of the zip archive to create followed by the list of files and directories to backup. we convert the source list into a string using the join method of strings which we have already seen how to use. then, we finally run the command using the os.system function which runs the command as if it was run from the system i.e. in the shell - it returns 0 if the command was successfully, else it returns an error number. depending on the outcome of the command, we print the appropriate message that the backup has failed or succeeded. that's it, we have created a script to take a backup of our important files! note to windows users instead of double backslash escape sequences, you can also use raw strings. for example, use 'c:\\\\documents' or r'c:\\documents'. however, do not use 'c:\\documents' since you end up using an unknown escape sequence \\d. now that we have a working backup script, we can use it whenever we want to take a backup of the files. linux/unix users are advised to use the executable method as discussed earlier so that they can run the backup script anytime anywhere. this is called the operation phase or the deployment phase of the software. the above program works properly, but (usually) first programs do not work exactly as you expect. for example, there might be problems if you have not designed the program properly or if you have made a mistake in typing the code, etc. appropriately, you will have to go back to the design phase or you will have to debug your program. python en:problem solving 75 second version the first version of our script works. however, we can make some refinements to it so that it can work better on a daily basis. this is called the maintenance phase of the software. one of the refinements i felt was useful is a better file-naming mechanism - using the time as the name of the file within a directory with the current date as a directory within the main backup directory. first advantage is that your backups are stored in a hierarchical manner and therefore it is much easier to manage. second advantage is that the length of the filenames are much shorter. third advantage is that separate directories will help you to easily check if you have taken a backup for each day since the directory would be created only if you have taken a backup for that day. #!/usr/bin/python # filename: backup_ver2.py import os import time # 1. the files and directories to be backed up are specified in a list. source = ['\"c:\\\\my documents\"', 'c:\\\\code'] # notice we had to use double quotes inside the string for names with spaces in it. # 2. the backup must be stored in a main backup directory target_dir = 'e:\\\\backup' # remember to change this to what you will be using # 3. the files are backed up into a zip file. # 4. the current day is the name of the subdirectory in the main directory today = target_dir + os.sep + time.strftime('%y%m%d') # the current time is the name of the zip archive now = time.strftime('%h%m%s') # create the subdirectory if it isn't already there if not os.path.exists(today): os.mkdir(today) # make directory print('successfully created directory', today) # the name of the zip file target = today + os.sep + now + '.zip' # 5. we use the zip command to put the files in a zip archive zip_command = \"zip -qr {0} {1}\".format(target, ' '.join(source)) # run the backup if os.system(zip_command) == 0: print('successful backup to', target) python en:problem solving 76 else: print('backup failed') output: $ python backup_ver2.py successfully created directory e:\\backup\\20080702 successful backup to e:\\backup\\20080702\\202311.zip $ python backup_ver2.py successful backup to e:\\backup\\20080702\\202325.zip how it works: most of the program remains the same. the changes is that we check if there is a directory with the current day as name inside the main backup directory using the os.path.exists function. if it doesn't exist, we create it using the os.mkdir function. third version the second version works fine when i do many backups, but when there are lots of backups, i am finding it hard to differentiate what the backups were for! for example, i might have made some major changes to a program or presentation, then i want to associate what those changes are with the name of the zip archive. this can be easily achieved by attaching a user-supplied comment to the name of the zip archive. note the following program does not work, so do not be alarmed, please follow along because there's a lesson in here. #!/usr/bin/python # filename: backup_ver3.py import os import time # 1. the files and directories to be backed up are specified in a list. source = ['\"c:\\\\my documents\"', 'c:\\\\code'] # notice we had to use double quotes inside the string for names with spaces in it. # 2. the backup must be stored in a main backup directory target_dir = 'e:\\\\backup' # remember to change this to what you will be using # 3. the files are backed up into a zip file. # 4. the current day is the name of the subdirectory in the main directory today = target_dir + os.sep + time.strftime('%y%m%d') # the current time is the name of the zip archive now = time.strftime('%h%m%s') python en:problem solving 77 # take a comment from the user to create the name of the zip file comment = input('enter a comment --> ') if len(comment) == 0: # check if a comment was entered target = today + os.sep + now + '.zip' else: target = today + os.sep + now + '_' + comment.replace(' ', '_') + '.zip' # create the subdirectory if it isn't already there if not os.path.exists(today): os.mkdir(today) # make directory print('successfully created directory', today) # 5. we use the zip command to put the files in a zip archive zip_command = \"zip -qr {0} {1}\".format(target, ' '.join(source)) # run the backup if os.system(zip_command) == 0: print('successful backup to', target) else: print('backup failed') output: $ python backup_ver3.py file \"backup_ver3.py\", line 25 target = today + os.sep + now + '_' + ^ syntaxerror: invalid syntax how this (does not) work: this program does not work! python says there is a syntax error which means that the script does not satisfy the structure that python expects to see. when we observe the error given by python, it also tells us the place where it detected the error as well. so we start debugging our program from that line. on careful observation, we see that the single logical line has been split into two physical lines but we have not specified that these two physical lines belong together. basically, python has found the addition operator (+) without any operand in that logical line and hence it doesn't know how to continue. remember that we can specify that the logical line continues in the next physical line by the use of a backslash at the end of the physical line. so, we make this correction to our program. this correction of the program when we find errors is called bug fixing. python en:problem solving 78 fourth version #!/usr/bin/python # filename: backup_ver4.py import os import time # 1. the files and directories to be backed up are specified in a list. source = ['\"c:\\\\my documents\"', 'c:\\\\code'] # notice we had to use double quotes inside the string for names with spaces in it. # 2. the backup must be stored in a main backup directory target_dir = 'e:\\\\backup' # remember to change this to what you will be using # 3. the files are backed up into a zip file. # 4. the current day is the name of the subdirectory in the main directory today = target_dir + os.sep + time.strftime('%y%m%d') # the current time is the name of the zip archive now = time.strftime('%h%m%s') # take a comment from the user to create the name of the zip file comment = input('enter a comment --> ') if len(comment) == 0: # check if a comment was entered target = today + os.sep + now + '.zip' else: target = today + os.sep + now + '_' + \\ comment.replace(' ', '_') + '.zip' # create the subdirectory if it isn't already there if not os.path.exists(today): os.mkdir(today) # make directory print('successfully created directory', today) # 5. we use the zip command to put the files in a zip archive zip_command = \"zip -qr {0} {1}\".format(target, ' '.join(source)) # run the backup if os.system(zip_command) == 0: print('successful backup to', target) else: print('backup failed') output: python en:problem solving 79 $ python backup_ver4.py enter a comment --> added new examples successful backup to e:\\backup\\20080702\\202836_added_new_examples.zip $ python backup_ver4.py enter a comment --> successful backup to e:\\backup\\20080702\\202839.zip how it works: this program now works! let us go through the actual enhancements that we had made in version 3. we take in the user's comments using the input function and then check if the user actually entered something by finding out the length of the input using the len function. if the user has just pressed enter without entering anything (maybe it was just a routine backup or no special changes were made), then we proceed as we have done before. however, if a comment was supplied, then this is attached to the name of the zip archive just before the .zip extension. notice that we are replacing spaces in the comment with underscores - this is because managing filenames without spaces are much easier. more refinements the fourth version is a satisfactorily working script for most users, but there is always room for improvement. for example, you can include a verbosity level for the program where you can specify a -v option to make your program become more talkative. another possible enhancement would be to allow extra files and directories to be passed to the script at the command line. we can get these names from the sys.argv list and we can add them to our source list using the extend method provided by the list class. the most important refinement would be to not use the os.system way of creating archives and instead using the zipfile or tarfile built-in module to create these archives. they are part of the standard library and available already for you to use without external dependencies on the zip program to be available on your computer. however, i have been using the os.system way of creating a backup in the above examples purely for pedagogical purposes, so that the example is simple enough to be understood by everybody but real enough to be useful. can you try writing the fifth version that uses the zipfile (http:/ / docs. python. org/ dev/ 3. 0/ library/ zipfile. html) module instead of the os.system call? python en:problem solving 80 the software development process we have now gone through the various phases in the process of writing a software. these phases can be summarised as follows: 1. what (analysis) 2. how (design) 3. do it (implementation) 4. test (testing and debugging) 5. use (operation or deployment) 6. maintain (refinement) a recommended way of writing programs is the procedure we have followed in creating the backup script: do the analysis and design. start implementing with a simple version. test and debug it. use it to ensure that it works as expected. now, add any features that you want and continue to repeat the do it-test-use cycle as many times as required. remember, software is grown, not built. summary we have seen how to create our own python programs/scripts and the various stages involved in writing such programs. you may find it useful to create your own program just like we did in this chapter so that you become comfortable with python as well as problem-solving. next, we will discuss object-oriented programming. previous next source: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=1395 contributors: swaroop, 3 anonymous edits python en:object oriented programming 81 python en:object oriented programming introduction in all the programs we wrote till now, we have designed our program around functions i.e. blocks of statements which manipulate data. this is called the procedure-oriented way of programming. there is another way of organizing your program which is to combine data and functionality and wrap it inside something called an object. this is called the object oriented programming paradigm. most of the time you can use procedural programming, but when writing large programs or have a problem that is better suited to this method, you can use object oriented programming techniques. classes and objects are the two main aspects of object oriented programming. a class creates a new type where objects are instances of the class. an analogy is that you can have variables of type int which translates to saying that variables that store integers are variables which are instances (objects) of the int class. note for static language programmers note that even integers are treated as objects (of the int class). this is unlike c++ and java (before version 1.5) where integers are primitive native types. see help(int) for more details on the class. c# and java 1.5 programmers will find this similar to the boxing and unboxing concept. objects can store data using ordinary variables that belong to the object. variables that belong to an object or class are referred to as fields. objects can also have functionality by using functions that belong to a class. such functions are called methods of the class. this terminology is important because it helps us to differentiate between functions and variables which are independent and those which belong to a class or object. collectively, the fields and methods can be referred to as the attributes of that class. fields are of two types - they can belong to each instance/object of the class or they can belong to the class itself. they are called instance variables and class variables respectively. a class is created using the class keyword. the fields and methods of the class are listed in an indented block. the self class methods have only one specific difference from ordinary functions - they must have an extra first name that has to be added to the beginning of the parameter list, but you do not give a value for this parameter when you call the method, python will provide it. this particular variable refers to the object itself, and by convention, it is given the name self. although, you can give any name for this parameter, it is strongly recommended that you use the name self - any other name is definitely frowned upon. there are many advantages to using a standard name - any reader of your program will immediately recognize it and even specialized ides (integrated development environments) can help you if you use self. python en:object oriented programming 82 note for c++/java/c# programmers the self in python is equivalent to the this pointer in c++ and the this reference in java and c#. you must be wondering how python gives the value for self and why you don't need to give a value for it. an example will make this clear. say you have a class called myclass and an instance of this class called myobject. when you call a method of this object as myobject.method(arg1, arg2), this is automatically converted by python into myclass.method(myobject, arg1, arg2) - this is all the special self is about. this also means that if you have a method which takes no arguments, then you still have to have one argument - the self. classes the simplest class possible is shown in the following example. #!/usr/bin/python # filename: simplestclass.py class person: pass # an empty block p = person() print(p) output: $ python simplestclass.py <__main__.person object at 0x019f85f0> how it works: we create a new class using the class statement and the name of the class. this is followed by an indented block of statements which form the body of the class. in this case, we have an empty block which is indicated using the pass statement. next, we create an object/instance of this class using the name of the class followed by a pair of parentheses. (we will learn more about instantiation in the next section). for our verification, we confirm the type of the variable by simply printing it. it tells us that we have an instance of the person class in the __main__ module. notice that the address of the computer memory where your object is stored is also printed. the address will have a different value on your computer since python can store the object wherever it finds space. python en:object oriented programming 83 object methods we have already discussed that classes/objects can have methods just like functions except that we have an extra self variable. we will now see an example. #!/usr/bin/python # filename: method.py class person: def sayhi(self): print('hello, how are you?') p = person() p.sayhi() # this short example can also be written as person().sayhi() output: $ python method.py hello, how are you? how it works: here we see the self in action. notice that the sayhi method takes no parameters but still has the self in the function definition. the _ _ init_ _ method there are many method names which have special significance in python classes. we will see the significance of the __init__ method now. the __init__ method is run as soon as an object of a class is instantiated. the method is useful to do any initialization you want to do with your object. notice the double underscores both at the beginning and at the end of the name. example: #!/usr/bin/python # filename: class_init.py class person: def __init__(self, name): self.name = name def sayhi(self): print('hello, my name is', self.name) p = person('swaroop') p.sayhi() # this short example can also be written as person('swaroop').sayhi() output: python en:object oriented programming 84 $ python class_init.py hello, my name is swaroop how it works: here, we define the __init__ method as taking a parameter name (along with the usual self). here, we just create a new field also called name. notice these are two different variables even though they are both called 'name'. the dotted notation allows us to differentiate between them. most importantly, notice that we do not explicitly call the __init__ method but pass the arguments in the parentheses following the class name when creating a new instance of the class. this is the special significance of this method. now, we are able to use the self.name field in our methods which is demonstrated in the sayhi method. class and object variables we have already discussed the functionality part of classes and objects (i.e. methods), now let us learn about the data part. the data part, i.e. fields, are nothing but ordinary variables that are bound to the namespaces of the classes and objects. this means that these names are valid within the context of these classes and objects only. that's why they are called name spaces. there are two types of fields - class variables and object variables which are classified depending on whether the class or the object owns the variables respectively. class variables are shared - they can be accessed by all instances of that class. there is only one copy of the class variable and when any one object makes a change to a class variable, that change will be seen by all the other instances. object variables are owned by each individual object/instance of the class. in this case, each object has its own copy of the field i.e. they are not shared and are not related in any way to the field by the same name in a different instance. an example will make this easy to understand: #!/usr/bin/python # filename: objvar.py class robot: '''represents a robot, with a name.''' # a class variable, counting the number of robots population = 0 def __init__(self, name): '''initializes the data.''' self.name = name print('(initializing {0})'.format(self.name)) # when this person is created, the robot # adds to the population robot.population += 1 python en:object oriented programming 85 def __del__(self): '''i am dying.''' print('{0} is being destroyed!'.format(self.name)) robot.population -= 1 if robot.population == 0: print('{0} was the last one.'.format(self.name)) else: print('there are still {0:d} robots working.'.format(robot.population)) def sayhi(self): '''greeting by the robot. yeah, they can do that.''' print('greetings, my masters call me {0}.'.format(self.name)) def howmany(): '''prints the current population.''' print('we have {0:d} robots.'.format(robot.population)) howmany = staticmethod(howmany) droid1 = robot('r2-d2') droid1.sayhi() robot.howmany() droid2 = robot('c-3po') droid2.sayhi() robot.howmany() print(\"\\nrobots can do some work here.\\n\") print(\"robots have finished their work. so let's destroy them.\") del droid1 del droid2 robot.howmany() output: (initializing r2-d2) greetings, my masters call me r2-d2. we have 1 robots. (initializing c-3po) greetings, my masters call me c-3po. we have 2 robots. python en:object oriented programming 86 robots can do some work here. robots have finished their work. so let's destroy them. r2-d2 is being destroyed! there are still 1 robots working. c-3po is being destroyed! c-3po was the last one. we have 0 robots. how it works: this is a long example but helps demonstrate the nature of class and object variables. here, population belongs to the robot class and hence is a class variable. the name variable belongs to the object (it is assigned using self) and hence is an object variable. thus, we refer to the population class variable as robot.population and not as self.population. we refer to the object variable name using self.name notation in the methods of that object. remember this simple difference between class and object variables. also note that an object variable with the same name as a class variable will hide the class variable! the howmany is actually a method that belongs to the class and not to the object. this means we can define it as either a classmethod or a staticmethod depending on whether we need to know which class we are part of. since we don't need such information, we will go for staticmethod. we could have also achieved the same using decorators (http:/ / www. ibm. com/ developerworks/ linux/ library/ l-cpdecor. html): @staticmethod def howmany(): '''prints the current population.''' print('we have {0:d} robots.'.format(robot.population)) decorators can be imagined to be a shortcut to calling an explicit statement, as we have seen in this example. observe that the __init__ method is used to initialize the robot instance with a name. in this method, we increase the population count by 1 since we have one more robot being added. also observe that the values of self.name is specific to each object which indicates the nature of object variables. remember, that you must refer to the variables and methods of the same object using the self only. this is called an attribute reference. in this program, we also see the use of docstrings for classes as well as methods. we can access the class docstring at runtime using robot.__doc__ and the method docstring as robot.sayhi.__doc__ just like the __init__ method, there is another special method __del__ which is called when an object is going to die i.e. it is no longer being used and is being returned to the computer system for reusing that piece of memory. in this method, we simply decrease the robot.population count by 1. python en:object oriented programming 87 the __del__ method is run when the object is no longer in use and there is no guarantee when that method will be run. if you want to explicitly see it in action, we have to use the del statement which is what we have done here. note for c++/java/c# programmers all class members (including the data members) are public and all the methods are virtual in python. one exception: if you use data members with names using the double underscore prefix such as __privatevar, python uses name-mangling to effectively make it a private variable. thus, the convention followed is that any variable that is to be used only within the class or object should begin with an underscore and all other names are public and can be used by other classes/objects. remember that this is only a convention and is not enforced by python (except for the double underscore prefix). inheritance one of the major benefits of object oriented programming is reuse of code and one of the ways this is achieved is through the inheritance mechanism. inheritance can be best imagined as implementing a type and subtype relationship between classes. suppose you want to write a program which has to keep track of the teachers and students in a college. they have some common characteristics such as name, age and address. they also have specific characteristics such as salary, courses and leaves for teachers and, marks and fees for students. you can create two independent classes for each type and process them but adding a new common characteristic would mean adding to both of these independent classes. this quickly becomes unwieldy. a better way would be to create a common class called schoolmember and then have the teacher and student classes inherit from this class i.e. they will become sub-types of this type (class) and then we can add specific characteristics to these sub-types. there are many advantages to this approach. if we add/change any functionality in schoolmember, this is automatically reflected in the subtypes as well. for example, you can add a new id card field for both teachers and students by simply adding it to the schoolmember class. however, changes in the subtypes do not affect other subtypes. another advantage is that if you can refer to a teacher or student object as a schoolmember object which could be useful in some situations such as counting of the number of school members. this is called polymorphism where a sub-type can be substituted in any situation where a parent type is expected i.e. the object can be treated as an instance of the parent class. also observe that we reuse the code of the parent class and we do not need to repeat it in the different classes as we would have had to in case we had used independent classes. the schoolmember class in this situation is known as the base class or the superclass. the teacher and student classes are called the derived classes or subclasses. we will now see this example as a program. #!/usr/bin/python # filename: inherit.py python en:object oriented programming 88 class schoolmember: '''represents any school member.''' def __init__(self, name, age): self.name = name self.age = age print('(initialized schoolmember: {0})'.format(self.name)) def tell(self): '''tell my details.''' print('name:\"{0}\" age:\"{1}\"'.format(self.name, self.age), end=\" \") class teacher(schoolmember): '''represents a teacher.''' def __init__(self, name, age, salary): schoolmember.__init__(self, name, age) self.salary = salary print('(initialized teacher: {0})'.format(self.name)) def tell(self): schoolmember.tell(self) print('salary: \"{0:d}\"'.format(self.salary)) class student(schoolmember): '''represents a student.''' def __init__(self, name, age, marks): schoolmember.__init__(self, name, age) self.marks = marks print('(initialized student: {0})'.format(self.name)) def tell(self): schoolmember.tell(self) print('marks: \"{0:d}\"'.format(self.marks)) t = teacher('mrs. shrividya', 40, 30000) s = student('swaroop', 25, 75) print() # prints a blank line members = [t, s] for member in members: member.tell() # works for both teachers and students output: $ python inherit.py (initialized schoolmember: mrs. shrividya) python en:object oriented programming 89 (initialized teacher: mrs. shrividya) (initialized schoolmember: swaroop) (initialized student: swaroop) name:\"mrs. shrividya\" age:\"40\" salary: \"30000\" name:\"swaroop\" age:\"25\" marks: \"75\" how it works: to use inheritance, we specify the base class names in a tuple following the class name in the class definition. next, we observe that the __init__ method of the base class is explicitly called using the self variable so that we can initialize the base class part of the object. this is very important to remember - python does not automatically call the constructor of the base class, you have to explicitly call it yourself. we also observe that we can call methods of the base class by prefixing the class name to the method call and then pass in the self variable along with any arguments. notice that we can treat instances of teacher or student as just instances of the schoolmember when we use the tell method of the schoolmember class. also, observe that the tell method of the subtype is called and not the tell method of the schoolmember class. one way to understand this is that python always starts looking for methods in the actual type, which in this case it does. if it could not find the method, it starts looking at the methods belonging to its base classes one by one in the order they are specified in the tuple in the class definition. a note on terminology - if more than one class is listed in the inheritance tuple, then it is called multiple inheritance. summary we have now explored the various aspects of classes and objects as well as the various terminologies associated with it. we have also seen the benefits and pitfalls of object-oriented programming. python is highly object-oriented and understanding these concepts carefully will help you a lot in the long run. next, we will learn how to deal with input/output and how to access files in python. previous next source: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=2359 contributors: horstjens, swaroop, 6 anonymous edits python en:input output 90 python en:input output introduction there will be situations where your program has to interact with the user. for example, you would want to take input from the user and then print some results back. we can achieve this using the input() and print() functions respectively. for output, we can also use the various methods of the str (string) class. for example, you can use the rjust method to get a string which is right justified to a specified width. see help(str) for more details. another common type of input/output is dealing with files. the ability to create, read and write files is essential to many programs and we will explore this aspect in this chapter. input from user #!/usr/bin/python # user_input.py def reverse(text): return text[::-1] def is_palindrome(text): return text == reverse(text) something = input('enter text: ') if (is_palindrome(something)): print(\"yes, it is a palindrome\") else: print(\"no, it is not a palindrome\") output: $ python user_input.py enter text: sir no, it is not a palindrome $ python user_input.py enter text: madam yes, it is a palindrome $ python user_input.py enter text: racecar yes, it is a palindrome how it works: we use the slicing feature to reverse the text. we've already seen how we can make slices from sequences using the seq[a:b] code starting from position a to position b. we can also provide a third argument that determines the step by which the slicing is done. the python en:input output 91 default step is 1 because of which it returns a continuous part of the text. giving a negative step, i.e., -1 will return the text in reverse. the input() function takes a string as argument and displays it to the user. then it waits for the user to type something and press the return key. once the user has entered, the input() function will then return that text. we take that text and reverse it. if the original text and reversed text are equal, then the text is a palindrome (http:/ / en. wiktionary. org/ wiki/ palindrome). homework exercise: checking whether a text is a palindrome should also ignore punctuation, spaces and case. for example, \"rise to vote, sir.\" is also a palindrome but our current program doesn't say it is. can you improve the above program to recognize this palindrome? files you can open and use files for reading or writing by creating an object of the file class and using its read, readline or write methods appropriately to read from or write to the file. the ability to read or write to the file depends on the mode you have specified for the file opening. then finally, when you are finished with the file, you call the close method to tell python that we are done using the file. example: #!/usr/bin/python # filename: using_file.py poem = '''\\ programming is fun when the work is done if you wanna make your work also fun: use python! ''' f = open('poem.txt', 'w') # open for 'w'riting f.write(poem) # write text to file f.close() # close the file f = open('poem.txt') # if no mode is specified, 'r'ead mode is assumed by default while true: line = f.readline() if len(line) == 0: # zero length indicates eof break print(line, end='') f.close() # close the file output: $ python using_file.py programming is fun python en:input output 92 when the work is done if you wanna make your work also fun: use python! how it works: first, open a file by using the built-in open function and specifying the name of the file and the mode in which we want to open the file. the mode can be a read mode ('r'), write mode ('w') or append mode ('a'). we can also by dealing with a text file ('t') or a binary file ('b'). there are actually many more modes available and help(open) will give you more details about them. by default, open() considers the file to be a 't'ext file and opens it in 'r'ead mode. in our example, we first open the file in write text mode and use the write method of the file object to write to the file and then we finally close the file. next, we open the same file again for reading. we don't need to specify a mode because 'read text file' is the default mode. we read in each line of the file using the readline method in a loop. this method returns a complete line including the newline character at the end of the line. when an empty string is returned, it means that we have reached the end of the file and we 'break' out of the loop. by deafult, the print() function prints the text as well as an automatic newline to the screen. we are suppressing the newline by specifying end='' because the line that is read from the file already ends with a newline character. then, we finally close the file. now, check the contents of the poem.txt file to confirm that the program has indeed written and read from that file. pickle python provides a standard module called pickle using which you can store any python object in a file and then get it back later. this is called storing the object persistently. example: #!/usr/bin/python # filename: pickling.py import pickle # the name of the file where we will store the object shoplistfile = 'shoplist.data' # the list of things to buy shoplist = ['apple', 'mango', 'carrot'] # write to the file f = open(shoplistfile, 'wb') pickle.dump(shoplist, f) # dump the object to a file f.close() del shoplist # destroy the shoplist variable # read back from the storage python en:input output 93 f = open(shoplistfile, 'rb') storedlist = pickle.load(f) # load the object from the file print(storedlist) output: $ python pickling.py ['apple', 'mango', 'carrot'] how it works: to store an object in a file, we have to first open the file in 'w'rite 'b'inary mode and then call the dump function of the pickle module. this process is called pickling. next, we retrieve the object using the load function of the pickle module which returns the object. this process is called unpickling. summary we have discussed various types of input/output and also file handling and using the pickle module. next, we will explore the concept of exceptions. previous next source: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=1583 contributors: horstjens, swaroop, 1 anonymous edits python en:exceptions introduction exceptions occur when certain exceptional situations occur in your program. for example, what if you are going to read a file and the file does not exist? or what if you accidentally deleted it when the program was running? such situations are handled using exceptions. similarly, what if your program had some invalid statements? this is handled by python which raises its hands and tells you there is an error. errors consider a simple print function call. what if we misspelt print as print? note the capitalization. in this case, python raises a syntax error. >>> print('hello world') traceback (most recent call last): file \"<pyshell#0>\", line 1, in <module> print('hello world') nameerror: name 'print' is not defined >>> print('hello world') hello world python en:exceptions 94 observe that a nameerror is raised and also the location where the error was detected is printed. this is what an error handler for this error does. exceptions we will try to read input from the user. press ctrl-d and see what happens. >>> s = input('enter something --> ') enter something --> traceback (most recent call last): file \"<pyshell#2>\", line 1, in <module> s = input('enter something --> ') eoferror: eof when reading a line python raises an error called eoferror which basically means it found an end of file symbol (which is represented by ctrl-d) when it did not expect to see it. handling exceptions we can handle exceptions using the try..except statement. we basically put our usual statements within the try-block and put all our error handlers in the except-block. #!/usr/bin/python # filename: try_except.py try: text = input('enter something --> ') except eoferror: print('why did you do an eof on me?') except keyboardinterrupt: print('you cancelled the operation.') else: print('you entered {0}'.format(text)) output: $ python try_except.py enter something --> # press ctrl-d why did you do an eof on me? $ python try_except.py enter something --> # press ctrl-c you cancelled the operation. $ python try_except.py enter something --> no exceptions you entered no exceptions how it works: we put all the statements that might raise exceptions/errors inside the try block and then put handlers for the appropriate errors/exceptions in the except clause/block. the except python en:exceptions 95 clause can handle a single specified error or exception, or a parenthesized list of errors/exceptions. if no names of errors or exceptions are supplied, it will handle all errors and exceptions. note that there has to be at least one except clause associated with every try clause. otherwise, what's the point of having a try block? if any error or exception is not handled, then the default python handler is called which just stops the execution of the program and prints an error message. we have already seen this in action above. you can also have an else clause associated with a try..except block. the else clause is executed if no exception occurs. in the next example, we will also see how to get the exception object so that we can retrieve additional information. raising exceptions you can raise exceptions using the raise statement by providing the name of the error/exception and the exception object that is to be thrown. the error or exception that you can arise should be class which directly or indirectly must be a derived class of the exception class. #!/usr/bin/python # filename: raising.py class shortinputexception(exception): '''a user-defined exception class.''' def __init__(self, length, atleast): exception.__init__(self) self.length = length self.atleast = atleast try: text = input('enter something --> ') if len(text) < 3: raise shortinputexception(len(text), 3) # other work can continue as usual here except eoferror: print('why did you do an eof on me?') except shortinputexception as ex: print('shortinputexception: the input was {0} long, expected at least {1}'\\ .format(ex.length, ex.atleast)) else: print('no exception was raised.') output: $ python raising.py enter something --> a python en:exceptions 96 shortinputexception: the input was 1 long, expected at least 3 $ python raising.py enter something --> abc no exception was raised. how it works: here, we are creating our own exception type. this new exception type is called shortinputexception. it has two fields - length which is the length of the given input, and atleast which is the minimum length that the program was expecting. in the except clause, we mention the class of error which will be stored as the variable name to hold the corresponding error/exception object. this is analogous to parameters and arguments in a function call. within this particular except clause, we use the length and atleast fields of the exception object to print an appropriate message to the user. try . . finally suppose you are reading a file in your program. how do you ensure that the file object is closed properly whether or not an exception was raised? this can be done using the finally block. note that you can use an except clause along with a finally block for the same corresponding try block. you will have to embed one within another if you want to use both. #!/usr/bin/python # filename: finally.py import time try: f = open('poem.txt') while true: # our usual file-reading idiom line = f.readline() if len(line) == 0: break print(line, end='') time.sleep(2) # to make sure it runs for a while except keyboardinterrupt: print('!! you cancelled the reading from the file.') finally: f.close() print('(cleaning up: closed the file)') output: $ python finally.py programming is fun when the work is done if you wanna make your work also fun: !! you cancelled the reading from the file. python en:exceptions 97 (cleaning up: closed the file) how it works: we do the usual file-reading stuff, but we have arbitrarily introduced sleeping for 2 seconds after printing each line using the time.sleep function so that the program runs slowly (python is very fast by nature). when the program is still running, press ctrl-c to interrupt/cancel the program. observe that the keyboardinterrupt exception is thrown and the program quits. however, before the program exits, the finally clause is executed and the file object is always closed. the with statement acquiring a resource in the try block and subsequently releasing the resource in the finally block is a common pattern. hence, there is also a with statement that enables this to be done in a clean manner: #!/usr/bin/python # filename: using_with.py with open(\"poem.txt\") as f: for line in f: print(line, end='') how it works: the output should be same as the previous example. the difference here is that we are using the open function with the with statement - we leave the closing of the file to be done automatically by with open. what happens behind the scenes is that there is a protocol used by the with statement. it fetches the object returned by the open statement, let's call it \"thefile\" in this case. it always calls the thefile.__enter__ function before starting the block of code under it and always calls thefile.__exit__ after finishing the block of code. so the code that we would have written in a finally block is should be taken care of automatically by the __exit__ method. this is what helps us to avoid having to use explicit try..finally statements repeatedly. more discussion on this topic is beyond scope of this book, so please refer pep 343 (http:/ / www. python. org/ dev/ peps/ pep-0343/ ) for comprehensive explanation. summary we have discussed the usage of the try..except and try..finally statements. we have seen how to create our own exception types and how to raise exceptions as well. next, we will explore the python standard library. previous next source: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=1470 contributors: swaroop, 2 anonymous edits python en:standard library 98 python en:standard library introduction the python standard library contains a huge number of useful modules and is part of every standard python installation. it is important to become familiar with the python standard library since many problems can be solved quickly if you are familiar with the range of things that these libraries can do. we will explore some of the commonly used modules in this library. you can find complete details for all of the modules in the python standard library in the 'library reference' section (http:/ / docs. python. org/ dev/ 3. 0/ library/ ) of the documentation that comes with your python installation. let us explore a few useful modules. note if you find the topics in this chapter too advanced, you may skip this chapter. however, i highly recommend coming back to this chapter when you are more comfortable with programming using python. sys module the sys module contains system-specific functionality. we have already seen that the sys.argv list contains the command-line arguments. suppose we want to check the version of the python command being used so that, say, we want to ensure that we are using at least version 3. the sys module gives us such functionality. >>> import sys >>> sys.version_info (3, 0, 0, 'beta', 2) >>> sys.version_info[0] >= 3 true how it works: the sys module has a version_info tuple that gives us the version information. the first entry is the major version. we can check this to, for example, ensure the program runs only under python 3.0: #!/usr/bin/python # filename: versioncheck.py import sys, warnings if sys.version_info[0] < 3: warnings.warn(\"need python 3.0 for this program to run\", runtimewarning) else: print('proceed as normal') output: python en:standard library 99 $ python2.5 versioncheck.py versioncheck.py:6: runtimewarning: need python 3.0 for this program to run runtimewarning) $ python3 versioncheck.py proceed as normal how it works: we use another module from the standard library called warnings that is used to display warnings to the end-user. if the python version number is not at least 3, we display a corresponding warning. logging module what if you wanted to have some debugging messages or important messages to be stored somewhere so that you can check whether your program has been running as you would expect it? how do you \"store somewhere\" these messages? this can be achieved using the logging module. #!/usr/bin/python # filename: use_logging.py import os, platform, logging if platform.platform().startswith('windows'): logging_file = os.path.join(os.getenv('homedrive'), os.getenv('homepath'), 'test.log') else: logging_file = os.path.join(os.getenv('home'), 'test.log') logging.basicconfig( level=logging.debug, format='%(asctime)s : %(levelname)s : %(message)s', filename = logging_file, filemode = 'w', ) logging.debug(\"start of the program\") logging.info(\"doing something\") logging.warning(\"dying now\") output: $python use_logging.py logging to c:\\users\\swaroop\\test.log if we check the contents of test.log, it will look something like this: 2008-09-03 13:18:16,233 : debug : start of the program 2008-09-03 13:18:16,233 : info : doing something 2008-09-03 13:18:16,233 : warning : dying now python en:standard library 100 how it works: we use three modules from the standard library - the os module for interacting with the operating system, the platform module for information about the platform i.e. the operating system and the logging module to log information. first, we check which operating system we are using by checking the string returned by platform.platform() (for more information, see import platform; help(platform)). if it is windows, we figure out the home drive, the home folder and the filename where we want to store the information. putting these three parts together, we get the full location of the file. for other platforms, we need to know just the home folder of the user and we get the full location of the file. we use the os.path.join() function to put these three parts of the location together. the reason to use a special function rather than just adding the strings together is because this function will ensure the full location matches the format expected by the operating system. we configure the logging module to write all the messages in a particular format to the file we have specified. finally, we can put messages that are either meant for debugging, information, warning or even critical messages. once the program has run, we can check this file and we will know what happened in the program, even though no information was displayed to the user running the program. urllib and json modules how much fun would it be if we could write our own program that will get search results from the web? let us explore that now. this can be achieved using a few modules. first is the urllib module that we can use to fetch any webpage from the internet. we will make use of yahoo! search to get the search results and luckily they can give us the results in a format called json which is easy for us to parse because of the built-in json module in the standard library. todo this program doesn't work yet which seems to be a bug in python 3.0 beta 2 (http:/ / bugs. python. org/ issue3763). #!/usr/bin/python # filename: yahoo_search.py import sys if sys.version_info[0] != 3: sys.exit('this program needs python 3.0') import json import urllib, urllib.parse, urllib.request, urllib.response # get your own app id at http://developer.yahoo.com/wsregapp/ yahoo_app_id = 'jl22psvv34helwhdfujbfdqzlj2b57kfs_qs4i8d0wz5u5_yci1awv8.lbsfphwr' search_base = 'http://search.yahooapis.com/websearchservice/v1/websearch' python en:standard library 101 class yahoosearcherror(exception): pass # taken from http://developer.yahoo.com/python/python-json.html def search(query, results=20, start=1, **kwargs): kwargs.update({ 'appid': yahoo_app_id, 'query': query, 'results': results, 'start': start, 'output': 'json' }) url = search_base + '?' + urllib.parse.urlencode(kwargs) result = json.load(urllib.request.urlopen(url)) if 'error' in result: raise yahoosearcherror(result['error']) return result['resultset'] query = input('what do you want to search for? ') for result in search(query)['result']: print(\"{0} : {1}\".format(result['title'], result['url'])) output: todo how it works: we can get the search results from a particular website by giving the text we are searching for in a particular format. we have to specify many options which we combine using key1=value1&key2=value2 format which is handled by the urllib.parse.urlencode() function. so for example, open this link in your web browser (http:/ / search. yahooapis. com/ websearchservice/ v1/ websearch?query=byte+ of+ python& appid=jl22psvv34helwhdfujbfdqzlj2b57kfs_qs4i8d0wz5u5_yci1awv8. lbsfphwr& results=20& start=1& output=json) and you will see 20 results, starting from the first result, for the words \"byte of python\", and we are asking for the output in json format. we make a connection to this url using the urllib.request.urlopen() function and pass that file handle to json.load() which will read the content and simultaneously convert it to a python object. we then loop through these results and display it to the end-user. python en:standard library 102 module of the week series there is much more to be explored in the standard library such as debugging (http:/ / docs. python. org/ dev/ library/ pdb. html), handling command line options (http:/ / docs. python. org/ dev/ 3. 0/ library/ getopt. html), regular expressions (http:/ / www. diveintopython. org/ regular_expressions/ index. html) and so on. the best way to further explore the standard library is to read doug hellmann's excellent python module of the week (http:/ / www. doughellmann. com/ projects/ pymotw/ ) series. summary we have explored some of the functionality of many modules in the python standard library. it is highly recommended to browse through the python standard library documentation (http:/ / docs. python. org/ dev/ 3. 0/ library/ ) to get an idea of all the modules that are available. next, we will cover various aspects of python that will make our tour of python more complete. previous next source: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=1156 contributors: swaroop, 2 anonymous edits python en:more introduction so far we have covered majority of the various aspects of python that you will use. in this chapter, we will cover some more aspects that will make our knowledge of python more well-rounded. passing tuples around ever wished you could return two different values from a function? you can. all you have to do is use a tuple. >>> def get_error_details(): ... return (2, 'second error details') ... >>> errnum, errstr = get_error_details() >>> errnum 2 >>> errstr 'second error details' notice that the usage of a, b = <some expression> interprets the result of the expression as a tuple with two values. if you want to interpret the results as (a, <everything else>), then you just need to star it just like you would in function parameters: python en:more 103 >>> a, *b = [1, 2, 3, 4] >>> a 1 >>> b [2, 3, 4] this also means the fastest way to swap two variables in python is: >>> a = 5; b = 8 >>> a, b = b, a >>> a, b (8, 5) special methods there are certain methods such as the __init__ and __del__ methods which have special significance in classes. special methods are used to mimic certain behaviors of built-in types. for example, if you want to use the x[key] indexing operation for your class (just like you use it for lists and tuples), then all you have to do is implement the __getitem__() method and your job is done. if you think about it, this is what python does for the list class itself! some useful special methods are listed in the following table. if you want to know about all the special methods, see the manual (http:/ / docs. python. org/ dev/ 3. 0/ reference/ datamodel. html#special-method-names). name explanation __init__(self, ...) this method is called just before the newly created object is returned for usage. __del__(self) called just before the object is destroyed __str__(self) called when we use the print function or when str() is used. __lt__(self, other) called when the less than operator (<) is used. similarly, there are special methods for all the operators (+, >, etc.) __getitem__(self, key) called when x[key] indexing operation is used. __len__(self) called when the built-in len() function is used for the sequence object. single statement blocks we have seen that each block of statements is set apart from the rest by its own indentation level. well, there is one caveat. if your block of statements contains only one single statement, then you can specify it on the same line of, say, a conditional statement or looping statement. the following example should make this clear: >>> flag = true >>> if flag: print 'yes' ... yes notice that the single statement is used in-place and not as a separate block. although, you can use this for making your program smaller, i strongly recommend avoiding this short-cut method, except for error checking, mainly because it will be much easier to add an extra python en:more 104 statement if you are using proper indentation. lambda forms a lambda statement is used to create new function objects and then return them at runtime. #!/usr/bin/python # filename: lambda.py def make_repeater(n): return lambda s: s * n twice = make_repeater(2) print(twice('word')) print(twice(5)) output: $ python lambda.py wordword 10 how it works: here, we use a function make_repeater to create new function objects at runtime and return it. a lambda statement is used to create the function object. essentially, the lambda takes a parameter followed by a single expression only which becomes the body of the function and the value of this expression is returned by the new function. note that even a print statement cannot be used inside a lambda form, only expressions. todo can we do a list.sort() by providing a compare function created using lambda? points = [ { 'x' : 2, 'y' : 3 }, { 'x' : 4, 'y' : 1 } ] # points.sort(lambda a, b : cmp(a['x'], b['x'])) list comprehension list comprehensions are used to derive a new list from an existing list. suppose you have a list of numbers and you want to get a corresponding list with all the numbers multiplied by 2 only when the number itself is greater than 2. list comprehensions are ideal for such situations. #!/usr/bin/python # filename: list_comprehension.py listone = [2, 3, 4] listtwo = [2*i for i in listone if i > 2] print(listtwo) output: python en:more 105 $ python list_comprehension.py [6, 8] how it works: here, we derive a new list by specifying the manipulation to be done (2*i) when some condition is satisfied (if i > 2). note that the original list remains unmodified. the advantage of using list comprehensions is that it reduces the amount of boilerplate code required when we use loops to process each element of a list and store it in a new list. receiving tuples and lists in functions there is a special way of receiving parameters to a function as a tuple or a dictionary using the * or ** prefix respectively. this is useful when taking variable number of arguments in the function. >>> def powersum(power, *args): ... '''return the sum of each argument raised to specified power.''' ... total = 0 ... for i in args: ... total += pow(i, power) ... return total ... >>> powersum(2, 3, 4) 25 >>> powersum(2, 10) 100 because we have a * prefix on the args variable, all extra arguments passed to the function are stored in args as a tuple. if a ** prefix had been used instead, the extra parameters would be considered to be key/value pairs of a dictionary. exec and eval the exec function is used to execute python statements which are stored in a string or file, as opposed to written in the program itself. for example, we can generate a string containing python code at runtime and then execute these statements using the exec statement: >>> exec('print(\"hello world\")') hello world similarly, the eval function is used to evaluate valid python expressions which are stored in a string. a simple example is shown below. >>> eval('2*3') 6 python en:more 106 the assert statement the assert statement is used to assert that something is true. for example, if you are very sure that you will have at least one element in a list you are using and want to check this, and raise an error if it is not true, then assert statement is ideal in this situation. when the assert statement fails, an assertionerror is raised. >>> mylist = ['item'] >>> assert len(mylist) >= 1 >>> mylist.pop() 'item' >>> mylist [] >>> assert len(mylist) >= 1 traceback (most recent call last): file \"<stdin>\", line 1, in <module> assertionerror the assert statement should be used judiciously. most of the time, it is better to catch exceptions, either handle the problem or display an error message to the user and then quit. the repr function the repr function is used to obtain a canonical string representation of the object. the interesting part is that you will have eval(repr(object)) == object most of the time. >>> i = [] >>> i.append('item') >>> repr(i) \"['item']\" >>> eval(repr(i)) ['item'] >>> eval(repr(i)) == i true basically, the repr function is used to obtain a printable representation of the object. you can control what your classes return for the repr function by defining the __repr__ method in your class. summary we have covered some more features of python in this chapter and yet we haven't covered all the features of python. however, at this stage, we have covered most of what you are ever going to use in practice. this is sufficient for you to get started with whatever programs you are going to create. next, we will discuss how to explore python further. python en:more 107 previous next source: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=1463 contributors: swaroop, 1 anonymous edits python en:what next if you have read this book thoroughly till now and practiced writing a lot of programs, then you must have become comfortable and familiar with python. you have probably created some python programs to try out stuff and to exercise your python skills as well. if you have not done it already, you should. the question now is 'what next?'. i would suggest that you tackle this problem: create your own command-line address-book program using which you can browse, add, modify, delete or search for your contacts such as friends, family and colleagues and their information such as email address and/or phone number. details must be stored for later retrieval. this is fairly easy if you think about it in terms of all the various stuff that we have come across till now. if you still want directions on how to proceed, then here's a hint. hint (don't read) create a class to represent the person's information. use a dictionary to store person objects with their name as the key. use the pickle module to store the objects persistently on your hard disk. use the dictionary built-in methods to add, delete and modify the persons. once you are able to do this, you can claim to be a python programmer. now, immediately send me a mail (http:/ / www. swaroopch. com/ contact/ ) thanking me for this great book ;-) . this step is optional but recommended. also, please consider making a donation, contributing improvements or volunteering translations to support the continued development of this book. if you found that program easy, here's another one: implement the replace command (http:/ / unixhelp. ed. ac. uk/ cgi/ man-cgi?replace). this command will replace one string with another in the list of files provided. the replace command can be as simple or as sophisticated as you wish, from simple string substitution to looking for patterns (regular expressions). after that, here are some ways to continue your journey with python: python en:what next 108 example code the best way to learn a programming language is to write a lot of code and read a lot of code: • the pleac project (http:/ / pleac. sourceforge. net/ pleac_python/ index. html) • rosetta code repository (http:/ / www. rosettacode. org/ wiki/ category:python) • python examples at java2s (http:/ / www. java2s. com/ code/ python/ catalogpython. htm) • python cookbook (http:/ / code. activestate. com/ recipes/ langs/ python/ ) is an extremely valuable collection of recipes or tips on how to solve certain kinds of problems using python. this is a must-read for every python user. questions and answers • official python dos and don'ts (http:/ / docs. python. org/ dev/ howto/ doanddont. html) • official python faq (http:/ / www. python. org/ doc/ faq/ general/ ) • norvig's list of infrequently asked questions (http:/ / norvig. com/ python-iaq. html) • python interview q & a (http:/ / dev. fyicenter. com/ interview-questions/ python/ index. html) • stackoverflow questions tagged with python (http:/ / beta. stackoverflow. com/ questions/ tagged/ python) tips and tricks • python tips & tricks (http:/ / www. siafoo. net/ article/ 52) • advanced software carpentry using python (http:/ / ivory. idyll. org/ articles/ advanced-swc/ ) • charming python (http:/ / gnosis. cx/ publish/ tech_index_cp. html) is an excellent series of python-related articles by david mertz. books, papers, tutorials, videos the logical next step after this book is to read mark pilgrim's awesome dive into python (http:/ / www. diveintopython. org) book which you can read fully online as well. the dive into python book explores topics such as regular expressions, xml processing, web services, unit testing, etc. in detail. other useful resources are: • showmedo videos for python (http:/ / showmedo. com/ videos/ python) • googletechtalks videos on python (http:/ / youtube. com/ results?search_query=googletechtalks+ python) • awaretek's comprehensive list of python tutorials (http:/ / www. awaretek. com/ tutorials. html) • the effbot's python zone (http:/ / effbot. org/ zone/ ) • links at the end of every python-url! email (http:/ / groups. google. com/ group/ comp. lang. python. announce/ t/ 37de95ef0326293d) • python papers (http:/ / pythonpapers. org) python en:what next 109 discussion if you are stuck with a python problem, and don't know whom to ask, then the comp.lang.python discussion group (http:/ / groups. google. com/ group/ comp. lang. python/ topics) is the best place to ask your question. make sure you do your homework and have tried solving the problem yourself first. news if you want to learn what is the latest in the world of python, then follow the official python planet (http:/ / planet. python. org) and/or the unofficial python planet (http:/ / www. planetpython. org). installing libraries there are a huge number of open source libraries at the python package index (http:/ / pypi. python. org/ pypi) which you can use in your own programs. to install and use these libraries, you can use philip j. eby's excellent easyinstall tool (http:/ / peak. telecommunity. com/ devcenter/ easyinstall#using-easy-install). graphical software suppose you want to create your own graphical programs using python. this can be done using a gui (graphical user interface) library with their python bindings. bindings are what allow you to write programs in python and use the libraries which are themselves written in c or c++ or other languages. there are lots of choices for gui using python: pyqt this is the python binding for the qt toolkit which is the foundation upon which the kde is built. qt is extremely easy to use and very powerful especially due to the qt designer and the amazing qt documentation. pyqt is free if you want to create open source (gpl'ed) software and you need to buy it if you want to create proprietary closed source software. starting with qt 4.5 you can use it to create non-gpl software as well. to get started, read the pyqt tutorial (http:/ / zetcode. com/ tutorials/ pyqt4/ ) or the pyqt book (http:/ / www. qtrac. eu/ pyqtbook. html). pygtk this is the python binding for the gtk+ toolkit which is the foundation upon which gnome is built. gtk+ has many quirks in usage but once you become comfortable, you can create gui apps fast. the glade graphical interface designer is indispensable. the documentation is yet to improve. gtk+ works well on linux but its port to windows is incomplete. you can create both free as well as proprietary software using gtk+. to get started, read the pygtk tutorial (http:/ / www. pygtk. org/ tutorial. html). wxpython this is the python bindings for the wxwidgets toolkit. wxpython has a learning curve associated with it. however, it is very portable and runs on linux, windows, mac and even embedded platforms. there are many ides available for wxpython which include gui designers as well such as spe (stani's python editor) (http:/ / spe. pycs. net/ ) and python en:what next 110 the wxglade (http:/ / wxglade. sourceforge. net/ ) gui builder. you can create free as well as proprietary software using wxpython. to get started, read the wxpython tutorial (http:/ / zetcode. com/ wxpython/ ). tkinter this is one of the oldest gui toolkits in existence. if you have used idle, you have seen a tkinter program at work. it doesn't have one of the best look & feel because it has an old-school look to it. tkinter is portable and works on both linux/unix as well as windows. importantly, tkinter is part of the standard python distribution. to get started, read the tkinter tutorial (http:/ / www. pythonware. com/ library/ tkinter/ introduction/ ). for more choices, see the guiprogramming wiki page at the official python website (http:/ / www. python. org/ cgi-bin/ moinmoin/ guiprogramming). summary of gui tools unfortunately, there is no one standard gui tool for python. i suggest that you choose one of the above tools depending on your situation. the first factor is whether you are willing to pay to use any of the gui tools. the second factor is whether you want the program to run only on windows or on mac and linux or all of them. the third factor, if linux is a chosen platform, is whether you are a kde or gnome user on linux. for a more detailed and comprehensive analysis, see of the the python papers, volume 3, issue 1 (http:/ / archive. pythonpapers. org/ thepythonpapersvolume3issue1. pdf). various implementations there are usually two parts a programming language - the language and the software. a language is how you write something. the software is what actually runs our programs. we have been using the cpython software to run our programs. it is referred to as cpython because it is written in the c language and is the classical python interpreter. there are also other software that can run your python programs: jython (http:/ / www. jython. org) a python implementation that runs on the java platform. this means you can use java libraries and classes from within python language and vice-versa. ironpython (http:/ / www. codeplex. com/ wiki/ view. aspx?projectname=ironpython) a python implementation that runs on the .net platform. this means you can use .net libraries and classes from within python language and vice-versa. pypy (http:/ / codespeak. net/ pypy/ dist/ pypy/ doc/ home. html) a python implementation written in python! this is a research project to make it fast and easy to improve the interpreter since the interpreter itself is written in a dynamic language (as opposed to static languages such as c, java or c# in the above three implementations) stackless python (http:/ / www. stackless. com) a python implementation that is specialized for thread-based performance. python en:what next 111 there are also others such as clpython (http:/ / common-lisp. net/ project/ clpython/ ) - a python implementation written in common lisp and ironmonkey (http:/ / wiki. mozilla. org/ tamarin:ironmonkey) which is a port of ironpython to work on top of a javascript interpreter which could mean that you can use python (instead of javascript) to write your web-browser (\"ajax\") programs. each of these implementations have their specialized areas where they are useful. summary we have now come to the end of this book but, as they say, this is the the beginning of the end!. you are now an avid python user and you are no doubt ready to solve many problems using python. you can start automating your computer to do all kinds of previously unimaginable things or write your own games and much much more. so, get started! previous next source: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=1845 contributors: swaroop, 2 anonymous edits python en:appendix floss free/ libre and open source software (floss) floss (http:/ / en. wikipedia. org/ wiki/ floss) is based on the concept of a community, which itself is based on the concept of sharing, and particularly the sharing of knowledge. floss are free for usage, modification and redistribution. if you have already read this book, then you are already familiar with floss since you have been using python all along and python is an open source software! here are some examples of floss to give an idea of the kind of things that community sharing and building can create: • linux. this is a floss operating system that the whole world is slowly embracing! it was started by linus torvalds as a student. now, it is giving competition to microsoft windows. [ linux kernel (http:/ / www. kernel. org) ] • ubuntu. this is a community-driven distribution, sponsored by canonical and it is the most popular linux distribution today. it allows you to install a plethora of floss available and all this in an easy-to-use and easy-to-install manner. best of all, you can just reboot your computer and run linux off the cd! this allows you to completely try out the new os before installing it on your computer. [ ubuntu linux (http:/ / www. ubuntu. com) ] • openoffice.org. this is an excellent office suite with a writer, presentation, spreadsheet and drawing components among other things. it can even open and edit ms word and ms powerpoint files with ease. it runs on almost all platforms. [ openoffice (http:/ / www. openoffice. org) ] • mozilla firefox. this is the next generation web browser which is giving great competition to internet explorer. it is blazingly fast and has gained critical acclaim for its sensible and impressive features. the extensions concept allows any kind of plugins to be used. python en:appendix floss 112 • its companion product thunderbird is an excellent email client that makes reading email a snap. [ mozilla firefox (http:/ / www. mozilla. org/ products/ firefox), mozilla thunderbird (http:/ / www. mozilla. org/ products/ thunderbird) ] • mono. this is an open source implementation of the microsoft .net platform. it allows .net applications to be created and run on linux, windows, freebsd, mac os and many other platforms as well. [ mono (http:/ / www. mono-project. com), ecma (http:/ / www. ecma-international. org), microsoft .net (http:/ / www. microsoft. com/ net) ] • apache web server. this is the popular open source web server. in fact, it is the most popular web server on the planet! it runs nearly more than half of the websites out there. yes, that's right - apache handles more websites than all the competition (including microsoft iis) combined. [ apache (http:/ / httpd. apache. org) ] • mysql. this is an extremely popular open source database server. it is most famous for it's blazing speed. it is the m in the famous lamp stack which runs most of the websites on the internet. [ mysql (http:/ / www. mysql. com) ] • vlc player. this is a video player that can play anything from divx to mp3 to ogg to vcds and dvds to ... who says open source ain't fun? ;-) [ vlc media player (http:/ / www. videolan. org/ vlc/ ) ] • geexbox is a linux distribution that is designed to play movies as soon as you boot up from the cd! [ geexbox (http:/ / geexbox. org/ en/ start. html) ] this list is just intended to give you a brief idea - there are many more excellent floss out there, such as the perl language, php language, drupal content management system for websites, postgresql database server, torcs racing game, kdevelop ide, xine - the movie player, vim editor, quanta+ editor, banshee audio player, gimp image editing program, ... this list could go on forever. to get the latest buzz in the floss world, check out the following websites: • linux.com (http:/ / www. linux. com) • linuxtoday (http:/ / www. linuxtoday. com) • newsforge (http:/ / www. newsforge. com) • distrowatch (http:/ / www. distrowatch. com) visit the following websites for more information on floss: • sourceforge (http:/ / www. sourceforge. net) • freshmeat (http:/ / www. freshmeat. net) so, go ahead and explore the vast, free and open world of floss! previous next source: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=1580 contributors: swaroop, 1 anonymous edits python en:appendix about 113 python en:appendix about colophon almost all of the software that i have used in the creation of this book are free and open source software. birth of the book in the first draft of this book, i had used red hat 9.0 linux as the foundation of my setup and in the sixth draft, i used fedora core 3 linux as the basis of my setup. initially, i was using kword to write the book (as explained in the history lesson in the preface). teenage years later, i switched to docbook xml using kate but i found it too tedious. so, i switched to openoffice which was just excellent with the level of control it provided for formatting as well as the pdf generation, but it produced very sloppy html from the document. finally, i discovered xemacs and i rewrote the book from scratch in docbook xml (again) after i decided that this format was the long term solution. in the sixth draft, i decided to use quanta+ to do all the editing. the standard xsl stylesheets that came with fedora core 3 linux were being used. the standard default fonts are used as well. the standard fonts are used as well. however, i had written a css document to give color and style to the html pages. i had also written a crude lexical analyzer, in python of course, which automatically provides syntax highlighting to all the program listings. now for this seventh draft, i'm using mediawiki (http:/ / www. mediawiki. org) as the basis of my setup (http:/ / www. swaroopch. com/ notes/ ). now i edit everything online and the readers can directly read/edit/discuss within the wiki website. i still use vim for editing thanks to the viewsourcewith extension for firefox (https:/ / addons. mozilla. org/ en-us/ firefox/ addon/ 394) that integrates with vim. python en:appendix about 114 about the author http:/ / www. swaroopch. com/ about/ previous next source: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=236 contributors: swaroop python en:appendix revision history • 1.90 • 04/09/2008 and still in progress • revival after a gap of 3.5 years! • updating to python 3.0 • rewrite using mediawiki (again) • 1.20 • 13/01/2005 • complete rewrite using quanta+ on fc3 with lot of corrections and updates. many new examples. rewrote my docbook setup from scratch. • 1.15 • 28/03/2004 • minor revisions • 1.12 • 16/03/2004 • additions and corrections. • 1.10 • 09/03/2004 • more typo corrections, thanks to many enthusiastic and helpful readers. • 1.00 • 08/03/2004 • after tremendous feedback and suggestions from readers, i have made significant revisions to the content along with typo corrections. • 0.99 • 22/02/2004 • added a new chapter on modules. added details about variable number of arguments in functions. • 0.98 • 16/02/2004 • wrote a python script and css stylesheet to improve xhtml output, including a crude-yet-functional lexical analyzer for automatic vim-like syntax highlighting of the program listings. • 0.97 • 13/02/2004 • another completely rewritten draft, in docbook xml (again). book has improved a lot - it is more coherent and readable. python en:appendix revision history 115 • 0.93 • 25/01/2004 • added idle talk and more windows-specific stuff • 0.92 • 05/01/2004 • changes to few examples. • 0.91 • 30/12/2003 • corrected typos. improvised many topics. • 0.90 • 18/12/2003 • added 2 more chapters. openoffice format with revisions. • 0.60 • 21/11/2003 • fully rewritten and expanded. • 0.20 • 20/11/2003 • corrected some typos and errors. • 0.15 • 20/11/2003 • converted to docbook xml. • 0.10 • 14/11/2003 • initial draft using kword. → previous → back to table of contents source: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=240 contributors: swaroop python en:appendix changes for python 3000 116 python en:appendix changes for python 3000 • vim and emacs editors • http:/ / henry. precheur. org/ 2008/ 4/ 18/ indenting%20python%20with%20vim. html • http:/ / www. enigmacurry. com/ 2008/ 05/ 09/ emacs-as-a-powerful-python-ide/ • string - unicode only • http:/ / docs. python. org/ dev/ 3. 0/ tutorial/ introduction. html#about-unicode • non-ascii identifiers allowed • http:/ / www. python. org/ dev/ peps/ pep-3131/ • print() function • http:/ / www. python. org/ dev/ peps/ pep-3105/ • raw_input() becomes input() • http:/ / www. python. org/ dev/ peps/ pep-3111/ • integer literal support and syntax • http:/ / www. python. org/ dev/ peps/ pep-3127/ • nonlocal statement • http:/ / www. python. org/ dev/ peps/ pep-3104/ • functions can take * argument (varargs) for lists and keyword-only arguments • http:/ / www. python. org/ dev/ peps/ pep-3102/ • functions can have annotations (make a passing note?) • http:/ / www. python. org/ dev/ peps/ pep-3107/ • better explanation of modules, packages and their organization (including __init__.py, etc.) • http:/ / ivory. idyll. org/ articles/ advanced-swc/ #packages • string .format() instead of % operator • http:/ / www. python. org/ dev/ peps/ pep-3101/ • http:/ / docs. python. org/ dev/ library/ string. html#formatstrings • dict method changes • http:/ / www. python. org/ dev/ peps/ pep-3106/ • built-in set class, in data structures chapter • problem solving • use http:/ / gnuwin32. sourceforge. net/ packages/ zip. htm on windows • classes • http:/ / docs. python. org/ dev/ 3. 0/ reference/ datamodel. html • metaclasses • http:/ / www. python. org/ dev/ peps/ pep-3115/ • abstract base classes • http:/ / www. python. org/ dev/ peps/ pep-3119/ • not sure if any changes required for new i/o • http:/ / www. python. org/ dev/ peps/ pep-3116/ • exception handling python en:appendix changes for python 3000 117 • http:/ / www. python. org/ dev/ peps/ pep-0352/ • http:/ / www. python. org/ dev/ peps/ pep-3109/ • http:/ / www. python. org/ dev/ peps/ pep-3110/ • standard library - interesting additions • reorganization : http:/ / www. python. org/ dev/ peps/ pep-3108/ • http:/ / docs. python. org/ dev/ library/ warnings. html • http:/ / docs. python. org/ dev/ library/ logging. html (important) • http:/ / docs. python. org/ dev/ library/ urllib. html • http:/ / docs. python. org/ dev/ library/ json. html • debugging • http:/ / docs. python. org/ dev/ library/ pdb. html • http:/ / docs. python. org/ dev/ 3. 0/ library/ trace. html • eval, repr/ascii functions • getopt/optparse - how to write a standard command-line program using python? • something like replace? • http:/ / hpux. connect. org. uk/ hppd/ hpux/ users/ replace-2. 24/ man. html • more • unpacking can take * argument • http:/ / www. python. org/ dev/ peps/ pep-3132/ • with statement • http:/ / www. python. org/ dev/ peps/ pep-0343/ • what next? • implement 'replace' • http:/ / unixhelp. ed. ac. uk/ cgi/ man-cgi?replace • mention use of pypi • q&a • http:/ / docs. python. org/ dev/ howto/ doanddont. html • http:/ / www. python. org/ doc/ faq/ general/ • http:/ / norvig. com/ python-iaq. html • books & resources • http:/ / www. coderholic. com/ free-python-programming-books/ • http:/ / pythonpapers. org • http:/ / www. mobilepythonbook. org • http:/ / effbot. org/ zone/ • links at the end of every python-url! email • http:/ / groups. google. com/ group/ comp. lang. python. announce/ t/ 37de95ef0326293d • examples • http:/ / www. rosettacode. org • http:/ / dev. fyicenter. com/ interview-questions/ python/ index. html • http:/ / www. java2s. com/ code/ python/ catalogpython. htm • tips & tricks • http:/ / www. siafoo. net/ article/ 52 source: http:/ / www. swaroopch. com/ mediawiki/ index. php? oldid=242 python en:appendix changes for python 3000 118 contributors: swaroop license creative commons attribution-share alike 3.0 unported http:/ / creativecommons. org/ licenses/ by-sa/ 3. 0/",
  "metadata": {
    "filename": "A_Byte_of_Python,_v1.92_(for_Python_3.0)_(2009).pdf",
    "filepath": "C:\\Users\\Albert\\aa-660-ai-doc-classification-deduplication\\data\\raw\\A_Byte_of_Python,_v1.92_(for_Python_3.0)_(2009).pdf",
    "hash": "d530ccae7ed9aa23078a2901dd7a18d2cb22a2a89fd21d19e4084d46979f8c54",
    "filesize": 623241,
    "language": "en"
  }
}